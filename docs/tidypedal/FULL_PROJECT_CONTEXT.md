# âš ï¸ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY

> **WARNING**: This file is automatically generated by `scripts/create_context.py`.
> Any manual edits will be overwritten the next time the script runs.
> To modify the content, edit the source files directly.

---

# TINYPEDAL Project Context

This file contains the full source code and documentation of the project.
It is generated automatically to provide complete context for LLM queries.


# File: README.md
```markdown
# TinyPedal - racing simulation overlay

TinyPedal is a Free and Open Source telemetry overlay application for racing simulation.

Focuses on minimalist design, light-weight and efficiency, extensive customization and data analysis. Features a large collection of highly configurable overlay widgets and data modules, advanced fuel calculator and editing tools.

Currently supports `rFactor 2` and `Le Mans Ultimate`, and runs on `Windows` and `Linux`.

[Download](unlinked: github_com/TinyPedal/TinyPedal/releases) -
[Quick Start](#quick-start) -
[FAQ](unlinked: github_com/TinyPedal/TinyPedal/wiki/Frequently-Asked-Questions) -
[User Guide](unlinked: github_com/TinyPedal/TinyPedal/wiki/User-Guide) -
[Run on Linux](#running-on-linux) -
[License](#license)
---

![preview](unlinked: user-images_githubusercontent_com/21177177/282278970-b806bf02-a83d-4baa-8b45-0ca10f28f775_png)

## Requirements

| Supported API | Requirement | Windows | Linux |
|:-:|---|:-:|:-:|
| Le Mans Ultimate | Game's built-in API, no plugin required. | Yes | No |
| Le Mans Ultimate (legacy) | Requires `rF2 Shared Memory Map Plugin` to access. | Yes | Yes |
| rFactor 2 | Requires `rF2 Shared Memory Map Plugin` to access. | Yes | Yes |

### Display Mode

Game display mode must be set to `Borderless` or `Windowed` to show overlay. `Fullscreen` mode is not supported.

### rF2 Shared Memory Map Plugin

TheIronWolfâ€™s `rF2 Shared Memory Map Plugin` is required for accessing `RF2` or `LMU (legacy)` API. It can be found from `Download` section of following page:  
unlinked: github_com/TheIronWolfModding/rF2SharedMemoryMapPlugin

The plugin file `rFactor2SharedMemoryMapPlugin64.dll` should be placed in:

1. For `rFactor 2`, it is `rFactor 2\Bin64\Plugins` folder.

2. For `Le Mans Ultimate`, it is `Le Mans Ultimate\Plugins` folder.

Note, if `Plugins` folder is missing from game folder, you will have to manually create this `Plugins` folder.

Some popular rF2/LMU Apps may also have this plugin pre-installed, check corresponding game's plugins folder first to see if it was installed already.

Enable plugin in game:

- For `rFactor 2`, in game `Settings` -> `Gameplay` page, find `Plugins` section and toggle on `rFactor2SharedMemoryMapPlugin64.dll`.

- For `Le Mans Ultimate`, user may have to manually enable plugin by editing `CustomPluginVariables.JSON` file (set `" Enabled"` value to `1` ) under `Le Mans Ultimate\UserData\player` folder.

After plugin enabled, must `restart game` to take effect.

Note, if game cannot generate `rFactor2SharedMemoryMapPlugin64.dll` entry in `CustomPluginVariables.JSON` file, make sure `VC12 (Visual C++ 2013) runtime` is installed, which can be found in game's `Support\Runtimes` folder.

## Quick Start

**Important:** make sure required plugins for specific game are installed as mentioned in [Requirements](#requirements) section.

1. Download latest TinyPedal version from [Releases](unlinked: github_com/TinyPedal/TinyPedal/releases) page, extract it into a clean folder, and run `tinypedal.exe`.  
Note, DO NOT extract TinyPedal into `system` or `game` folder, such as `Program Files` or `rFactor 2` folder, otherwise it may fail to run.  
Alternatively, run TinyPedal from source, see [Run from source](#run-from-source) section for details.  
For Linux user, please follow [Running on Linux](#running-on-linux) section for instruction.  

2. A tray icon will appear at system tray. If not shown, check hidden tray icon. `Right Click` on tray icon will bring up context menu.

3. Launch game, overlay will appear once vehicle is on track, and auto-hide otherwise. Auto-hide can be toggled On and Off by clicking `Auto Hide` from tray menu.

4. Overlay can be Locked or Unlocked by clicking `Lock Overlay` from tray menu. While Unlocked, click on overlay to drag around.

5. Widgets can be Enabled or Disabled from `Widget` panel in main window. `Right Click` on tray icon and select `Config` to show main window if it is hidden.

6. To quit APP, `Right Click` on tray icon and select `Quit`; or, click `Overlay` menu from main window and select `Quit`.

See [Frequently Asked Questions](unlinked: github_com/TinyPedal/TinyPedal/wiki/Frequently-Asked-Questions) for common issues.

See [User Guide](unlinked: github_com/TinyPedal/TinyPedal/wiki/User-Guide) for usage info.

## Run from source

### Dependencies:
* [Python](unlinked: www_python_org/) 3.8, 3.9, or 3.10
* PySide2
* pyLMUSharedMemory
* pyRfactor2SharedMemory
* psutil

Note, PySide2 may not be available for Python version higher than 3.10; or requires PySide6 instead for running with newer Python version. PySide6 is currently supported only via command line argument, see `Command line arguments` section in `User Guide` for details.

### Download source code

Method 1:

1. Download TinyPedal source code from [Releases](unlinked: github_com/TinyPedal/TinyPedal/releases) page; or click `Code` button at the top of repository and select `Download ZIP`.

2. Download submodule source code from following links:
    - pyLMUSharedMemory: unlinked: github_com/s-victor/pyLMUSharedMemory
    - pyRfactor2SharedMemory: unlinked: github_com/s-victor/pyRfactor2SharedMemory

3. Extract TinyPedal source code ZIP file. Then extract submodule ZIP files and put them in corresponding folder in the root folder of TinyPedal.

Method 2:

1. Use [Git](unlinked: git-scm_com/) tool and run following command to clone TinyPedal source code alongside required submodules:  
    `git clone --recursive unlinked: github_com/TinyPedal/TinyPedal_git`
2. To update submodules, run command:  
    `git submodule update --init`

### Install dependencies

Install additional dependencies by using command:  
`pip3 install PySide2 psutil`

To start TinyPedal, type command from root folder:  
`python run.py`

## Build executable for Windows

Executable file can be built with [py2exe](unlinked: www_py2exe_org).

To install py2exe, run command:  
`pip3 install py2exe`

To build executable file, run command:  
`python freeze_py2exe.py`

After building completed, executable file can be found in `dist\TinyPedal` folder.

Note: the build script only supports py2exe `v0.12.0.0` or higher.

## Running on Linux

The procedure described in the [Run from source](#run-from-source) section is mostly valid,
except some differences in the dependencies, and that no executable can be
built. The differences are explained here.

Configuration and data files will be stored in the defined user-specific
directories, usually at `$HOME/.config/TinyPedal/` and
`$HOME/.local/share/TinyPedal/` respectively.

The required Python packages are `PySide2`, `psutil` and `pyxdg`. Most distros
name the package with a prefix, like `python3-pyside2`, `python3-psutil` and
`python3-pyxdg`.

Some distros split `PySide2` in subpackages. If you don't find
`python3-pyside2` then you should install `python3-pyside2.qtgui`,
`python3-pyside2.qtwidgets` and `python3-pyside2.qtmultimedia`.

Alternatively, you can install them using `pip3` but this will bypass your
system package manager and it isn't the recommended option. The command to
install the dependencies with this method is:

`pip3 install PySide2 psutil pyxdg`

The Iron Wolf's rF2 Shared Memory Map Plugin has to be replaced with [this fork
for
Wine](unlinked: github_com/schlegp/rF2SharedMemoryMapPlugin_Wine/blob/master/build).

To start TinyPedal type the following command:  
`./run.py`

### Installation

Once you have a working instance of TinyPedal, created using the git command or
by unpacking the Linux release file, you can run the install script to install
or update TinyPedal on your system.

The install script will create a desktop launcher and will make `TinyPedal`
available as a command from the terminal.

The files will be installed at the `/usr/local/` prefix. You'll need
appropriate permissions to write there, for example, by using `sudo`.

You can run the script as (it doesn't support any arguments or options):  
`sudo ./install.sh`

### Known issues

- Widgets don't appear over the game window in KDE. Workaround: enable `Bypass Window Manager` option in `Compatibility` dialog from `Config` menu in main window.
- Transparency of widgets doesn't work when desktop compositing is disabled. Workaround: enable `window manager compositing` in your DE.

## License

Copyright (C) 2022-2026 TinyPedal developers

TinyPedal is free software and licensed under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. TinyPedal is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY. See [LICENSE.txt](./LICENSE.txt) for more info.

TinyPedal icon, as well as image files located in `images` folder, are licensed under [CC BY-SA 4.0](unlinked: creativecommons_org/licenses/by-sa/4_0/).

Licenses and notices file for third-party software are located in `docs\licenses` folder, see [THIRDPARTYNOTICES.txt](./docs/licenses/THIRDPARTYNOTICES.txt) file for details.

## Credits

See [docs\contributors.md](./docs/contributors.md) file for full list of developers and contributors.

```

# File: freeze_py2exe.py
```python
"""
py2exe build script

Args:
    -c, --clean: force remove old build folder before building.
"""

import argparse
import os
import shutil
import sys
from glob import glob

from py2exe import freeze

from tinypedal import version_check
from tinypedal.const_app import (
    APP_NAME,
    COPYRIGHT,
    PLATFORM,
    VERSION,
)

PYTHON_PATH = sys.exec_prefix
DIST_FOLDER = "dist/"

EXECUTABLE_SETTING = [
    {
        "script": "run.py",
        "icon_resources": [(1, "images/icon.ico")],
        "dest_base": APP_NAME.lower(),
    }
]

EXCLUDE_MODULES = [
    "difflib",
    "pdb",
    "venv",
    "tkinter",
    "curses",
    "distutils",
    "lib2to3",
    "unittest",
    "xmlrpc",
    "multiprocessing",
    # "_ssl",
    # "ssl",
    # "email",
    # "http",
    # "urllib",
]

IMAGE_FILES = [
    "images/CC-BY-SA-4.0.txt",
    "images/icon_compass.png",
    "images/icon_instrument.png",
    "images/icon_steering_wheel.png",
    "images/icon_weather.png",
    "images/icon.png",
]

DOCUMENT_FILES = [
    "docs/changelog.txt",
    "docs/customization.md",
    "docs/contributors.md",
]

LICENSES_FILES = glob("docs/licenses/*")

QT_PLATFORMS = [
    f"{PYTHON_PATH}/Lib/site-packages/PySide2/plugins/platforms/qwindows.dll",
]

QT_MEDIASERVICE = [
    f"{PYTHON_PATH}/Lib/site-packages/PySide2/plugins/mediaservice/dsengine.dll",
    f"{PYTHON_PATH}/Lib/site-packages/PySide2/plugins/mediaservice/wmfengine.dll",
]

BUILD_DATA_FILES = [
    ("", ["LICENSE.txt", "README.md"]),
    ("docs", DOCUMENT_FILES),
    ("docs/licenses", LICENSES_FILES),
    ("images", IMAGE_FILES),
    ("platforms", QT_PLATFORMS),
    ("mediaservice", QT_MEDIASERVICE),
]

BUILD_OPTIONS = {
    "dist_dir": f"{DIST_FOLDER}/{APP_NAME}",
    "excludes": EXCLUDE_MODULES,
    "optimize": 2,
    "compressed": 1,
    # "dll_excludes": ["libcrypto-1_1.dll", "libcrypto-3.dll"],
    # "bundle_files": 2,
}

BUILD_VERSION = {
    "version": VERSION.split("-")[0],  # strip off version tag
    "description": APP_NAME,
    "copyright": COPYRIGHT,
    "product_name": APP_NAME,
    "product_version": VERSION,
}


def get_cli_argument():
    """Get command line argument"""
    parse = argparse.ArgumentParser(
        description="TinyPedal windows excutable build command line arguments"
    )
    parse.add_argument(
        "-c",
        "--clean",
        action="store_true",
        help="force remove old build folder before building",
    )
    return parse.parse_args()


def check_dist(build_ready: bool = False) -> bool:
    """Check whether dist folder exist"""
    if not os.path.exists(DIST_FOLDER):
        print("INFO:dist folder not found, creating")
        try:
            os.mkdir(DIST_FOLDER)
            build_ready = True
            print("INFO:dist folder created")
        except (PermissionError, FileExistsError):
            build_ready = False
            print("ERROR:Cannot create dist folder")

    if os.path.exists(DIST_FOLDER):
        build_ready = True
    return build_ready


def check_old_build(clean_build: bool = False, build_ready: bool = False) -> bool:
    """Check whether old build folder exist"""
    if os.path.exists(f"{DIST_FOLDER}{APP_NAME}"):
        print("INFO:Found old build folder")

        if clean_build:
            build_ready = delete_old_build()
            return build_ready

        is_remove = input(
            "INFO:Remove old build folder before building? Yes/No/Quit \n"
        ).lower()

        if "y" in is_remove:
            build_ready = delete_old_build()
        elif "q" in is_remove:
            build_ready = False
        else:
            build_ready = True
            print("WARNING:Building without removing old files")
    return build_ready


def delete_old_build() -> bool:
    """Delete old build folder"""
    try:
        shutil.rmtree(f"{DIST_FOLDER}{APP_NAME}/")
        print("INFO:Old build files removed")
        return True
    except (PermissionError, OSError):
        print("ERROR:Cannot delete build folder")
        return False


def build_exe() -> None:
    """Building executable file"""
    freeze(
        version_info=BUILD_VERSION,
        windows=EXECUTABLE_SETTING,
        options=BUILD_OPTIONS,
        data_files=BUILD_DATA_FILES,
        zipfile="lib/library.zip",
    )


def build_start() -> None:
    """Start building"""
    print("INFO:platform:", PLATFORM)
    print("INFO:TinyPedal:", VERSION)
    print("INFO:Python:", version_check.python())
    print("INFO:Qt:", version_check.qt())
    print("INFO:PySide:", version_check.pyside())
    print("INFO:psutil:", version_check.psutil())

    if PLATFORM != "Windows":
        print("ERROR:Build script does not support none Windows platform")
        print("INFO:Building canceled")
        return

    cli_args = get_cli_argument()
    if check_old_build(cli_args.clean, check_dist()):
        build_exe()
        print("INFO:Building finished")
    else:
        print("INFO:Building canceled")


build_start()

```

# File: run.py
```python
#!/usr/bin/env python3

#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Run program
"""

import argparse
import os
import sys


def get_cli_argument() -> argparse.Namespace:
    """Get command line argument"""
    parse = argparse.ArgumentParser(
        description="TinyPedal command line arguments",
    )
    parse.add_argument(
        "-l",
        "--log-level",
        choices=range(3),
        default=1,
        type=int,
        help=(
            "set logging output level:"
            " 0 - warning and error only;"
            " 1 - all levels (default);"
            " 2 - output to file;"
        ),
    )
    parse.add_argument(
        "-s",
        "--single-instance",
        choices=range(2),
        default=1,
        type=int,
        help=(
            "set running mode:"
            " 0 - allow running multiple instances;"
            " 1 - single instance (default);"
        ),
    )
    # Disallow version override if run as compiled exe
    if "tinypedal.exe" not in sys.executable:
        parse.add_argument(
            "-p",
            "--pyside",
            choices=(2, 6),
            default=2,
            type=int,
            help=(
                "set PySide (Qt for Python) version:"
                " 2 - PySide2;"
                " 6 - PySide6;"
            ),
        )
    return parse.parse_args()


def override_pyside_version(version: int = 6):
    """Override PySide version 2 to 6"""
    if version != 6:
        return
    original = "PySide2"
    override = f"PySide{version}"
    override_module(original, override)
    override_module(f"{original}.QtCore", f"{override}.QtCore")
    override_module(f"{original}.QtGui", f"{override}.QtGui")
    override_module(f"{original}.QtWidgets", f"{override}.QtWidgets")
    override_module(f"{original}.QtMultimedia", f"{override}.QtMultimedia")


def override_module(original: str, override: str):
    """Manual import & override module"""
    sys.modules[original] = __import__(override, fromlist=[override])


if __name__ == "__main__":
    os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))

    # Load command line arguments
    cli_args = get_cli_argument()

    # Check whether to override PySide version
    pyside_override = getattr(cli_args, "pyside", 2)
    os.environ["PYSIDE_OVERRIDE"] = f"{pyside_override}"  # store to env
    override_pyside_version(pyside_override)

    # Start
    from tinypedal.main import start_app

    start_app(cli_args)

```

# File: AGENTS.md
```markdown
# TINYPEDAL - AI Developer Guide

This file provides SOP, build commands, code style, and patterns for AI agents working on TINYPEDA.

---

## âœ… Standard Task Workflow (SOP)

**Perform these steps for EVERY task to ensure quality and consistency.**

### 1. ðŸ§  Consult Memory
*   **Action**: Use the hivemind tool.
*   **Why**: It contains workarounds (like Git fixes) and architectural lessons learned from previous sessions.
---
### 2. ðŸ”„ Context
    *   **Read Updated Docs**: For each changed documentation file, read its current content to understand the updates.
    *   **Why**: Documentation changes often reflect new features, API changes, architecture updates, or critical fixes. You must stay current with the project's evolving knowledge base.
    *   **Priority Files**: Pay special attention to changes in:
        *   `README.md` - User-facing features and setup
        *   `CHANGELOG.md` - Recent changes and version history
        *    use `hivemind` tool - Previous session learnings
    *  **run** `python scripts/create_context.py`.
---
### 4. ðŸ“š Documentation Updates
*   **Requirement**: You **must** scan and update ALL relevant documentation to reflect your changes.
*   **Process**:
    1.  **Scan Documentation**: Use `find_by_name` to list all `.md` files in the project.
    2.  **Read Relevant Docs**: Review the documentation files that are likely affected by your changes.
    3.  **Determine Relevance**: Identify which documents need updates based on your changes.
    4.  **Update Documents**: Modify all relevant documentation to maintain consistency.
*   **Documentation Directories**:
    *   `docs/` - User-facing documentation
    *   Root `.md` files - `README.md`, `CHANGELOG.md`, `AGENTS.md`
*   **Critical**: Do NOT assume only one document needs updating. Your changes may affect multiple documents.

### 6. ðŸ§  Update Memory (Critical)
*   **Action**: If you encountered a build error, a command failure, or learned something new about the code structure, use the `hivemind` tool to store it.
*   **Goal**: Help the *next* AI session avoid the same problem.

### 7. ðŸ“¤ Delivery
*   **Do Not Push**: Do not run any command that change git history (e.g. `git add`, `git commit`, `git push`) or that reset the local staged changes (e.g. `git reset`).

### 8. MANDATORY CHECKLIST:
    *   [ ] **Documentation Scanned**: Did you scan all `.md` files and identify relevant docs?
    *   [ ] **Documentation Updated**: Did you update ALL relevant documentation (not just one file)?
---

## ðŸŒ Environment & Constraints
*   **Target OS**: Windows 10/11.
*   **Current Environment**: Arch Linux.
*   **Build Limitation**: You **cannot** build the main application (`TINYPEDAL.exe`) in this environment.

---

## 10. Hivemind - Unified Memory System

The hive remembers everything. Learnings, sessions, patternsâ€”all searchable.

### Tools

| Tool | Purpose |
|------|---------|
| `hivemind_store` | Store a memory (learnings, decisions, patterns) |
| `hivemind_find` | Search all memories (semantic + FTS fallback) |
| `hivemind_get` | Get specific memory by ID |
| `hivemind_remove` | Delete outdated/incorrect memory |
| `hivemind_validate` | Confirm memory still accurate (resets 90-day decay) |
| `hivemind_stats` | Memory statistics and health |
| `hivemind_index` | Index AI session directories |
| `hivemind_sync` | Sync to .hive/memories.jsonl |

### Usage

# Store a learning (include WHY, not just WHAT)
`hivemind_store(information="OAuth refresh tokens need 5min buffer before expiry to avoid race conditions",tags="auth,oauth,tokens")`

# Search memories (includes past sessions)
`hivemind_find(query="token refresh", limit=5)`

# Search only Claude sessions
`hivemind_find(query="authentication error", collection="claude")`

# Index new sessions
`hivemind_index()`

# Sync to git
`hivemind_sync()`

```

# File: docs/contributors.md
```markdown
# Contributors to TinyPedal

## Development
* Xiang (S.Victor) - Project founder, core development, TinyPedal icons

## Cross-platform
* Bernat (berarma) - Cross-platform (Linux) implementation & maintainer
* SynthetikzZ - Cross-platform (Linux) assistance, features
* Sergio Rafael Lemke (srlemke) - Cross-platform (Linux) assistance, features, bug fixes

## Implementation
* nikidigi - Widget snapping & alignment
* TiberiuC39 - VR compatibility toggle
* Sihyung Park (naturale0) - Auto load preset system
* DanRZ - Trailing widget, various features, bug fixes
* Sasker - Tyre carcass widget
* Nibo - Sectors widget

## Other contributors
* Tanizo Yashima (yashiman) - Various features, testing assistance
* ebeninca - Various features & designs, testing assistance
* Erik Jacobs (thoraxe) - Various features, bug fixes

## Technical assistance
* Lee Bowden - Author of GPL pace notes system, assistance on GPL pace notes system & file specification
* Jim Pearson - Assistance on GPL pacenotes system
* Xudong Zhang (zxd1997) - Assistance on various feature implementation
* DumibirdF - Assistance on mathematics & testing

## Community support
* rFactor 2 Community (forum.studio-397.com) - for everyone's kind support over the years
* Andres (Corti) - Community support & help
* sepi - Community support & help

## Special Thanks
* Vytautas LeonaviÄius (The Iron Wolf) - for rF2 Shared Memory Map Plugin
* Tony Whitley (Seven Smiles) - for pyRfactor2SharedMemory library
* Alpha testers (Rnzi, chips, derricklu30, DKxiaoming, fatboy, fartman, felixfight, Sendoh, y1Thunder, zxd1997)

```

# File: docs/customization.md
```markdown
**Note: following guide is updated to match latest released version.**

TinyPedal offers a wide range of customization options for `widget` and `module` controls, which can be accessed from corresponding tabs in main window.

# Global user configuration
TinyPedal stores global user configuration in `config.json` file, which is used for none-preset specific options.

* For Windows, `config.json` is stored under `username\AppData\Roaming\TinyPedal` folder.
* For Linux, `config.json` is stored under `home/username/.config/TinyPedal` folder.

Available settings:

* `Application`, can be accessed from `Config` menu in main window, see [Application](#application) section for details.
* `Telemetry API`, can be accessed from `API` menu in main window, see [Telemetry API](#telemetry-api) section for details.
* `Compatibility`, can be accessed from `Config` menu in main window, see [Compatibility](#compatibility) section for details.
* `User path`, can be accessed from `Config` menu in main window, see [User Path](#user-path) section for details.
* `Auto load preset`, can be accessed from `Preset` tab in main window, see [Preset Management](#preset-management) section for details.

Reload or Restart:

* To reload all presets, select `Reload` from `Overlay` menu in main window.
* To restart game API, select `Restart API` from `API` menu in main window.
* To restart TinyPedal, select `Restart TinyPedal` from `Window` menu in main window.

[**`Back to Top`**](#)


# Preset management
TinyPedal stores all customization options in `JSON` format preset files, and can be managed from `Preset` tab in main window.

All user preset files, by default, are located in `TinyPedal\settings` folder. Those `JSON` files can also be manually edited with text editor.

`Double-Click` on a preset name in `Preset` tab to load selected preset.

Click `Transfer` button to transfer settings from currently loaded preset to another preset. See [Preset Transfer](#preset-transfer) section for details.

`Right-Click` on a preset name in `Preset` tab opens up a context menu that provides additional preset file management options:

* Lock Preset

    Lock selected preset, which prevents any changes that made through TinyPedal from saving to locked preset file. APP `version` tag will be attached to the preset that is locked with.

    Note, this feature does not prevent user from modifying or deleting locked preset file by other means. Locked preset file info is stored in `config.lock` file in [Global User Configuration](#global-user-configuration) folder.

* Unlock Preset

    Unlock selected preset.

* Set Primary for Class

    Add primary `class` tag to selected preset, which will be auto loaded by `Auto load preset` system. Class tags and colors are defined in `classes.json` file, which can be modified in [Vehicle Class Editor](#vehicle-class-editor).

    Note, a single preset can have tags from multiple classes. Auto loading `primary class` preset (if available) always takes priority over `primary sim`.

* Clear Primary Tag

    Clear all primary tags from selected preset.

* Duplicate

    Duplicate selected preset with a new name.

* Rename

    Rename selected preset with a new name. This option is not available for locked preset.

* Delete

    Delete selected preset with confirmation. This option is not available for locked preset.

[**`Back to Top`**](#)


## Saving JSON file
TinyPedal automatically saves setting when user makes changes to widget position, or has toggled widget visibility, auto-hide, overlay-lock, etc. Changes will only take effect after `Reload` preset, or clicked `Save` or `Apply` button in `Config` dialog, or `Restart` APP.

[**`Back to Top`**](#)


## Backup JSON file
TinyPedal will automatically create backup file with time stamp suffix if old setting file fails to load, and new default `JSON` with same filename will be generated.

A newer released version will auto-update old setting and add new setting after loading. It may still be a good idea to manually backup files before upgrading to newer version.

[**`Back to Top`**](#)


## Editing JSON file
Customization can be done through various configuration dialogs and menus from main window. Manual editing `JSON` file is not recommended.

[**`Back to Top`**](#)


## Preset Transfer
**Preset transfer dialog is used for transferring settings from one preset to another.**

Note, you can only transfer settings from a currently loaded preset to another preset, this is done to ensure one-way transfer.

**A confirmation dialog will be shown before transfer.**

It is recommended to first load a preset, then unhide the preset and double-check if you wish to transfer its settings to another preset.

**For important preset, it is recommended to make a backup copy, and/or lock the preset.**

To transfer settings from currently loaded preset to another specific preset, select a preset name from preset selector on the top right. Locked presets are not available from preset selector.

To select one or more settings, select and check setting name from `Setting` list on the left side. Only selected settings will be transferred.

To select one or more option types, select and check option type name from `Option Type` list on the right side. Only selected options will be transferred.

To select or deselect all settings or option types from list, click `All` or `None` button on list header.

Option types:
- Enable State: widget or module enable state.
- Feature Toggle: widget or module feature enable state, such as `enable_XXX` or `show_XXX`.
- Update Interval: widget or module update interval and idle update interval.
- Position: widget position.
- Opacity: widget opacity.
- Layout: widget layout.
- Color: color options.
- Font: font name, font weight, font size options.
- Column Index: column index options.
- Decimal Places: decimal places options.
- Other Options: all other options that are not part of above option types.

For example, to only transfer all widgets `position` setting to another preset, select and check all settings from `Setting` list on the left side, then select only `position` from `Option Type` list on the right side, and click `Transfer` button.

[**`Back to Top`**](#)


## Brands preset
**Brands preset is used for customizing brand name that matches specific vehicle name.**

Brands preset can be customized by accessing `Vehicle brand editor` from `Tools` menu in main window. See [Vehicle Brand Editor](#vehicle-brand-editor) section for complete editing guide.

`brands.json` preset will be generated and saved in `TinyPedal\settings` folder after first time launch of the APP.

[**`Back to Top`**](#)


## Classes preset
**Classes preset is used for customizing class name and color that matches specific vehicle class.**

Classes preset can be customized by accessing `Vehicle class editor` from `Tools` menu in main window. See [Vehicle Class Editor](#vehicle-class-editor) section for complete editing guide.

`classes.json` preset will be generated and saved in `TinyPedal\settings` folder after first time launch of the APP.

[**`Back to Top`**](#)


## Brakes preset
**Brakes preset is used for customizing brake failure thickness and heatmap style that matches specific vehicle class.**

Brakes preset can be customized by accessing `Brake editor` from `Tools` menu in main window. See [Brake Editor](#brake-editor) section for complete editing guide.

`brakes.json` preset will be generated and saved in `TinyPedal\settings` folder after first time launch of the APP.

[**`Back to Top`**](#)


## Compounds preset
**Compounds preset is used for customizing tyre compound symbol and heatmap style that matches specific tyre compound.**

Compounds preset can be customized by accessing `Tyre compound editor` from `Tools` menu in main window. See [Tyre Compound Editor](#tyre-compound-editor) section for complete editing guide.

`compounds.json` preset will be generated and saved in `TinyPedal\settings` folder after first time launch of the APP.

[**`Back to Top`**](#)


## Heatmap preset
**Heatmap preset is used for customizing heatmap color that matches specific value range of telemetry data, such as brake and tyre temperature.**

Heatmap preset can be customized by accessing `Heatmap editor` from `Tools` menu in main window. See [Heatmap Editor](#heatmap-editor) section for complete editing guide.

`heatmap.json` preset will be generated and saved in `TinyPedal\settings` folder after first time launch of the APP.

[**`Back to Top`**](#)


## Tracks preset
**Tracks preset is used for storing and customizing track info for various track-related calculation.**

Tracks preset can be customized by accessing `Track info editor` from `Tools` menu in main window. See [Track Info Editor](#track-info-editor) section for complete editing guide.

Track info recording is handled by [Mapping Module](#mapping-module).

`tracks.json` preset will be generated and saved in `TinyPedal\settings` folder after first time launch of the APP.

[**`Back to Top`**](#)


# User files
TinyPedal generates and saves user session data in specific folders defined in `User path`. Session data can be reset by accessing `Reset data` menu from `Overlay` menu in main window; or, delete data file from corresponding folder.

[**`Back to Top`**](#)


## Driver stats
Driver stats data is stored as `JSON` format (.stats extension) under [Global User Configuration](#global-user-configuration) folder. Driver stats can be viewed with [Driver Stats Viewer](#driver-stats-viewer) from `Tools` menu in main window.

Data recording is handled by [Stats Module](#stats-module).

[**`Back to Top`**](#)


## Delta best
Delta best data is stored as `CSV` format (.csv extension) under `TinyPedal\deltabest` folder (default). Those files can be opened in spreadsheet or notepad programs.

Data recording is handled by [Delta Module](#delta-module).

[**`Back to Top`**](#)


## Energy delta
Energy delta data is stored as `CSV` format (.energy extension) under `TinyPedal\deltabest` folder (default). Those files can be opened in spreadsheet or notepad programs.

Data recording is handled by [Energy Module](#energy-module).

[**`Back to Top`**](#)


## Fuel delta
Fuel delta data is stored as `CSV` format (.fuel extension) under `TinyPedal\deltabest` folder (default). Those files can be opened in spreadsheet or notepad programs.

Data recording is handled by [Fuel Module](#fuel-module).

[**`Back to Top`**](#)


## Consumption history
Consumption history data is stored as `CSV` format (.consumption extension) under `TinyPedal\deltabest` folder (default). Those files can be opened in spreadsheet or notepad programs.

Consumption history data stores lap time, fuel consumption, battery charge, tyre wear usage data per `track and vehicle class`, which can be loaded in [Fuel Calculator](#fuel-calculator). Up to 100 most recent lap entries are saved per `track and vehicle class`. Data recording is handled by [Fuel Module](#fuel-module).

[**`Back to Top`**](#)


## Sector best
Sector best data is stored as `CSV` format (.sector extension) under `TinyPedal\deltabest` folder (default). Those files can be opened in spreadsheet or notepad programs.

Data recording is handled by [Sectors Module](#sectors-module).

[**`Back to Top`**](#)


## Track map
Track map is stored as `SVG` vector image format (.svg extension) under `TinyPedal\trackmap` folder (default). Track map can be viewed with [Track Map Viewer](#track-map-viewer) from `Tools` menu in main window.

Data recording is handled by [Mapping Module](#mapping-module).

The SVG vector map data contains two coordinate paths:
* First is global x,y position path, used for drawing track map.
* Second is corresponding track distance and elevation path, used for drawing elevation plot.

Each sector position index is also stored in SVG file for finding sector coordinates.

[**`Back to Top`**](#)


## Pace notes
`TinyPedal Pace Notes` data is stored as `TPPN` format (.tppn extension) under `TinyPedal\pacenotes` folder (default). Pace notes can be created or edited with [Track Notes Editor](#track-notes-editor) from `Tools` menu in main window.

Pace notes data is mainly used for [Pace Notes Playback](#pace-notes-playback) for specific tracks.

To allow `auto notes loading` function to work, pace notes file name must match same track map file name.

[**`Back to Top`**](#)


## Track notes
`TinyPedal Track Notes` data is stored as `TPTN` format (.tptn extension) under `TinyPedal\tracknotes` folder (default). Track notes can be created or edited with [Track Notes Editor](#track-notes-editor) from `Tools` menu in main window.

Track notes data is mainly used for displaying corner and section names for specific tracks, or providing additional info at specific track location while driving.

To allow `auto notes loading` function to work, track notes file name must match same track map file name.

[**`Back to Top`**](#)


## Brand logo
TinyPedal supports user-defined brand logo image in `PNG` format (.png extension) which is placed under `TinyPedal\brandlogo` folder (default).

Note: TinyPedal does not provide brand logo image assets, it is up to user to prepare images. Maximum `PNG` file size is limited to `1MB`.

How to prepare brand logo image:
1. Brand logo image should have all transparent borders cropped. For example, in `GIMP` this can be done by selecting `Image` > `Crop to Content`.
2. Make sure image dimension is not too big, usually around 100 pixel width or height is good enough. Bigger dimension may consume more RAM or exceed maximum supported file size.
3. Save image to `TinyPedal\brandlogo` folder, image filename must match corresponding `brand name` that defined in [Vehicle Brand Editor](#vehicle-brand-editor). For cross-platform compatibility, filename matching is set to be case-sensitive, make sure filename has the same upper or lower case as set in `brand name`.
4. `Reload` preset to load newly added brand logo images for displaying in overlay.

[**`Back to Top`**](#)


# Command line arguments
**Command line arguments can be passed to script or executable to enable additional features.**

    -h, --help
List all available command line arguments.

Usage: `python .\run.py -h` or `.\tinypedal.exe --help`

    -l, --log-level
Set logging output level. Supported values are:
  * `--log-level 0` outputs only warning or error log to `console`.
  * `--log-level 1` outputs all log to `console`.
  * `--log-level 2` outputs all log to both `console` and `tinypedal.log` file.

Log location:
  * On windows, `tinypedal.log` is located under `username\AppData\Roaming\TinyPedal` folder.
  * On Linux, `tinypedal.log` is located under `home/username/.config/TinyPedal` folder.

Default logging output level is set on `1` if argument is not set.

Usage: `python .\run.py -l 2` or `.\tinypedal.exe --log-level 2`

    -s, --single-instance
Set running mode. `0` allows running multiple instances (copies) of TinyPedal. `1` allows only single instance (default).

To run multiple copies of TinyPedal at same time: `python .\run.py -s 0` or `.\tinypedal.exe --single-instance 0`

Single instance mode saves `pid.log` file in the same folder as `tinypedal.log`, which is used for instance identification.

    -p, --pyside
Set PySide (Qt for Python) module version. Set `2` for PySide2 (default). Set `6` for PySide6. Currently, this option is only available while `running from source`, and mainly for testing purpose or used on platform where PySide2 is no longer available.

[**`Back to Top`**](#)


# Telemetry API
**Telemetry API options can be accessed from `API` menu in main window.**

| Supported API | Requirement | Windows | Linux |
|:-:|---|:-:|:-:|
| Le Mans Ultimate | Game's built-in API, no requirements. | Yes | No |
| Le Mans Ultimate (legacy) | Requires `rF2 Shared Memory Map Plugin` to access. | Yes | Yes |
| rFactor 2 | Requires `rF2 Shared Memory Map Plugin` to access. | Yes | Yes |

    api_name
Set API name for accessing data from supported API.

    enable_api_selection_from_preset
Set `true` to remember and load API selection from preset; set `false` to select API globally for all presets.

[**`Back to Top`**](#)


## Le Mans Ultimate API
**Le Mans Ultimate API options can be accessed from `Options` while this API is enabled in `API` menu in main window.**

    access_mode
Set access mode for API. Mode value `0` uses copy access and additional data check to avoid data desynchronized or interruption issues. Mode value `1` uses direct access, which may result data desynchronized or interruption issues. Default mode is copy access.

    enable_active_state_override
Set `true` to enable `active state` manual override. While enabled, `overriding` notification will be shown on API status bar from main window.

    active_state
This option overrides local player on-track status check, and updates or stops overlay and data processing accordingly. Set `true` to activate state. Set `false` to deactivate state. This option works only when `enable_active_state_override` enabled.

    enable_player_index_override
Set `true` to enable `player index` manual override.

    player_index
Set `player index` override for displaying data from specific player. Valid player index range starts from `0` to max number players minus one, and must not exceed `127`. Set value to `-1` for unspecified player, which can be useful for display general standings and trackmap data (ex. broadcasting). This option works only when `enable_player_index_override` enabled.

    character_encoding
Set character encoding for displaying text in correct encoding. Available encoding: `UTF-8`, `ISO-8859-1`. Default encoding is `UTF-8`.

    enable_restapi_access
Enable Rest API accessing, which connects to game's Rest API for accessing additional data that is not available through sharedmemory API.

    restapi_update_interval
Set update interval (in milliseconds) for requesting data from Rest API.

Note, minimum update interval is hard-limited to `200` milliseconds or higher, and some data are accessed `only once` per garage-exit. Update interval is auto-delayed up to `5` seconds if has not received new data recently. See individual data description for details.

    url_host
Set Rest API host address. Default is `localhost`.

    url_port
Set port for Rest API host address. Port value must match `WebUI port` value that sets in `LMU` (UserData\player\Settings.JSON) setting file in order to successfully connect to Rest API and receive data. The default port value for `LMU` is `6397`.

Note, `WebUI port` value from game setting file may change in some situations, and would require manual correction to match `WebUI port` value.

    connection_timeout
Set connection timeout duration in seconds for Rest API. Value range in `0.5` to `10`. Default is `1` second.

    connection_retry
Set number of attempts to retry connection for Rest API. Value range in `0` to `10`. Default is `3` retries.

    connection_retry_delay
Set time delay in seconds to retry connection for Rest API. Value range in `0` to `60`. Default is `1` second.

    enable_energy_remaining
Enable access to `remaining energy` data from Rest API. This is required for showing remaining energy data in widgets such as Relative, Rivals, Standings. Minimum request interval is hard-limited to `1.0` second (1 request per second) for this data.

    enable_garage_setup_info
Enable access to `garage setup` data from Rest API. This is required for accessing various vehicle setup data. This data is requested `only once` when player exited garage each time.

    enable_session_info
Enable access to `session` data from Rest API. This is required for accessing various session data, such as time-scale. This data is requested `only once` when player exited garage each time.

    enable_vehicle_info
Enable access to `vehicle` data from Rest API. This is essential for accessing `virtual energy`, `brake wear`, `vehicle damage`, `pit stop timing` data. Minimum request interval is hard-limited to `0.2` second (5 requests per second) for this data.

    enable_weather_info
Enable access to `weather` data from Rest API. This is required for showing weather forecast. This data is requested `only once` when player exited garage each time.

[**`Back to Top`**](#)


## rFactor 2 API
**rFactor 2 API options can be accessed from `Options` while this API is enabled in `API` menu in main window.**

    access_mode
Set access mode for API. Mode value `0` uses copy access and additional data check to avoid data desynchronized or interruption issues. Mode value `1` uses direct access, which may result data desynchronized or interruption issues. Default mode is copy access.

    process_id
Set process ID string for accessing API from server. This option is for server use only.

    enable_active_state_override
Set `true` to enable `active state` manual override. While enabled, `overriding` notification will be shown on API status bar from main window.

    active_state
This option overrides local player on-track status check, and updates or stops overlay and data processing accordingly. Set `true` to activate state. Set `false` to deactivate state. This option works only when `enable_active_state_override` enabled.

    enable_player_index_override
Set `true` to enable `player index` manual override.

    player_index
Set `player index` override for displaying data from specific player. Valid player index range starts from `0` to max number players minus one, and must not exceed `127`. Set value to `-1` for unspecified player, which can be useful for display general standings and trackmap data (ex. broadcasting). This option works only when `enable_player_index_override` enabled.

    character_encoding
Set character encoding for displaying text in correct encoding. Available encoding: `UTF-8`, `ISO-8859-1`. Default encoding is `UTF-8`. Note, `UTF-8` may not work well for some Latin characters in `RF2`, try use `ISO-8859-1` instead.

    enable_restapi_access
Enable Rest API accessing, which connects to game's Rest API for accessing additional data that is not available through sharedmemory API.

    restapi_update_interval
Set update interval (in milliseconds) for requesting data from Rest API.

Note, minimum update interval is hard-limited to `200` milliseconds or higher, and some data are accessed `only once` per garage-exit. Update interval is auto-delayed up to `5` seconds if has not received new data recently. See individual data description for details.

    url_host
Set Rest API host address. Default is `localhost`.

    url_port
Set port for Rest API host address. Port value must match `WebUI port` value that sets in `RF2` (UserData\player\player.JSON) setting file in order to successfully connect to Rest API and receive data. The default port value for `RF2` is `5397`.

Note, `WebUI port` value from game setting file may change in some situations, and would require manual correction to match `WebUI port` value.

    connection_timeout
Set connection timeout duration in seconds for Rest API. Value range in `0.5` to `10`. Default is `1` second.

    connection_retry
Set number of attempts to retry connection for Rest API. Value range in `0` to `10`. Default is `3` retries.

    connection_retry_delay
Set time delay in seconds to retry connection for Rest API. Value range in `0` to `60`. Default is `1` second.

    enable_garage_setup_info
Enable access to `garage setup` data from Rest API. This is required for accessing various vehicle setup data. This data is requested `only once` when player exited garage each time.

    enable_session_info
Enable access to `session` data from Rest API. This is required for accessing various session data, such as time-scale. This data is requested `only once` when player exited garage each time.

    enable_weather_info
Enable access to `weather` data from Rest API. This is required for showing weather forecast. This data is requested `only once` when player exited garage each time.

[**`Back to Top`**](#)


# General options
**General options can be accessed from main window menu.**

[**`Back to Top`**](#)


## Common terms and keywords
**These are the commonly used setting terms and keywords.**

    enable
Check whether a widget or module will be loaded at startup.

    update_interval
Set refresh rate for widget or module in milliseconds. A value of `20` means refreshing every 20ms, which equals 50fps. Since most data from sharedmemory plugin is capped at 50fps, and most operation system has a roughly 15ms minimum sleep time, setting value less than `10` has no benefit, and extreme low value may result significant increase of CPU usage.

    idle_update_interval
Set refresh rate for module while idling for conserving resources.

    position_x, position_y
Define widget position on screen in pixels. Those values will be auto updated and saved.

    opacity
Set opacity for entire widget. By default, all widgets have a 90% opacity setting, which equals value `0.9`. Lower value adds more transparency to widget. Acceptable value range in `0.0` to `1.0`. Note, opacity can also be set by adjusting alpha value in `color` options for individual elements.

    bar_gap, inner_gap
Set gap (screen pixel) between elements in a widget, only accept integer, `1` = 1 pixel.

    font_name
Mono type font is highly recommended. To set custom font, write `full font name` inside quotation marks. If a font name is invalid, a default fallback font will be used by program.

    font_size
Set font size in pixel, increase or decrease font size will also apply to widget size.

    font_weight
Acceptable value: `normal` or `bold`.

    enable_auto_font_offset
Automatically adjust font vertical offset based on font geometry for better vertical alignment, and should give good result in most case. This option is enabled by default, and only available to certain widgets. Set `false` to disable.

    font_offset_vertical
Manually set font vertical offset. Default is `0`. Negative value will offset font upward, and position value for downward. This option only takes effect when `enable_auto_font_offset` is set to `false`.

    *_offset_x, *_offset_y
Set text offset position (percentage), value range in `0.0` to `1.0`.

    bar_padding
Set widget edge padding value that multiplies and scales with `font_size`. Default is `0.2` for most widgets. Increase padding value will further increase each element width in widget.

    color
Set color in hexadecimal color codes with alpha value (opacity). The color code format starts with `#`, then follows by two-digit hexadecimal numbers for each channel in the order of `alpha`, `red`, `green`, `blue`. Note, `alpha` is optional and can be omitted. User can select a new color without manual editing, by double-clicking on color entry box in `Config` dialog.

    text_alignment
Set text alignment. Acceptable value: `Left`, `Center`, `Right`.

    prefix
Set prefix text that displayed beside corresponding data. Set to `""` to hide prefix text.

    show_caption
Show short caption description on widget.

    column_index
Set order of each info column(or row). Must keep index number unique to each column, otherwise columns may overlap.

    decimal_places
Set amount decimal places to keep.

[**`Back to Top`**](#)


## Application
**Application options can be accessed from `Config` and `Window` menu in main window.**

    show_at_startup
Show main window at startup, otherwise hides to tray icon.

    check_for_updates_on_startup
Enable automatically checking for updates on startup, and display notification message in main window. This option is enabled by default.

Click on the notification message will bring up a menu, where user can click `View Updates On GitHub` to open `Latest Releases` page in web browser, or `Dismiss` the message.

Note, this option is checked only once per startup, and notification message will only be displayed if new updates is available. This option only checks for new updates info, it does not provide updates downloading or installing feature.

User can also manually check for updates any time by accessing `Check for Updates` option from `Help` menu in main window.

    minimize_to_tray
Minimize to tray when user clicks `X` close button.

    remember_position
Remember main window last position.

    remember_size
Remember main window last size.

    enable_high_dpi_scaling
Enable window dialog and overlay widget auto-scaling under high DPI screen resolution. This option requires restarting TinyPedal to take effect. This option is enabled by default.

High DPI scaling mode can be quickly toggled via `Scale` button on main window status bar.

On Windows, scaling is determined by percentage value set in `Display` > `Scale and Layout` setting. For example, `200%` scale in windows setting will double the size of main window dialog and also every widget.

On Linux, DPI scaling may already be forced `ON` in some system, which this option may not have effect.

    enable_auto_load_preset
Enable `Auto load preset` system to allow auto loading user-defined game-specific preset depends on active game (currently supports `RF2` and `LMU`).

Auto loading preset is triggered when a new or different game is started and active. Auto loading will only trigger once per game change. A preset must be tagged as `primary` for specific game before it can be auto loaded. See [Preset Management](#preset-management) section for details.

This option is disabled by default.

    show_confirmation_for_batch_toggle
Show confirmation dialog for enabling or disabling all widgets or modules. This option is enabled by default.

    snap_distance
The distance (in pixels) at which the widget will snap to screen edges or other widgets. Default `10`. Hold `Ctrl` to enable snapping.

    snap_gap
The gap (in pixels) to leave between the widget and the snapped widget edges. Default `0`.

    grid_move_size
Set grid size for grid move, value in pixel. Default is `8` pixel. Minimum value is limited to `1`.

    minimum_update_interval
Set minimum refresh rate limit for widget and module in milliseconds. This option is used for preventing extremely low refresh rate that may cause performance issues in case user incorrectly sets `update_interval` and `idle_update_interval` values. Default value is `10`, and should not be modified.

    maximum_saving_attempts
Set maximum retry attempts for preset saving. Default value is `10`. Minimum value is limited to `3` maximum attempts. Note, each attempt has a roughly 50ms delay. If all saving attempts failed, saving will be aborted, and old preset file will be restored to avoid preset file corruption.

    position_x, position_y
Define main window position on screen in pixels. Those values will be auto updated and saved while `remember_position` option is enabled.

    window_width, window_height
Define main window size on screen in pixels. Those values will be auto updated and saved while `remember_size` option is enabled.

    window_color_theme
Set color theme for main window and dialog. Default theme is `Dark`. This option does not affect overlay widget.

Color theme can be quickly toggled via `UI` button on main window status bar.

[**`Back to Top`**](#)


## Compatibility
**Compatibility options can be accessed from `Config` menu in main window.**

    enable_bypass_window_manager
Set `true` to bypass window manager on Linux. This option does not affect windows system. This option is enabled by default on Linux. Note, while this option is enabled, OBS may not be able to capture overlay widgets in streaming on Linux.

    enable_translucent_background
Set `false` to disable translucent background.

    enable_window_position_correction
Set `true` to enable main application window position correction, which is used to correct window-off-screen issue with multi-screen. This option is enabled by default.

    enable_x11_platform_plugin_override
Set Qt platform plugin type to `X11` via environment variable on Linux. This option may help work around some issues with overlay dragging and position on `Wayland`. This option requires restarting TinyPedal to take effect. This option is enabled by default on Linux.

    global_bkg_color
Sets global background color for all widgets.

Note, global background color will only be visible when `enable_translucent_background` option is disabled or translucent background is not supported. Some widgets with own background setting may override this option.

    multimedia_plugin_on_windows
Set multimedia plugin for playing sound file on windows. Default is using `WMF` plugin.

Note, if the option is set on `DirectShow`, additional audio decoder software may be required to play certain sound formats, such as `MP3`. This option requires restarting TinyPedal to take effect.

[**`Back to Top`**](#)


## User path
**User path options can be accessed from `Config` menu in main window.**

User path dialog allows customization to global user path for storing different user data.

To change user path, double-clicking on edit box to open `Select folder` dialog; or manually editing path text. Folder will be automatically created if does not exist.

Click `Apply` or `Save` button to verify and apply new paths. Invalid path will not be applied.

**Notes to relative and absolute path**

User path that sets inside TinyPedal root folder will be automatically converted to relative path. Relative path is not considered global path, and does not share data between multiple copies of TinyPedal. This is done to retain portability and compatibility with old version.

To share user path across multiple copies of TinyPedal, user must set path to place outside TinyPedal APP root folder.

**Default user path**

* On windows, all user paths are set inside TinyPedal root folder as relative paths:

        brandlogo/
        deltabest/
        settings/
        trackmap/
        pacenotes/
        tracknotes/

* On Linux, all user paths are set outside TinyPedal root folder as absolute paths:

        home/username/.config/TinyPedal/brandlogo/
        home/username/.config/TinyPedal/settings/
        home/username/.config/TinyPedal/pacenotes/
        home/username/.config/TinyPedal/tracknotes/
        home/username/.local/share/TinyPedal/deltabest/
        home/username/.local/share/TinyPedal/trackmap/

[**`Back to Top`**](#)


## Overlay
**Overlay options can be accessed from `Overlay` menu in main window, or from tray icon menu.**

    fixed_position
Check whether widget is locked at startup. This setting can be toggled from tray icon menu.

    auto_hide
Check whether auto hide is enabled. This setting can be toggled from tray icon menu.

    enable_grid_move
Enable grid-snap effect while moving widget for easy alignment and repositioning.

    vr_compatibility
Enable widget visibility as windows on taskbar in order to be used in VR via APPs such as `OpenKneeboard`. Non-VR user should not enable this option.

Note, you will still need a third party program (such as `OpenKneeboard`) to project overlay windows (widgets) into VR.

[**`Back to Top`**](#)


## Units
**Units options can be accessed from `Config` menu in main window.**

    distance_unit
2 unit types are available: `Meter`, `Feet`.

    fuel_unit
2 unit types are available: `Liter`, `Gallon`.

    odometer_unit
3 unit types are available: `Kilometer`, `Mile`, `Meter`.

    power_unit
3 unit types are available: `Kilowatt`, `Horsepower`, `Metric Horsepower`.

    speed_unit
3 unit types are available: `KPH`, `MPH`, `m/s`.

    temperature_unit
2 unit types are available: `Celsius`, `Fahrenheit`.

    turbo_pressure_unit
3 unit types are available: `bar`, `psi`, `kPa`.

    tyre_pressure_unit
3 unit types are available: `kPa`, `psi`, `bar`.

[**`Back to Top`**](#)


## Global font override
**Global font override options can be accessed from `Config` menu in main window, which allow changing font setting globally for all widgets.**

    Font Name
Select a font name to replace `font_name` setting of all widgets. Default selection is `no change`, which no changes will be applied.

    Font Size Addend
Set a value that will be added (or subtracted if negative) to `font_size` value of all widgets. Default is `0`, which no changes will be applied.

    Font Weight
Set font weight to replace `font_weight` setting of all widgets. Default selection is `no change`, which no changes will be applied.

[**`Back to Top`**](#)


## Spectate mode
**Spectate mode can be accessed from `Spectate` tab in main window.**

Click `Enabled` or `Disabled` button to toggle spectate mode on and off. Note, spectate mode can also be enabled by setting `enable_player_index_override` option to `true` in [Telemetry API](#telemetry-api) config.

While Spectate mode is enabled, `double-click` on a player name in the list to access telemetry data and overlay readings from selected player; alternatively, select a player name and click `Spectate` button. Current spectating player name is displayed on top of player name list. Player names are listed in alphabetical order.

Select `Anonymous` for unspecified player, which is equivalent to player index `-1` in JSON file.

Click `Refresh` button to manually refresh player name list.

[**`Back to Top`**](#)


## Pace notes playback
**Pace notes playback control panel can be accessed from `Pace Notes` tab in main window.**

Note, [Notes Module](#notes-module) must be enabled to allow pace notes playback.

Click `Playback Enabled` or `Playback Disabled` button to quickly enable or disable pace notes playback. Disabling this option does not affect `Notes Module` or `Pace notes Widget`.

Click `Enable Playback While in Pit Lane` check box to enable or disable pace notes playback while in pit lane. This option takes immediate effect when changed.

Enable `Manually Select Pace Notes File` check box to disable auto-file-name matching, and manually select a pace notes file that can be played on any track. By default, pace notes file is automatically loaded from `pace_notes_path` if a file that matches current track name is found. This option takes immediate effect when changed.

`Sound file path` sets path for loading pace notes sound files that matches name value (exclude file extension) from `pace note` column found in pace notes file. If no sound file found, sound won't be played. This option takes immediate effect when changed.

`Sound format` sets sound format for loading sound file, which should match sound file extension. This option only takes effect after clicked `Apply` button.

`Global offset` adds global position offset (in meters) to current vehicle position on track, which affects when next pace note line will be played. This option only takes effect after clicked `Apply` button.

`Max duration` sets maximum playback duration for each sound file, which can be used to limit sound file maximum playing duration. Default duration is `10` seconds. This option only takes effect after clicked `Apply` button.

`Max Queue` sets maximum number of sound files in playback queues. Default is `5` sound files. This option only takes effect after clicked `Apply` button.

`Playback volume` sets output volume for sound file. This option takes immediate effect when adjusted.

[**`Back to Top`**](#)


# Tools
**Tools can be accessed from main window menu.**

[**`Back to Top`**](#)


## Fuel calculator
**Fuel calculator can be accessed from `Tools` menu in main window.**

Fuel value and unit symbol depend on `Fuel Unit` setting from [Units](#units) config dialog, `L` = liter, `gal` = gallon. Virtual energy unit is `%` = percentage. Note, after changed `Fuel Unit` setting, it is required to close and reopen `Fuel calculator` in order to update units info for calculation.

    Calculation panel
On the left side is calculation panel, which handles `fuel` and `virtual energy` usage calculation and results display.

This panel also includes a vertical `pit stop preview` bar on the left, which visualizes pit stops as blue marks and stint laps as grey marks. Each pit stop mark shows a reference lap completion number. Total estimated number of race laps is displayed at bottom of the bar.

Note, when `Energy consumption` value is higher than zero, pit stops and stint laps from preview bar will be calculated based on energy usage. Stint lap mark may not be displayed if there is not enough space to draw.

    Consumption history table
On the right side is consumption history table, which lists `lap number`, `lap time`, `fuel consumption`, `virtual energy consumption`, `battery drain`, `battery regen`, `average tyre tread wear`, `tank capacity` data from [Consumption History](#consumption-history) data. Invalid lap time or consumption data is highlighted in red.

Click `Load Live` button to load or update consumption history from live session to history table and automatically fill in latest data to calculator.

Click `Load File` button to load data from specific consumption history file to history table and automatically fill in latest data to calculator.

Loaded data source and track and class name will be displayed on status bar.

Select one or more `Time`, `Fuel`, `Energy`, `Tyre`, `Tank` values from history table and click `Add selected data` button to send value to calculator.

Select multiple values from history table and click `Add selected data` button to calculate average reading of selected values and send to calculator.

    Lap time
Set lap time in `minutes` : `seconds` : `milliseconds` format. Values are automatically carried over between spin boxes when exceeded min or max value range. This value can be retrieved from `Time` column.

    Tank capacity
Set vehicle fuel tank capacity. This value can be retrieved from `Tank` column.

    Fuel consumption
Set fuel consumption per lap. This value can be retrieved from `Fuel` column.

    Energy consumption
Set virtual energy consumption per lap. This value can be retrieved from `Energy` column.

    Fuel ratio
Show fuel ratio between fuel and virtual energy consumption.

    Race minutes
Set race length in minutes for time-based race. Note, option is disabled if `Race laps` is set.

    Race laps
Set race length in laps for lap-based race. Note, option is disabled if `Race minutes` is set.

    Formation/Rolling
Set number of formation or rolling start laps.

    Average pit seconds
Set average pit stop time in seconds.

    Total race fuel, Total race energy
Show total required fuel or energy to finish race. First value is raw reading with decimal places, second value behind `â‰ˆ` sign is rounded up integer reading.

    End stint fuel, End stint energy
Show remaining fuel or energy at the end of stint.

    Total pit stops
Show total number of pit stops required to finish race. First value is raw reading with decimal places, second value behind `â‰ˆ` sign is rounded up integer reading.

Note, sometimes when `Average pit seconds` is set to longer duration, ceiling integer reading may be rounded up `2` units higher than raw reading, this is not an error. For example, it may show `5.978 â‰ˆ 7` instead of `5.978 â‰ˆ 6`, this is because when calculating from `6` pit stops, due to less amount time spent in pit stop compare to `7`, more fuel is required per pit stop which would exceed tank capacity, hence calculator adds 1 more pit stop.

    One less pit stop
Show theoretical fuel or energy consumption in order to make one less pit stop.

    Total laps, Total minutes
Show total laps and minutes can run based on `Total race fuel` or `Total race energy` value.

    Max stint laps, Max stint minutes
Show maximum laps and minutes can run per stint based on `Tank capacity` value (or 100% capacity for virtual energy).

    Starting fuel, Starting energy
Set amount fuel or energy to carry at the starting of race (first stint). This value affects `Total race fuel (or energy)` and `Total pit stops` calculation, and is used for calculating `Average refueling` or `Average replenishing` per pit stop. Maximum value cannot exceed `Tank capacity` for fuel (or `100%` for energy). If value is set to `0` (default), `Tank capacity` value will be used as starting fuel (or `100%` for starting energy) for `Average refueling` calculation.

    Average refueling, Average replenishing
Show average refueling or replenishing per pit stop, and display warning color if value exceeds `Tank capacity` (fuel) or `100%` (energy).

    Starting tyre tread
Set average starting tyre tread (percent). For example, 100% for new tyres, and less for worn tyres.

    Tread wear per lap
Set average tyre tread wear (percent) per lap. This value can be retrieved from `Tyre` column.

    Tread wear per stint
Show total average tyre tread wear (percent) per stint. Note, while virtual energy is available, this value will be calculated based on the least `max stint laps` between fuel and virtual energy.

    Lifespan laps, Lifespan minutes
Show total tyre lifespan in laps and minutes based on `tread wear per lap` and `lap time`.

    Lifespan stints
Show estimated tyre lifespan in number of stints. Note, while virtual energy is available, this value will be calculated based on the least `max stint laps` between fuel and virtual energy.

[**`Back to Top`**](#)


## Driver stats viewer
**Driver stats viewer can be accessed from `Tools` menu in main window.**

Driver stats viewer is used for viewing [Driver Stats](#driver-stats). Note, the viewer only allows limited reset or removal, stat value cannot be edited by design. Any changes will take immediate effect after confirmation, changes cannot be undone.

Driver stats are grouped under specific track name, which can be switched from track name selector on the top.

To sort by specific stat, click on corresponding column name. Stats are sorted by `personal best lap time` by default.

To view corresponding track map, click `View Map` button.

To reload stats data, click `Reload` button.

To delete all stats from a specific track, click `Delete` button.

To remove all stats from a specific vehicle, right-click on vehicle name and select `Remove Vehicle`.

To reset personal best lap time to default, right-click on personal best lap time and select `Reset Lap Time`.

`Vehicle` column is vehicle classification info, which is determined by `vehicle_classification` option in [Stats Module](#stats-module).

`PB` column is personal best lap time. This value can be reset via right-click menu.

`Qualifying` column is personal best lap time from qualifying session only. This value can be reset via right-click menu.

`Race` column is personal best lap time from race session only. This value can be reset via right-click menu.

`Km` column is total driven distance in kilometers. Note, `odometer_unit` setting from [Units](#units) affects how this column is displayed.

`Hours` column is total time spent in driving (only counts when vehicle speed higher than 1 m/s).

`Liter` column is total fuel consumed. Note, `fuel_unit` setting from [Units](#units) affects how this column is displayed.

`Valid` column is total valid laps completed.

`Invalid` column is total invalid laps completed.

`Penalties` column is total penalties received in race. Non-race penalties are not recorded.

`Finishes` column is total races completed.

`Wins` column is total races won.

`Podiums` column is total podiums from race.

Note, race completion and final standings stats are retrieved at the moment when local driver crossed finish line on final lap, it does not concern any post-race penalties or finish state from team mate.

[**`Back to Top`**](#)


## Vehicle brand editor
**Vehicle brand editor can be accessed from `Tools` menu in main window.**

Vehicle brand editor is used for editing [Brands Preset](#brands-preset). Note, any changes will only be saved and take effect after clicking `Apply` or `Save` Button.

For brand logo image preparation, see [Brand Logo](#brand-logo) section.

`Vehicle name` is full vehicle name that must match in-game vehicle name.

`Brand name` is custom brand name.

To import vehicle brand data from `Rest API`, click `Import from` menu, and select either `RF2 Rest API` or `LMU Rest API`. Note, game updates may introduce new vehicles, it is recommended to re-import after each game update to keep brand info updated.

Note, there are currently two sources for importing from `LMU Rest API`:
- Primary: allows to import brands from both original and custom vehicle skins.
- Alternative: may allow to import some brands that are missing from Primary source. This is normally not required.

**Important notes**

Game must be running in order to import from `Rest API`. Newly imported data will be appended on top of existing data, existing data will not be changed.

If importing fails while game is running, check if `URL Port` option in `RestAPI` module that matches `WebUI port` value that sets in `LMU` (UserData\player\Settings.JSON) or `RF2` (UserData\player\player.JSON) setting file. See [Telemetry API](#telemetry-api) section for details.

Alternatively, to import vehicle brand data from vehicle `JSON` file, click `Import from` menu, and select `JSON file`.

    How to manually export vehicle brand data from RF2 Rest API:
    1. Start RF2, then open following link in web browser:
    localhost:5397/rest/race/car
    2. Click "Save" button which saves vehicle data to JSON file.

    How to manually export vehicle brand data from LMU Rest API:
    1. Start LMU, then open following link in web browser:
    localhost:6397/rest/race/car
    localhost:6397/rest/sessions/getAllVehicles
    2. Click "Save" button which saves vehicle data to JSON file.

    Note: importing feature is experimental. Maximum acceptable JSON file size is limited to "5MB".

To add new brand name, click `Add` button. Note, the editor can auto-detect and fill-in missing vehicle names found from current active session, existing data will not be changed.

To sort brand name in orders, click `Sort` button.

To remove a brand name, select a vehicle name and click `Delete` button.

To batch replace name, click `Replace` button.

To reset all brands setting to default, click `Reset` button; or manually delete `brands.json` preset.

[**`Back to Top`**](#)


## Vehicle class editor
**Vehicle class editor can be accessed from `Tools` menu in main window.**

Vehicle class editor is used for editing [Classes Preset](#classes-preset). Note, any changes will only be saved and take effect after clicking `Apply` or `Save` Button.

`Class name` column is full vehicle class name that must match in-game vehicle.

`Alias name` column is alternative name that replaces class name for displaying.

`Color` column is class color style (HEX code). Double-click on color to open color dialog.

To add new class, click `Add` button. Note, the editor can auto-detect and fill-in missing vehicle classes found from current active session, existing data will not be changed.

To sort class name in orders, click `Sort` button.

To remove class, select one or more rows and click `Delete`.

To reset all classes setting to default, click `Reset` button; or manually delete `classes.json` preset.

[**`Back to Top`**](#)


## Brake editor
**Brake editor can be accessed from `Tools` menu in main window.**

Brake editor is used for editing [Brakes Preset](#brakes-preset). Note, any changes will only be saved and take effect after clicking `Apply` or `Save` Button.

`Brake name` column is full vehicle class name plus brake name that must match in-game vehicle. Brand name may also be added if vehicle brand data is available.

`Failure (mm)` column is millimeter thickness threshold at brake failure and affects brake wear calculation. See [Brake Wear](#brake-wear) widget for details.

`Heatmap name` column is heatmap style name selector. Click on heatmap selector to open drop down list and select a heatmap style.

To add new brake, click `Add` button. Note, the editor can auto-detect and fill-in missing brakes found from running vehicles in current active session, existing data will not be changed.

To sort brake name in orders, click `Sort` button.

To remove brake, select one or more rows and click `Delete`.

To reset all brakes setting to default, click `Reset` button; or manually delete `brakes.json` preset.

[**`Back to Top`**](#)


## Track info editor
**Track info editor can be accessed from `Tools` menu in main window.**

Track info editor is used for editing [Tracks Preset](#tracks-preset). Note, any changes will only be saved and take effect after clicking `Apply` or `Save` Button.

`Track name` column is full track name that must match in-game track.

`Pit entry (m)` column is pit entry position (in meters) relative to track length. This value is automatically recorded or updated by [Mapping Module](#mapping-module).

`Pit exit (m)` column is pit exit position (in meters) relative to track length. This value is automatically recorded or updated by [Mapping Module](#mapping-module).

`Pit speed (m/s)` column is pit lane speed limit (in meters per second). This value is automatically recorded or updated by [Mapping Module](#mapping-module). Note, vehicle pit limiter must be activated while in pit lane to allow recording speed limit.

`Speed trap (m)` column is speed trap position (in meters) relative to track length. To manually set speed trap position at your current on-track position, `Right-Click` on corresponding track's speed trap column and select `Set from Telemetry`.

To add new track, click `Add` button. Note, the editor can auto-detect and fill-in missing track found from current active session, existing data will not be changed.

To sort track name in orders, click `Sort` button.

To remove track, select one or more rows and click `Delete`.

To reset all tracks setting to default, click `Reset` button; or manually delete `tracks.json` preset.

[**`Back to Top`**](#)


## Tyre compound editor
**Tyre compound editor can be accessed from `Tools` menu in main window.**

Tyre compound editor is used for editing [Compounds Preset](#compounds-preset). Note, any changes will only be saved and take effect after clicking `Apply` or `Save` Button.

`Compound name` column is full vehicle class name plus full tyre compound name that must match in-game vehicle.

`Symbol` column is alternative symbol character that replaces full tyre compound name for displaying.

`Heatmap name` column is heatmap style name selector. Click on heatmap selector to open drop down list and select a heatmap style.

To add new tyre compound, click `Add` button. Note, the editor can auto-detect and fill-in missing tyre compounds found from running vehicles in current active session, existing data will not be changed.

To sort tyre compound name in orders, click `Sort` button.

To remove tyre compound, select one or more rows and click `Delete`.

To batch replace name, click `Replace` button.

To reset all tyre compounds setting to default, click `Reset` button; or manually delete `compounds.json` preset.

[**`Back to Top`**](#)


## Heatmap editor
**Heatmap editor can be accessed from `Tools` menu in main window.**

Heatmap editor is used for editing [Heatmap Preset](#heatmap-preset). Note, any changes will only be saved and take effect after clicking `Apply` or `Save` Button.

Each row represents a target temperature and corresponding color. First column is temperature degree value in `Celsius`, and up to one decimal place is kept. Second column is corresponding color (HEX code). Double-click on color to open color dialog.

To add temperature, click `Add` button.

To sort temperature list in orders, click `Sort` button.

To batch offset temperature values, select one or more temperature from `temperature` column, then click `Offset` button. Click `Scale Mode` check box to scale temperature values. Note, offset option will be reset to `0` each time after applying. Last applied offset value is displayed on top of dialog.

To remove a temperature, select one or more temperature and click `Remove` button.

To select a different heatmap preset, click `drop-down list` at top, and select a preset name. Note: by selecting a different preset, any changes to previously selected heatmap will be saved in cache, and only be saved to file after clicking `Apply` or `Save` Button.

To create a new heatmap preset, click `New` button. Note: only alphabetic characters, numbers, underscores are accepted in preset name, and renaming preset is not supported.

To duplicate a heatmap preset, click `Copy` button.

To delete selected heatmap preset, click `Delete` button. Note: built-in presets cannot be deleted.

To reset selected heatmap preset, click `Reset` button. Note: only built-in presets can be reset.

To assign a heatmap preset to specific widget, select corresponding `heatmap name` in widget config dialog.

In case of errors found in `heatmap.json` preset, the APP will automatically fall back to built-in default heatmap preset.

To restore all heatmap settings back to default, just delete `heatmap.json` preset.

[**`Back to Top`**](#)


## Track map viewer
**Track map viewer can be accessed from `Tools` menu in main window.**

To load a track map, click `Load Map` button. Map file name will be displayed alongside if file is successfully loaded. Note, only track map files (.svg extension) that generated from TinyPedal [Mapping Module](#mapping-module) are supported.

To customize map display, click `Config` button. Note, some display options may require reload track map file to be updated.

To zoom map in or out, scroll mouse wheel in map display area; or adjust `Zoom` spin box value.

To move current position on map, use position slider at bottom of map display; or adjust `Position` spin box value.

To increase or decrease current nodes selection, adjust `Nodes` spin box value. Note, minimum nodes selection is limited to `3` nodes, maximum nodes selection cannot exceed total map nodes.

To toggle on or off specific map display, `Right-Click` on map display area to open context menu, includes:
* Map info - Show map length, total map nodes.
* Position info - Show current node position and global XYZ coordinates (Z is elevation).
* Curve info - Show curve section length, grade, radius, angle, curvature.
* Slope info - Show slope grade, percent, angle, height delta.
* Center mark - Mark current node position.
* Distance circle - Show reference distance circles.
* Osculating circle - Show osculating circle that calculated from curve section.
* Curve section - Show curve section from current nodes selection.
* Marked coordinates - Show marked coordinates if available.
* Highlighted coordinates - Show highlighted coordinates if available.
* Dark background - Show dark background color.

---

    inner_margin
Set inner margin for info display.

    position_increment_step
Set single increment step for position slider and spin box. Default is `5` meters.

    curve_grade_*
Set corner curve classification by radius (meters). Set value to `-1` to exclude from grade selection.

    length_grade_*
Set corner length classification by meters.

    slope_grade_*
Set road slope classification by slope percent.

[**`Back to Top`**](#)


## Track notes editor
**Track notes editor allows for creating and editing track or pace notes, which can be accessed from `Tools` menu in main window.**

Note, by default the editor starts in `Pace Notes` edit mode as displayed in status bar.

**Important note, the editor does not provide `undo` function, it is recommended to save file before doing heavy modification.**

The editor consists of two panel views:
* Left panel is the `Track Map Viewer`, which can be used to visualize track map and providing analytic info for assisting notes creation. See [Track Map Viewer](#track-map-viewer) section for details.
* Right panel is the track and pace notes editor, which allows to create, open, and save track or pace notes file.

The table view consists of multiple columns:
* `distance` column defines track position (in meters) of a note line.
* `pace note` column (in Pace Notes edit mode) defines `pace note` name that is used to match pace note sound file name. Because windows system excludes some special characters from used in file name, the `pace note` column will automatically strip off invalid characters. Note, DO NOT write file extension (format) in `pace note` column. File extension should be set in `Pace Notes` control panel tab from main window.
* `track note` column (in Track Notes edit mode) defines track `corner name` or `section name` or any thing user wish to note.
* `comment` column defines optional extra info for `pace note` or `track note` column for user. Note, a comment can be broken into multiple lines by adding `\n` to any part of the comment.

To create or open pace notes, click `File` and select `New Pace Notes` or `Open Pace Notes`.

To create or open track notes, click `File` and select `New Track Notes` or `Open Track Notes`.

To save notes file, click `Save`. Note, notes file name should exactly match with track name from track map file name for `auto notes loading` function to work. The editor will try to retrieve track name automatically in an active session, or from an opened track map in `Track Map Viewer`.

To save notes file to other formats for used in other games, select a file format name from `save type` in save dialog, such as `GPL Pace Notes (*.ini)` which saves pace notes in GPL pace notes file format. Note, only `TinyPedal` notes file formats are supported for used in TinyPedal.

To hide map viewer, click `Hide Map`. To show map viewer, click `Show Map`.

To edit metadata info, click `Info`. Metadata info provides optional info to notes:
* `Title` of notes.
* `Author` of notes.
* `Date` when notes created or modified.
* `Description` about notes.

To set `distance` (position) value, first select one cell from `distance` column, then click `Set Pos` and click either `From Map` or `From Telemetry`. Note, `From Map` retrieves `distance` data from track map that opened in `Track Map Viewer`; `From Telemetry` retrieves `distance` data from current on-track vehicle position.

To add a note line, click `Add`, which adds a new note line at the end of notes table.

To insert a note line, first select a note line from notes table, then click `Insert` to insert a new note line `above` selected note line. To insert below selected note line, right-click on selected note line and click `Insert Row Below` from context menu.

To sort notes table, click `Sort`.

To delete notes, first select one or multiple note lines from notes table, then click `Delete`.

To replace words, click `Replace` and select a column, then use `Find` and `Replace` to find and replace words.

To batch offset `distance` (position) values, first select one or multiple note lines from `distance` column, then click `Offset` button. Click `Scale Mode` check box to scale distance values. Note, offset option will be reset to `0` each time after applying. Last applied offset value is displayed on top of dialog.

To highlight a `distance` value on `Track Map Viewer`, right-click on a note line and click `Highlight on Map`.

[**`Back to Top`**](#)


# Modules
Modules provide important data that updated in real-time for other widgets. Widgets may stop updating or receiving readings if corresponding modules were turned off. Each module can be configured by accessing `Config` button from `Module` tab in main window.

[**`Back to Top`**](#)


## Delta module
**This module provides deltabest and timing data.**

    module_delta
Enable delta module.

    minimum_delta_distance
Set minimum recording distance (in meters) between each lap time sample. Default value is `5` meters. Lower value may result more samples recorded and bigger file size; higher value may result less samples recorded and inaccuracy. Recommended value range in `5` to `10` meters.

    delta_smoothing_samples
Set number of samples for reducing data fluctuation. Higher value results more smoothness, but may lose accuracy. Default is `30` samples. Set to `1` to disable smoothing.

    laptime_pace_samples
Set number of samples for average laptime pace calculation. Default is `6` samples. Set `1` to disable averaging. Note, initial laptime pace is always based on player's all time personal best laptime if available. If a new laptime is faster than current laptime pace, it will replace current laptime pace without calculating average. Invalid lap, pit-in/out laps are always excluded from laptime pace calculation.

    laptime_pace_margin
Set additional margin for laptime pace that cannot exceed the sum of previous `laptime pace` and `margin`. This option is used to minimize the impact of unusually slow laptime. Default value is `5` seconds. Minimum value is limited to `0.1`.

[**`Back to Top`**](#)


## Energy module
**This module provides vehicle virtual energy usage data.**

    module_energy
Enable energy module.

    minimum_delta_distance
Set minimum recording distance (in meters) between each virtual energy usage sample. Default value is `5` meters. Lower value may result more samples recorded and bigger file size; higher value may result less samples recorded and inaccuracy. Recommended value range in `5` to `10` meters.

[**`Back to Top`**](#)


## Force module
**This module provides vehicle g force, downforce, braking rate data.**

    module_force
Enable force module.

    gravitational_acceleration
Set gravitational acceleration value on earth.

    max_g_force_reset_delay
Set time delay in seconds for resetting max g force reading.

    max_average_g_force_samples
Set amount samples for calculating max average g force. Minimum value is limited to `3`.

    max_average_g_force_difference
Set max average g force difference threshold which compares with the standard deviation calculated from max average g force samples. Default is `0.2` g.

    max_average_g_force_reset_delay
Set time delay in seconds for resetting max average g force. Default is `30` seconds.

    max_braking_rate_reset_delay
Set time delay in seconds for resetting max braking rate. Default is `60` seconds.

[**`Back to Top`**](#)


## Fuel module
**This module provides vehicle fuel usage data.**

    module_fuel
Enable fuel module.

    minimum_delta_distance
Set minimum recording distance (in meters) between each fuel usage sample. Default value is `5` meters. Lower value may result more samples recorded and bigger file size; higher value may result less samples recorded and inaccuracy. Recommended value range in `5` to `10` meters.

[**`Back to Top`**](#)


## Hybrid module
**This module provides vehicle battery usage and electric motor data.**

    module_hybrid
Enable hybrid module.

    minimum_delta_distance
Set minimum recording distance (in meters) between each battery charge usage sample. Default value is `5` meters. Lower value may result more samples recorded and bigger file size; higher value may result less samples recorded and inaccuracy. Recommended value range in `5` to `10` meters.

[**`Back to Top`**](#)


## Mapping module
**This module records and processes track map data.**

    module_mapping
Enable mapping module.

[**`Back to Top`**](#)


## Notes module
**This module processes track and pace notes data.**

    module_notes
Enable notes module.

[**`Back to Top`**](#)


## Relative module
**This module provides vehicle relative and standings data.**

    module_relative
Enable relative module.

[**`Back to Top`**](#)


## Sectors module
**This module provides sectors timing data.**

    module_sectors
Enable sectors module.

    enable_all_time_best_sectors
Calculate sectors timing based on all time best sectors and affects [Sectors](#sectors) widget display. This option is enabled by default. Set `false` to calculate sectors timing from current session only. Note, both session best and all time best sectors data are saved no matter the setting.

[**`Back to Top`**](#)


## Stats module
**This module records driver stats data.**

Note, while `enable_player_index_override` or `enable_active_state_override` option is enabled in [Telemetry API](#telemetry-api), driver stats will not be recorded. Stats are only saved when driver returned to garage.

    module_stats
Enable stats module.

    vehicle_classification
Set one of the three vehicle classifications where stats will be saved.

`Class - Brand` saves corresponding stats under class and brand name. Make sure to use [Vehicle Brand Editor](#vehicle-brand-editor) to import brand name. If brand name does not exist, only class name will be used instead.

`Class` saves corresponding stats under class name only.

`Vehicle` saves corresponding stats under vehicle name only. Saving stats under vehicle name is not recommended, because each single vehicle in `RF2` or `LMU` uses unique vehicle name, which will result multiple records of the same vehicle.

    enable_podium_by_class
Enable to count race finish position by class instead of overall position.

[**`Back to Top`**](#)


## Vehicles module
**This module provides additional processed vehicles data.**

    module_vehicles
Enable vehicles module.

    lap_difference_ahead_threshold
Lap difference (percentage) threshold for tagging opponents as ahead. Default is `0.9` lap.

    lap_difference_behind_threshold
Lap difference (percentage) threshold for tagging opponents as behind. Default is `0.9` lap.

[**`Back to Top`**](#)


## Wheels module
**This module provides wheel radius, slip ratio, tyre wear, brake wear data.**

    minimum_axle_rotation
Set minimum axle rotation (radians per second) for calculating wheel radius and differential locking percent. Default value is `4`.

    maximum_rotation_difference_front, maximum_rotation_difference_rear
Set maximum rotation difference between left or right wheel rotation and same axle rotation for limiting wheel radius calculation. Default value is `0.002` (0.2%). Setting higher difference value may result inaccurate wheel radius reading.

    cornering_radius_sampling_interval
Set position sampling interval for cornering radius calculation. Value range in `5` to `100`. Default sampling interval is `10`, which is roughly 200ms interval between each recorded position. Higher value may result inaccuracy. Note, this option does not affect position recording interval.

    minimum_delta_distance
Set minimum recording distance (in meters) between each tyre wear sample. Default value is `5` meters. Lower value may result more samples recorded and bigger file size; higher value may result less samples recorded and inaccuracy. Recommended value range in `5` to `10` meters.

    enable_suspension_measurement_while_offroad
Enable suspension travel measurement while vehicle is offroad. This option should be disabled for road racing for more accurate suspension measurement. This option is disabled by default.

    average_suspension_position_samples
Set amount samples for calculating average suspension position, which helps to filter out unusual data. Default is `20`. Minimum value is limited to `3`.

    average_suspension_position_margin
Set additional margin that cannot exceed the sum of previous `average suspension position` and `margin`. This option is used to minimize the impact of unusual data. Default value is `1` millimeter. Minimum value is limited to `0.1`.

    wheel_lift_off_threshold
Set millimeter threshold of tyre vertical deflection for detecting lifted wheels. Suspension travel is not calculated from wheel that is lifted off the ground (as below the threshold). Default threshold is `1` millimeter. Set to `-1` to always calculate suspension travel even if wheel is lifted off.

[**`Back to Top`**](#)


# Widgets
Each widget can be configured by accessing `Config` button from `Widget` tab in main window.

Widget context menu can be accessed by `Right-Click` on widget, which provides additional options:
- Center horizontally: align widget to the center of active screen horizontally.
- Center vertically: align widget to the center of active screen vertically.

[**`Back to Top`**](#)


## Battery
**This widget displays battery usage info.**

Note, there are some electric vehicles in `RF2` that are not based on the new electric motor and battery charge system, which there is no battery usage info available.

    show_battery_charge
Show percentage available battery charge.

    show_battery_drain
Show percentage battery charge drained in current lap.

    show_battery_regen
Show percentage battery charge regenerated in current lap.

    show_estimated_net_change
Show estimated battery charge net change from current lap. Positive value indicates net gain (regen higher than drain); negative indicates net loss (drain higher than regen).

Total net change reading is more accurate for vehicles that constantly consume battery charge, such as `FE` or `Hypercar` class. It is less useful for vehicles that only utilize electric motor for a short duration, such as `P2P`.

Note, at least one full lap (excludes pit-out or first lap) is required to generate estimated net change data.

    show_activation_timer
Show electric boost motor activation timer.

    high_battery_threshold, low_battery_threshold
Set percentage threshold for displaying low or high battery charge warning indicator. Default high threshold is `95` percent (default color purple), low threshold is `10` percent (default color red).

    show_battery_charge_warning_flash
Show battery charge warning flash effect when battery charge decreased below `low_battery_threshold` or increased above `high_battery_threshold`.

    number_of_warning_flashes
Set number of warning flashes that will be played for a limited number of times. Default is `10` flashes. Minimum value is limited to `3`.

    warning_flash_highlight_duration
Set color highlight duration for each warning flash. Default is `0.4` seconds. Minimum value is limited to `0.2`.

    warning_flash_interval
Set minimum time interval between each warning flash. Default is `0.4` seconds. Minimum value is limited to `0.2`.

    freeze_duration
Set freeze duration (seconds) for displaying previous lap total drained/regenerated battery charge after crossing finish line. Value range in `0` to `30` seconds. Default is `10` seconds.

[**`Back to Top`**](#)


## Brake bias
**This widget displays brake bias info.**

    show_front_and_rear
Show both front and rear bias. Default is `false`.

    show_percentage_sign
Set `true` to show percentage sign for brake bias value.

    show_baseline_bias_delta
Show delta between current and baseline brake bias, which can be useful for keeping track of brake bias changes easier during a long race. Baseline brake bias is automatically set (and reset) while vehicle is stationary in pit lane or stationary during formation lap.

    show_brake_migration
Show real-time brake migration change, as commonly seen in LMH and LMDh classes.

Note, brake migration is calculated based on brake input and brake pressure telemetry data, and is affected by pedal force setting from car setup and electric braking allocation of specific vehicle.

To get accurate brake migration reading, it is necessary for brake pedal to reach fully pressed state for at least once while entering track to recalibrate brake pressure scaling for brake migration calculation. It is normally not required to do manually, as game's auto-hold brake assist is on by default. However if auto-hold brake assist is off, or the APP was reloaded while player was already on track, then it is required to do a full braking for at least once to get accurate brake migration reading.

    electric_braking_allocation
Set allocation for calculating brake migration under different electric braking allocation from specific vehicle. Note, vehicle that has not electric braking, or has disabled regeneration, is not affected by this option. Incorrect allocation value will result wrong brake migration reading from vehicle that has electric braking activated.

Set value to `-1` to enable auto-detection, which automatically checks whether electric braking is activated on either axles while braking, and sets allocation accordingly. This is enabled by default. Note, it may take a few brakes to detect correct allocation.

Set value to `0` to manual override and use front allocation, which is commonly seen in LMH class.

Set value to `1` to manual override and use rear allocation, which is commonly seen in LMDh class.

[**`Back to Top`**](#)


## Brake performance
**This widget displays brake performance info.**

    show_transient_max_braking_rate
Show transient max braking rate (g) from last braking input, and resets after 3 seconds.

    show_max_braking_rate
Show max braking rate (g), and resets after a set period of time that defined by `max_braking_rate_reset_delay` value in Force Module.

    show_delta_braking_rate
Show max braking rate difference (g) against transient max braking rate, and resets on the next braking.

    show_delta_braking_rate_in_percentage
Show max braking rate difference (g) in percentage (%) instead.

    show_front_wheel_lock_duration, show_rear_wheel_lock_duration
Show front and rear wheel lock duration (seconds) per lap under braking. Duration increases when tyre slip ratio has exceeded `wheel_lock_threshold` value, and resets on first braking input of a new lap.

    wheel_lock_threshold
Set percentage threshold for counting wheel lock duration under braking. `0.3` means 30% of tyre slip ratio.

[**`Back to Top`**](#)


## Brake pressure
**This widget displays visualized percentage brake pressure info.**

    show_brake_input
Show raw brake input on each brake. This option can be useful to check amount difference between brake input and applied brake pressure.

[**`Back to Top`**](#)


## Brake temperature
**This widget displays brake temperature info.**

Note, if temperature drops below `-100` degrees Celsius, temperature readings will be replaced by unavailable sign as `-`. This usually indicates brake failure, or brake is not available on one of the wheels.

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    enable_heatmap_auto_matching
Enable automatically heatmap style matching for specific brakes defined in `brakes.json` preset. This option applies matching heatmap style to front and rear brakes separately.

    heatmap_name
Set heatmap preset name that is defined in `heatmap.json` preset. Note, this option has no effect while `enable_heatmap_auto_matching` is enabled.

    swap_style
Swap heatmap color between font and background color.

    show_degree_sign
Set `true` to show degree sign for each temperature value.

    leading_zero
Set amount leading zeros for each temperature value. Default is `2`. Minimum value is limited to `1`.

    show_average
Show average brake temperature calculated from most recent braking period. The braking period is defined by `average_sampling_duration` and `off_brake_duration` options.

    average_sampling_duration
Set duration (seconds) for calculating average brake temperature from most recent braking period. Default is `10` seconds. Maximum duration is limited to `600` seconds.

    off_brake_duration
Set duration (seconds) for continuously updating average brake temperature for a short period after fully released brakes. Default is `1` seconds.

[**`Back to Top`**](#)


## Brake wear
**This widget displays brake wear info.**

Important note: Brake wear data is currently only available on `LMU`. `RF2` currently doesn't provide brake wear data. Depends on vehicle, brake may or may not have noticeable wear.

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_thickness
Show brake thickness (millimeter) instead of percentage, which also affects wear difference readings.

Note, brake maximum thickness (for percentage wear calculation) is retrieved at the moment when car leaves garage or has brake repaired or changed. Reloading a preset or restarting APP in the middle of a running stint could result wrong maximum thickness and percentage wear calculation, which should be avoided.

**Notes to brake failure thickness:**

Brake failure thickness is millimeter thickness threshold at brake failure, which affects brake wear calculation accuracy, and can be customized for specific vehicle class in [Brake Editor](#brake-editor).

For example, if `brake thickness` is `40`mm, and `failure thickness` is `25`mm, then `effective thickness` is `40 - 25 = 15mm`. And brake fails upon reaching `25`mm thickness. Note, each installed brake may have a random failure thickness variation of `Â±0.1`mm.

Since brake failure thickness threshold data is not available from game API, it requires testing to find out, and may vary from vehicle to vehicle. Front brake failure thickness threshold can be different from rear brake. Thickness threshold value should not exceed brake maximum thickness, otherwise brake wear readings will not be displayed correctly.

Note, failure thickness values are automatically saved to `brakes.json` preset when brakes failed, and most recent brake failures are logged and can be found in `Show Log` dialog from Help menu.

**Tips for testing failure thickness:**

Before start, make sure vehicle brand data is imported via [Vehicle Brand Editor](#vehicle-brand-editor). This is necessary to save brake failure thickness settings per vehicle brand.

First, set all `brake duct` settings to `closed` in car setup, then keeps brakes on while driving at around 100kph speed until brakes failed (use brake bias to control front and rear wear rate), and failure thickness value will be automatically saved for this vehicle. Be aware that testing may take a very long time for some vehicles.

    show_remaining
Show total remaining brake in percentage that changes color according to wear. A `FAIL` text will be shown on failed brakes.

    show_wear_difference
Show estimated brake wear difference per lap (at least one valid lap is required).

    show_live_wear_difference
Show current lap brake wear difference.

    show_lifespan_laps
Show estimated brake lifespan in laps.

    show_lifespan_minutes
Show estimated brake lifespan in minutes.

    warning_threshold_remaining
Set warning threshold for total remaining brake in percentage. Default is `30` percent.

    warning_threshold_wear
Set warning threshold for total amount brake wear of last lap in percentage. Default is `1` percent.

    warning_threshold_laps
Set warning threshold for estimated brake lifespan in laps. Default is `5` laps.

    warning_threshold_minutes
Set warning threshold for estimated brake lifespan in minutes. Default is `5` laps.

[**`Back to Top`**](#)


## Cruise
**This widget displays track clock, compass, elevation, odometer info.**

    show_track_clock
Show current in-game clock time of the circuit.

    enable_track_clock_synchronization
Enable auto track clock and time scale synchronization. `enable_restapi_access` must be enabled to synchronize track clock from Rest API.

Note, for `RF2`, synchronization only works in singleplayer; for `LMU`, synchronization works in both singleplayer and multiplayer.

    track_clock_time_scale
Manually set time multiplier for time-scaled session. Default is `1`, which matches `Time Scale: Normal` setting in-game. Note, this option will only be used if `enable_track_clock_synchronization` option is disabled.

    track_clock_format
Set track clock format string. To show seconds, add `%S`, such as `%H:%M:%S %p`. See [link](unlinked: docs_python_org/3/library/datetime_html#strftime-and-strptime-format-codes) for full list of format codes.

    show_time_scale
Show current session track clock time scale multiplier.

    show_compass
Show compass directions with three-figure bearings that matches game's cardinal directions.

    show_elevation
Show elevation difference in game's coordinate system.

    show_odometer
Show odometer that displays total driven distance of local player.

    odometer_maximum_digits
Set maximum number of display digits.

    show_distance_into_lap
Show distance into current lap.

    show_cornering_radius
Show cornering radius calculated in real-time.

[**`Back to Top`**](#)


## Damage
**This widget displays visualized vehicle damage info.**

**Wheel (suspension) damage levels**

1. No damage to suspension or wheel (default color: green).
2. Light suspension damage (default damage range: 2% - 15%, default color: yellow).
3. Medium suspension damage (default damage range: 15% - 40%, default color: orange).
4. Heavy suspension damage (default damage range: 40% - 80%, default color: purple).
5. Totaled suspension (default damage range: 80% - 100%, default color: blue).
6. Wheel detached (default color: black).

Note, body aero integrity and suspension damage display is only available for `LMU`.

    display_margin
Set display margin in pixels.

    inner_gap
Set body parts inner gap in pixels.

    part_width
Set body parts width in pixels. Minimum value is limited to `1`.

    parts_width_ratio
Set width ratio between side and center body parts. Value range in `0.1` to `1.0`.

    parts_max_width, parts_max_height
Set maximum body parts width, height in pixels. Minimum value is limited to `4`.

    wheel_width, wheel_height
Set wheel width, height in pixels. Minimum value is limited to `1`.

    show_background
Show widget background.

    suspension_damage_*_threshold
Set suspension damage level percentage threshold for suspension damage color indication, which better reflects severity of suspension damage that would affect handling.

    show_detached_warning_flash
Show warning flash for detached parts, such as wings and wheels.

    warning_flash_highlight_duration
Set color highlight duration for each warning flash. Default is `0.5` seconds. Minimum value is limited to `0.2`.

    warning_flash_interval
Set minimum time interval between each warning flash. Default is `0.5` seconds. Minimum value is limited to `0.2`.

    show_last_impact_cone
Show cone indicator towards last known impact (collision) position.

    last_impact_cone_angle
Set cone angle (size) in degree. Value range in `2` to `90`. Default is `15`.

    last_impact_cone_duration
Set cone indicator display duration (seconds) for last known impact. Default is `15` seconds.

    show_integrity_reading
Show vehicle bodywork integrity reading in percentage. Note, bodywork damage may not necessarily affect aero or handling.

    show_aero_integrity_if_available
Show vehicle body aero integrity reading in percentage if available, which better reflects severity of bodywork damage that would affect performance.

    show_inverted_integrity
Invert integrity reading.

[**`Back to Top`**](#)


## Deltabest
**This widget displays deltabest info.**

    layout
2 layouts are available: `0` = delta bar above deltabest text, `1` = delta bar below deltabest text.

    swap_style
Swap time gain and loss color between font and background color.

    deltabest_source
Set lap time source for deltabest display. Available values are: `Best` = all time best lap time, `Session` = session best lap time, `Stint` = stint best lap time, `Last` = last lap time.

    show_delta_bar
Show visualized delta bar.

    bar_length, bar_height
Set delta bar length and height in pixels.

    bar_display_range
Set max display range (gain or loss) in seconds for delta bar, accepts decimal place. Default is `2` seconds.

    delta_display_range
Set max display range (gain or loss) in seconds for delta reading, accepts decimal place. Default is `99.999` seconds.

    freeze_duration
Set freeze duration (seconds) for displaying previous lap time difference against best lap time source after crossing finish line. Value range in `0` to `30` seconds. Default is `3` seconds. Set to `0` to disable.

    show_animated_deltabest
Deltabest display follows delta bar progress.

[**`Back to Top`**](#)


## Deltabest extended
**This widget displays deltabest info against multiple lap time sources.**

    show_all_time_deltabest
Show deltabest against personal all time best lap time.

    show_session_deltabest
Show deltabest against current personal session best lap time. Note: session deltabest will be reset upon changing session, or reload preset/restart APP.

    show_stint_deltabest
Show deltabest against current personal stint best lap time. Note: stint deltabest will be reset if vehicle stops in pit lane.

    show_deltalast
Show delta against personal last lap time (deltalast). Note: deltalast will be reset upon ESC.

[**`Back to Top`**](#)


## Differential
**This widget displays wheel differential locking info.**

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_inverted_locking
Invert minimum differential locking percent reading.

    show_power_locking_*, show_coast_locking_*
Show minimum differential locking percent between left and right wheels on the same axle under power (on throttle) or coasting (off throttle).

A `100%` reading indicates two wheels on the same axle are rotating at same speed; while `0%` indicates that one of the wheels is completely spinning or locked.

    off_throttle_threshold
Set percentage threshold which counts as off throttle if throttle position is lower, value range in `0.0` to `1.0`. Default is `0.01` (1%).

    on_throttle_threshold
Set percentage threshold which counts as on throttle if throttle position is higher, value range in `0.0` to `1.0`. Default is `0.01` (1%).

    power_locking_reset_cooldown, coast_locking_reset_cooldown
Set cooldown duration (seconds) before resetting minimum power or coast locking percent value if value hasn't changed during cooldown period. Default is `5` seconds.

[**`Back to Top`**](#)


## DRS
**This widget displays DRS(rear flap) usage info.**

    drs_text
Set custom DRS text.

    font_color_activated, bkg_color_activated
Set color when DRS is activated by player.

    font_color_allowed, bkg_color_allowed
Set color when DRS is allowed but not yet activated by player.

    font_color_available, bkg_color_available
Set color when DRS is available but current disallowed to use.

    font_color_not_available, bkg_color_not_available
Set color when DRS is unavailable for current track or car.

[**`Back to Top`**](#)


## Electric motor
**This widget displays electric motor usage info.**

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_motor_temperature
Show electric motor temperature.

    show_water_temperature
Show electric motor cooler water temperature.

    overheat_threshold_motor, overheat_threshold_water
Set temperature threshold for electric motor and water overheat color indicator, unit in Celsius.

    show_rpm
Show electric motor RPM.

    show_torque
Show electric motor torque.

    show_power
Show electric motor power.

[**`Back to Top`**](#)


## Elevation
**This widget displays elevation plot. Note: elevation plot data is recorded together with track map. At least one complete and valid lap is required to generate elevation plot.**

    display_detail_level
Sets detail level for track map. Default value is `1`, which auto adjusts map detail according to display size. Higher value reduces map detail and RAM usage, and may also help reduce rough edges from large map. Set to `0` for full detail.

    display_width
Set widget display width in pixels. Minimum width is limited to `20`.

    display_height
Set widget display height in pixels. Minimum height is limited to `10`.

    display_margin_*
Set widget display margin in pixels. Maximum margin is limited to half of `display_height` value.

    show_elevation_reading
Show elevation difference in game's coordinate system.

    show_elevation_scale
Show elevation plot scale reading, which is ratio between screen pixel and real world elevation. A `1:10.5` reading means 1 pixel equals 10.5 meters (or feet, depends on distance unit setting).

    show_background
Show widget background.

    show_elevation_background
Show background of elevation plot.

    show_elevation_progress
Show elevation progress bar according player's current position.

    show_elevation_progress_line
Show elevation progress line according player's current position.

    show_elevation_line
Show elevation reference line.

    show_zero_elevation_line
Show zero elevation reference line in game's coordinate system.

    show_start_line
Show start line mark.

    show_sector_line
Show sector line mark.

    show_position_mark
Show player's current position line mark.

[**`Back to Top`**](#)


## Engine
**This widget displays engine usage info.**

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_temperature
Show oil and water temperature.

    overheat_threshold_oil, overheat_threshold_water
Set temperature threshold for oil and water overheat color indicator, unit in Celsius.

    show_turbo_pressure
Show turbo pressure.

    show_rpm
Show engine RPM.

    show_rpm_maximum
Show maximum engine RPM (rev limit).

    show_torque
Show engine torque.

    show_power
Show engine power.

[**`Back to Top`**](#)


## Flag
**This widget displays flags, pit state, warnings, start lights info.**

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_pit_timer
Show pit timer, and total amount time spent in pit after exit pit.

    pit_time_highlight_duration
Set highlight duration for total amount time spent in pit after exit pit.

    pit_closed_text
Set custom pit closed text.

    font_color_pit_closed, bkg_color_pit_closed
Set color indicator on pit timer when pit lane is closed.

    show_low_fuel
Show low fuel (or low virtual energy if available) indicator when below certain amount value. Only one indicator will be displayed for low fuel (LF) or low virtual energy (LE), depends on which one would deplete sooner.

    show_low_fuel_for_race_only
Only show low fuel indicator during race session.

    low_fuel_volume_threshold
Set fuel volume threshold (in Liter) to show low fuel indicator when total amount of remaining fuel is equal or less than this value. This setting is used to limit low fuel warning when racing on lengthy tracks, where fuel tank may only hold for a lap or two. Default is `20` Liter.

    low_fuel_lap_threshold
Set amount lap threshold to show low fuel indicator when total completable laps of remaining fuel is equal or less than this value. Default is `2` laps before running out of fuel.

    show_speed_limiter
Show speed limiter indicator.

    speed_limiter_text
Set custom pit speed limiter text which shows when speed limiter is engaged.

    show_yellow_flag
Show yellow flag indicator and distance display which shows nearest yellow flag vehicle distance. Note, positive distance reading indicates yellow flag that ahead of driver, negative indicates behind.

    show_yellow_flag_for_race_only
Only show yellow flag indicator during race session.

    yellow_flag_maximum_range_ahead, yellow_flag_maximum_range_behind
Set maximum range (meters) for displaying yellow flags that ahead of or behind driver. Default range ahead is `500` meters, range behind is `50` meters. To disable yellow flag that behind driver, set range behind to `0`.

Note, yellow flags that ahead of driver take priority over those from behind.

    show_blue_flag
Show blue flag indicator with timer.

    show_blue_flag_for_race_only
Only show blue flag indicator during race session.

    show_startlights
Show race start lights indicator with light frame number for standing-type start.

    green_flag_duration
Set display duration(seconds) for green flag text before it disappears. Default is `3`.

    red_lights_text
Set custom text for red lights.

    green_flag_text
Set custom text for green flag.

    show_traffic
Show nearest incoming on-track traffic indicator (time gap) while in pit lane or after pit-out.

    traffic_maximum_time_gap
Set maximum time gap (seconds) of incoming on-track traffic.

    traffic_pitout_duration
Set traffic indicator extended duration (seconds) after pit-out.

    traffic_low_speed_threshold
Set low speed threshold for showing nearest incoming traffic indicator. Default is `8` m/s (roughly 28kph). Set to `0` to disable. This option can be useful to quickly determine nearby traffic situation after a spin or crash.

    show_pit_request
Show pit request indicator and `pit-in laps countdown` alongside `estimated remaining laps` reading that current fuel or energy can run. Note, `pit-in laps countdown` value is always calculated towards the finish line of current stint's final lap, and thus is always less than or equal to `estimated remaining laps` reading. If countdown drops below 1.0 (laps), it indicates the final lap of current stint, and driver should pit in before the end of current lap to refuel. If countdown reaches zero or negative, there may still be some fuel or energy left in tank, however it will not be enough to complete another full lap.

    show_finish_state
Show finish or disqualify state.

[**`Back to Top`**](#)


## Force
**This widget displays g force and downforce info.**

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_g_force
Show longitudinal and lateral g force with direction indicator.

    show_downforce_ratio
Show downforce ratio between front and rear. 50% indicates equal downforce; higher than 50% indicates front has more downforce.

    show_front_downforce, show_rear_downforce
Show front and rear downforce reading in Newtons.

    warning_color_liftforce
Set lift force indicator color.

[**`Back to Top`**](#)


## Friction circle
**This widget displays g force in circle diagram.**

    display_size
Set widget size in pixels.

    display_radius_g
Set viewable g force range by radius(g).

    show_inverted_orientation
Set `true` to invert display orientation for longitudinal and lateral g force axis. Default is `false`, which shows brake at top, acceleration at bottom, right-turn at left, left-turn at right.

    show_readings
Show values from g force reading. Value at top is current longitudinal g force, and value at bottom is max longitudinal g force. Value at left is max lateral g force, and value at right is current lateral g force.

    show_background
Show background color that covers entire widget.

    show_circle_background
Show circle background color.

    show_fade_out
Fade out circle background edge.

    fade_in_radius, fade_out_radius
Set fade in/out radius, value range in `0.0` to `1.0`.

    show_max_average_lateral_g_circle
Show max average lateral g force reference circle.

    max_average_lateral_g_circle_style
Set circle line style. `0` for dashed line, `1` for solid line.

    max_average_lateral_g_circle_width
Set circle line width in pixels.

    show_dot
Show g force dot.

    dot_size
Set g force dot size in pixels.

    show_trace
Show g force trace.

    trace_max_samples
Set max amount g force trace samples.

    trace_style
Set g force trace style. `0` for line style. `1` for point style.

    trace_width
Set g force trace width in pixels.

    show_trace_fade_out
Show trace fade out effect.

    trace_fade_out_step
Set trace fade out speed. Value range in `0.1` to `0.9`, higher value increases trace fade out speed. Default value is `0.2`.

    show_center_mark
Show center mark.

    center_mark_radius_g
Set center mark size by radius(g).

    center_mark_style
Set center mark line style. `0` for dashed line, `1` for solid line.

    center_mark_width
Set center mark line width in pixels.

    show_reference_circle
Show reference circle.

    reference_circle_*_radius_g
Set reference circle size by radius(g). Circle will not be displayed if radius is bigger than `display_radius_g`.

    reference_circle_*_style
Set reference circle line style. `0` for dashed line, `1` for solid line.

    reference_circle_*_width
Set reference circle line width in pixels.

[**`Back to Top`**](#)


## Fuel
**This widget displays fuel usage info.**

Note, for non-hybrid pure electric vehicle, this widget will show `battery charge` usage (in percentage) info instead. Since multiple different electric systems exist in `RF2`, there is no reliable way to distinguish pure electric vehicles from fuel or hybrid vehicles, it is important to make sure `fuel_unit` option in [Units](#units) setting is set to `Liter` in order to correctly display battery charge usage in `percentage` for pure electric vehicles.

---

Differences between `relative` and `absolute` refueling:

* Relative refueling value shows total amount `additional` fuel required to finish the remaining race length, which matches `relative refueling` mechanism (amount to add on top of remaining fuel in tank) in `RF2`.

* Absolute refueling value shows absolute total amount fuel required to finish the remaining race length, which matches `absolute refueling` mechanism (amount total fuel to fill tank up to) in `LMU`.

Also see `estimated laps` display option in [Session](#session) widget that can be used for `absolute refueling`.

---

    show_absolute_refueling
Show absolute refueling value instead of relative refueling when enabled. Note, `+` or `-` sign is not displayed with absolute refueling.

    show_estimated_pitstop_count
Show estimated number of pit stop counts column.

    show_delta_and_end_remaining
Show delta consumption and estimated end stint remaining fuel column.

    *remain
Remaining fuel in tank.

    *refuel
Estimated refueling reading, which is the total amount additional fuel required to finish race.

Note, for `relative refueling` (`show_absolute_refueling` disabled), positive value indicates additional refueling and pit stop would be required, while negative value indicates total remaining fuel at the end of race, and no extra pit stop required. For example, a `-1.5` value indicates `1.5` remaining fuel after crossed finish line.

For `absolute refueling` (`show_absolute_refueling` enabled), total remaining fuel at the end of race can be found by subtracting `refuel` value from `remain` value. For example, `6` (remain column) - `4.5` (refuel column) = `1.5` remaining fuel after crossed finish line.

    *laps
Estimated laps reading that current fuel can last.

    *minutes
Estimated minutes reading that current fuel can last.

    *used
Estimated fuel consumption reading, which is calculated from last-valid-lap fuel consumption and delta fuel consumption. Note, when vehicle is in garage stall, this reading only shows last-valid-lap fuel consumption without delta calculation.

    *save
Estimated fuel saving target consumption reading for making one less pit stop.

    *delta
Estimated delta fuel consumption reading. Positive value indicates an increase in consumption, while negative indicates a decrease in consumption.

    *end
Estimated remaining fuel reading at the end of current stint before next pit stop, which reflects fuel usage efficiency.

Note, this value does not count towards the end of race; instead, this value always counts towards the end of last completeable lap. To find out total remaining fuel at the end of race, see `refuel` column and explanation.

    *pits
Estimate number of pit stop counts when making a pit stop at end of current stint. Any non-zero decimal places would be considered for an additional pit stop.

    *early
Estimate number of pit stop counts when making an early pit stop at end of current lap. This value can be used to determine whether an early pit stop is worth performing comparing to `pits` value.

Example 1: When this value is just below `1.0` (such as `0.97`), it indicates an early pit stop can be made right at the end of current lap with enough empty capacity to refuel according to `refuel` reading which would last to the end of race.

Example 2: When this value is just below `2.0` (such as `1.96`), and `pits` value is also in `1.x` range (such as `1.32`),  it indicates 2 required pit stops, and an early pit stop can be made right at the end of current lap with tank fully refueled according to `refuel` reading. After refueling, `pits` reading would show an approximately `0.96` value which indicates one more required pit stop.

Example 3: If this value is one or more integers higher than `pits` value, then additional pit stops would be required after making a pit stop at the end of current lap.

    bar_width
Set each column width, value in chars, such as 10 = 10 chars. Default is `5`. Minimum width is limited to `3`.

    low_fuel_lap_threshold
Set amount lap threshold to show low fuel indicator when total completable laps of remaining fuel is equal or less than this value. Default is `2` laps before running out of fuel.

    warning_color_low_fuel
Set low fuel color indicator, which changes widget background color when there is just 2 laps of fuel left.

    show_low_fuel_warning_flash
Show low fuel warning flash effect when below `low_fuel_lap_threshold`.

    number_of_warning_flashes
Set number of warning flashes that will be played for a limited number of times. Default is `10` flashes. Minimum value is limited to `3`.

    warning_flash_highlight_duration
Set color highlight duration for each warning flash. Default is `0.4` seconds. Minimum value is limited to `0.2`.

    warning_flash_interval
Set minimum time interval between each warning flash. Default is `0.4` seconds. Minimum value is limited to `0.2`.

    show_fuel_level_bar
Show visualized horizontal fuel level bar.

    fuel_level_bar_height
Set fuel level bar height in pixels.

    show_starting_fuel_level_mark
Show starting fuel level mark of current stint. Default mark color is red.

    show_refueling_level_mark
Show estimated fuel level mark after refueling. If the mark is not visible on fuel level bar, it indicates total refueling has exceeded fuel tank capacity. Default mark color is green.

    starting_fuel_level_mark_width, refueling_level_mark_width
Set fuel level mark width in pixels.

    caption_text
Set custom caption text.

    swap_upper_caption, swap_lower_caption
Swap caption row position.

[**`Back to Top`**](#)


## Fuel energy saver
**This widget displays fuel or virtual energy saving info.**

Show current stint estimated total completable laps and completed laps based on current consumption.

Show estimated target lap consumption to save (extend) one or more total stint laps.

Show delta consumption against target lap consumption, which allows fuel or energy saving to be visualized and easily controlled in real-time.

Show consumption type in `FUEL` or `NRG` (if virtual energy available).

Show last lap consumption.

    layout
Set target laps horizontal display order. Set `0` to show from left (less laps) to right (more laps). Set `1` to show from right to left instead.

    minimum_reserve
Set minimum amount fuel or virtual energy in tank that is excluded from saving calculation and reserved for the end of stint. Default is `0.2` Liter for fuel (or % for virtual energy).

    number_of_more_laps
Set number of target slots for more completable laps. Default is `3`. Range in `1` to `10`.

    number_of_less_laps
Set number of target slots for less completable laps. Default is `0`. Range in `0` to `5`.

    enable_pit_entry_bias
Auto calibrate target fuel (or energy) saving bias towards either pit entry position or finish line, depending on number of estimated remaining pit stops.

This feature is made specially for tracks that have pit entry position located far away from finish line, which it is necessary to take pit entry position into fuel saving calculation for increased accuracy.

While enabled, a new `BIAS` column will be added, which shows amount added fuel (or energy) bias towards pit entry position, as well as percentage pit entry bias from finish line, When bias is `0`, it means there is no pit entry bias added.

**Important notes:** Do not enable this feature if you are not sure what it does. You must enter pit at least once to record pit entry position of the track for this feature to work.

    remaining_pitstop_threshold
Set number of remaining pit stops threshold for auto calibrating target fuel (or energy) saving bias. Default value is `0.1`.

Fuel (or energy) saving calculation is biased towards pit entry position when number of estimated remaining pit stops is greater than the threshold, otherwise biased towards finish line.

[**`Back to Top`**](#)


## Gear
**This widget displays gear, RPM, speed, battery info.**

    inner_gap
Set inner gap between gear and speed readings. Negative value reduces gap, while positive value increases gap. Default is `0`.

    show_speed
Show speed reading.

    show_speed_below_gear
Show speed reading below gear.

    font_scale_speed
Set font scale for speed reading. This option only takes effect when `show_speed_below_gear` is enabled. Default is `0.5`.

    show_speed_limiter
Show pit speed limiter indicator.

    speed_limiter_text
Set custom pit speed limiter text which shows when speed limiter is engaged.

    show_battery_bar
Show battery bar, which is only visible if electric motor available.

    show_inverted_battery
Invert battery bar progression.

    battery_bar_height
Set battery bar height in pixels.

    high_battery_threshold, low_battery_threshold
Set percentage threshold for displaying low or high battery charge warning indicator. Default high threshold is `95` percent (default color purple), low threshold is `10` percent (default color red).

    show_battery_reading
Show battery charge (in percentage) reading text on battery bar.

    show_rpm_bar
Show a RPM bar at bottom of gear widget, which moves when RPM reaches range between safe and max RPM.

    show_inverted_rpm
Invert RPM bar progression.

    rpm_bar_height
RPM bar height, in pixel.

    show_rpm_reading
Show RPM reading text on RPM bar.

    rpm_multiplier_safe
This value multiplies max RPM value, which sets relative safe RPM range for RPM color indicator (changes gear widget background color upon reaching this RPM value).

    rpm_multiplier_redline
This value multiplies max RPM value, which sets relative redline RPM range for RPM color indicator.

    rpm_multiplier_critical
This value multiplies max RPM value, which sets critical RPM range for RPM color indicator.

    show_rpm_flickering_above_critical
Show flickering effects when RPM is above critical range and gear is lower than max gear.

    neutral_warning_speed_threshold, neutral_warning_time_threshold
Set speed/time threshold value for neutral gear color warning, which activates color warning when speed and time-in-neutral is higher than threshold. Speed unit in meters per second, Default is `28`. Time unit in seconds, Default is `0.3` seconds.

[**`Back to Top`**](#)


## Heading
**This widget displays vehicle yaw angle, slip angle, heading info.**

    display_size
Set widget size in pixels.

    show_yaw_angle_reading
Show yaw angle reading in degree.

    show_slip_angle_reading
Show slip angle reading in degree.

    show_degree_sign
Set `true` to show degree sign for yaw angle reading.

    show_background
Show background color that covers entire widget.

    show_circle_background
Show circle background color.

    show_yaw_line
Show yaw line (vehicle heading).

    show_direction_line
Show vehicle's direction of travel line.

    show_slip_angle_line
Show slip angle (average of the front tyres) line.

    *_line_head_scale
Set line length scale from center to head, value range in `0.0` to `1.0`.

    *_line_tail_scale
Set line length scale from center to tail, value range in `0.0` to `1.0`.

    *_line_width
Set line width in pixels.

    show_dot
Show center dot.

    show_center_mark
Show center mark.

    center_mark_length_scale
Set center mark length scale, value range in `0.0` to `1.0`.

    center_mark_style
Set center mark line style. `0` for dashed line, `1` for solid line.

    center_mark_width
Set center mark line width in pixels.

[**`Back to Top`**](#)


## Instrument
**This widget displays vehicle instruments info.**

    icon_size
Set size of instrument icon in pixel. Minimum value is limited to `16`.

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_headlights
Show headlights state.

    show_ignition
Show engine ignition, starter, stalling state.

    stalling_rpm_threshold
Set RPM threshold for triggering engine stalling warning. Default is `100` RPM.

    show_clutch
Show auto-clutch and clutch state.

    show_wheel_lock
Show wheel lock state.

    show_wheel_slip
Show wheel slip state.

    wheel_lock_threshold
Set percentage threshold for triggering wheel lock warning under braking. `0.3` means 30% of tyre slip ratio.

    wheel_slip_threshold
Set percentage threshold for triggering wheel slip warning under acceleration. `0.1` means 10% of tyre slip ratio.

[**`Back to Top`**](#)


## Lap time history
**This widget displays lap time history info.**

This widget consists of four columns from left to right (default order): `Lap number`, `Lap time`, `Fuel or virtual energy consumption per lap`, `Average tyre wear per lap (percent)`. History data are loaded and updated from corresponding [Consumption History](#consumption-history) file.

    layout
2 layouts are available: `0` = vertical layout, `1` = reversed vertical layout.

    lap_time_history_count
Set the number of lap time history display. Default is to show `10` most recent lap times.

    show_virtual_energy_if_available
Show virtual energy consumption instead of fuel consumption if available. This option is enabled by default.

    show_empty_history
Show empty lap time history. Default is `false`, which hides empty rows.

[**`Back to Top`**](#)


## Laps and position
**This widget displays lap number, driver overall position, position in class info.**

    show_lap_number
Show your current lap number (lap progression) and total race laps. If total race laps is not available, such as in time-based session, estimated total laps will be displayed instead, and a `~` sign will be displayed before estimated total laps reading, and up to two decimal places will be kept.

Note, estimated total laps reading is calculated based on local player's lap time pace data from Delta Module, which can be different from in-game HUD reading. This reading does not concern about race leader's lap time pace, which means there may be an extra final lap on top of it.

    bkg_color_maxlap_warn
Set warning color that shows 1 lap before exceeding max-lap in qualify (or indicates the last lap of a lap-type race).

    show_position_overall
Show your current overall position against all drivers in a session.

    show_position_in_class
Show your current position in class against all drivers from the same class.

[**`Back to Top`**](#)


## Navigation
**This widget displays a zoomed navigation map that centered on player's vehicle. Note: at least one complete and valid lap is required to generate map.**

    display_size
Set widget size in pixels.

    view_radius
Set viewable area by radius(unit meter). Default is `500` meters. Minimum value is limited to `5`.

    show_background
Show background color that covers entire widget.

    show_circle_background
Show circle background color.

    circle_outline_width
Set circle background outline width. Set value to `0` to hide outline.

    show_fade_out
Fade out view edge.

    fade_in_radius, fade_out_radius
Set fade in/out radius, value range in `0.0` to `1.0`.

    map_width
Set navigation map line width.

    map_outline_width
Set navigation map outline width.

    show_start_line
Show start line mark.

    show_sector_line
Show sector line mark.

    show_vehicle_standings
Show vehicle standings info on navigation map.

    show_circle_vehicle_shape
Set `True` to show vehicle in circle shape, set `False` for arrow shape.

    vehicle_size
Set vehicle size in pixels.

    vehicle_offset
Set vehicle vertical position offset (percentage) relative to display size, value range in `0.0` to `1.0`.

    vehicle_outline_width
Set vehicle outline width.

[**`Back to Top`**](#)


## P2P
**This widget displays push to pass usage info.**

    show_battery_charge
Show percentage available battery charge.

    show_activation_timer
Show electric boost motor activation timer.

    activation_threshold_gear
Set minimum gear threshold for P2P ready indicator.

    activation_threshold_speed
Set minimum speed threshold for P2P ready indicator, unit in KPH.

    activation_threshold_throttle
Set minimum throttle input percentage threshold for P2P ready indicator, value range in `0.0` to `1.0`. Default is `0.6` (60%).

    minimum_activation_time_delay
Set minimum time delay between each P2P activation, unit in seconds.

    maximum_activation_time_per_lap
Set maximum P2P activation time per lap, unit in seconds.

[**`Back to Top`**](#)


## Pace notes
**This widget displays pace notes, comments, debugging info.**

    show_background
Show background color. Turn off to show text only.

    show_pit_notes_while_in_pit
Show custom notes while in pit lane.

    pit_notes_text, pit_comments_text
Set custom notes and comments to be displayed while in pit lane.

    show_pace_notes
Show nearest pace notes info behind current vehicle position.

    show_comments
Show nearest pace notes comments info behind current vehicle position.

    enable_comments_line_break
Enable line break for displaying multi-line comments. To break a line into multiple lines, add `\n` to any part of the comment.

    show_debugging
Show nearest pace notes index number behind current vehicle position, and distance value (meters) behind current position to next index position.

    pace_notes_width, comments_width, debugging_width
Set maximum display width, value in chars, such as 10 = 10 chars.

    auto_hide_if_not_available
Auto hide this widget if pace notes data is not available for current track.

    maximum_display_duration
Set maximum display duration (seconds) of each note. Set to `-1` to always display notes. Default is `-1`.

[**`Back to Top`**](#)


## Pedal
**This widget displays pedal input and force feedback info.**

    show_readings
Show pedal input and force feedback readings. Note, while `show_*_filtered` option is enabled, only the highest reading between filtered and raw input is displayed.

    readings_offset
Set reading text offset position (percentage), value range in `0.0` to `1.0`.

    enable_horizontal_style
Show pedal bar in horizontal style.

    bar_length, bar_width_unfiltered, bar_width_filtered
Set pedal bar length and width in pixels.

    inner_gap
Set gap between pedal and max indicator.

    max_indicator_height
This is the indicator height when pedal reaches 100% travel, value in pixel.

    show_brake_pressure
Show brake pressure changes applied on all wheels, which auto scales with max brake pressure and indicates amount brake released by ABS on all wheels. This option is enabled by default, which replaces game's filtered brake input that cannot show ABS.

    show_throttle
Show throttle bar.

    show_brake
Show brake bar.

    show_clutch
Show clutch bar.

    show_ffb_meter
Show Force Feedback meter.

    show_*_filtered
Show filtered pedal input if available. Note, some vehicles may not provide filtered pedal input value, which the value will be zero. Disable this option to show raw input only.

[**`Back to Top`**](#)


## Pit stop estimate
**This widget displays estimated pit stop duration and refilling info.**

Note, this widget is designed for `LMU`. Most readings are not available for `RF2` due to lack of API data.

    lengthy_stop_duration_threshold
Set warning threshold for lengthy pit stop duration in seconds. Default is `60` seconds. This option can be useful to check for unusually long pit stop duration, such as repairing.

    pass_duration
Show estimated pit-lane pass through (drive-through) time, calculated from pit-entry to pit-exit line. Average accuracy is within `0.5` seconds. Note, for any new tracks, at least one pit-lane pass through is required to record data for pass through time calculation.

    pit_timer
Show pit timer, useful for comparing against other pit time readings.

    stop_duration
Show estimated pit stop time while making a service stop or serving a penalty, calculated according to each setting from MFD `Pitstop` page and underlying service timing and concurrency differences. Average accuracy is within `1` seconds.

Note, for unscheduled pit stop (without requesting pit), game sometimes will add random amount extra delay (as part of pit crew preparation time) on top of pit stop time. To avoid this, always requests pit before entering pit.

    minimum_total_duration
Show estimated minimum total pit time, which is the sum of `pass_duration`, `stop_duration`, and `additional_pitstop_time`. Note, this reading is recalculated only while not in pit lane.

    stop_go_penalty_time
Set stop go penalty time in seconds. Default value is `10` seconds. Note, this value is only used if penalty time data is not available from game API.

    additional_pitstop_time
Set additional pit stop time that is not part of `pass_duration` or `stop_duration`. Default value is `2` seconds, which is the average time it takes to decelerate and accelerate towards and away from pit spot.

    show_relative_refilling
Show `actual_relative_refill` and `total_relative_refill` columns.

    actual_relative_refill
Show actual relative refilling, as the total additional fuel or virtual energy that will be added in next pit stop according to remaining fuel or virtual energy and user refill setting from MFD `Pitstop` page.

    total_relative_refill
Show total relative refilling, as the total additional fuel or virtual energy that is required to finish the race. This is the same value as seen from `refill` column of Fuel Widget or Virtual energy Widget.

With both `actual` and `total` relative refilling readings, users can determine precisely how much fuel or virtual energy that will be added in next pit stop, and whether the refilling will be enough or more pit stops are required.

    show_pit_occupancy
Show `pit_occupancy` and `pit_requests` columns.

    pit_occupancy
Show number of vehicles that stopped in pit lane, and number of vehicles currently in pit lane (whether passing or stopped). This does not include vehicles that are parked in garage.

    pit_requests
Show number of vehicles that requested for pit stop, and number of vehicles currently outside pit lane.

[**`Back to Top`**](#)


## Radar
**This widget displays vehicle radar info.**

    global_scale
Sets global scale of radar display. Default is `6`, which is 6 times of original size.

    radar_radius
Set the radar display area by radius(unit meter). Default is `30` meters. Minimum value is limited to `5`.

    show_vehicle_orientation
Show opponent vehicle orientation (heading) relative to player. Disable this option to show player and opponent vehicle headings in parallel.

    vehicle_length, vehicle_width
Set vehicle overall size (length and width), value in meters.

    vehicle_border_radius
Set vehicle round border radius.

    vehicle_outline_width
Set vehicle outline width.

    enable_radar_fade
Enable radar gradually fade in/out effect.

    radar_fade_out_radius
Set radar fade out radius relative to radar radius. Value range in `0.5` to `1.0`. Default value is `0.98`.

    radar_fade_in_radius
Set radar fade in radius relative to radar radius. Minimum value is limited to `0.1`, maximum value cannot exceed `radar_fade_out_radius`. Default value is `0.8`.

    show_background
Show background color that covers entire widget.

    show_circle_background
Show circle background color.

    show_edge_fade_out
Fade out radar edge.

    edge_fade_in_radius, edge_fade_out_radius
Set fade in/out radius relative to radar radius, value range in `0.0` to `1.0`.

    show_overlap_indicator
Show overlap indicator when there are nearby side by side vehicles. This option shows `boundary style` indicator if `show_overlap_indicator_in_cone_style` option is disabled.

    show_overlap_indicator_in_cone_style
Show overlap indicator in `cone style` instead of `boundary style`.

    overlap_cone_angle
Set cone display angle in degrees. This option does not affect overlap detection range. Default is `120` degrees.

    overlap_nearby_range_multiplier
Set nearby vehicle overlap detection range multiplier that scales with vehicle width. A value of `5` would result a 5-vehicle-wide detection range. Default is `5` vehicle-wide.

    overlap_critical_range_multiplier
Set nearby vehicle critical overlap detection range multiplier that scales with vehicle width. Default is `1` vehicle-wide.

    indicator_size_multiplier
Set indicator size multiplier that scales with vehicle width.

    show_center_mark
Show center mark on radar.

    center_mark_style
Set center mark line style. `0` for dashed line, `1` for solid line.

    center_mark_radius
Set center mark size by radius(unit meter).

    center_mark_width
Set center mark line width in pixels.

    show_angle_mark
Show angle mark (fixed 45 degrees) on radar.

    show_distance_circle
Show distance circle line on radar for distance reference.

    distance_circle_*_style
Set distance circle line style. `0` for dashed line, `1` for solid line.

    distance_circle_*_radius
Set distance circle size by radius(unit meter). Circle will not be displayed if radius is bigger than `radar_radius`.

    distance_circle_*_width
Set distance circle line width in pixels.

    auto_hide
Auto hides radar display when no nearby vehicles.

    auto_hide_in_private_qualifying
Auto hides radar in private qualifying session, requires both `auto_hide` and `enable_restapi_access` enabled.

    auto_hide_time_threshold
Set amount time(unit second) before triggering auto hide. Default is `1` second. Note, this option has no effect while `enable_radar_fade` is enabled.

    auto_hide_minimum_distance_ahead, behind, side
The three values define an invisible rectangle area(unit meter) that auto hides radar if no vehicle is within the rectangle area. Default value is `-1`, which auto scales with `radar_radius` value. Set to any positive value to customize radar auto-hide range. Note, each value is measured from center of player's vehicle position.

    vehicle_maximum_visible_distance_ahead, behind, side
The three values define an invisible rectangle area(unit meter) that hides any vehicle outside the rectangle area. Default value is `-1`, which auto scales with `radar_radius` value. Set to any positive value to customize vehicle visible range. Note, each value is measured from center of player's vehicle position.

[**`Back to Top`**](#)


## Rake angle
**This widget displays vehicle rake angle info.**

    wheelbase
Set wheelbase in millimeters, for used in rake angle calculation.

    rake_angle_smoothing_samples
Set number of samples for reducing data fluctuation. Lower value may result more fluctuated reading. Set `1` to disable smoothing.

    show_degree_sign
Set `true` to show degree sign for rake angle value.

    show_ride_height_difference
Show average front and rear ride height difference in millimeters.

[**`Back to Top`**](#)


## Relative
**This widget displays relative standings info.**

    show_player_highlighted
Highlight player row with customizable specific color.

    show_lap_difference
Show different font color based on lap difference between player and opponents. Note, this option will override `font_color` setting from `position`, `driver name`, `vehicle name`.

    font_color_same_lap, font_color_laps_ahead, font_color_laps_behind
Set font color for lap difference. Note, `font_color_laps_ahead` and `font_color_laps_behind` applies to race session only.

    show_position
Show overall position standings.

    show_position_change
Show overall driver position change relative to overall qualification position.

    show_position_change_in_class
Show driver position change in class instead of overall. This option is enabled by default.

    show_driver_name
Show driver name.

    driver_name_shorten
Shorten driver's first name to a single letter with a period separating driver's last name, and any middle names will not be displayed. Note, if a driver is using nickname that consists only a single word, the name will not be shortened.

    driver_name_uppercase
Set driver name to uppercase.

    driver_name_width
Set drive name display width, value in chars, such as 10 = 10 chars.

    driver_name_align_center
Align driver name in the center when enabled. Default is left alignment when disabled.

    show_vehicle_name
Show vehicle name. Note, game API outputs `skin livery name` as `vehicle name`, which means actual displayed name depends on what skin livery name is called. For example, some vehicles may add `team name` and/or `class name` in `skin livery name`, some may not.

    show_vehicle_brand_as_name
Show vehicle brand name instead of vehicle name. If brand name does not exist, vehicle name will be displayed instead.

    vehicle_name_uppercase
Set vehicle name to uppercase.

    vehicle_name_width
Set vehicle name display width, value in chars, such as 10 = 10 chars.

    vehicle_name_align_center
Align vehicle name in the center when enabled. Default is left alignment when disabled.

    show_brand_logo
Show user-defined brand logo if available.

    brand_logo_width
Set maximum brand logo display width in pixels. Note, maximum brand logo display height is automatically adapted to `font_size`.

    show_time_gap
Show relative time gap between player and opponents.

    show_time_gap_sign
Show plus or minus sign for time gap. `-` sign indicates opponent's relative position is in front of player, `+` sign indicates the opposite.

    time_gap_width
Set time gap display width, value is in chars, 5 = 5 chars wide.

    time_gap_align_center
Align time gap in the center when enabled. Default is right alignment when disabled.

    show_highlighted_nearest_time_gap
Show highlighted color on opponents within nearest time gap threshold.

    nearest_time_gap_threshold_front, nearest_time_gap_threshold_behind
Set nearest time gap threshold (in seconds) for opponent who is in front of or behind player. Default is `1` second for front, and `2` seconds for behind.

    show_laptime
Show driver's last lap time or pit stop duration if available.

    show_pitstop_duration_while_requested_pitstop
Show driver's last recorded pit stop duration (in lap time column) while you have requested pit stop.

    show_highlighted_fastest_last_laptime
Highlight the fastest last lap time within the same class if available.

    show_position_in_class
Show driver's position standing in class.

    show_class_style_for_position_in_class
Show class style background color for position in class.

    show_class
Show vehicle class categories. Class alias name and color are fully customizable in `classes.json` preset, see [Vehicle Class Editor](#vehicle-class-editor) section for details.

Note, random color will be displayed for unknown class name that is not defined in `classes.json` preset.

    class_width
Set class name display width, value is in chars, `4` = 4 chars wide. Set to `0` to hide class name while showing only class color.

    show_pit_status
Show indicator whether driver is currently in pit or garage, or causes yellow flag.

    pit_status_text
Set custom pit status text which shows when driver is in pit.

    garage_status_text
Set custom garage status text which shows when driver is in garage.

    yellow_flag_status_text
Set custom yellow flag status text which shows when driver causes (or likely to) yellow flag. Note, unlike in-game yellow flag, the indicator is always displayed when driver's speed is below 28kph (outside pit lane), regardless whether driver has caused yellow flag on track.

    show_tyre_compound
Show tyre compound symbols (front and rear) that matches specific tyre compounds defined in `compounds.json` preset.

    show_pitstop_count
Show each driver's pit stop count and penalty count if available. Note, when a driver accumulates one or more penalties, this column will show the number of penalties in negative value with purple (default) background to distinguish from number of pit stops.

    show_pit_request
Show pit request color indicator on pit stop count column.

    show_vehicle_in_garage
Show vehicles parked in garage stall. Default is `false`. Note, local player is always displayed.

    additional_players_front, additional_players_behind
Set additional players shown on relative list. Each value is limited to a maximum of 60 additional players (for a total of 120 additional players). Default is `0`.

[**`Back to Top`**](#)


## Relative finish order
**This widget displays estimated relative finish order between leader and local player with corresponding refilling estimate in a table view.**

**Overview**

This widget predicts `relative final lap progress` (percent into lap) at the moment when session timer ended in time-type race, or leader crossed finish line in laps-type race, which can be used to determine whether extra laps are required to finish race.

Simple example: in time-type race, at the moment when session timer ended, assume race leader's vehicle is in `Sector 1` (or 20% into lap), and local player is in `Sector 3` (or 80% into lap) which is ahead of leader in terms of `relative lap progress` (0% from start line to 100% at finish line). When local player finishes his current lap, the race does not end for him because leader is behind local player and has not yet crossed finish line. This means local player has to complete another lap in order to finish the race, and needs an extra lap of fuel.

---

The table consists of 5 fixed rows, 1 optional row, 3 fixed columns, and 10 optional prediction columns that can be customized. Example:

| TIME |   0s  |  30s  |  40s  |  50s  |  60s  |  54s  |
|:----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|  LDR |  0.49 |  0.20 |  0.11 |  0.02 |  0.92 |  0.98 |
| 0.04 |  0.91 |  0.64 |  0.55 |  0.46 |  0.37 |  0.51 |
| DIFF |   0s  |  30s  |  40s  |  50s  |  60s  |  43s  |
|  NRG | +18.1 | +18.1 | +18.1 | +18.1 | +18.1 | +18.1 |
| EX+1 | +20.3 | +20.3 | +20.3 | +20.3 | +20.3 | +20.3 |

First and fourth rows, starting from second cell, show estimated `leader's pit time` and `local player's pit time`, where first row first cell shows current session type in `TIME` or `LAPS`. Last cell shows last recorded total time that leader and local player had spent in pit. Note, last recorded total pit time counts from pit entry to pit exit point, it doesn't include the extra few seconds that spent while approaching or exiting from pit.

Second and third rows, starting from second cell, show estimated `leader's final lap progress` (fraction of lap) and `local player's final lap progress` that depend on current session type:
* For `TIME` type race, it shows final lap progress at the moment when session timer ended.
* For `LAPS` type race, it shows relative final total lap difference between leader and local player.
Leader's value from second row second cell always shows `integer value`, because laps-type race has no timer, and the end of race is determined at the moment when leader crossed finish line, which can only be full laps.
Local player's value from third row second cell always shows final lap progress relative to leader's value from second row second cell.
Both leader's and local player's `final lap progress` values starting from third cell are offset from second cell of same row.

Third row, first cell shows `relative lap difference` between leader and local player that is calculated from lap time pace difference of both players, which can be used to determine whether leader has the chance to overtake local player on final lap. For example:
* If relative lap difference value shows 0.25, that means for every full lap, leader is faster than local player by 0.25 lap. If leader is at start line and player is just within 0.25 lap distance from leader, that means leader can catch up and overtake player before the end of lap.
* If relative lap difference value shows 0.25 and leader is at middle of current lap (0.5 lap), that means leader now only has roughly half of the lap distance (0.12 lap) to make successful overtake before the end of lap. If player is not within this 0.12 lap distance, then leader may not be able to overtake.

Fifth row, first cell shows refilling type in `FUEL` or `NRG` (if virtual energy available). Starting from second cell, shows estimated `local player's refilling` that depends on current session type:
* For `TIME` type race, refilling value from each column is calculated based on local player's current `laptime pace`, `consumption`, and `local player's final lap progress` from third row of same column. Note, each refilling value has no relation to `leader's final lap progress` value from same column. Refilling value from `0s` column gives same reading as seen from `Fuel` or `Virtual Energy` Widget in time-type race.
* For `LAPS` type race, only refilling value from `0s` column is calculated and displayed according to leader's `leader's final lap progress` value.
Other column values are not displayed, this is done to avoid confusion. Because unlike `TIME` type race where all `final lap progress` values are within `0.0` to `1.0` range, in `LAPS` type race values can exceed `1.0` or below `0.0` (negative), which the number of possible lap differences would increase exponentially and not possible to list all of them in the widget.

Sixth row (optional), first cell shows `number of extra laps` for extra refilling display. Starting from second cell, shows estimated `extra refilling` value that depends on `local player's refilling` value and `number of extra laps` setting. Each extra refilling value equals `extra laps of consumption` plus `local player's refilling` value of same column. Those values save the trouble from manual calculation in case there will be extra laps.

See `TIME` or `LAPS` type race example usages below for details.

---

**Important notes**

* Prediction accuracy depends on many variables and is meant for final stint estimate. Such as laptime pace, pit time, penalties, weather condition, safety car, yellow flag, can all affect prediction accuracy. It requires at least 2-3 laps to get sensible readings, and more laps to have better accuracy.

* `Final lap progress` values will not be displayed if no corresponding valid lap time pace data found, which requires at least 1 or 2 laps to record. If local player is the leader, then all values from leader's row will not be displayed. Refilling values will not be displayed during formation lap for the reasons mentioned in first note.

* Refilling estimate calculation is different between `TIME` and `LAPS` type races, make sure to look at the correct value, check out `example usage` below for details.

* `LMU` currently uses `absolute refueling` mechanism (amount `total` fuel to fill tank up to), as opposite to relative fuel (amount to `add` on top of remaining fuel in tank). User can enabled `show_absolute_refilling` option to display total amount fuel/energy required (including fuel/energy in tank) to finish race.

---

**Time-type race example usage**

| TIME | 0s   | 30s  | 40s  | 50s  | 60s  | 0s   |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| LDR  | 0.38 | 0.10 | 0.01 | 0.91 | 0.82 | 0.38 |
| 0.11 | 0.72 | 0.47 | 0.39 | 0.31 | 0.22 | 0.37 |
| DIFF | 0s   | 30s  | 40s  | 50s  | 60s  | 43s  |
| FUEL | +7.4 | +7.4 | +7.4 | +7.4 | +7.4 | +7.4 |
| EX+1 | +11.2 | +11.2 | +11.2 | +11.2 | +11.2 | +11.2 |

1. Determine leader's next pit time and select `leader's final lap progress` (second row) value from corresponding pit time (first row) column. `0s` column means no pit stop.

2. Determine local player's next pit time and select `local player's final lap progress` (third row) value from corresponding pit time (fourth row) column.

3. Compare the two `final lap progress` values from leader and local player, assume fuel per lap is `3.8`:

    * If leader's `final lap progress` value is greater than local player, such as leader's 0.91 (50s column) vs player's 0.47 (30s column), it indicates that leader will be ahead of local player when timer ended, and there will be no extra final lap. So `local player's refilling` value from corresponding `30s` column can be used, in this case, it's `+7.4` fuel to add.
    However, if leader is closer to finish line (as show in orange color indicator), there is a chance that leader may be fast enough to cross finish line before the end of timer, which would result an extra final lap for local player, and requires adding an extra lap of fuel (`3.8`) on top of `+7.4` fuel. In this case it would be `+11.2` refuel, or you can simply look at the refuel value from `extra refilling row` of same column.

    * If local player's `final lap progress` value is greater than leader, such as leader's 0.10 (30s column) vs player's 0.39 (40s column), it indicates that local player will be ahead of leader when timer ended, and there will be an extra final lap for local player, and here again requires adding an extra lap of fuel (`3.8`) on top of `+7.4` fuel from `40s` column, which is `+11.2` refuel.
    However, if the difference between the two `final lap progress` values is smaller than `relative lap difference` (from third row first cell) value, it may indicate that leader could overtake local player on final lap, which would result no extra final lap.

4. To sum up, if comparison shows no extra final lap, then just refill according to `local player's refilling` (fifth row) value from the same column of `local player's final lap progress` (third row). If comparison shows an extra final lap, then just add an extra lap of fuel on top of `local player's refilling` value; or, just look at the refuel value from `extra refilling row` of same column.


**Laps-type race example usage**

Note, there is generally no reason to use this widget in `LAPS` type race unless you are doing multi-class laps-type race which is very rarely seen.

| LAPS | 0s    | 30s  | 40s   | 50s   | 60s   | 0s   |
|:----:|:-----:|:----:|:-----:|:-----:|:-----:|:----:|
| LDR  | 2.00  | 1.57 | 1.43  | 1.28  | 1.14  | 2.00 |
| 0.11 | 0.40  | 0.02 | -0.11 | -0.24 | -0.37 | 0.40 |
| DIFF | 0s    | 30s  | 40s   | 50s   | 60s   | 43s  |
| FUEL | +12.8 | -    | -     | -     | -     | -    |
| EX+1 | +15.0 | -    | -     | -     | -     | -    |

1. Determine leader's next pit time and select `leader's final lap progress` (second row) value from corresponding pit time (first row) column. `0s` means no pit stop.

2. Determine local player's next pit time and select `local player's final lap progress` (third row) value from corresponding pit time (fourth row) column.

3. Subtract `local player's final lap progress` value from `leader's final lap progress`, then round down value:

    * If leader's `final lap progress` value is 2.00 (0s column), and local player's `final lap progress` value is 0.40 (0s column), then after subtracting (2 - 0.4 = 1.6) and rounding down, the final value is `1` lap difference, which means local player will do `one less lap` than leader.
    As mentioned earlier, for laps-type race, refilling value from `0s column` is calculated according to leader's `leader's final lap progress` value, which any lap difference is already included in the result from `local player's refilling` value (fifth row second cell), in this case, it's `+12.8` fuel to add.

    * If leader's `final lap progress` value is 1.43 (40s column), and local player's `final lap progress` value is -0.24 (50s column), then after subtracting (1.43 - -0.24 = 1.67) and rounding down, the final value is also `1` lap difference, which means local player will do the same `one less lap` than leader. So in this case, it's still `+12.8` fuel to add.

    * If leader's `final lap progress` value is 2.00 (0s column), and local player's `final lap progress` value is -0.11 (40s column), then after subtracting (2 - -0.11 = 2.11) and rounding down, the final value is `2` lap difference, which means local player will do `two less laps` than leader. So an extra lap of fuel may be removed from `local player's refilling` value from fifth row second cell, in this case, it's `12.8` minus one lap of fuel `2.2`, equals `+10.6` fuel to add. Alternatively, it can be calculated from full lap refuel (as show in Fuel Widget), which will be `15.0` minus two lap of fuel `4.4`, and equals `+10.6` fuel to add.
    Be aware that carrying less fuel is risky in laps-type race due to reasons below.

4. Last note, since the end of laps-type race is determined by the moment that leader completed all race laps, leader can greatly affect final prediction outcome. To give an extreme example, if leader is ahead of everyone by a few laps, and decides to wait a few minutes on his final lap before finish line, then everyone else will be catching up and do a few `extra laps` which would require more fuel. Thus it is always risky to carry less fuel in laps-type race.

---

    layout
2 layouts are available: `0` = show columns from left to right, `1` = show columns from right to left.

    near_start_range
Set detection range (in seconds) near (after) start/finish line to show color indicator when vehicle is within the range (or less). Default is `20` seconds. Default color is green.

    near_finish_range
Set detection range (in seconds) near (before) start/finish line to show color indicator when vehicle is within the range (or less). Default is `20` seconds. Default color is orange.

    leader_laptime_pace_samples
Set number of samples for average laptime pace calculation. Default is `6` samples. Set `1` to disable averaging.

Note, initial laptime pace is always based on leader's session personal best laptime if available. If a new laptime is faster than current laptime pace, it will replace current laptime pace without calculating average. Invalid lap, pit-in/out laps are always excluded from laptime pace calculation.

    leader_laptime_pace_margin
Set additional margin for laptime pace that cannot exceed the sum of previous `laptime pace` and `margin`. This option is used to minimize the impact of unusually slow laptime. Default value is `5` seconds. Minimum value is limited to `0.1`.

    show_absolute_refilling
Show absolute refilling value instead of relative refilling when enabled. Note, `+` or `-` sign is not displayed with absolute refilling.

    show_extra_refilling
Show readings of extra refilling row below `local player's refilling` row. Each extra refilling value equals `extra laps of consumption` plus `local player's refilling` value of same column. Those values save the trouble from manual calculation in case there will be extra laps.

The first column of extra refilling row shows number of extra laps depends on `number of extra laps` setting, such as `EX+1` for 1 extra lap, or `EX+3` for 3 extra laps.

    number_of_extra_laps
Set number of extra laps for extra refilling calculation. Default is `1` extra lap.

    number_of_prediction
Set number of optional prediction columns with customizable pit time. Value range in `0` to `10`. Default is `4` extra customizable columns.

    prediction_*_leader_pit_time, prediction_*_player_pit_time
Set prediction pit time for leader or local player.

[**`Back to Top`**](#)


## Ride height
**This widget displays visualized ride height info.**

    ride_height_max_range
Set visualized maximum ride height display range (millimeter).

    rideheight_offset*
Set ride height offset for bottoming indicator. Value in millimeters, but without decimal place.

[**`Back to Top`**](#)


## Rivals
**This widget displays standings info from opponent ahead and behind local player from same vehicle class.**

Note, most options are inherited from [Relative](#relative) and [Standings](#standings) widgets, with some additions noted below.

    time_interval_align_center
Align time interval in the center when enabled. Default is right alignment when disabled.

    *_color_time_interval_ahead, *_color_time_interval_behind
Set custom time interval color of opponent ahead and behind.

[**`Back to Top`**](#)


## Roll angle
**This widget displays vehicle front and rear roll angles info.**

    show_degree_and_percentage_sign
Set `true` to show degree and percentage sign.

    wheel_track_front, wheel_track_rear
Set front and rear wheel track in millimeters, for used in roll angle calculation. Default is `2000` millimeters.

    roll_angle_smoothing_samples, roll_angle_ratio_smoothing_samples
Set number of samples for reducing data fluctuation. Lower value may result more fluctuated reading. Set `1` to disable smoothing.

    show_roll_angle_difference
Show roll angle difference between front and rear roll angles.

    show_roll_angle_ratio
Show roll angle ratio between front and rear. 50% indicates equal roll angle; less than 50% indicates rear rolls more than front.

[**`Back to Top`**](#)


## RPM LED
**This widget displays RPM LED info.**

    number_of_led
Set number of LED to display. Minimum LED is limited to `3`.

    enable_double_side_led
Enable `Outside to Center` LED layout (as opposite to `Left to Right` layout). While this option is enabled, total number of LED is doubled.

    led_width, led_height, led_radius
Set LED width, height, radius in pixels. To achieve circle LED, set a higher radius value.

    rpm_multiplier_low
This value multiplies max RPM value, which sets starting range of RPM LED.

    rpm_multiplier_safe
This value multiplies max RPM value, which sets safe range of RPM LED.

    rpm_multiplier_redline
This value multiplies max RPM value, which sets redline range of RPM LED.

    rpm_multiplier_critical
This value multiplies max RPM value, which sets critical range of RPM LED.

    rpm_multiplier_over_rev
This value multiplies max RPM value, which sets over rev range of RPM LED.

    show_rpm_flickering_above_critical
Show flickering effects when RPM is above critical range and gear is lower than max gear.

    show_speed_limiter_flash
Show RPM LED flash effect when speed limiter is activated.

    speed_limiter_flash_interval
Set minimum time interval between each LED flash. Default is `0.25` seconds. Minimum value is limited to `0.2`.

[**`Back to Top`**](#)


## Sectors
**This widget displays sectors timing info.**

    layout
2 layouts are available: `0` = target and current sectors above deltabest sectors, `1` = deltabest sectors above target and current sectors.

    target_laptime
Set target laptime for display target reference lap and sector time. Set `Theoretical` to show theoretical best sector time. Set `Personal` to show sector time from personal best lap time. Note, if `enable_all_time_best_sectors` option is enabled in `Sectors Module`, all time best sectors data will be displayed instead, otherwise only current session best sectors data will be displayed.

    freeze_duration
Set freeze duration (seconds) for displaying previous sector time. Default is `5` seconds.

[**`Back to Top`**](#)


## Session
**This widget displays system clock, session name, timing, lap number, overall position info.**

    show_session_name
Show current session name that includes testday, practice, qualify, warmup, race.

    session_text_*
Set custom session name text.

    show_system_clock
Show current system clock time.

    system_clock_format
Set clock format string. To show seconds, add `%S`, such as `%H:%M:%S %p`. See [link](unlinked: docs_python_org/3/library/datetime_html#strftime-and-strptime-format-codes) for full list of format codes.

    show_session_time
Show total remaining session time.

    show_estimated_laps
Show estimated total remaining laps (from current lap position towards finish line) based on total remaining session time and local player's lap time pace. This value can be used for adjusting absolute refueling.

Note, this is the same value that used for calculating estimated refueling value in Fuel Module. As with estimation, there may be a margin of error of one lap, and may be affected by other variables such as those mentioned in [Relative Finish Order](#relative-finish-order) widget.

[**`Back to Top`**](#)


## Slip ratio
**This widget displays visualized slip ratio info.**

    slip_ratio_optimal_range
Set optimal slip ratio range (percentage) for optimal and critical slip ratio color indication, value range in `0` to `100`. Default is `30` percent.

    slip_ratio_max_range
Set visualized maximum slip ratio display range (percentage), value range in `10` to `100`. Default is `50` percent.

[**`Back to Top`**](#)


## Speedometer
**This widget displays conditional speed info.**

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_speed
Show current vehicle speed.

    show_speed_minimum
Show minimum speed that is updated while off throttle.

    show_speed_maximum
Show maximum speed that is updated while on throttle.

    show_speed_fastest
Show fastest recorded speed. To reset current record, shift gear into reverse, or reload preset.

    off_throttle_threshold
Set throttle threshold which counts as off throttle if throttle position is lower, value range in `0.0` to `1.0`. Default is `0.5`.

    on_throttle_threshold
Set throttle threshold which counts as on throttle if throttle position is higher, value range in `0.0` to `1.0`. Default is `0.01`.

    speed_minimum_reset_cooldown, speed_maximum_reset_cooldown
Set cooldown duration (seconds) before resetting minimum or maximum speed value.

[**`Back to Top`**](#)


## Standings
**This widget displays standings info.**

Note, most options are inherited from [Relative](#relative) widget, with some additions noted below.

    enable_single_class_exclusive_mode
Enable single-class exclusive mode, which displays vehicles from player's class only. This mode takes priority over all other display mode.

    enable_multi_class_split_mode
Enable multi-class split mode, which splits and displays each vehicle class in separated groups. This mode will only take effect when there is more than one vehicle class present in a session, otherwise it will automatically fall back to normal single class mode.

    min_top_vehicles
Set minimum amount top place vehicles to display. This value has higher priority over other `max_vehicles` settings. Default is `3`, which always shows top 3 vehicles if present.

    max_vehicles_exclusive_mode
Set maximum amount vehicles to display in exclusive mode, which takes effect when `enable_single_class_exclusive_mode` is enabled.

    max_vehicles_combined_mode
Set maximum amount vehicles to display in combined mode, which takes effect when `enable_multi_class_split_mode` is not enabled. When total vehicle number is lower than this value, extra rows will auto-hide. When total vehicle number is above this value, the top 3 vehicles will always show, and rest of the vehicles will be selected from the nearest front and behind places related to player.

    max_vehicles_split_mode
Set maximum amount vehicles to display in split mode, which takes effect when in multi-class session and `enable_multi_class_split_mode` is enabled. If total vehicle number is above this value, any extra vehicles will not be shown. Default is `50`, which is sufficient in most case.

    max_vehicles_per_split_player
Set maximum amount vehicles to display for class where player is in. Default is `7`. Note that, if player is not in first place, then at least one opponent ahead of player will always be displayed, even if this value sets lower.

    max_vehicles_per_split_others
Set maximum amount vehicles to display for classes where player is not in. Default is `3`.

    split_gap
Set split gap between each class.

    show_time_gap
Show each driver's time gap behind overall leader in race session. In none race sessions, time gap is calculated from overall leader's session best lap time.

    show_time_gap_from_same_class
Show time gap from same class leader instead of overall leader. This option only takes effect while `enable_multi_class_split_mode` is enabled.

    time_gap_leader_text
Set text indicator for race leader in time gap column.

    show_time_interval
Show time interval between each closest driver in order.

    show_time_interval_from_same_class
Show time interval from same class. This option only takes effect while `enable_multi_class_split_mode` is enabled.

    time_interval_leader_text
Set text indicator for race leader in time interval column.

    show_laptime
Show driver's last lap time or pit timer if available. If `show_best_laptime` is not enabled, this option will show driver's session best lap time in none-race sessions.

    show_best_laptime
Show driver's session best lap time.

    show_best_laptime_from_recent_laps_in_race
Show driver's best lap time from (five) most recent laps in race session. This option provides a better view of driver's recent performance during longer race.

    show_delta_laptime
Show lap time difference (delta) between player and opponents from most recent laps (up to 5 recent lap time records). The default layout order shows delta lap time records from right side column (most recent lap) to left.

A green color (default) delta indicates that player's recent lap time is faster than opponent, while orange color delta indicates the opposite.

    show_inverted_delta_laptime_layout
Enable this option to invert layout order for delta lap time records.

    number_of_delta_laptime
Set number of delta lap time records to display. Minimum number is limited to `2`, maximum is limited to `5`.

    show_stint_laps
Show number of completed laps from current stint and estimated total stint laps.

Note, `estimated total stint laps` reading is based on virtual energy usage data, which currently is only available on vehicles with virtual energy for LMU, and `enable_restapi_access` must be enabled for accessing stint data.

    show_energy_remaining
Show remaining virtual energy reading in percentage from each driver, with 4 different states:
- Unavailable: virtual energy reading is not available currently, default color grey.
- High: above 30% remaining, default color green.
- low: from 30% to 10% remaining, default color orange.
- critical: 10% or lower remaining, default color red.

**Known limitation with remaining virtual energy readings**

Currently, remaining virtual energy data from `LMU's Rest API` is updated only when driver completes a lap, which means the data from API will not change during a lap, but only at the moment a lap is done by a driver. And due to this, the data will not tell how much energy was refilled in pit until the driver finished his pit-out lap. This makes the data less useful by itself.

To workaround this API limitation, a special interpolation algorithm is implemented, which enables accurate estimates to remaining energy progressively during a lap for each driver. The average accuracy of estimation is within 1%.

Some cases where interpolation may not be applied:
- Interpolation may require at least 1 full lap (not counting pit-out lap) done before it can take effect.
- During pit stop, refilled energy reading may not be updated until driver finishes his pit-out lap (as mentioned earlier), which means old energy reading persists during pit-out lap and would result wrong estimates with interpolation. For this reason, interpolation is disabled during pit-out lap.

In either case, just wait another lap and energy readings will be synchronized.

    show_vehicle_integrity
Show opponent vehicle integrity reading.

The integrity reading is calculated from hull damage, detachable wheels and parts, and displayed as:
- Full integrity (no damage), as `-` (default color grey).
- High integrity (lightly damaged hull), from `9` to `5` (default color blue).
- Low integrity (severely damaged hull, and most likely has detached wheels or parts), from `4` to `0` (default color red).

    show_speed_trap
Show fastest recorded speed of each driver per lap at user-defined speed trap position on track. This option can be useful to keep track of each driver's straight line performance from most recent lap.

Note, speed trap position is defined in `tracks.json` preset, which can be customized via [Track Info Editor](#track-info-editor). Default speed trap position is set at start/finish line.

[**`Back to Top`**](#)


## Steering
**This widget displays steering input info.**

    bar_width, bar_height
Set steering bar width and height in pixels.

    bar_edge_width
Set left and right edge boundary width.

    manual_steering_range
Manually set steering display range in degree. Set to `0` to read physical steering range from API. This option may be useful when steering range value is not provided by some vehicles.

    show_steering_angle
Show steering angle text in degree.

    show_scale_mark
This enables scale marks on steering bar.

    scale_mark_degree
Set gap between each scale mark in degree. Default is `90` degree. Minimum value is limited to `10` degree.

[**`Back to Top`**](#)


## Steering wheel
**This widget displays virtual steering wheel.**

    show_custom_steering_wheel
Show user-defined custom steering wheel image instead of default image.

    custom_steering_wheel_image_file
Set custom steering wheel image file path. Double-click this option in widget's `Config` dialog to select an image file.

Note, image file must be in `PNG` format with same width and height. Maximum supported `PNG` file size is limited to `5MB`. Default image will be used if selected image is not valid.

    display_size
Set widget display size in pixels.

    display_margin
Set widget display margin in pixels.

    show_steering_angle
Show steering angle text in degree.

    manual_steering_range
Manually set steering display range in degree. Set to `0` to read physical steering range from API. This option may be useful when steering range value is not provided by some vehicles.

    show_rotation_line
Show steering rotation reference line, which can be useful to see if physical steering wheel is misaligned.

    show_rotation_line_while_stationary_only
Show rotation line only while vehicle is stationary (less than 1m/s).

[**`Back to Top`**](#)


## Stint history
**This widget displays stint history info.**

This widget consists of five columns from left to right (default order): `Total completed laps`, `Total driving time`, `Total fuel or virtual energy consumption`, `Tyre compound`, `Total average tyre wear (percent)`.

Note, stint history is not recorded while in garage or during formation lap.

    layout
2 layouts are available: `0` = vertical layout, `1` = reversed vertical layout.

    stint_history_count
Set the number of stint history display. Default is to show `2` most recent stints.

    show_virtual_energy_if_available
Show virtual energy consumption instead of fuel consumption if available. This option is enabled by default.

    show_empty_history
Show empty stint history. Default is `false`, which hides empty rows.

    minimum_stint_threshold_minutes
Set the minimum stint time threshold in minutes for updating stint history. This only affects ESC.

[**`Back to Top`**](#)


## Suspension force
**This widget displays visualized suspension force and ratio info.**

    show_force_ratio
Show percentage force ratio between each and total suspension force. Set `false` to show individual suspension force in Newtons.

[**`Back to Top`**](#)


## Suspension position
**This widget displays visualized suspension position info.**

    position_max_range
Set visualized maximum display range of suspension position (millimeter).

    show_third_spring_position_mark
Show front and rear third spring position mark relative to each suspension position.

    show_maximum_position_range
Show a visualized line indicating maximum suspension position range under compression, which can be useful to check suspension travel limits. While this option enabled, the suspension position line will also change its color to match `maximum_position_range_color` when reaching maximum position. The visualized line will not be displayed if maximum position range is negative (such as with too much packers).

Note, maximum suspension position calculation is handled by [Wheels Module](#wheels-module), and is not updated while in pit lane, and resets when exiting pit lane. A minimum of two laps are required to get sensible readings.

[**`Back to Top`**](#)


## Suspension travel
**This widget displays suspension travel info.**

Note, suspension travel data calculation is handled by [Wheels Module](#wheels-module), and is not updated while in pit lane, and resets when exiting pit lane.

Static suspension position is measured only while car is stationary on track or in garage stall (neutral gear and no throttle). Measurement is disabled in pit lane, as car can be lifted by pit crew which would result incorrect readings.

A minimum of two laps are required to get sensible readings.

    show_total_travel
Show total travel (millimeter) between minimum and maximum recorded suspension position.

    show_bump_travel
Show bump travel (millimeter) between static and maximum recorded suspension position. Note, bump travel may not be available if static suspension position was not recorded.

    show_rebound_travel
Show rebound travel (millimeter) between static and minimum recorded suspension position. Note, rebound travel may not be available if static suspension position was not recorded.

    show_travel_ratio
Show travel ratio (percentage) between bump travel and total travel. For example, a `70%` reading indicates 70% of travel is spent in bump, and 30% of travel in rebound. A `50%` reading indicates equal travel in bump and rebound travel.

    show_minimum_position
Show minimum recorded suspension position under extension (millimeter).

    show_maximum_position
Show maximum recorded suspension position under compression (millimeter).

    show_live_position
Show current suspension position (millimeter).

    show_live_position_relative_to_static_position
Show current suspension position (millimeter) relative to static position instead.

[**`Back to Top`**](#)


## System performance
**This widget displays system performance info.**

    show_system_performance
Show system's overall CPU utilization (percent) and memory usage (GB). Note, sampling interval is determined by `update_interval` setting.

    show_tinypedal_performance
Show TinyPedal's CPU utilization (percent) and memory usage (MB).

    average_samples
Set number of samples for average CPU utilization calculation. Lower value may result more fluctuated reading. Set `1` to disable averaging.

[**`Back to Top`**](#)


## Timing
**This widget displays lap time info.**

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_session_best
Show current session best lap time from all vehicle classes.

    show_session_best_from_same_class_only
Show current session best lap time from same vehicle class only.

    show_best
Show personal all time best lap time.

    show_last
Show personal last lap time.

    show_current
Show personal current lap time.

    show_estimated
Show personal current estimated lap time.

    show_session_personal_best
Show personal current session best lap time.

    show_stint_best
Show personal current stint best lap time.

    show_average_pace
Show personal current average lap time pace, this reading is also used in real-time fuel calculation. Note, additional `average lap time pace` calculation setting can be found in [Delta Module](#delta-module) config. After ESC or session ended, lap time pace reading will be reset, and aligned to `all time personal best lap time` if available.

[**`Back to Top`**](#)


## Track map
**This widget displays track map and standings. Note: at least one complete and valid lap is required to generate track map.**

    vehicle_scale, vehicle_scale_player
Set vehicle scale that multiplies base vehicle size. Note, base vehicle size is determined by `font size` and `bar padding`. Minimum scale is limited to `1.0`.

    display_orientation
Set track map display orientation in degrees. For example, a `270` value will rotate map by `270` degrees clockwise. Default value is `0`, which always displays track map `North Up` in game's coordinate system.

    display_detail_level
Sets detail level for track map. Default value is `1`, which auto adjusts map detail according to display size. Higher value reduces map detail and RAM usage, and may also help reduce rough edges from large map. Set to `0` for full detail.

    area_size
Set area display size.

    area_margin
Set area margin size.

    show_background
Show widget background.

    show_map_background
Show background of the inner map area. This option only works for circular type tracks.

    map_width
Set track map line width.

    map_outline_width
Set track map outline width.

    show_start_line
Show start line mark.

    show_sector_line
Show sector line mark.

    show_proximity_circle
Show proximity circle around player's position, which helps to quickly spot player and nearby opponents on map.

    proximity_circle_radius
Set proximity circle radius in meters. Default radius is `150` meters.

    show_vehicle_standings
Show vehicle standings info on track map. Note, if `enable_multi_class_styling` is enabled, position in class will be displayed for each vehicle class instead.

    enable_multi_class_styling
Show vehicles in multi-class color styles on map instead. Multi-class color can be customized from [Vehicle Class Editor](#vehicle-class-editor).

Note, while multi-class styling is enabled, following color styles will not be displayed:
`vehicle_color_player`, `vehicle_color_leader`, `vehicle_color_same_lap`, `vehicle_color_laps_ahead`, `vehicle_color_laps_behind`.

    show_custom_player_color_in_multi_class
Show custom player vehicle color (defined in `vehicle_color_player` option) while `enable_multi_class_styling` option is enabled.

    show_position_in_class
Show position in class while `enable_multi_class_styling` option is also enabled, otherwise this option has no effect.

    show_lap_difference_outline
Show outline color based on lap difference (ahead or behind) between player and opponents. This option is disabled by default.

    show_pitout_prediction
Show estimated pit-out on-track position indication for each pit stop duration. Default indication shows `circle` with `pit stop duration` displayed above.

Note, pit-out position prediction is based on `delta best` data which scaled with player's latest `lap time pace` for accurate real-time position prediction under various track conditions. Pit-out prediction requires both valid `track map` and `delta best` data to display. At least `one valid lap` for any car and track combo is required to display pit-out prediction.

For accurate prediction, the location of `pit-out line` must be found first. And since each track has different pit-out line location, it is required to `pit-out` at least `once per session` to mark the correct pit-out line location. This can be easily done by driving out of pit lane.

    show_pitout_prediction_while_requested_pitstop
Show estimated pit-out on-track position indication while player has requested pit stop and not in pit lane.

    number_of_prediction
Set number of pit-out prediction to display. Value range is limited in `1` to `20`.

    pitout_time_offset
Set amount time offset (in seconds) for catching up with vehicle speed after pit-out. Default is `3` seconds.

Note, this value is important for accurate prediction, as initial vehicle speed is much slower after pit-out, so extra time is needed for driver to catch up, and also affected by pit-out line location. For most tracks, this extra time after pit-out is roughly within `1` to `5` seconds.

    pitout_duration_minimum
Set pit stop duration (in seconds) of first prediction. This option has no effect if `enabled_fixed_pitout_prediction` is enabled.

    pitout_duration_increment
Set each pit stop duration (in seconds) increment after previous prediction. Default increment is `10` seconds. This option has no effect if `enabled_fixed_pitout_prediction` is enabled.

Note, each time when pit stop duration of the nearest prediction exceeded current pit stop timer, the prediction circle will be removed, and a new prediction circle will be appended with pit stop duration increment after the last prediction.

    enabled_fixed_pitout_prediction
Show pit-out prediction based on user-defined fixed pitstop duration instead. This option overrides `pitout_duration_minimum` and `pitout_duration_increment` options.

While this option is enabled, total pit-out duration is calculated from the sum of `pit-out time offset`, `fixed pit stop duration` and `estimated pit lane pass-through duration`. It's required to enter and exit pit lane at least once to get correct total pit-out duration.

    fixed_pitstop_duration
Set fixed amount pit stop duration (in seconds). Note, only `stopped` time should be considered for this option. Set to `0` if only passing through pit lane (such as `Drive Through`). Set to `-1` to disable this option.

    show_pitstop_duration
Show pit stop duration reading on top of each prediction circle.

[**`Back to Top`**](#)


## Track notes
**This widget displays track notes, comments, debugging info.**

    show_background
Show background color. Turn off to show text only.

    show_pit_notes_while_in_pit
Show custom notes while in pit lane.

    pit_notes_text, pit_comments_text
Set custom notes and comments to be displayed while in pit lane.

    show_track_notes
Show nearest track notes info behind current vehicle position.

    track_notes_uppercase
Set track notes text to uppercase.

    show_comments
Show nearest track notes comments info behind current vehicle position.

    enable_comments_line_break
Enable line break for displaying multi-line comments. To break a line into multiple lines, add `\n` to any part of the comment.

    show_debugging
Show nearest track notes index number behind current vehicle position, and distance value (meters) behind current position to next index position.

    track_notes_width, comments_width, debugging_width
Set maximum display width, value in chars, such as 10 = 10 chars.

    auto_hide_if_not_available
Auto hide this widget if track notes data is not available for current track.

    maximum_display_duration
Set maximum display duration (seconds) of each note. Set to `-1` to always display notes. Default is `-1`.

[**`Back to Top`**](#)


## Trailing
**This widget displays pedal, steering input and force feedback plots.**

    display_width
Set pedal plot display width in pixels.

    display_height
Set pedal plot display height in pixels.

    display_margin
Set pedal plot display margin (vertical relative to pedal) in pixels.

    display_scale
Set plot display scale. Default scale is `2`. Minimum scale is limited to `1`.

    show_inverted_pedal
Invert pedal range display.

    show_inverted_trailing
Invert trailing direction.

    show_throttle
Show filtered throttle plot. Note, some vehicles may not provide filtered pedal input value, which the value will be zero.

    show_raw_throttle
Show unfiltered throttle instead.

    show_absolute_ffb
Convert force feedback value to absolute value before plotting. Set to `false` to show force feedback plot in both positive and negative range.

    show_steering
Show steering plot.

    show_inverted_steering
Invert steering plot direction.

    *_line_width
Set trailing line width in pixels.

    *_line_style
Set trailing line style. `0` for solid line, `1` for dashed line.

    show_wheel_lock
Show wheel lock (slip ratio) plot under braking when slip ratio has exceeded `wheel_lock_threshold` value.

    wheel_lock_threshold
Set percentage threshold for triggering wheel lock warning under braking. `0.3` means 30% of tyre slip ratio.

    show_wheel_slip
Show wheel slip (slip ratio) plot under acceleration when slip ratio has exceeded `wheel_slip_threshold` value.

    wheel_slip_threshold
Set percentage threshold for triggering wheel slip warning under acceleration. `0.1` means 10% of tyre slip ratio.

    show_reference_line
Show reference line.

    reference_line_*_offset
Set reference line vertical offset position (percentage) relative to pedal, value range in `0.0` to `1.0`.

    reference_line_*_style
Set reference line style. `0` for solid line, `1` for dashed line.

    reference_line_*_width
Set reference line width in pixels. Set value to `0` to hide line.

    draw_order_index_*
Set draw order of plot lines.

[**`Back to Top`**](#)


## Tyre carcass temperature
**This widget displays tyre carcass temperature info.**

Note, if temperature drops below `-100` degrees Celsius, temperature readings will be replaced by unavailable sign as `-`.

    enable_heatmap_auto_matching
Enable automatically heatmap style matching for specific tyre compounds defined in `compounds.json` preset. This option applies matching heatmap style to front and rear tyre compounds separately.

Note, separate compounds info for tyres on the same axle is not available from game API, which currently it is not possible to show left and right compounds separately.

    heatmap_name
Set heatmap preset name that is defined in `heatmap.json` preset. Note, this option has no effect while `enable_heatmap_auto_matching` is enabled.

    show_degree_sign
Set `true` to show degree sign for each temperature value.

    leading_zero
Set amount leading zeros for each temperature value. Default is `2`. Minimum value is limited to `1`.

    show_rate_of_change
Show carcass temeperature rate of change for a specific time interval.

    rate_of_change_interval
Set time interval in seconds for rate of change calculation. Default interval is `5` seconds. Minimum interval is limited to `1` second, maximum interval is limited to `60` seconds.

    rate_of_change_smoothing_samples
Set number of samples for reducing data fluctuation. Lower value may result more fluctuated reading. Set `1` to disable smoothing.

    show_tyre_compound
Show tyre compound symbols (front and rear) that matches specific tyre compounds defined in `compounds.json` preset.

[**`Back to Top`**](#)


## Tyre inner layer
**This widget displays tyre inner layer temperature info.**

Note, if temperature drops below `-100` degrees Celsius, temperature readings will be replaced by unavailable sign as `-`.

    enable_heatmap_auto_matching
Enable automatically heatmap style matching for specific tyre compounds defined in `compounds.json` preset. This option applies matching heatmap style to front and rear tyre compounds separately.

Note, separate compounds info for tyres on the same axle is not available from game API, which currently it is not possible to show left and right compounds separately.

    heatmap_name
Set heatmap preset name that is defined in `heatmap.json` preset. Note, this option has no effect while `enable_heatmap_auto_matching` is enabled.

    swap_style
Swap heatmap color between font and background color.

    show_inner_center_outer
Set inner, center, outer temperature display mode. Set `false` to show average temperature instead.

    show_degree_sign
Set `true` to show degree sign for each temperature value.

    leading_zero
Set amount leading zeros for each temperature value. Default is `2`. Minimum value is limited to `1`.

    show_tyre_compound
Show tyre compound symbols (front and rear) that matches specific tyre compounds defined in `compounds.json` preset.

[**`Back to Top`**](#)


## Tyre load
**This widget displays visualized tyre load and ratio info.**

    show_tyre_load_ratio
Show percentage load ratio between each and total tyre load. Set `false` to show individual tyre load in Newtons.

[**`Back to Top`**](#)


## Tyre pressure
**This widget displays tyre pressure info.**

    hot_pressure_temperature_threshold
Set minimum temperature threshold (measured from tyre carcass in Celsius) for hot pressure indication. Default is `65` degrees Celsius. Default color for cold pressure is blue, and orange for hot pressure.

    show_pressure_deviation
Show average tyre pressure deviation between each tyre and the tyre with highest pressure.

    average_sampling_duration
Set duration (seconds) for calculating average tyre pressure. Default is `10` seconds. Maximum duration is limited to `600` seconds.

    swap_style
Swap cold and hot pressure color.

    show_tyre_compound
Show tyre compound symbols (front and rear) that matches specific tyre compounds defined in `compounds.json` preset.

[**`Back to Top`**](#)


## Tyre temperature
**This widget displays tyre surface temperature info.**

Note, if temperature drops below `-100` degrees Celsius, temperature readings will be replaced by unavailable sign as `-`.

    enable_heatmap_auto_matching
Enable automatically heatmap style matching for specific tyre compounds defined in `compounds.json` preset. This option applies matching heatmap style to front and rear tyre compounds separately.

Note, separate compounds info for tyres on the same axle is not available from game API, which currently it is not possible to show left and right compounds separately.

    heatmap_name
Set heatmap preset name that is defined in `heatmap.json` preset. Note, this option has no effect while `enable_heatmap_auto_matching` is enabled.

    swap_style
Swap heatmap color between font and background color.

    show_inner_center_outer
Set inner, center, outer temperature display mode. Set `false` to show average temperature instead.

    show_degree_sign
Set `true` to show degree sign for each temperature value.

    leading_zero
Set amount leading zeros for each temperature value. Default is `2`. Minimum value is limited to `1`.

    show_tyre_compound
Show tyre compound symbols (front and rear) that matches specific tyre compounds defined in `compounds.json` preset.

[**`Back to Top`**](#)


## Tyre wear
**This widget displays tyre wear info.**

    layout
2 layouts are available: `0` = vertical layout, `1` = horizontal layout.

    show_remaining
Show total remaining tyre tread in percentage that changes color according to wear.

    show_wear_difference
Show estimated tyre wear difference per lap (at least one valid lap is required).

    show_live_wear_difference
Show current lap tyre wear difference.

    show_lifespan_laps
Show estimated tyre lifespan in laps.

    show_lifespan_minutes
Show estimated tyre lifespan in minutes.

    show_end_stint_remaining
Show estimated total remaining tyre tread at the end of current stint, which helps to determine whether there is enough tread for current or more stints. Negative reading indicates that there will not be enough tyre tread remaining at the end of current stint.

For example, if minimum safe tyre tread is around 10%, then for triple-stint tyre saving, aim for 70% remaining tread for first stint, 40% for second stint, and 10% for third stint.

    warning_threshold_remaining
Set warning threshold for total remaining tyre in percentage. Default is `30` percent.

    warning_threshold_wear
Set warning threshold for total amount tyre wear of last lap in percentage. Default is `3` percent.

    warning_threshold_laps
Set warning threshold for estimated tyre lifespan in laps. Default is `5` laps.

    warning_threshold_minutes
Set warning threshold for estimated tyre lifespan in minutes. Default is `5` laps.

[**`Back to Top`**](#)


## Virtual energy
**This widget displays virtual energy usage info.**

Note, most options are inherited from [Fuel](#fuel) widget, with some additions noted below. For battery charge usage info, see [Battery](#battery) widget.

    show_absolute_refilling
Show absolute refilling value instead of relative refilling when enabled. Note, `+` or `-` sign is not displayed with absolute refilling.

    show_fuel_ratio_and_bias
Show fuel ratio and fuel bias column.

    *ratio
Show fuel ratio between estimated fuel and energy consumption, which can help balance fuel and energy usage, as well as providing refueling reference for adjusting pit stop `Fuel ratio` during race.

    *bias
Show fuel bias (unit in laps) that calculated from estimated laps difference between fuel and virtual energy.

Positive value indicates more laps can be run on fuel than virtual energy; in other words, virtual energy will deplete sooner than fuel. For example, a value of `+1.5` indicates that there will be `1.5 laps` of extra fuel remaining after virtual energy depleted.

Note, depleting virtual energy could result a `Stop-Go` penalty in `LMU`; while running out of fuel means no power for vehicle and would result retirement from race. So it is a good idea to keep fuel bias close to `0.0`, and slightly towards positive side to avoid depleting fuel before virtual energy.

[**`Back to Top`**](#)


## Weather
**This widget displays weather info.**

    show_temperature
Show track and ambient temperature.

    show_rain
Show rain precipitation in percentage.

    show_wetness
Show average surface wetness in percentage.

    show_rubber_coverage_while_dry
Show rough estimate of rubber coverage (percent) based on total number of laps done by all drivers while road surface is dry.

Note, rubber coverage reading may not be accurate during `practice session` in multiplayer, as some API data will be lost or reset while people joining or leaving server. This does not affect `qualifying` and `race` session.

| Rubber Coverage | Equivalent Grip | Equivalent Laps (LMU) | Equivalent Laps (RF2) |
|:-:|:-:|:-:|:-:|
| 0.0 (0%) | Green | 0+ | 0+ |
| 0.25 (25%) | Light | 600+ | 300+ |
| 0.5 (50%) | Medium |  1200+ | 600+ |
| 0.75 (75%) | Heavy (High) | 2000+ (Median) | 1000+ (Median) |
| 1.0 (100%) | Saturated | 4000+ | 2000+ |

**Note, all data from above table are rough estimate based on testing.*

    rubber_median_laps
Set median laps at the point when grip becomes `Heavy (High)` for calculating accurate rubber coverage. Default median laps is `2000`. This value may vary from different games, see above table for reference.

    rubber_time_scale_*
Set time scale multiplier for calculating rubber coverage in corresponding sessions (practice, qualifying, race). This value should match `Realroad Time Scale` session setting from game. For `static` rubber, set time scale to `0`.

Note, since Realroad Time Scale data is not available from game API, it is required to manually set the value.

Most online servers use default `1.0` Realroad Time Scale setting during `qualifying` and `race` session, while some servers may use `static` setting during `practice` session only.

    starting_rubber_*
Set starting rubber coverage (percent) in corresponding sessions (practice, qualifying, race).

Note, since session starting rubber coverage data is not available from game API, it is required to manually set the value.

    temperature_trend_interval, raininess_trend_interval, wetness_trend_interval
Set weather change trend interval in seconds for temperature, raininess, surface wetness readings. Default interval is `60` seconds.

If weather readings increased within the interval, `â–²` uparrow sign will be shown; if readings decreased within the interval, `â–¼` downarrow sign will be shown; If readings has not changed during the interval, `â—` sign will be shown after.

    decimal_places_temperature
Set amount decimal places to keep. Default is `1` decimal place, set to `0` to hide decimals. Note, when number of digits is less than expected, extra leading zero or decimal place will be added to fill the gap.

[**`Back to Top`**](#)


## Weather forecast
**This widget displays weather forecast info.**

    layout
2 layouts are available: `0` = show columns from left to right, `1` = show columns from right to left. Note, the `now` column always shows current weather condition.

    show_estimated_time
Show estimated time reading for upcoming weather. Note, estimated time reading only works in time-based race. Other race type such as lap-based race shows `n/a` instead.

    show_ambient_temperature
Show estimated ambient temperature reading for upcoming weather. Note, the `now` column always shows current ambient temperature instead.

    show_rain_chance_bar
Show visualized rain chance bar reading for upcoming weather. Note, the `now` column always shows current raininess instead.

    number_of_forecasts
Set number of forecasts to display. Value range in `1` to `4`. Default is `4` forecasts.

    show_unavailable_data
Show columns with unavailable weather data. Set `False` to auto hide columns with unavailable data. Note, auto hide only works for time-based race.

[**`Back to Top`**](#)


## Weight distribution
**This widget displays weight distribution info.**

Note, to get accurate static weight distribution readings, test setup on level ground.

Weight distribution is calculated from tyre load data, which may not be available from certain vehicles in game API (such as LMGT3).

To workaround this limitation, suspension load data, while not entirely the same, will be used for calculation instead.

    show_front_to_rear_distribution
Show front to rear weight distribution in percentage.

    show_left_to_right_distribution
Show left to right weight distribution in percentage.

    show_cross_weight
Show cross weight (known as `wedge`) in percentage.

    smoothing_samples
Set number of samples for reducing data fluctuation. Lower value may result more fluctuated reading. Set `1` to disable smoothing.

[**`Back to Top`**](#)


## Wheel camber
**This widget displays wheel camber info.**

Note, all camber readings are in degrees.

    show_camber_difference
Show camber difference between left and right wheel on the same axle, useful for quickly checking misalignment while driving.

    camber_smoothing_samples, camber_difference_smoothing_samples
Set number of samples for reducing data fluctuation. Lower value may result more fluctuated reading. Set `1` to disable smoothing.

[**`Back to Top`**](#)


## Wheel toe
**This widget displays wheel toe info.**

Note, all toe readings are in degrees. Positive reading indicates toe-in; negative indicates toe-out.

    show_total_toe_angle
Show total toe angle between left and right wheel on the same axle, useful for quickly checking amount total toe angle while driving.

    toe_in_smoothing_samples, total_toe_angle_smoothing_samples
Set number of samples for reducing data fluctuation. Lower value may result more fluctuated reading. Set `1` to disable smoothing.

[**`Back to Top`**](#)

```

# File: docs/changelog.txt
```
WIP
-----------------------------
* Standings Widget
  - Added "enable_single_class_exclusive_mode" option (requested by user "omenek159"), which enables single-class exclusive mode that displays vehicles from player's class only. This mode takes priority over all other display mode.
  - Added "max_vehicles_exclusive_mode" option, which sets maximum amount vehicles to display when "enable_single_class_exclusive_mode" is enabled.

* Track map Widget
  - Added "enabled_fixed_pitout_prediction" option (requested by user "Ces-cos"), which shows pit-out prediction based on user-defined fixed pit stop duration instead.
    Total pit-out duration is calculated from the sum of "pit-out time offset", "fixed pit stop duration" and "estimated pit lane pass-through duration". It's required to enter and exit pit lane at least once to get correct total pit-out duration.
    While this option is enabled, "pitout_duration_minimum" and "pitout_duration_increment" options will have no effect.
  - Added "fixed_pitstop_duration" option, which sets fixed amount pit stop duration (in seconds). Note, only "stopped" time should be considered for this option. Set to "0" if only passing through pit lane (such as "Drive Through"). Set to "-1" to disable this option.

* Misc
  - Fixed an issue where default read-only setting can be modified.

2.39.0 (2026-01-13)
-----------------------------
* Track Info Editor
  - Added "Speed trap" column for customizing speed trap position. To manually set speed trap position at your current on-track position, "Right-Click" on corresponding track's speed trap column and select "Set from Telemetry".

* Vehicles Module
  - Added speed trap recording function.

* Wheels Module
  - Added suspension travel calculation, which is required by "Suspension position" and "Suspension travel" Widgets.
  - Added "enable_suspension_measurement_while_offroad" option, which enables suspension travel measurement while vehicle is offroad. This option should be disabled for road racing for more accurate suspension measurement. This option is disabled by default.
  - Added "average_suspension_position_samples", "average_suspension_position_margin" options for filtering out unusual data.
  - Added "wheel_lift_off_threshold" option, which sets millimeter threshold of tyre vertical deflection for detecting lifted wheels. Suspension travel is not calculated from wheel that is lifted off the ground (as below the threshold). Default threshold is "1" millimeter. Set to "-1" to always calculate suspension travel even if wheel is lifted off.

* Relative, Rivals, Standings Widget
  - Added "show_speed_trap" option (requested by user "francescodg"), which shows fastest recorded speed of each driver per lap at user-defined speed trap position on track. This option can be useful to keep track of each driver's straight line performance from most recent lap.
    Note, speed trap position is defined in "tracks.json" preset, which can be customized via Track Info Editor. Default speed trap position is set at start/finish line.

* Brake pressure Widget
  - Added "show_brake_input" option, which shows raw brake input on each brake. This option can be useful to check amount difference between brake input and applied brake pressure.
  - Added "brake_input_size", "brake_input_color" options.

* Pit stop estimate Widget
  - Added "show_pit_occupancy" option, which shows "pit occupancy" and "pit requests" columns.
  - Added "pit occupancy" column, which shows number of vehicles that stopped in pit lane, and number of vehicles currently in pit lane (whether passing or stopped). This does not include vehicles that are parked in garage.
  - Added "pit requests" column, which shows number of vehicles that requested for pit stop, and number of vehicles currently outside pit lane.
  - Now reads pit stop timing data from more reliable source. Due to this change, "show_maximum_delay" and related options no longer worked and removed.

* Suspension position Widget
  - Added "show_maximum_position_range" option (requested by user "yhnp78"), which shows a visualized line indicating maximum suspension position range under compression, which can be useful to check suspension travel limits. While this option enabled, the suspension position line will also change its color to match "maximum_position_range_color" when reaching maximum position. The visualized line will not be displayed if maximum position range is negative (such as with too much packers).
    Note, maximum suspension position data calculation is handled by Wheels Module, and is not updated while in pit lane, and resets when exiting pit lane. A minimum of two laps are required to get sensible readings.
  - Added "maximum_position_range_size", "maximum_position_range_color" options.

* [New]Suspension travel Widget
  - Show total travel (millimeter) between minimum and maximum recorded suspension position.
  - Show bump travel (millimeter) between static and maximum recorded suspension position.
  - Show rebound travel (millimeter) between static and minimum recorded suspension position.
  - Show travel ratio (percentage) between bump travel and total travel.
  - Show minimum recorded suspension position under extension (millimeter).
  - Show maximum recorded suspension position under compression (millimeter).
  - Show current suspension position (millimeter) relative to static position (optional).
    Note, static suspension position is measured only while car is stationary on track or in garage stall (neutral gear and no throttle). Measurement is disabled in pit lane, as car can be lifted by pit crew which would result incorrect readings.
    Bump or rebound travel may not be available if static suspension position was not recorded.

* Misc
  - Added "caption_text" options for "Brake wear", "Suspension travel", "Tyre wear" Widgets.
  - Added "prefix and suffix" and "caption text" options in "Preset Transfer" dialog.

2.38.0 (2026-01-01)
-----------------------------
* [New]RPM LED Widget
  - Show customizable RPM LED (requested by user "BorzhonovAI").
  - Support two primary LED layouts: "Left to Right" and "Outside to Center" (via "enable_double_side_led").
  - Customizable number of LEDs, size, radius, color range, and more.
  - Show speed limiter state.

* Fuel energy saver Widget
  - Added "enable_pit_entry_bias" option (requested by user "Alit54"), which auto calibrates target fuel (or energy) saving bias towards either pit entry position or finish line, depending on number of estimated remaining pit stops.
    This feature is made specially for tracks that have pit entry position located far away from finish line, which it is necessary to take pit entry position into fuel saving calculation for increased accuracy.
    While enabled, a new "BIAS" column will be added, which shows amount added fuel (or energy) bias towards pit entry position, as well as percentage pit entry bias from finish line, When bias is "0", it means there is no pit entry bias added.
    Important notes:
    This feature is disabled by default. Do not enable this feature if you are not sure what it does.
    You must enter pit at least once to record pit entry position of the track for this feature to work.
  - Added "remaining_pitstop_threshold" option, which sets number of remaining pit stops threshold for auto calibrating target fuel (or energy) saving bias. Default value is "0.1".
    Fuel (or energy) saving calculation is biased towards pit entry position when number of estimated remaining pit stops is greater than the threshold, otherwise biased towards finish line.

* Relative, Rivals, Standings Widget
  - Added "show_best_laptime" option for Relative Widget (requested by user "MzzyL"), which shows best lap time for each driver.
  - Added "show_best_laptime_from_recent_laps_in_race" option, which shows driver's best lap time from (five) most recent laps in race session. This option provides a better view of driver's recent performance during longer race. This option is disabled by default.

* Weather
  - Added "show_rubber_coverage_while_dry" option (requested by user "kby702"), which shows rough estimate of rubber coverage (percent) based on total number of laps done by all drivers while road surface is dry.
    Note, rubber coverage reading may not be accurate during "practice session" in multiplayer, as some API data will be lost or reset while people joining or leaving server. This does not affect "qualifying" and "race" session.
  - Added "rubber_median_laps", "rubber_time_scale", "starting_rubber" options, which affect rubber coverage calculation accuracy.
    Note, currently all those options must be set manually, as game API does not provide those data.
    See User Guide for complete explanation and usage info of those options.

2.37.0 (2025-12-24)
-----------------------------
* API
  - Added "Remember API Selection from Preset" check box to "API" menu, which allows to remember and load API selection from preset. Turn off this option to select API globally for all presets. This option is enabled by default.
  - Added asterisk (*) symbol to legacy API name in status bar.

* Driver Stats
  - Now records personal best lap time also for qualifying and race session separately, and can be viewed under "Qualifying" and "Race" columns in Driver stats viewer.

* Pace Notes Playback
  - Added "Enable Playback While in Pit Lane" check box, which allows to enable or disable pace notes playback while in pit lane. This option takes immediate effect when changed.

* Damage Widget
  - Now shows detached wings (for LMU built-in API only).
  - Added "show_detached_warning_flash" option, which shows warning flash for detached parts, such as wings and wheels.
  - Added "parts_width_ratio" option, which sets width ratio between side and center body parts. Value range in "0.1" to "1.0".

* Pace notes Widget
  - Added "show_pit_notes_while_in_pit" option (requested by user "DanRZ"), which shows alternative pit notes while in pit lane. Note, this option does not affect pace notes playback.
  - Added "pit_notes_text" & "pit_comments_text" options.

* Radar Widget
  - Added "show_vehicle_orientation" option, which shows opponent vehicle orientation (heading) relative to player. Disable this option to show player and opponent vehicle headings in parallel.

* Relative, Rivals, Standings Widget
  - Added "show_class_style_for_position_in_class" option (requested by user "Wigg1es"), which shows class style background color for position in class. This option is disabled by default.
  - Removed "show_random_color_for_unknown_class" option. Random color is now always displayed for unknown class.

* Track map Widget
  - Added "show_proximity_circle" option, which draws a proximity circle around player's position. The proximity circle helps to quickly spot player and nearby opponents on map. Default circle radius is "150" meters.
  - Added "vehicle_scale" & "vehicle_scale_player" options, which set vehicle scale that multiplies base vehicle size. Note, base vehicle size is determined by "font size" and "bar padding". Minimum scale is limited to "1.0".
  - Added "show_custom_player_color_in_multi_class" option (requested by user "mzluzifer"), which shows custom player vehicle color while "enable_multi_class_styling" option is enabled. This option is disabled by default.
  - Now always highlight player vehicle color while in pit.

* [Removed]Wheel alignment Widget
  - Removed Wheel alignment Widget, split into the new "Wheel camber" & "Wheel toe" widgets. Relevant settings are automatically transferred to the new corresponding widget.

* [New]Wheel camber Widget
  - Show camber angle in degrees.
  - Show camber difference between left and right wheel on the same axle, useful for quickly checking misalignment while driving.
  - Added "smoothing_samples" option for reducing data fluctuation.
  - Added "horizontal_gap", "vertical_gap", "caption_text" options.

* [New]Wheel toe Widget
  - Show toe angle in degrees.
  - Show total toe angle between left and right wheel on the same axle, useful for quickly checking amount total toe angle while driving.
  - Added "smoothing_samples" option for reducing data fluctuation.
  - Added "horizontal_gap", "vertical_gap", "caption_text" options.

* Misc
  - More accurate vehicle coordinates synchronization between local player and opponents (smoother vehicle position update on Radar & Navigation Widget).

2.36.0 (2025-12-13)
-----------------------------
* Major API Changes
  - Now supports LMU's new built-in API, no plugin is required to access this API. Note, currently this new API is not accessible on Linux system.
  - Added "legacy" tag to the old plugin-based LMU API (rF2SharedMemoryMapPlugin), and can still be used as fallback.
  - Added "API" menu to main window, which allows to switch game API, configure options, and restart API. "API" menu can also be accessed by clicking "API" button on right-bottom of status bar.
  - API settings are now saved separately in user preset file for each different game API.
  - Auto-switching API is not supported currently. Removed "auto load primary preset for sim" option.

* Pace Notes Playback
  - Fixed volume slider could not apply volume change while using PySide6.

* Brake wear, Tyre wear Widget
  - Added "show_live_wear_difference" option (requested by user "kfran42" & "laabbassi"), which shows current lap wear difference. This option is disabled by default.
  - Fixed wear data sometimes did not reset after changed session.

* Track notes Widget
  - Added "show_pit_notes_while_in_pit" option (requested by user "DanRZ"), which shows alternative pit notes while in pit lane.
  - Added "pit_notes_text" & "pit_comments_text" options.

* Misc
  - Now saves current version info in user preset, which is used to auto check and update outdated settings.
  - Updated "README.md" and "User Guide" with new API info and options.

2.35.3 (2025-11-25)
-----------------------------
* Wheels Module
  - Avoid resetting wheel radius, tyre wear, brake wear data while game is paused.
  - Added delta wear calculation for estimating brake wear difference per lap.
  - Now automatically saves brake failure thickness values to "brakes.json" preset when brakes failed.

* Brakes Preset
  - Now saves and loads brake style and failure thickness settings per vehicle brand for the same class, as different brands utilize different settings.
    Note, user must import vehicle brand data via "Vehicle Brand Editor" in order to save settings under vehicle brand name.

* Brake wear Widget
  - Now shows "FAIL" text on failed brakes.

* Pit stop estimate Widget
  - Added "lengthy_stop_duration_threshold" option, which sets warning threshold for lengthy pit stop duration in seconds. Default is "60" seconds.
    This option can be useful to check for unusually long pit stop duration, such as repairing.
  - Added "show_maximum_delay" option, which allows to show or hide "maximum delay" and "maximum total duration" column.
  - Added "show_relative_refilling" option, which allows to show or hide "actual relative refill" and "total relative refill" column.

2.35.1 (2025-11-18)
-----------------------------
* Relative, Vehicles Module
  - Added alternative stint laps recording for vehicle without virtual energy (requested by user "bshpanchuk").
  - Now continues to update relative and vehicles data while not driving in active session (such as in garage or spectating).

* Relative, Rivals, Standings Widget
  - Current stint laps reading now shows on vehicle without virtual energy (such as LMP2). Note, estimated total stint laps cannot be shown on vehicle without virtual energy due to missing game API data.

* Misc
  - Fixed an issue where TinyPedal could not be closed if "enable_restapi_access" option is disabled in Telemetry API setting (reported by user "Deckard9999").

2.35.0 (2025-11-12)
-----------------------------
* API Changes
  - Added new "Telemetry API" setting that handles both "Shared memory API" and "Rest API" accessing.
  - Previous settings from "Shared memory API" and "RestAPI Module" will be auto transferred to "Telemetry API". All old settings are preserved for backward compatibility with older versions.
  - Rest API accessing can now be enabled or disabled by toggling "enable_restapi_access" option in "Telemetry API" dialog.
  - Removed "RestAPI Module" from Module Tab.

* Delta Module
  - Now calculates estimated lap time based on stint deltabest for increased accuracy (requested by user "Obly88").
    Note, if stint deltabest is not yet available, session deltabest (or all time deltabest) will be used instead.

* Wheels Module
  - Added brake failure thickness logging to console if brake fails (LMU only).

* Battery Widget
  - Added "show_battery_charge_warning_flash" option (requested by user "Ces-cos"), which shows battery charge warning flash effect when battery charge decreased below "low_battery_threshold" or increased above "high_battery_threshold".
  - Added "number_of_warning_flashes", "warning_flash_highlight_duration", "warning_flash_interval" options.

* Brake wear Widget
  - Fixed an issue where brake "warning_threshold_wear" was not correctly applied while "show_thickness" enabled.

* Relative, Rivals, Standings Widget
  - Added "show_stint_laps" option (requested by user "Shu Gu"), which shows number of completed laps from current stint and estimated total stint laps.
    Note, this option is only available for LMU, and "RestAPI Module" must be enabled for accessing stint data.
  - Added "yellow_flag_status_text" option (requested by user "bshpanchuk"), which shows yellow flag indicator when driver causes (or likely to) yellow flag. Note, unlike in-game yellow flag, the indicator is always displayed when driver's speed is below 28kph (outside of pit lane), regardless whether driver has caused yellow flag on track.
  - "class_width" can now be set to "0" to hide class name while showing only class color. (requested by user "Levis1234").
  - Added "show_pitstop_duration_while_requested_pitstop" option, which shows driver's last recorded pit stop duration (in lap time column) while you have requested pit stop.

* Misc
  - Fixed an issue where consumption history was not recorded if two consecutive laps ended with exact same lap time.

2.34.0 (2025-10-01)
-----------------------------
* Repository change notice
  - In order to better organize things, as well as serve future development, the repository address (previous under my personal repo) is now moved to "github.com/TinyPedal".
    All previous links to the old repository will be auto-redirected to the new address and continue to work, with only one exception to "Check for updates".
  - Updated "Check for updates" function to point to the new repository address (any version before v2.34.0 may not be able to detect this or newer updates, as expected due to changes above).

* Auto load preset system
  - Now supports auto loading primary preset for specific vehicle class (requested by user "H4dro" and "Lymark"). Note, auto loading primary class preset (if available) always takes priority over primary sim (such as LMU or RF2).
  - Added "Set Primary for Class" sub-menu to right-click context menu in Preset tab list, which allows to tag select preset with specific vehicle class name for auto loading.
  - Show vehicle class tags in Preset tab. Class tags and colors are defined in "classes.json" file, which can be modified in "Vehicle Class Editor".
  - "Clear Primary Tag" option now removes both "class" and "sim" tags from selected preset.

* [New]Roll angle Widget
  - Show vehicle front and rear roll angles in degrees.
  - Show roll angle difference between front and rear roll angles.
  - Show roll angle ratio between front and rear. 50% indicates equal roll angle; less than 50% indicates rear rolls more than front.
  - See User Guide "Roll angle" section for details.

* [New]Weight distribution Widget
  - Show front to rear weight distribution in percentage.
  - Show left to right weight distribution in percentage.
  - Show cross weight (known as "wedge") in percentage.
  - Note, to get accurate static weight distribution readings, test setup on level ground.
    Weight distribution is calculated from tyre load data, which may not be available from certain vehicles in game API (such as LMGT3).
    To workaround this limitation, suspension load data, while not entirely the same, will be used for calculation instead.

* Tyre pressure Widget
  - Redesigned tyre pressure widget to show cold and hot pressure indication and average pressure deviation (requested by user "ebeninca"). Default color for cold pressure is blue, and orange for hot pressure.
  - Added "hot_pressure_temperature_threshold" option, which sets minimum temperature threshold (measured from tyre carcass in Celsius) for hot pressure indication. Default is "65" degrees Celsius.
  - Added "show_pressure_deviation" option, which shows average tyre pressure deviation between each tyre and the tyre with highest pressure.
  - Added "show_tyre_compound" option for displaying tyre compound symbols.

* Relative, Rivals, Standings Widget
  - Added "show_vehicle_integrity" option (requested by user "francescodg"), which shows opponent vehicle integrity reading.
    The integrity reading is calculated from hull damage, detachable wheels and parts, and displayed as:
    - Full integrity (no damage), as "-" (default color grey).
    - High integrity (lightly damaged hull), from "9" to "5" (default color blue).
    - Low integrity (severely damaged hull, and most likely has detached wheels or parts), from "4" to "0" (default color red).

* Fuel Widget, Virtual energy Widget
  - Added "show_estimated_pitstop_count", "show_delta_and_end_remaining", "show_fuel_ratio_and_bias" options, which allow to show or hide corresponding column.

* Brake temperature Widget
  - Reworked average brake temperature calculation to more accurately reflect average temperature change under braking. Average brake temperature is now calculated from most recent braking period. The braking period is defined by "average_sampling_duration" and "off_brake_duration" options.
  - Added "average_sampling_duration" option, which sets duration (seconds) for calculating average brake temperature from most recent braking period. Default is "10" seconds. Maximum duration is limited to "600" seconds.
  - Added "off_brake_duration" option, which sets duration (seconds) for continuously updating average brake temperature for a short period after fully released brakes. Default is "1" seconds.
  - Removed old "highlight_duration", "font_color_highlighted", "bkg_color_highlighted" options.

* Laps and position Widget
  - Now shows estimated total laps for time-based session (requested by user "Sandriekus"). A "~" sign will be displayed before estimated total laps reading, and up to two decimal places will be kept.
    Note, estimated total laps reading is calculated based on local player's lap time pace data from Delta Module, which can be different from in-game HUD reading. This reading does not concern about race leader's lap time pace, which means there may be an extra final lap on top of it.
  - Increased "lap_number" bar width by 3 characters to fit with additional digits and decimals from estimated total laps reading.

* Rake angle Widget
  - Added "rake_angle_smoothing_samples" option for reducing data fluctuation and improved readability.
  - Added "decimal_places" option.

* Spectate mode
  - Fixed an issue where lower-case names were sorted and placed at the bottom of player list.

* Misc
  - Added new contributor "sepi" to contributors.md in "Community support" section.

Thanks to everyone supporting the development, have fun.

2.33.2 (2025-09-03)
-----------------------------
* Flag Widget
  - [New]Added "yellow_flag_maximum_range_ahead" and "yellow_flag_maximum_range_behind" options (requested by user "Obly88"), which set maximum range for displaying yellow flags that ahead of or behind driver.
    Default range ahead is "500" meters, range behind is "50" meters. To disable yellow flag that behind driver, set range behind to "0".
    Note, yellow flags that ahead of driver take priority over those from behind.
  - Now shows plus and minus sign for nearest yellow flag distance reading. Positive distance reading indicates yellow flag that ahead of driver, negative indicates behind.

* Brake Bias Widget
  - No longer resets baseline bias delta while game is paused (requested by user "matteocnt92"). Baseline bias delta now also resets while vehicle is stationary during formation lap.

* Damage Widget
  - Fixed an issue where aero damage reading sometimes was not updated after impact.

* Speedometer Widget
  - Fixed an issue where minimum and maximum speed could not be reset.

* Stint History Widget
  - No longer resets current stint data while game is paused (requested by user "ebeninca"). Stint history is no longer recorded during formation lap.

* Trailing Widget
  - [New]Added "show_steering" option (requested by user "Badorio"), which shows steering input plot. This option is disabled by default.

* Tyre carcass, Tyre inner layer, Tyre temperature Widget
  - Fixed "enable_heatmap_auto_matching" not working if "show_tyre_compound" option is disabled.

2.33.1 (2025-08-22)
-----------------------------
* [New]Check for Updates
  - Add "Check For Updates On Startup" global option (requested by user "coasting-nc"), which enables automatically checking for updates on startup, and displays notification message in main window.
    This option is enabled by default, and can be disabled in "Application" dialog from "Config" menu in main window.
    Note, this option is checked only once per startup, and notification message will only be displayed if new updates is available.
    This option only checks for new updates info, it does not provide updates downloading or installing feature.
  - Add "Check for Updates" option to "Help" menu in main window, which allows to manually check for updates. This option always displays notification message in main window.
  - Add notification message for "Check for Updates" in main window. Click on the notification message will bring up a menu, where user can click "View Updates On GitHub" to open "Latest Releases" page in web browser, or "Dismiss" the message.
  - Add "Check for Updates" message to console output.

* Spectate mode
  - Now lists player names in alphabetical order, making it easier for finding specific player.

* Relative finish order, Track map Widget
  - Fixed a typo with option name "predication" (reported by user "PeterVRC"). Existing setting won't be affected.

* Misc
  - Small optimization.

2.33.0 (2025-08-10)
-----------------------------
* Fuel Calculator
  - [New]Add "pit stop preview" bar on the left side of calculator panel, which visualizes pit stops as blue marks and stint laps as grey marks.
    Each pit stop mark shows a reference lap completion number. Total estimated number of race laps is displayed at bottom of the bar.
    Note, when "Energy consumption" value is higher than zero, pit stops and stint laps from preview bar will be calculated based on energy usage. Stint lap mark may not be displayed if there is not enough space to draw.
  - "Starting Fuel" and "Starting Energy" values now affect "total pit stops" outcome, as well as visualized on "pit stop preview" bar.

* RestAPI Module
  - Add togglable options for each accessible data from Rest API.
  - Add "enable_garage_setup_info" option, which enables access to "garage setup" data (RF2 & LMU). This is required for accessing various vehicle setup data.
  - Add "enable_session_info" option, which enables access to "session" data (RF2 & LMU). This is required for accessing various session data, such as time-scale.
  - Add "enable_weather_info" option, which enables access to "weather" data (RF2 & LMU). This is required for showing weather forecast.
  - Add "enable_vehicle_info" option, which enables access to "vehicle" data (LMU only). This is essential for accessing "virtual energy", "brake wear", "vehicle damage", "pit stop timing" data.

* Battery, Gear Widget
  - Add "high_battery_threshold, low_battery_threshold" options (requested by user "H4dro"), which set percentage threshold for displaying low or high battery charge warning indicator.
    Default high threshold is "95" percent (default color purple), low threshold is "10" percent (default color red).
  - Changed default background color to blue (old color was black) for normal battery charge level for Battery Widget. Existing setting won't be affected.

* Track map Widget
  - [New]Add "show_lap_difference_outline" option (requested by user "Woodee"), which shows outline color based on lap difference (ahead or behind) between player and opponents. This option is disabled by default.
    Note, both outline color and width can be customized.

* Misc
  - Fixed a rare issue where module data would not update after restarted module.
  - Fixed an issue where virtual energy usage from "Lap time history Widget" sometimes fails to load due to desync.
  - Various optimization.

2.32.1 (2025-07-26)
-----------------------------
* Relative, Rivals, Standings Widget
  - [New]Add "show_energy_remaining" option (frequently requested by community), which shows remaining virtual energy reading in percentage from each driver, with 4 different states:
    - Unavailable: virtual energy reading is not available currently, default color grey.
    - High: above 30% remaining, default color green.
    - low: from 30% to 10% remaining, default color orange.
    - critical: 10% or lower remaining, default color red.
  - Known limitation with remaining virtual energy readings:
    Currently, remaining virtual energy data from LMU's Rest API is updated only when driver completes a lap, which means the data from API will not change during a lap, but only at the moment a lap is done by a driver. And due to this, the data will not tell how much energy was refilled in pit until the driver finished his pit out lap. This makes the data less useful by itself.
    To workaround this API data limitation, a special interpolation algorithm is implemented, which enables accurate estimates to remaining energy progressively during a lap for each driver. The average accuracy of estimation is within 1% (as from the extensive testing results during the past few weeks).
    Some cases where interpolation may not be applied:
    - Interpolation may require at least 1 full lap (not counting pit out lap) done before it can take effect.
    - During pit stop, refilled energy reading may not be updated until driver finishes his pit out lap (as mentioned earlier), which means old energy reading persists during pit out lap and would result wrong estimates with interpolation. For this reason, interpolation is disabled during pit out lap.
    In either case, just wait another lap and energy readings will be synchronized.

* RestAPI Module
  - [New]Now reads "remaining energy" data from LMU Rest API. This data is processed and used for Relative, Rivals, Standings Widgets.
  - Add "enable_energy_remaining" option, which enables access to "remaining energy" data from LMU Rest API.

* Vehicle Brand Editor
  - Add "Primary" and "Alternative" sources for importing vehicle brand data from LMU Rest API. The "Primary" source now allows to import brands from both original and custom vehicle skins, just select "LMU Rest API (Primary)" from "import from" menu to import them. The "Alternative" source (normally not required) is provided in case if some brands are missing from "Primary" source.
    Note, auto-importing function is not provided currently for stability and performance concerns, as importing is very expensive operation that involves large data set processing.

2.32.0 (2025-07-23)
-----------------------------
* [New]Widget Snapping
  - Add widget snapping and alignment (implemented by @nikidigi), which allows to snap and align widget to other widgets or screen edges. Snapping is activated by holding down "Ctrl" key while moving widget.
  - Add "snap_distance" and "snap_gap" options in global user config, which can be accessed from "Config > Application" in main menu.
  - Add Right-Click "context menu" for each overlay widget, which enables additional options:
    Center horizontally: align widget to the center of active screen horizontally.
    Center vertically: align widget to the center of active screen vertically.

* Lap time history Widget
  - Now loads and shows lap history data from corresponding "Consumption History" file.

* Standings Widget
  - Renamed "show_time_gap_from_class_best" option to "show_time_gap_from_same_class", which now also shows time gap behind the same class leader in race session (requested by user "ssalamon"). This option is enabled by default, and only takes effect while "enable_multi_class_split_mode" is enabled.
  - Fixed a calculation error with time interval between each driver.

* RestAPI Module
  - Add individual hard-coded "minimum update interval" for each different url resources, where some resources are accessed less frequently than others for conserving resource.
  - Fixed an issue where accessing extremely large dataset may fail sometimes.

* Stats Module
  - Fixed an issue that would cause incorrect best lap time saved due to network desync.

* Misc
  - Updated README with pyside2 (qtmultimedia) dependency info for Linux (by @berarma).
  - Add new contributor "nikidigi" to contributors.md.
  - Various optimization.

2.31.0 (2025-07-08)
-----------------------------
* Fuel Calculator
  - [New]Add "Tyre" column to history table, which lists "average tyre tread wear" data that can be used for tyre wear calculation.
  - [New]Add tyre tread wear and lifespan calculation in laps, minutes, stints, which helps to plan tyre usage for multi-stint race. See "Fuel Calculator" section in User Guide for details.
  - [New]Add "Max stint laps" & "Max stint minutes" calculation, which shows maximum laps and minutes can run per stint based on "Tank capacity" value (or 100% capacity for virtual energy).

* Consumption History
  - [New]Add "average tyre tread wear" logging via Fuel Module, which is used in Fuel Calculator.

* Wheels Module
  - Brake and tyre wear calculation is now handled by Wheels Module.
  - [New]Add delta wear calculation for accurately estimating tyre wear difference per lap.
  - [New]Add "minimum_delta_distance" option for delta wear data recording.

* Tyre Wear Widget
  - [New]Add "show_end_stint_remaining" option, which shows estimated total remaining tyre tread at the end of current stint. This option helps to determine whether there is enough tread for current or more stints. Negative reading indicates that there will not be enough tyre tread remaining at the end of current stint.
  - "show_wear_difference" option now shows estimated tyre wear difference per lap (at least one valid lap is required).
  - Removed "show_live_wear_difference", "freeze_duration" options. 

* Brake Wear Widget
  - "show_wear_difference" option now shows estimated brake wear difference per lap (at least one valid lap is required).
  - Removed "show_live_wear_difference", "freeze_duration" options. 

* Fuel, Virtual Energy Widget
  - [New]Add "show_low_fuel_warning_flash" and "show_low_energy_warning_flash" options (requested by users "ebeninca"), which show warning flash effect while on low fuel or low virtual energy. This option is enabled by default.
    This warning flash effect plays only a limited number of times, with highlight duration and interval that can be customized via "number_of_warning_flashes, warning_flash_highlight_duration, warning_flash_interval" options.
    Default number of flashes is 10 times, with a highlight duration of 0.4s, and a cooldown interval of 0.4s in-between.

* Misc
  - Reload module and widget automatically after saving or applying changes in editor.
  - "enable_high_dpi_scaling" option is now enabled by default for new user.
  - Fixed global locale setting for correctly displaying digits and decimal separator in certain system that uses special characters.
  - Auto load preset function now checks load-state only once when player enters track.
  - Various optimization.

2.30.1 (2025-06-12)
-----------------------------
* Major change to API accessing
  - Updated URL addresses for accessing data from LMU's Rest API (due to changes from June update), including new penalty time data that used for accurate pit time estimate.
  - Virtual energy, brake wear, vehicle damage, pit stop related data are now read from "RepairAndRefuel" URL address (same as in v2.28.1).
    Important note:
    "RepairAndRefuel" URL address previously was known to have chance to cause MFD pitstop menu flickering issue if accessed at high frequency. This flickering issue has been acknowledged by game developer, but not yet fixed by game.
    "RepairAndRefuel" is the only address for accessing those important data from LMU Rest API (as of LMU June update), currently there is no other alternatives.
    This "flickering issue" should not be a concern for user using only TinyPedal, as the default "update interval" in RestAPI Module is set on 100ms.
    For user concerned or experienced with this issue, you can either increase the value of "update interval" in RestAPI Module (such as "500" or "1000"); or, disable "RestAPI Module" entirely (which then those crucial data will not be available).
    Also note:
    There are currently other third-party APPs or Plugins that also have access to this "RepairAndRefuel" URL address, and running them at the same may have higher chance to trigger MFD "flickering issue".
  - Removed "enable_pit_strategy_access" option from RestAPI Module, this option no longer works due to game API changes.
  - Various improvements and optimization to game API accessing.

2.30.0 (2025-06-04)
-----------------------------
* Major change
  - New "Preset Transfer" dialog is now available by clicking "Transfer" button from "Preset" tab in main window (requested by user "Wigg1es"),
    which allows to quickly transfer selected settings and options from currently loaded preset to another preset.
    This new addition can make life much easier for users with a lot presets and options to manage and keep them updated with latest changes.
    See "Preset Transfer" section in User Guide for usage and example.

* Wheels Module
  - Optimized average wheel radius data sampling and calculation.

* Weather Widget
  - Add "decimal_places_temperature" option for customizing number of decimal places for displaying track and air temperature (requested by user "Dean688"). Default is "1" decimal place, set to "0" to hide decimals.
    Note, when number of digits is less than expected, extra leading zero or decimal place will be added to fill the gap.

2.29.2 (2025-05-29)
-----------------------------
* RestAPI Module
  - Fixed an issue where some telemetry readings would stop updating if game was paused and resumed recently.

2.29.1 (2025-05-25) hot fix
-----------------------------
* RestAPI Module
  - Fixed a game-crash issue that related to some bugged "Rest API" URI resource addresses. Thanks to user "npastore28" for reporting the issue.
    Note, this game-crash issue is due to a known issue in LMU's "Rest API", where some of the URI resource addresses (such as "garage/Pitstop/getPitstopTimes") are buggy and can crash game if accessed them under certain conditions.
    This hot fix removed access to those bugged URI resource addresses.

2.29.0 (2025-05-24)
-----------------------------
* Major change
  - Optimized "Rest API" accessing methods, which adds additional update time delay that reduces unnecessary data accessing if API data has not changed recently.
    For example, data from Rest API is accessed every 0.1 seconds on default setting, but if API data has not changed recently, the update interval will be increased up to every 2 seconds instead (for example, "pit strategy" data is only changed when user changes it in MFD menu).
  - Separated "pit strategy" data accessing from other none-pit data (fuel, energy, damage, etc), and can be turned off completely via the new "enable_pit_strategy_access" option in RestAPI Module.
    Note, recently there has been reports regarding an issue related to MFD "Pitstop" menu flickering in "LMU", which can be caused by accessing "pit strategy" data frequently. This flickering issue should not be a concern now for TinyPedal with the new accessing methods mentioned above.
    Additionally, a new "enable_pit_strategy_access" option is provided in RestAPI Module, which allows disabling "pit strategy" data accessing completely and avoids the flickering issue.
    However note, flickering issue can still be triggered by other programs or plugins that have frequently accessed to those "pit strategy" data.

* RestAPI Module
  - Apply additional time delay to update interval when data has not changed recently, up to 2 seconds max update interval. Update interval will be reset if data has updated recently. This change helps avoid unnecessary frequent data accessing.
  - Add "enable_pit_strategy_access" option, which allows turning off "pit strategy" data accessing completely. Note, "Pit stop estimate Widget" will not be able to display pit data if this option is turned off.

* [New]Suspension force Widget
  - Show visualized suspension force (Newtons) and ratio (percent).

* Suspension position Widget
  - Add "show_third_spring_position_mark" option, which shows front and rear third spring position mark relative to each suspension position.

* Track map Widget
  - Add "display_orientation" option (requested by user "peterkasbergen" and "lucamilan87"), which sets track map display orientation in degrees.
    For example, a "270" value will rotate map by "270" degrees clockwise. Default value is "0", which always displays track map "north up" in game's coordinate system.
  - Improved "display_detail_level" calculation to work with smaller maps.

* Pit stop estimate Widget
  - Add "stop_go_penalty_time" option, which sets stop go penalty time in seconds. Default value is "10" seconds.

* Misc
  - Add "horizontal_gap", "vertical_gap" options for following widgets: Brake pressure, Ride height, Slip ratio, Suspension force, Suspension position, Tyre load.
  - Fixed an issue that would add time increment on pitout prediction (Track map Widget) while outside pit lane.
  - Renamed "display_orientation" option to "show_inverted_orientation" in Friction circle Widget.

2.28.1 (2025-05-08)
-----------------------------
* Gear Widget
  - Add "show_rpm_reading" option (requested by users "ebeninca" and "EmperorOfFinland"), which shows RPM charge reading on RPM bar. This option is disabled by default.
  - Add "show_battery_reading" option, which shows battery charge reading (percentage) on battery bar. This option is disabled by default.
  - Add "decimal_places, font_size, font_weight, font_color, offset_x, text_alignment" options for customizing RPM and battery charge readings.

* Track map Widget
  - Add "show_pitout_prediction_while_requested_pitstop" option (requested by user "geims12"), which shows pit out on-track position indication while player has requested pitstop and not in pit lane. This option is enabled by default.

* Misc
  - Fixed an issue that would prevent Track Info Editor from opening while "API state override" is activated.

2.28.0 (2025-05-05)
-----------------------------
* Major change
  - New "Pit stop estimate Widget" and pit stop timing calculation for accurately estimating pit stop duration, designed specifically for "LMU".
  - New "Track Info" preset and "Track Info Editor" for customizing track info, which is currently used for various pit stop related calculation.

* [New]Pit stop estimate Widget
  - Show estimated pit-lane pass through (drive-through) time, calculated from pit-entry to pit-exit line. Average accuracy is within 0.5 seconds.
  - Show estimated pit stop time while making a service stop or serving a penalty, calculated according to each setting from MFD "Pitstop" page and underlying service timing and concurrency differences. Average accuracy is within 1 seconds.
  - Show maximum total random delay which game may add on top of pit stop time. For example, if estimated pit stop time is 12.0s, and maximum delay is +3.0s, then final pit stop time will be between 12.0s and 15.0s.
  - Show estimated minimum total pit time, which is the sum of "pit-lane pass through", "pit stop time", and optional customizable "additional time spent in pit".
  - Show estimated maximum total pit time, which is the sum of "minimum total pit time" and "maximum total random delay".
  - Show pit timer, useful for comparing against other pit time readings.
  - Show actual relative refilling, as the total additional fuel or virtual energy that will be added in next pit stop.
  - Show total relative refilling, as the total additional fuel or virtual energy that is required to finish the race.
  - See User Guide "Pit stop estimate" section for details.

* [New]Track Info Editor
  - Add "Track Info Editor" to "Tools" menu for customizing track info. See User Guide "Track Info Editor" section for details.

* [New]Tracks Preset
  - Add new "tracks.json" preset file in "settings" folder, which is used for storing track info. Track info is automatically recorded by Mapping Module.
  - "tracks" file name is now reserved for "tracks.json" preset.

* Mapping Module
  - Now records pit-entry position, pit-exit position, pit speed limit data, and saves in "tracks.json" preset.
    Note, for any new tracks, at least one pit-lane pass through is required to record data for pass through time calculation.

* RestAPI Module
  - Now processes user pit stop setting data from LMU Rest API for pit stop timing calculation.

* Track map Widget
  - Now reads pit-exit position data from Mapping Module for calculating pit-out prediction.

* Misc
  - Updated User Guide info for Tracks Preset, Track Info Editor, Pit stop estimate Widget.
  - Removed obsolete setting "meters_driven" from Cruise Widget.

2.27.1 (2025-04-28) hot fix
-----------------------------
* Preset
  - Fixed an issue that would prevent user from creating "new preset" via Preset tab.

2.27.0 (2025-04-28)
-----------------------------
* Window dialog & DPI scaling
  - Add "window_color_theme" option in global user config, which sets color theme for main window and dialog. Default theme is "Dark". This option does not affect overlay widget.
    Color theme can be quickly toggled via "UI" button on main window status bar.
  - Add "enable_high_dpi_scaling" option in global user config, which enables window dialog and overlay widget auto-scaling under high DPI screen resolution. This option is disabled by default.
    High DPI scaling mode can be quickly toggled via "Scale" button on main window status bar.
    On Windows, scaling is determined by percentage value set in "Display" > "Scale and Layout" in windows setting.
    For example, "200%" scale in windows setting will double the size of main window dialog and also every widget.
    On Linux, DPI scaling may already be forced "ON" in some system, which this option may not have effect.
  - Fixed broken main window dialog view under high DPI screen resolution. Main window dialog font & elements now scale relatively with system DPI scaling setting.
    Note, while TinyPedal is running, changing screen DPI scaling may still break main window dialog view, and requires restarting TinyPedal to scale correctly according to new DPI scaling setting.
    Alternatively, enable the new "enable_high_dpi_scaling" option to allow auto-scaling window dialog while TinyPedal is running.

* Linux
  - Add "enable_x11_platform_plugin_override" option in "Compatibility", which sets Qt platform plugin type to "X11" via environment variable on Linux. (thanks to @berarma & @SynthetikzZ for Linux assistance)
    This option may help work around some issues with overlay dragging and position on "Wayland". This option requires restarting TinyPedal to take effect. This option is enabled by default on Linux.
  - Fixed missing end slash "/" from global config path that saved global config files in wrong folder.
    For existing Linux user, manual correction is required.
    In "home/username/.config/" folder, find following files and rename:
    "TinyPedalconfig.json" to "config.json"
    "TinyPedalconfig.lock" to "config.lock"
    "TinyPedaldriver.stats" to "driver.stats"
    "TinyPedalpid.log" to "pid.log"
    Then move those files back to "home/username/.config/TinyPedal/" folder.

* Cruise Widget
  - Now reads "scaled track clock time" ("LMU" only) from Rest API if available, which allows synchronizing track clock time and time scale in both singleplayer and multiplayer in "LMU".
  - Add "show_time_scale" option, which shows current session track clock time scale multiplier.

* Misc
  - Add "Restart TinyPedal" to "Window" menu for quickly restarting the APP.
  - Heatmap Editor now shows temperature entries in table view, and supports multi-selection for offsetting and removing temperature, and up to one decimal place is kept.
  - Show "Preset Locked" notification on main window if currently loaded preset is locked.
  - Add new command line arguments "-p, --pyside" for choosing PySide (Qt for Python) module version.
    Currently, this option is only available while "running from source", and mainly for testing purpose or used on platform where PySide2 is no longer available.
  - Fixed a visual problem where fuel level bar indicator does not update remaining level if fuel delta data was not yet recorded for current track.
  - Added new contributor "SynthetikzZ" to contributors.md.

2.26.0 (2025-04-02)
-----------------------------
* Radar Widget
  - Add "show_overlap_indicator_in_cone_style" option (optional), which shows overlap indicator in "cone style" instead of "boundary style".
  - Add "overlap_cone_angle" option, which sets cone display angle in degrees. This option does not affect overlap detection range.
  - Renamed "overlap_detection_range_multiplier" option to "overlap_nearby_range_multiplier", which sets nearby vehicle overlap detection range multiplier.
    A value of "5" would result a 5-vehicle-wide detection range. Default is "5" vehicle-wide.
  - Add "overlap_critical_range_multiplier" option, which sets nearby vehicle critical overlap detection range multiplier. Default is "1" vehicle-wide.
  - Add "show_angle_mark" and angle mark style options, which show angle mark (fixed 45 degrees) on radar background.
  - Fixed radar circle background that was incorrectly displayed on top of overlap indicators.

* Relative, Rivals, Standings Widget
  - Add "show_delta_laptime" option for Rivals & Standings Widget (requested by user "oljemace"), which shows lap time difference (delta) between player and opponents from most recent laps.
    A green color (default) delta indicates that player's recent lap time is faster than opponent, while orange color delta indicates the opposite.
    Number of delta lap time display can be set with "number_of_delta_laptime" option, minimum number is limited to 2, maximum is limited to 5.
    The default layout order shows delta lap time records from right side column (most recent lap) to left. Enable "show_inverted_delta_laptime_layout" option to invert the layout.
  - Add "show_position_change" option (requested by user "bongio94"), which shows overall driver position change relative to overall qualification position.
  - Add "show_position_change_in_class" option, which shows driver position change in class instead of overall. This option is enabled by default.
  - Add "time_gap_align_center" option for Relative Widget.
  - Add "time_interval_align_center" option for Rivals Widget.

* User Preset
  - Add "Lock Preset" and "Unlock Preset" toggle to "right-click" menu in "Preset" tab, which allows locking or unlocking user preset file.
    Any changes made to locked preset will still take effect, but will not be saved to file. APP "version" tag will be attached to the preset that is locked with.
    This feature can be useful for keeping preset unchanged while testing new updates or features.
    Note, this "lock" feature only prevents any changes that made through this APP from saving to locked preset file.
    It does not prevent user from modifying or deleting locked preset file by other means.
  - Add "file lock" config file (config.lock) that saves in "global user configuration" folder, which keeps a list of locked file names.

* Misc
  - Fixed an issue where changes from "Units" and "Global Font Override" dialogs would not take effect after clicked "Apply" more than once.
  - Fixed a rare glitch where widget could be dragged around while "Lock Overlay" is enabled.
  - Various optimization to widgets, modules and save system.
  - Added new contributor "Andres (Corti)" to contributors.md.

2.25.1 (2025-03-18)
-----------------------------
* Important Fix
  - Fixed an issue where all driver stats could be completely reset if driver.stats file could not be accessed while saving.
    Stats file saving now uses "maximum_saving_attempts" value in "Application" setting for saving retries, and backup accordingly.
  - Fixed a rare case where extremely small fuel tank capacity would break fuel calculation,
    such as 1 liter or less tank capacity found on some unusual vehicle mods in "RF2".

* Fuel Module
  - Now supports and auto-detects "battery charge usage" as a primary consumption type with charge regeneration taken into
    calculation for non-hybrid pure electric vehicles such as "FE Gen3" that is based on "RF2" new electric motor system.
    Note, some electric vehicles in "RF2" are based on older electric system and not utilizing the new battery charge
    and electric motor system, such as "FE Gen1" & "FE Gen2".

* Hybrid Module
  - Add estimated battery charge net change (gain or loss) per lap and delta calculation.
  - Add "minimum_delta_distance" option, which sets minimum recording distance (in meters) between each delta sample.
  - Add alternative electric motor state checker for electric vehicle that doesn't have motor state available.
    Battery usage and state info can now be correctly displayed in "Battery, Gear, P2P" Widget for electric vehicles
    that are based on "RF2" new electric motor system but don't have motor state available.

* Battery Widget
  - Add "show_estimated_net_change" option, which shows estimated battery charge net change from current lap.
    Positive value indicates net gain (regen higher than drain); negative indicates net loss (drain higher than regen).
    Total net change reading is more accurate for vehicles that constantly consume battery charge, such as "FE" or "Hypercar" class.
    It is less useful for vehicles that only utilize electric motor for a short duration, such as "P2P".
    Note, at least one full lap (excludes pit-out or first lap) is required to generate estimated net change data.

* Brake temperature, Tyre carcass, Tyre inner layer, Tyre temperature Widget
  - Show unavailable sign as "-" if temperature drops below -100 degrees Celsius.

* Fuel Widget
  - Show "battery usage" (in percentage) data instead of fuel usage for non-hybrid pure electric vehicles.
    Note, since multiple different electric systems exist in "RF2", there is no reliable way to distinguish pure
    electric vehicles from fuel or hybrid vehicles, it is important to make sure "fuel_unit" option in "Units" setting
    is set to "Liter" in order to correctly display battery charge usage in "percentage" for pure electric vehicles.
  - Fixed an issue where "starting fuel level" indicator would sometimes incorrectly reset its position.

* Misc
  - Various small code optimization, further reduced memory usage.
  - Renamed "Units and symbols" to "Units" in config dialog and user guide.
  - Improved user guide navigation.

2.25.0 (2025-03-09)
-----------------------------
* General
  - Show "state overriding" notification on API status bar while "enable_active_state_override" option is enabled.
  - Show "Pace Notes Playback Enabled" notification on main window while pace notes playback is enabled.
  - Replaced all "Set" buttons in "Pace Notes Playback" tab with a single "Apply" button for applying changes.
  - Fixed an error in "Spectate Mode" if player index is set lower than "-1" in "Shared Memory API" config.
  - Removed unnecessary "wheel radius info" options from Wheels Module.
  - Optimized copy access mode with Shared Memory API.

* Overlay
  - Add "VR Compatibility" toggle to Overlay & tray menu (implemented by TiberiuC39), which enables widget visibility
    as windows on taskbar in order to be used in VR via APPs such as "OpenKneeboard". Non-VR user should not enable this option.

* [New]Driver Stats (user data)
  - Add new "driver stats" user data file (driver.stats) that saves in "global user configuration" folder.

* [New]Driver Stats Viewer
  - Add "Driver stats viewer" to "Tools" menu in main window for viewing "Driver stats".
    Note, the viewer only allows limited reset or removal, stat value cannot be edited by design.
    Any changes will take immediate effect after confirmation, changes cannot be undone.
    See "Driver stats viewer" section in User Guide for complete usage.

* [New]Stats Module
  - Add "Stats Module" for recording driver stats data. Note, driver stats will not be recorded while spectate mode is enabled.
    See "Stats module" section in User Guide for configuration details.
  - Now outputs "meters driven" data for odometer display in Cruise Widget.

* [New]Consumption History (user data)
  - Add new consumption history user data file (.consumption extension) that saves in "deltabest" folder (default),
    which stores lap time and fuel consumption data per "track and vehicle class", and can be loaded in Fuel Calculator.
    Up to 100 most recent lap entries are saved per "track and vehicle class". Data recording is handled by "Fuel Module".
  - Add "Consumption History" to "Reset Data" menu.

* Fuel Calculator
  - Add "Load Live" button, which loads or updates data from live session to history table.
  - Add "Load File" button, which loads data from consumption history file to history table.
  - Show loaded data source and track and class name on status bar.
  - Add "Tank" column, which shows fuel tank capacity for specific vehicle of the same class
    and can be selected and added to calculation panel.

* [New]Brakes Preset
  - Add new "brakes.json" preset file in "settings" folder, which is used for customizing
    brake failure thickness ("LMU" only) and heatmap style that matches specific vehicle class.
  - Add default brake failure thickness and heatmap style for all vehicle classes currently found in "LMU".
  - Automatically adds missing brake styles found from all running vehicle class to "brakes.json".
  - "brakes" file name is now reserved for "brakes.json" preset.

* [New]Brake Editor
  - Add "Brake Editor" to "Tools" menu in main window, which allows customizing "brakes.json" preset.
    See User Guide "Brake Editor" section for complete usage.

* Brake temperature Widget
  - Add "enable_heatmap_auto_matching" option, which enables automatically heatmap style matching
    for specific brakes defined in "brakes.json" preset.
    This option applies matching heatmap style to front and rear brakes separately.
    While this option is enabled, "heatmap_name" option has no effect. This option is enabled by default.

* Brake wear Widget
  - Now loads brake "failure thickness" values from "brakes.json" preset for brake wear calculation.
  - Removed old "front_brake_failure_thickness" and "rear_brake_failure_thickness" options.

* Deltabest, Deltabest extended Widget
  - Add "decimal_places" option (requested by Oblit0r). Default is "3" decimal places. Minimum is limited to "1".

* Trailing Widget
  - Add "show_absolute_ffb" option, which converts force feedback value to absolute value before plotting.
    Disable this option to show force feedback plot in both positive and negative range.

* Misc
  - Moved all tools and editors guide into "Tools" section in User Guide. Added internal links for quick accessing related info.
  - Added new contributor "TiberiuC39" to contributors.md.
  - Added "rFactor 2 Community" to "Special Thanks" list in contributors.md.

2.24.0 (2025-02-06)
-----------------------------
* General
  - Add log info for showing various style presets loading status.
  - Unified preset backup file name format.
  - Add preset file validation for "classes.json" and "compounds.json".
  - Removed "tyre_compound_symbol" option from "units" config.

* [New]Compounds Preset
  - Add new "compounds.json" preset file in "settings" folder, which is used for displaying custom
    tyre compound symbol and heatmap style that matches specific tyre compounds.
  - Add default tyre compound styles for all tyres currently found in "LMU".
  - Add default tyre compound styles for some popular vehicles found in "RF2".
  - Add tyre compounds auto-detection system, which automatically adds missing tyre compounds found
    from all running vehicles to "compounds.json" and assigns closest matched compound symbols.
    A "?" symbol will be displayed if a compound name is not commonly known.
  - "compounds" file name is now reserved for "compounds.json" preset.

* [New]Tyre Compound Editor
  - Add "Tyre Compound Editor" to "Tools" menu in main window, which allows customizing "compounds.json" preset.
    See User Guide "Compounds preset" section for complete usage.

* Classes Preset
  - Extended classes preset structure to support more customization in future.
    The new structure now saves alternative "class name" under "alias" key, and "class color" under "color" key.
  - Old "classes.json" file will be auto-updated to this newer structure,
    and a "classes.json.old" backup file will be created in "settings" folder.

* Vehicle Class Editor
  - Now shows customizable classes styles in table view, including "Class name", "Alias name", "Color" columns.
  - Now supports multi-selection for deleting multiple classes.
  - Now supports classes sorting.

* Delta, Energy, Fuel Module
  - Add "minimum_delta_distance" option, which sets minimum recording distance (in meters) between each delta sample.
    Lower value may result more samples recorded and bigger file size; higher value may result less samples recorded and inaccuracy.
    Default value is "5" meters. Recommended value range in "5" to "10" meters.
  - Improved calculation and significantly reduced data fluctuation.

* Relative, Rivals, Standings Widget
  - Now shows tyre compound symbols (front and rear) that matches specific tyre compounds defined in "compounds.json" preset.

* Tyre carcass, Tyre inner layer, Tyre temperature Widget
  - Add "enable_heatmap_auto_matching" option, which enables automatically heatmap style matching
    for specific tyre compounds defined in "compounds.json" preset.
    This option applies matching heatmap style to front and rear tyre compounds separately.
    While this option is enabled, "heatmap_name" option has no effect. This option is enabled by default.
    Note, separate compounds info for tyres on the same axle is not available from game API,
    which currently it is not possible to show left and right compounds separately.
  - Now shows tyre compound symbols (front and rear) that matches specific tyre compounds defined in "compounds.json" preset.

* Misc
  - Updated User Guide info for related changes above.

2.23.0 (2025-01-15)
-----------------------------
* General
  - Add "Remember Size" option in main window Config menu, which remembers last window size.
    This option is enabled by default.
  - Apply laptime pace margin after laptime pace calculation instead of before.

* Relative Widget
  - Add "show_highlighted_nearest_time_gap" option (requested by Jonathan07),
    which highlights opponents within nearest time gap threshold.
  - Add "nearest_time_gap_threshold_*" options for customizing nearest time gap threshold (in seconds).
    Default is "1" second for front, and "2" seconds for behind.
  - Add "show_time_gap_sign" option, "-" indicates opponent's relative position is in front of player,
    "+" indicates the opposite. This option is disabled by default.
  - "show_lap_difference" option no longer applies to "time gap" column to avoid confusion with
    "show_highlighted_nearest_time_gap".

* Track map Widget
  - Add "show_pitout_prediction" option (requested by David levis & Marcelo Prestes),
    which shows estimated pit out on-track position indication for each pit stop duration.
    Note, pit out position prediction is based on "delta best" data which scaled with player's latest
    "lap time pace" for accurate real-time position prediction under various track conditions.
    Pit out prediction requires both valid "track map" and "delta best" data to display.
    At least "one valid lap" for any car and track combo is required to display pit out prediction.
    For accurate prediction, the location of "pit out line" must be found first.
    And since each track has different pit out line location,
    it is required to "pit out" at least "once per session" to mark the correct pit out line location.
    This can be easily done by driving out of pit lane.
  - Add "number_of_prediction" option that sets number of pit out prediction to display.
    Value range is limited in "1" to "20".
  - Add "pitstop_duration_minimum" option that sets pit stop duration (in seconds) of first prediction.
  - Add "pitstop_duration_increment" option that sets each pit stop duration (in seconds) increment
    after previous prediction. Default increment is "10" seconds.
    Note, each time when pit stop duration of the nearest prediction exceeded current pit stop timer,
    the prediction circle will be removed, and a new prediction circle will be appended
    with pit stop duration increment after the last prediction.
  - Add "pitout_time_offset" option that sets amount time offset (in seconds) for catching up with
    vehicle speed after pit out. Default is "3" seconds.
    Note, this value is important for accurate prediction, as initial vehicle speed is much slower after pit out,
    so extra time is needed for driver to catch up, and also affected by pit out line location.
    For most tracks, this extra time after pit out is roughly within "1" to "5" seconds,
  - Add "show_pitstop_duration" option that shows pit stop duration reading on top of each prediction circle.
  - Add "show_position_in_class" option, which shows position in class while "enable_multi_class_styling"
    is also enabled, otherwise this option has no effect.
    While "enable_multi_class_styling" is enabled, disable this option to show overall standings with
    multi-class color (requested by Lazaros Filippakos).

* Misc
  - Updated "Application", "Relative", "Track map" sections in User Guide.

2.22.0 (2024-12-26)
-----------------------------
* General
  - Auto corrects duplicated "column_index" values in widget options to avoid display overlapping.
  - Various code optimization.

* Brake bias Widget
  - Add "show_baseline_bias_delta" option, which shows delta between current and baseline brake bias.
    This can be useful for keeping track of brake bias changes easier during a long race.
    Baseline brake bias is automatically set (and reset) while vehicle is stationary in pit lane.

* Fuel Widget
  - Add "show_absolute_refueling" option (requested by barrett & francescodg), which shows absolute refueling value
    instead of relative refueling when enabled.
    Note, "+" or "-" sign is not displayed with absolute refueling.
    Differences between relative and absolute refueling:
    - Relative refueling value shows total amount "additional" fuel required to finish the remaining race length,
      which matches "relative refueling" mechanism (amount to add on top of remaining fuel in tank) in "RF2".
    - Absolute refueling value shows absolute total amount fuel required to finish the remaining race length,
      which matches "absolute refueling" mechanism (amount total fuel to fill tank up to) in "LMU".
    - Also see "estimated laps" display option in "Session Widget" that can be used for "absolute refueling".
  - Add "caption_text_absolute_refuel" option that shows absolute refueling caption text if
    "show_absolute_refueling" option is enabled. This helps distinguish difference from relative refueling.
    Default caption text is "abfuel".
  - Exchanged column positions of "end" and "pits" for consistency and readability.
    "pits" column is now in the same column as "early".

* Instrument Widget
  - Add "stalling_rpm_threshold" option, which sets RPM threshold for triggering engine stalling warning.
    Default is "100" RPM.
  - Renamed "warning_color_ignition" option to "warning_color_stalling".

* Pace notes, Track notes Widget
  - Fixed notes not showing up if game was paused and unpaused again while on track.

* Relative finish order Widget
  - Add "show_absolute_refilling" option.

* Relative, Rivals, Standings Widget
  - Add "number of penalties" display in "pit stop count" column.
    When a driver accumulates one or more penalties, this column will show the number of penalties
    in negative value with purple (default) background to distinguish from number of pit stops.

* Session Widget
  - Add "show_estimated_laps" option, which shows estimated total remaining laps (from current lap position
    towards finish line) based on total remaining session time and local player's lap time pace.
    This value can be used for adjusting absolute refueling. No value will be shown if session is not time-based.
    Note, this is the same value that used for calculating estimated refueling value in Fuel Module.
    As with estimation, there may be a margin of error of one lap, and may be affected
    by other variables such as those mentioned in "Relative finish order" widget.

* [New]Slip ratio Widget
  - Show visualized slip ratio of each tyre with customizable optimal and critical range and color indication.

* Track map Widget
  - Add "enable_multi_class_styling" option (requested by AndreT990 & Marcelo Prestes), which shows vehicles in
    multi-class color styles on map along with position-in-class standings.
    Multi-class color can be customized from Vehicle Class Editor.
    Random color will be shown if vehicle class is not defined in Vehicle Class Editor.
    Note, while multi-class styling is enabled, following color styles will not be displayed:
    "vehicle_color_player", "vehicle_color_leader", "vehicle_color_same_lap", "vehicle_color_laps_ahead", "vehicle_color_laps_behind".
  - Add "font_color_player", "vehicle_outline_player_color", "vehicle_outline_player_width" options for
    customizing player vehicle style.

* Virtual Energy Widget
  - Add "show_absolute_refilling", "caption_text_absolute_refill" options.
  - Exchanged column positions of "end" and "pits".

* Misc
  - Updated User Guide info for related changes above.

2.21.0 (2024-12-10)
-----------------------------
* General
  - More optimization to all widgets & modules for further improved efficiency and less resource usage.

* RestAPI Module
  - Updated steerlock function to retrieve steerlock value from new LMGT3 vehicles in LMU.

* Brake pressure, Ride height, Suspension position, Tyre load Widget
  - Add "show_caption", "font_scale_caption", "caption_text" options for displaying and customizing
    caption text (requested by coasting&cruising). This option is disabled by default.

* Relative Widget, Standings Widget
  - Add "show_highlighted_fastest_last_laptime" option (requested by Hany Alsabti), which highlights
    the fastest last lap time within the same class if available.
  - Improved consistency and accuracy of relative time interval (requested by Hany Alsabti).
  - Renamed "show_vehicle_in_garage_for_race" option to "show_vehicle_in_garage" in Relative Widget,
    which now affects all sessions. Default is "False", which hides vehicles in garage.
    Note, local player (user) is always displayed.

* Gear Widget
  - Add "show_inverted_battery" & "show_inverted_rpm" options that invert battery or rpm bar progression.

* [New]Steering wheel
  - Show virtual steering wheel with customizable steering wheel image.
  - Show steering rotation reference line, which can be useful to see if physical steering wheel is misaligned.
  - See User Guide for details.

* [New]Tyre inner layer Widget, Tyre temperature Widget
  - Separated inner layer temperature display from "Tyre temperature Widget" into the new
    "Tyre inner layer Widget" (requested by H4dro), which can now be configured completely separately.
    Tip: set color style differently to easier distinguish the two widgets.
  - Add "horizontal_gap", "vertical_gap" options for enhanced arrangement (requested by doublebidule).

* Misc
  - Updated User Guide info for related changes above.

2.20.1 (2024-11-24)
-----------------------------
* Pace Notes Playback
  - Default "playback" option is now set on "disabled" for new presets.
    User may click "Disabled Playback" button from "Pace Notes" tab to enable playback.
  - Adjusting playback volume now takes immediate effect.

* Pace notes Widget, Track notes Widget
  - Add "enable_comments_line_break" option (requested by DanRZ) for enabling multi-line comments display.
    Note, a note comment can be broken into multiple lines by adding "\n" to any part of
    the comment in Track Notes Editor.
  - Add "maximum_display_duration" option (requested by DanRZ), which sets maximum display duration (seconds)
    of each note. Set to "-1" to always display notes. Default is "-1".

* Notes Module
  - "Global offset" option from "Pace Notes" tab no longer affects "track notes".
  - Fixed position desync issue that would occasionally trigger previous note again.

2.20.0 (2024-11-17)
-----------------------------
* General
  - [New]Implemented track & pace notes system, which allows load & save track & pace notes files.
  - Add "pace_notes_path" & "track_notes_path" options to global user config file.
  - Add new ".TPPN" (TinyPedal Pace Notes) & ".TPTN" (TinyPedal Track Notes) file formats.
  - Add support for load & save GPL pace notes ".ini" file format.
    Special thanks to "Lee Bowden" (author of GPL pace notes system & file format) and "Jim Pearson"
    for providing technical assistance.
  - Add "multimedia_plugin_on_windows" option in Compatibility dialog, which sets multimedia plugin
    for playing sound file on windows.

* [New]Pace Notes Playback Tab
  - Add "Pace Notes Playback" control panel that can be accessed from "Pace Notes" tab in main window.
    This control panel provides pace notes sound playback control and configuration.
  - Click "Enabled Playback" or "Disabled Playback" button to quickly enable or disable pace notes playback.
    Note, "Notes Module" must be enabled to allow pace notes playback.
    Disabling this option does not affect "Notes Module" or "Pace notes Widget".
  - By default, pace notes file is automatically loaded from "pace_notes_path" if a file that
    matches current track name is found.
    Enable "Manually Select Pace Notes File" check box to disable auto-file-name matching,
    and manually select a pace notes file that can be played on any track.
    This option takes immediate effect when changed.
  - "Sound file path" sets path for loading pace notes sound files that matches value from
    "pace note" column found in pace notes file. If no sound file found, sound won't be played.
    This option takes immediate effect when changed.
  - "Sound format" sets sound format for loading sound file.
    This option only takes effect after clicked any "Set" button.
  - "Global offset" adds global position offset (in meters) to current vehicle position on track,
    which affects when next pace note line will be played.
    This option only takes effect after clicked any "Set" button.
  - "Max duration" sets maximum playback duration for each sound file, which can be used to limit
    sound file maximum playing duration. Default duration is 10 seconds.
    This option only takes effect after clicked any "Set" button.
  - "Max Queue" sets maximum number of sound files in playback queues. Default is 5 sound files.
    This option only takes effect after clicked any "Set" button.
  - "Playback volume" sets output volume for sound file.
    This option takes effect when next sound file is played.

* [New]Track Notes Editor
  - Add "Track Notes Editor" to "Tools" menu in main window for creating & editing track or pace notes.
    Note, by default the editor starts in "Pace Notes" edit mode as displayed in status bar.
    The editor consists of two panel views:
      - Left panel is the track map viewer, which can be used to visualize track map and providing
        analytic info for assisting notes creation. For detailed usage, see "Track Map Viewer" section.
      - Right panel is the notes editor, which allows create, open, save track or pace notes file.
  - For complete usage, see "Track Notes Editor" section in User Guide.

* [New]Track Map Viewer
  - Add "Track Map Viewer" to "Tools" menu in main window for viewing & analyzing track map.
    Note, only track map (SVG) files that generated from TinyPedal Mapping Module are supported.
    The Track Map Viewer consists of three main areas:
    * At top area, user can "Load Map", view map file name, and "Config" map display.
    * At center area, track map image and various analytic data are displayed.
    * At bottom area, user can set map "Zoom", position slider, map nodes selection.
    Other notable features:
    * Right-Click on map display area to open a context menu to quickly toggle various
      displays & analytic options on and off.
    * Use mouse wheel to quickly zoom in and out map display.
    * Analytic data are displayed at four corners of map display, which include:
      - Map length and total nodes.
      - Curve section length, grade, radius, angle, curvature.
      - Slope grade, percent, angle, height delta.
      - Current node position and global XYZ coordinates (Z is elevation).
  - Add "track_map_viewer" options to global user config file.
  - See "Track Map Viewer" section in User Guide for details.

* Heatmap editor, Vehicle brand editor, Vehicle class editor
  - Add "Offset" button for batch offsetting or scaling temperature values in Heatmap editor.
  - Add "Copy" button for duplicate heatmap preset in Heatmap editor.
  - Keep "Rename" dialog open after renaming for easy access in Vehicle brand editor.
  - Show close confirmation if changes were not saved.
  - Show deletion info and confirmation.

* [New]Notes Module
  - Add Notes Module for processing track & pace notes data, which is used by
    Pace Notes playback control panel, Pace notes Widget, Track notes Widget.
    Note, this module requires Delta Module enabled to function correctly.

* Wheels Module
  - Add cornering radius calculation.
  - Add "cornering_radius_sampling_interval" option, which sets position sampling interval
    for cornering radius calculation.
    Value range in "5" to "100". Default sampling interval is "10", which is roughly 200ms
    interval between each recorded position. Higher value may result inaccuracy.
    Note, this option does not affect position recording interval.

* Cruise Widget
  - Add "show_distance_into_lap" option which shows distance into current lap.
  - Add "show_cornering_radius" option which shows real-time cornering radius.

* [New]Pace notes Widget
  - Show nearest pace notes, comments, debugging info behind current vehicle position,
    mainly for pace notes creation and debugging purpose.
  - Auto hides itself if pace notes data is not available for current track.

* [New]Track notes Widget
  - Show nearest track notes, comments, debugging info behind current vehicle position,
    mainly for displaying corner name or section name.
  - Auto hides itself if track notes data is not available for current track.

* Misc
  - Updated contributors info, added new contributors:
    "Lee Bowden", "Jim Pearson", "Tanizo Yashima (yashiman)".

2.19.1 (2024-10-18)
-----------------------------
* Brake wear Widget
  - Separated "front_brake_failure_thickness, rear_brake_failure_thickness" options
    for front and rear brakes.
    Front brake failure thickness threshold can be different from rear brake.
  - Some reference brake failure thickness threshold:
    Hypercar and P2 classes in LMU usually have 25mm brake failure threshold.
    GTE class in LMU usually has 30mm brake failure threshold.

* Cruise Widget
  - Add "enable_track_clock_synchronization" option, which enables auto track clock
    and time scale synchronization. RestAPI module must be enabled to synchronize
    track clock from Rest API. This option is enabled by default.
    Disable this option to manually set and use "track_clock_time_scale" option for
    track clock display.

2.19.0 (2024-10-15)
-----------------------------
* RestAPI Module
  - Read "brake wear" data from LMU Rest API.

* [New]Brake wear Widget
  - Show brake wear data in percentage or millimeter thickness.
    Important note:
    Brake wear data is currently only available on LMU.
    RF2 currently doesn't provide brake wear data.
    Depends on vehicle, brake may or may not have noticeable wear.
    Additional note:
    Brake maximum thickness (for percentage wear calculation) is retrieved at the moment
    when car leaves garage or has brake repaired or changed.
    Reloading a preset or restarting APP in the middle of a running stint could result
    wrong maximum thickness and percentage wear calculation, which should be avoided.
    "Brake failure thickness" note:
    This option manually sets millimeter thickness threshold at brake failure, which
    affects brake thickness readings and overall brake wear calculation.
    For example, if brake thickness is 40mm, and brake failure thickness is 25mm,
    then effective thickness is 40 - 25 = 15mm.
    Note, brake failure thickness threshold data is not available from game API,
    it may require testing to find out, and may vary from vehicle to vehicle.
    Thickness threshold value should not exceed brake maximum thickness, otherwise
    brake wear readings will not be displayed correctly.
  - Show total brake wear difference of previous lap.
  - Show live brake wear difference of current lap that constantly updated.
  - Show estimated brake lifespan in laps.
  - Show estimated brake lifespan in minutes.
  - Customizable wear warning threshold.

* Misc
  - Updated User Guide info for Brake wear Widget.

2.18.3 (2024-10-08)
-----------------------------
* RestAPI Module
  - Read "body aero" and "suspension damage" data from LMU Rest API.

* [Reworked]Damage Widget
  - Add "show_last_impact_cone" option that shows cone indicator towards last known impact position.
    This option can be useful to determine whether there was a collision, even if car was not damaged.
    Cone indicator display duration can be customized by "last_impact_cone_duration" option.
    Default display duration for last known impact is 15 seconds.
    Cone angle (size) can be customized by "last_impact_cone_angle" option.
  - Add "show_aero_integrity_if_available" option that shows body aero integrity reading
    (only available for LMU) instead of bodywork integrity, which better reflects
    severity of bodywork damage that would affect performance.
  - Add suspension damage color indication (only available for LMU) for each wheel, which
    better reflects severity of suspension damage that would affect handling.
    There are now 6 damage levels for each wheel:
    1. No damage to suspension or wheel (default color: green).
    2. Light suspension damage (default damage range: 2% - 15%, default color: yellow).
    3. Medium suspension damage (default damage range: 15% - 40%, default color: orange).
    4. Heavy suspension damage (default damage range: 40% - 80%, default color: purple).
    5. Totaled suspension (default damage range: 80% - 100%, default color: blue).
    6. Wheel detached (default color: black).
  - Add "suspension_damage_*_threshold" options for customizing damage level range.
  - Add a new set of "suspension_color_damage_*" options.
  - Add "wheel_width, wheel_height" options for customizing wheel display size.
    Removed body parts horizontal size restriction.
    Size of body parts and wheels can now be customized freely.
  - Adjusted default "update_interval" value from "20" to "100", as frequent refreshing is
    unnecessary for this widget. Existing setting won't be affected.

* Misc
  - Updated User Guide info for Damage Widget.

2.18.2 (2024-10-06)
-----------------------------
* Relative, Rivals, Standings Widget
  - Fixed tyre compound info not correctly updated in some cases (issue reported by MarcoSaupe).

2.18.1 (2024-10-02)
-----------------------------
* General
  - Fixed a font weight verification error that prevents user from saving any changes
    in "Gear Widget" config dialog.
  - Fixed missing combo choices (text alignment, font weight options) from
    Elevation and Gear Widget config dialog.

* Differential Widget
  - Fixed cooldown timer did not reset after changed or restarted a session.

* DRS Widget
  - Add "drs_text" option for setting custom DRS display text.
  - Optimized DRS status check.

2.18.0 (2024-09-26)
-----------------------------
* General
  - Add global user config file as "config.json", which stores global user settings
    that are independent from user presets.
    For Windows, "config.json" is stored under "username\AppData\Roaming\TinyPedal" folder.
    For Linux, "config.json" is stored under "home/username/.config/TinyPedal" folder.
  - Log files are now stored in the same folder as global user config file.
  - All "Application" and "Compatibility" settings are moved into "config.json".
  - All Config dialogs now shows preset file name on title bar.
  - Color pick dialog now shows up to 16 previously picked colors in "Custom colors" selector.
  - Smaller panel size for "Fuel Calculator".
  - Most of widgets & modules code has been rewritten and optimized for improved efficiency
    and less CPU and memory usage.
    Note, currently both "Friction Circle" & "Navigation" Widgets are known to consume more
    CPU usage for drawing complex plot and animated map, especially with "Navigation" Widget
    and a lot of vehicles on track. If there is significant increase in APP 's CPU usage,
    try disable either widgets, which should help lower CPU usage to normal level.
    The new "System performance Widget" (see below) can be used to monitor performance change.

* [New]Application dialog
  - Add "Application" to main window "Config" menu for customizing global application settings
    and saved in global user config file.
  - "grid_move_size, minimum_update_interval, maximum_saving_attempts" options from
    "compatibility" are moved to "application".
  - Add "show_confirmation_for_batch_toggle" option, which shows confirmation dialog
    for enabling or disabling all widgets or modules. This option is enabled by default.

* [New]User path dialog
  - Add "User path" to main window "Config" menu for customizing global user path settings
    and saved in global user config file.
    To change user path, double-clicking on edit box to open "Select folder" dialog;
    or manually editing path text.
    Click "Apply" or "Save" to verify and apply new paths. Invalid path will not be applied.
  - For linux, all default user config-type paths are now set according to XDG specification,
    which is located under "home/username/.config" folder. (thanks to feedback from Bernat)
    Changes include:
    * Default "user preset" path is changed to "home/username/.config/TinyPedal/settings/",
      previously this was set in "home/username/.config/TinyPedal/".
    * Default "brandlogo" path is changed to "home/username/.config/TinyPedal/brandlogo/",
      previously this was set in "home/username/.local/share/TinyPedal/brandlogo/".
    Note, if you wish to keep using old paths on linux, you can use "User path dialog"
    to set paths to the old ones as mentioned above.
  - See User Guide "User path" section for additional info.

* [New]Auto load preset system
  - Add "Auto load preset" system (implemented by naturale0) to allow auto loading user-defined
    game-specific preset depends on active game (currently supports RF2 and LMU).
    Auto loading preset is triggered when a new or different game is started & active.
    Auto loading will only trigger once per game change.
    A preset must be tagged as "primary" for specific game before it can be auto loaded.
    This option is disabled by default.
  - Add "Auto load primary preset" check box in "Preset" tab, which enables or disables
    "Auto load preset" system.
  - Add "primary preset" tagging function in "Preset" tab, user can "Right" click on a preset
    and select "Set primary for ***" to tag a preset as "primary" for specific game.
    To clear all tags from selected preset, "Right" click and select "Clear primary tag".
    Primary preset will be auto loaded when "Auto load primary preset" is enabled and
    a new or different game is started & active.
    Note, a single preset can have tags from multiple games.

* Shared Memory API
  - Improved accessing efficiency, now uses fast-restart method for same API.
  - Significantly reduced opponents vehicle position desync issue when using "direct access" mode
    (as previously was noticeable on Radar Widget sometimes).

* Vehicle Brand Editor
  - Now allows multi-selection for deleting vehicle brand entries.
  - Fixed some vehicle info that could not be imported from LMU Rest API (issue reported by DanRZ).
    Make sure to use "import" again from Vehicle Brand Editor to update missing vehicle info from LMU.

* Wheels module
  - Add differential locking calculation and output for the new Differential Widget.
  - Add "minimum_axle_rotation" option, which sets minimum axle rotation (radians per second)
    for calculating wheel radius and differential locking percent.
    Default value is "4".
  - Add "maximum_rotation_difference_*" options, which set maximum rotation difference (percentage)
    between left or right wheel and same axle for limiting wheel radius calculation.
    Setting higher difference value may result inaccurate wheel radius reading.
    Default value is "0.002".

* Brake bias Widget
  - Add "layout" option, which sets display orientation.
    Default is horizontal. Set "0" to show vertically.

* Cruise Widget
  - Add "layout" option, which sets display orientation.
    Default is horizontal. Set "0" to show vertically.
  - Add "odometer_maximum_digits" option, which sets maximum number of display digits.

* [New]Differential Widget
  - Show minimum differential locking percent between left and right wheels on the same axle
    under power (on throttle) or coasting (off throttle).
    A "100%" reading indicates two wheels on the same axle are rotating at same speed;
    while "0%" indicates that one of the wheels is completely spinning or locked.
    Each reading will reset back to "100%" if minimum locking percent hasn't changed during
    cooldown period, as defined by "reset_cooldown" option.

* Instrument Widget
  - Changed default "layout" setting value to "1" for horizontal layout for consistency.
    User may need to edit old value "0" to "1" to display horizontal layout.
  - Wheel slip warning indicator now only shows under acceleration.

* [New]Laps and position Widget
  - Show your current lap number (lap progression) & max laps if available.
  - Show your current overall position against all drivers in a session.
  - Show your current position in class against all drivers from the same class.

* P2P Widget
  - Replaced old "font_color_inactive" and "bkg_color_inactive" color settings with new cooldown
    "font_color_battery_cooldown, bkg_color_battery_cooldown" for battery charge, and
    "font_color_activation_cooldown, bkg_color_activation_cooldown" for activation timer.

* Radar Widget
  - Add "enable_radar_fade" option (feature requested by Jernej Simoncic), which enables
    gradually fade in/out effect while opponent vehicles approach or leave radar range.
  - Add "radar_fade_out_radius" option, which sets radar fade out radius relative to radar radius.
    Value range in "0.5" to "1.0". Default value is "0.98".
  - Add "radar_fade_in_radius" option, which sets radar fade in radius relative to radar radius.
    Minimum value is limited to "0.1", maximum value cannot exceed "radar_fade_out_radius".
    Default value is "0.8".
  - Renamed options "show_fade_out, fade_in_radius, fade_out_radius" to
    "show_edge_fade_out, edge_fade_in_radius, edge_fade_out_radius" to
    distinguish from new radar fade options.

* Relative, Rivals, Standings Widget
  - "show_pit_status" option now also displays garage status (as "G" sign) for driver in garage.
  - Add "garage_status_text" option, which sets custom garage status text for driver in garage.

* Session Widget
  - Removed "lap number" and "driver position" readings. Those two readings are now included in
    the new "Laps and position Widget".
  - Add "layout" option, which sets display orientation.
    Default is horizontal. Set "0" to show vertically.

* Speedometer Widget
  - Changed default "layout" setting value to "1" for horizontal layout for consistency.

* [New]System performance Widget
  - Show system's overall CPU utilization (percent) and memory usage (GB).
  - Show TinyPedal's CPU utilization (percent) and memory usage (MB).

* Tyre carcass temperature Widget
  - Now calculates temperature rate of change at an average base interval of 0.1 seconds
    which is then scaled to "rate_of_change_interval" value for more responsive estimate.
  - Add "rate_of_change_smoothing_samples" option for smoothing data and filter out fluctuation.

* Tyre wear Widget
  - Now uses laptime pace for calculating "tyre lifespan in minutes".

* [Reworked]Weather Widget
  - Add weather trend indication, which shows whether there has been an increasing or
    decreasing trend for temperature, raininess, wetness readings for a given period.
    This can be useful to determine pit stop strategy.
  - Add "temperature_trend_interval", "raininess_trend_interval", "wetness_trend_interval"
    options, which set each trend interval in seconds. Default interval is "60" seconds.
  - Add "prefix_rain", "prefix_dry", "prefix_wet", "font_color_trend_constant",
    "font_color_trend_decreasing", "font_color_trend_increasing" options.
  - Improved display formatting for temperature, raininess, wetness readings.

* Weather forecast Widget
  - The "now" column always shows current weather condition even if RestAPI Module is disabled.

* Misc
  - Updated User Guide for all changes mentioned above and additional usage info.
  - Added new contributor "Sihyung Park (naturale0)" to contributors.md.

2.17.4 (2024-08-30)
-----------------------------
* General
  - Fixed state check error while restarting API in rare case.
  - Add clickable API button on main window status bar
    that opens "Shared Memory API" config dialog for easy access.

* Fuel calculator
  - Fixed an error when calculating with Gallon unit.

* Relative finish order Widget
  - Add "show_extra_refilling" option, which shows readings of extra refilling row
    below "local player's refilling" row. Each extra refilling value equals "extra laps
    of consumption" plus "local player's refilling" value of same column.
    Those values save the trouble from manual calculation in case there will be extra laps.
    The first column of extra refilling row shows number of extra laps depends on
    "number of extra laps" setting, such as "EX+1" for 1 extra lap, or "EX+3" for 3 extra laps.
  - Add "number_of_extra_laps" option, which sets number of extra laps for extra refilling calculation.
    Default is "1" extra lap.
  - Updated usage and examples for Relative finish order Widget in User Guide.

2.17.3 (2024-08-19)
-----------------------------
* General
  - Fixed a bug (introduced in v2.17.0) in API connector that would cause TinyPedal to stop work
    when user selected "LMU API" in Shared Memory API config dialog.
    Note, LMU API option is currently only a placeholder which uses the same underlying
    RF2 API and "rF2 Shared Memory Plugin" and works exactly same as RF2.
    Updated "User Guide" info regarding API selector.
  - Optimized overlay state check to avoid unnecessary function calls.

* Command line arguments
  - Add "-h, --help" argument, which shows all available command line arguments.
  - Add "-s, --single-instance" argument for toggling single instance mode,
    which allows multiple instances of TinyPedal to be running at same time
    by adding "-s 0" or "--single-instance 0" argument.
    Default is single instance only, which only one TinyPedal may be run at a time.
  - Single instance mode now works under Linux, or running from source script.
  - Add "Single instance mode" info to log output.
  - Add "pid.log" output file in log folder when "Single instance mode" is enabled.
  - See User Guide "Command line arguments" section for details.

* Misc
  - Added new contributor (ebeninca) to contributors.md.

2.17.2 (2024-08-08)
-----------------------------
* Brake bias Widget
  - [New]Add brake migration display, which shows real-time brake migration change,
    as commonly seen in LMH and LMDh classes.
    Note, brake migration is calculated based on brake input and brake pressure
    telemetry data, and is affected by pedal force setting from car setup and
    electric braking allocation of specific vehicle.
    To get accurate brake migration reading, it is necessary for brake pedal
    to reach fully pressed state for at least once while entering track to recalibrate
    brake pressure scaling for brake migration calculation.
    It is normally not required to do manually, as game's auto-hold brake assist is on by default.
    However if auto-hold brake assist is off, or the APP was reloaded while player was already on track,
    then it is required to do a full braking for at least once to get accurate brake migration reading.
  - Add "electric_braking_allocation" option for calculating brake migration
    under different electric braking allocation from specific vehicle.
    Note, vehicle that has not electric braking, or has disabled regeneration, is not affected by this option.
    Incorrect allocation value will result wrong brake migration reading from vehicle that has electric braking activated.
    Set value to "-1" to enable auto-detection, which automatically checks whether electric braking is activated
    on either axles while braking, and sets allocation accordingly.
    This is enabled by default. Note, it may take a few brakes to detect correct allocation.
    Set value to "0" to manual override and use front allocation,
    which is commonly seen in LMH class.
    Set value to "1" to manual override and use rear allocation,
    which is commonly seen in LMDh class.
  - Add "prefix_brake_migration" and "suffix_brake_migration" options for brake migration.
  - Add "column_index" and "decimal_places" options for both brake bias and brake migration.

* Misc
  - Updated User Guide for Brake bias Widget.

2.17.1 (2024-08-04)
-----------------------------
* Fuel energy saver Widget
  - Fixed "minimum_reserve" setting not taking effect.

* Navigation Widget
  - Reworked map path drawing methods which completely eliminated high memory usage issue with this widget.
    Map drawing now uses around 1MB memory for normal tracks,
    and at most 3 or 4MB memory for very large tracks, such as Isle of Man.
    There is also a slightly increase in map display quality.

2.17.0 (2024-08-02)
-----------------------------
* [New]Fuel energy saver Widget
  - Show current stint estimated total completable laps and completed laps
    based on current consumption.
  - Show estimated target lap consumption to save (extend) one or more total
    stint laps, with customizable number of target slots (10 for more, 5 for less).
  - Show delta consumption against target lap consumption, which allows
    fuel or energy saving to be visualized and easily controlled in real-time.
  - Show consumption type in "FUEL" or "NRG" (if virtual energy available).
  - Show last lap consumption.
  - For complete customizable options, usage examples, see User Guide "Fuel energy saver" section.

* Virtual energy Widget
  - Add "delta energy consumption" display (to be in line with Fuel Widget),
    which shows "delta consumption" against last lap energy consumption.
  - Add "fuel bias" display, which shows estimated laps difference between
    fuel and virtual energy.
    Positive value means more laps can be run on fuel than energy;
    in other words, energy is drained faster than fuel.
    General speaking, it is a good idea to keep bias close to 0.0 so that
    fuel and energy drains at same pace, and slightly towards positive side
    to avoid running out of fuel before energy does.
  - Set new default low energy warning color to purple instead of red, which helps
    distinguish from Fuel Widget.
    Existing setting won't be affected, use Config "reset" to set new default.

* Misc
  - Updated User Guide info for Fuel energy saver Widget, Virtual energy Widget.

2.16.0 (2024-07-29)
-----------------------------
* Delta Module
  - Add data smoothing function to filter out unusual data noise.
  - Add "delta_smoothing_samples" option, which sets number of samples
    for delta data smoothing calculation using exponential moving average (EMA) method.
    Value range in "1" to "100". Default is "30" samples. Set to "1" to disable smoothing.
    Higher value results more smoothness, but may lose accuracy.
  - Add average laptime pace calculation and output.
  - Add "laptime_pace_samples" option, which sets number of samples
    for average laptime pace calculation (EMA).
    Value range in "1" to "20". Default is "6" samples. Set to "1" to disable averaging.
    Note, initial laptime pace is always based on player's all time personal best laptime if available.
    If a new laptime is faster than current laptime pace, it will replace
    current laptime pace without calculating average.
    Invalid lap, pit-in/out laps are always excluded from laptime pace calculation.
  - Add "laptime_pace_margin" option, which sets additional margin for current laptime
    that cannot exceed the sum of "laptime pace" and "margin".
    This option is used to minimize the impact of unusually slow laptime.
    Default value is "5" seconds. Minimum value is limited to "0.1".

* Fuel Module
  - Now uses laptime pace value from Delta Module for real-time fuel calculation
    for increased consistency and accuracy.

* Vehicles Module
  - Fixed pit timer incorrectly reset after pit out.

* Flag Widget
  - "Pit Request" indicator now shows "pit-in laps countdown" alongside
    "estimated remaining laps" reading that current fuel or energy can run.
    Note, "pit-in laps countdown" value is always calculated towards
    the finish line of current stint's final lap, and thus is always
    less than or equal to "estimated remaining laps" reading.
    If countdown drops below 1.0 (laps), it indicates the final lap of current stint,
    and driver should pit in before the end of current lap to refuel.
    If countdown reaches zero or negative, there may still be some fuel or energy left in tank,
    however it will not be enough to complete another full lap.

* Friction circle Widget
  - Add "show_trace_fade_out" option, which enables trace fade out effect.
  - Add "trace_fade_out_step" option, which sets trace fade out speed.
    Value range in "0.1" to "0.9", higher value increases trace fade out speed.
    Default value is "0.2". This option is enabled by default.

* [New]Relative finish order Widget
  - New Relative finish order Widget that displays estimated relative finish order
    between leader and local player with corresponding refilling estimate.
    This widget auto-switches display mode ("TIME" or "LAPS") depends on current session type.
  - Show both predefined and customizable "leader's pit time" and "local player's pit time",
    as well as last pit stop time from leader and local player.
  - Show "leader's final lap progress" and "local player's final lap progress"
    that depend on current session type.
  - Show "relative lap difference" between leader and local player that is calculated from
    lap time pace difference of both players, which can be used to determine whether leader
    has the chance to overtake local player on final lap.
  - Show refilling type in "FUEL" or "NRG" (if virtual energy available).
  - Show estimated "local player's refilling" that depends on current session type.
  - For complete customizable options, usage examples, see User Guide "Relative finish order" section.

* Timing Widget
  - Add "show_average_pace" option, which shows personal current average laptime pace,
    this reading is also used in real-time fuel calculation.
    Note, additional "average laptime pace" calculation setting can be found in "Delta Module" config.
    After ESC or session ended, laptime pace reading will be reset,
    and aligned to "all time personal best laptime" if available.

* Weather forecast Widget
  - Add "number_of_forecasts" option, which sets number of forecasts to display.
    Value range in "1" to "4". Default is "4" forecasts.
  - Add "column_index_*" options for customizing data display order of each forecast.

* Misc
  - Updated User Guide info for Delta Module, Flag Widget, Friction circle Widget,
    Relative finish order Widget, Timing Widget, Weather forecast Widget.

2.15.1 (2024-07-13)
-----------------------------
* General
  - Reworked preset saving system to prevent preset file corruption in rare case.
    Saving system now creates temporary backup for old preset file before saving.
    If all saving attempts failed, saving will be aborted,
    and old preset file will be restored to avoid preset file corruption.
  - Add "maximum_saving_attempts" option in Compatibility dialog,
    which sets maximum retry attempts for preset saving.
    Default value is "10". Minimum value is limited to "3" maximum attempts.
    Note, each attempt has a roughly 50ms delay.

* Radar Widget
  - Fixed an issue where radar would not auto hide under certain condition.

* Sectors Widget
  - Fixed incorrect PB sector time display if "target time" is set on "Personal".

* Weather forecast Widget
  - Add "layout" option, which sets columns display order.
    "0" = show columns from left to right.
    "1" = show columns from right to left.

* Misc
  - Updated User Guide info for Compatibility, Sectors Module, Weather forecast Widget.

2.15.0 (2024-07-11)
-----------------------------
* General
  - Added new weather icon set (by S.Victor) in "images" folder.

* Fuel Calculator
  - Add Battery charge drain & regen (%) per lap to history log.
  - History table now supports multi-selection that adds data
    from any columns at once.

* RestAPI Module
  - Read "weather forecast" data from RF2 and LMU Rest API.
  - Improved and optimized accessing methods.
  - Updated session info accessing paths that work in
    both single-player and multi-player sessions.
  - Minimum "connection_timeout" value changed to "0.5".

* Sectors Module
  - Now records both "session best" and "all time best" sectors timing data
    and saved as ".sector" file under "deltabest" folder.
  - Add "enable_all_time_best_sectors" option,
    which calculates sectors timing based on all time best sectors
    and affects "Sectors Widget" display.
    This option is enabled by default.
    Set "false" to calculate sectors timing from current session only.
    Note, both session best and all time best sectors data
    are saved no matter the setting.
  - Add reset "Sector best" option to "Reset data" menu.

* Gear Widget
  - Add "rpm_bar_bkg_color" option, which sets RPM bar background color.
    Default color is full transparent.
  - Add "battery_bar_bkg_color" option, which sets RPM bar background color.
    Default color is semi-transparent.

* Pedal Widget
  - Add "show_readings" option, which shows pedal input
    and force feedback readings.
    Note, while "show_*_filtered" option is enabled, only the highest
    reading between filtered & raw input is displayed.
    Text position can be adjusted by "readings_offset" option,
    default value is 0.5, which sets position in the middle.

* [New]Weather forecast Widget
  - Show weather forecast info from RF2 or LMU, which includes:
    * Show weather icons corresponds to 11 in-game "sky types".
    * Show estimated time reading, ambient temperature reading,
      and visualized rain chance bar for upcoming weather.
    Note:
    Weather forecast currently only support in-game weather.
    The first column (with "now" label) always shows live weather condition & temperature.
    The first column always shows live rain severity instead of rain chance.
    Estimated time reading only works in time-based race.
  - Each forecast info (except weather icon) can be individually toggled on or off.
  - Auto hide unavailable weather data column.
    Note, auto hide only works for time-based race.

* Misc
  - Updated User Guide info for Fuel Calculator, RestAPI Module, Sectors Module,
    Pedal Widget, Weather forecast Widget.

2.14.1 (2024-06-24)
-----------------------------
* Radar Widget
  - Add 3 new "auto_hide_minimum_distance" options (ahead, behind, side),
    which define an invisible rectangle area(unit meter) that auto hides radar
    if no vehicle is within the rectangle area.
    Default value is "-1", which auto scales with "radar_radius" value.
    Set to any positive value to customize radar auto-hide range.
  - Add 3 new "vehicle_maximum_visible_distance" options (ahead, behind, side),
    which define an invisible rectangle area(unit meter) that
    hides any vehicle outside the rectangle area.
    Default value is "-1", which auto scales with "radar_radius" value.
    Set to any positive value to customize vehicle visible range.
  - Add 3 additional distance circle marks (total of 5 marks)
    that can be used to determine nearby vehicle relative distance.
    Each circle's default radius value is "10" meter apart.
    Note, circle marks are only displayed if "distance_circle_*_radius" values
    are within "radar_radius" value.

* Relative, Rivals, Standings Widget
  - Now draws logo only once per unique brand and stores image in cache.

* Misc
  - Updated User Guide info for Radar Widget.

2.14.0 (2024-06-14)
-----------------------------
* General
  - Config window can now be opened by double-clicking on tray icon.

* Vehicle Brand Editor
  - Add new "import from" menu, which allows importing
    brand info directly from Rest API.
    To import from Rest API, just make sure game is running,
    then click either "RF2 Rest API" or "LMU Rest API" from menu, done.
    Note, import function uses connection setting from "RestAPI Module".

* Fuel calculator
  - Add "Virtual Energy" history data and calculation.
    All fuel calculation outputs are now aligned on the left side,
    and virtual energy outputs on the right side for easy comparison.
    See user guide "Fuel calculator" section for details.
  - Add "Fuel ratio" output, which is automatically calculated from
    fuel and virtual energy consumption values.
  - Lap time values are now automatically carried over between spin boxes
    when exceeded min or max value range.
    It is now quicker and easier to adjust lap time by
    mouse clicking or scrolling.
  - "Reload" button now only updates valid lap time data
    to lap time spin boxes.

* [New]Energy Module
  - Add Energy Module for calculating virtual energy usage in LMU.
  - Add new "energy delta" user data file that stored as "CSV" format
    (.energy extension) under "TinyPedal\deltabest" folder.
    Energy delta data can be reset by accessing "Reset" menu.

* RestAPI Module
  - Read "virtual energy" values from LMU's Rest API
    for used in Energy Module.
  - Read "steering wheel range" value from LMU's Rest API
    for used in Steering Widget.
    This value is only used when "steering wheel range" value
    cannot be read from sharedmemory API.
  - Fixed a timeout error.

* Flag Widget
  - Now shows low fuel (or low virtual energy if available) indicator
    when below certain amount value.
    Only one indicator will be displayed for low fuel (LF) or low virtual energy (LE),
    depends on which one would deplete sooner.
  - Now shows low fuel value in "liter" or "gallon" based on fuel unit setting.

* Fuel Widget
  - Add "swap_upper_caption" and "swap_lower_caption" options,
    which swap caption row position.
  - Add "column_index_*" options, which set display order for
    upper, middle, and lower rows.

* Lap time history Widget, Stint history Widget
  - Add "show_virtual_energy_if_available" option,
    which shows virtual energy consumption instead of
    fuel consumption if available.
    This option is enabled by default.

* [New]Virtual Energy Widget
  - Show Virtual Energy usage data. Most settings and functionalities
    work the same way as Fuel Widget.
  - Show "fuel ratio" between estimated fuel and energy consumption,
    which can help balance fuel and energy usage,
    as well as providing refueling reference for adjusting
    pitstop "Fuel ratio" during race.
  - Virtual Energy usage readings are displayed in percentage,
    which range from 0 to 100.

* Misc
  - Updated User Guide info for Brands preset, Fuel calculator, Energy Module,
    RestAPI Module, Flag Widget, Fuel Widget, Lap time history Widget,
    Stint history Widget, Virtual Energy Widget.

2.13.0 (2024-06-08)
-----------------------------
* General
  - Now unloads all image resources on widget close to free up RAM.

* RestAPI Module
  - Add "connection_retry" option, which sets
    number of attempts to retry connection.
    Value range in "0" to "10".
    Default is "3" retries.
  - Add "connection_retry_delay" option, which sets
    time delay in seconds to retry connection.
    Value range in "0" to "60".
    Default is "1" second.
  - Fixed a timeout error.

* [New]Elevation Widget
  - Add Elevation Widget that displays track elevation plot.
    Note: elevation plot data is recorded together with track map.
    At least one complete & valid lap is required to generate elevation plot,
  - Show elevation reading in either meters or feet,
    depends on distance unit setting.
  - Show elevation progress bar & line according player's current position.
  - Show reference lines and marks.
  - Fully customizable plot display size, margin,
    detail level, text position and alignment.
    See user guide "Elevation" section for details.

* Flag Widget
  - Add "traffic_low_speed_threshold" option,
    which sets low speed threshold for showing
    nearest incoming traffic indicator (time gap).
    Default is "8" m/s (roughly 28kph).
    Set to "0" to disable.
    This option can be useful to quickly determine
    nearby traffic situation after a spin or crash.

* Track map Widget
  - Add "display_detail_level" option,
    which sets detail level for track map.
    Default value is "1", which auto adjusts
    map detail according to display size.
    Higher value reduces map detail and RAM usage,
    and may also help reduce rough edges from large map.
    Set to "0" for full detail.

* Misc
  - Updated User Guide info for RestAPI Module,
    Elevation Widget, Flag Widget, Track map Widget.

2.12.0 (2024-05-31)
-----------------------------
* General
  - Add "power_unit" option in "Units and symbols" dialog,
    which sets power unit for Electric motor & Engine Widgets.
    Available units: "Kilowatt", "Horsepower", "Metric Horsepower".

* [New]RestAPI Module
  - Add RestAPI Module, which connects to RF2 or LMU Rest API
    for accessing data that is not available through Sharedmemory API.
    Note, the APP auto detects RF2 or LMU.
    This module is enabled by default.
  - Add "module_restapi" section in JSON preset.
  - Add "url_host" option, which sets RF2 or LMU Rest API host address.
  - Add "url_port_rf2" and "url_port_lmu" options, which set port for host address.
  - Add "connection_timeout" option, which sets connection timeout duration in seconds.

* Cruise Widget
  - Now reads session "time scale" value from Rest API
    for calculating correct in game track clock time.
    Note, if RestAPI Module is disabled or Rest API data is not available,
    "track_clock_time_scale" option value will be used instead.

* Electric motor Widget
  - Add "show_power" option, which shows motor power.
  - Renamed some old option names for better readability & consistency.

* Engine Widget
  - Add "show_torque" option, which shows engine torque.
  - Add "show_power" option, which shows engine power.

* Radar Widget
  - Add "auto_hide_in_private_qualifying" option,
    which auto hides Radar in private qualifying session.
    This option is enabled by default.
  - Now reads "private qualifying" value from Rest API
    for used in "auto_hide_in_private_qualifying".
    Note, if RestAPI Module is disabled or Rest API data is not available,
    "auto_hide_in_private_qualifying" option will not take effect.

* Misc
  - Updated User Guide info for Units and symbols, RestAPI Module,
    Cruise Widget, Electric motor Widget, Engine Widget, Radar Widget.

2.11.2 (2024-04-11)
-----------------------------
* General
  - "bar_padding" option will no longer crop text between edge and padding from
    some none "mono" type fonts.
    "bar_padding" option can now be used to further increase
    each element width in widget for some none "mono" type fonts
    that exceeds default widget width.
  - Config dialog now validates values before saving,
    and shows error prompt for incorrect values.
  - Improved color validation, fixed an issue where invalid color could be saved.
  - Add clock time format validation, improved track clock time calculation.
  - Add "minimum_update_interval" option in Compatibility config,
    which sets minimum refresh rate limit for widget and module in milliseconds.
    This option is used for preventing extremely low refresh rate
    that may cause performance issues in case user incorrectly sets
    "update_interval" and "idle_update_interval" values.
    Default value is "10", and should not be modified.

* Deltabest & Deltabest extended Widgets
  - Add "freeze_duration" option, which sets freeze duration (seconds)
    for displaying previous lap time difference against best lap time source
    after crossing finish line. Value range in "0" to "30" seconds.
    Default is "3" seconds. Set to "0" to disable.

* Flag Widget
  - Optimized flag update methods.

* Gear Widget
  - Fixed a typo in "battery_bar_color_regen" default value,
    which would not show regeneration color.

* Lap time history Widget
  - Fixed missing fuel unit conversion for gallon.
  - Optimized lap history update methods.

* Pedal Widget
  - Add "show_throttle_filtered" "show_brake_filtered" "show_clutch_filtered" options,
    which set visibility of filtered pedal input.
    For vehicle that does not provide filtered pedal API data,
    turn off those options to show raw pedal input only.

* Sectors Widget
  - Now shows laptime "time gap" on "target time" bar,
    which shows laptime difference between current laptime and target laptime.
    Target laptime source depends on new "target_laptime" option.
  - Add new "target_laptime" option,
    which sets target laptime for display target reference lap and sector time.
    Set "Theoretical" to show theoretical best sector time from session best sectors.
    Set "Personal" to show sector time from personal best lap time.
  - Removed old "target_time_mode" options.
  - Removed old "always_show_laptime_gap" options.

* Stint history Widget
  - Optimized stint history update methods.

* Shared Memory API
  - Fixed a rare issue where rapidly restarting API could freeze the APP.

* Misc
  - Updated User Guide info for General options, Compatibility, Deltabest Widget,
    Deltabest extended Widget, Pedal Widget, Sectors Widget.

2.11.1 (2024-03-28)
-----------------------------
* Trailing Widget
  - Add "draw_order_index_*" options,
    which sets draw order of plot lines.

2.11.0 (2024-03-28)
-----------------------------
* [New]Fuel calculator
  - New "Fuel Calculator" can be accessed from Tools menu in main window.
    Editable options:
      * Lap time (minute:second:millisecond), can be auto-filled by Reload.
      * Tank capacity (liter or gallon), can be auto-filled by Reload.
      * Fuel consumption (liter or gallon), can be auto-filled by Reload.
      * Race length in minutes.
      * Race length in laps.
      * Formation/Rolling.
      * Average pit stop in seconds.
      * Starting fuel (liter or gallon).
    Output values:
      * Total required race fuel (liter or gallon).
      * End stint remaining fuel (liter or gallon).
      * Total required pit stops.
      * One less pit stop fuel consumption (liter or gallon).
      * Total laps can run based on "Total fuel" value.
      * Total minutes can run based on "Total fuel" value.
      * Average refueling (liter or gallon) per pit stop.
  - "Reload" button to load fuel usage & stint data from recent sessions
    into calculator without having to manually set values.
  - "History" table which lists "lap number", "lap time", "fuel consumption",
    "remaining fuel" data from recent sessions.
    Invalid lap time or fuel consumption data is highlighted in red.
  - Select any "lap time" or "fuel consumption" values from history table,
    and click "Add selected data" to send value to calculator.
    Select multiple values of same column and click "Add selected data" button
    to calculate average reading of selected values and send to calculator,
    which can be useful for planning long race.
    See user guide "Fuel calculator" section for details.

* [New]Brake performance Widget
  - Show transient max braking rate (g) from last braking input,
    and resets after 3 seconds.
  - Show max braking rate (g), and resets after a set period of time
    that defined by "max_braking_rate_reset_delay" value in Force Module.
  - Show max braking rate difference (g) against
    transient max braking rate, and resets on the next braking.
  - Show max braking rate difference (g) in percentage (%) instead.
  - Show front and rear wheel lock duration (seconds)
    per lap under braking.
    Duration increases when tyre slip ratio has exceeded
    "wheel_lock_threshold" value, and resets on first
    braking input of a new lap.

* Gear Widget
  - Add "battery_bar_color_regen" option,
    which shows energy regeneration color indicator for battery bar.

* Instrument Widget
  - Changed "wheel_lock_threshold" default value to "0.3".

* Trailing Widget
  - Add "show_wheel_lock" option,
    which shows wheel lock (slip ratio) plot under braking
    when slip ratio has exceeded "wheel_lock_threshold" value.
    Default plot style is yellow dots.
    Default "wheel_lock_threshold" value is "0.3".
  - Add "show_wheel_slip" option,
    which shows wheel slip (slip ratio) plot under acceleration
    when slip ratio has exceeded "wheel_slip_threshold" value.
    Default plot style is purple dots.
    Default "wheel_slip_threshold" value is "0.1".
  - Fixed plot lines that kept drawing after game paused.

* Force Module
  - Add "braking rate" calculation and output.
  - Add "max_average_g_force_reset_delay" option,
    which sets time delay (in seconds) for resetting
    max average g force. Default is "30" seconds.
  - Add "max_braking_rate_reset_delay" option,
    which sets time delay (in seconds) for resetting
    max braking rate. Default is "60" seconds.
  - Renamed "max_g_force_freeze_duration" option
    to "max_g_force_reset_delay" for consistency.

* Fuel Module
  - Add fuel "consumption history" logging and output for Fuel Calculator.
    Currently fuel log is not saved to user file, which resets after APP closed.

* [New]Wheels Module
  - "Wheels Module" now calculates and outputs wheel radius
    and slip ratio data for other modules and widgets.

* Config Window
  - Add "Spectate Mode Enabled" status notification,
    which shows when spectate mode is enabled.
    Click on the notification will show Spectate tab.
  - Add "Tools" menu, moved all editors to "Tools" menu.

* Shared Memory API
  - Always use direct access for "rF2ForceFeedback" and "rF2Extended"
    which don't require synchronizing.
  - Reduced "pause" detection timeout duration from 5s to 2s.

* Misc
  - Added Fuel calculator, Brake performance Widget, Wheels Module info in User Guide.
  - Updated Trailing Widget, Force Module info in User Guide.

Thanks to @DanRZ for suggestions and testing feedback.

2.10.1 (2024-03-13)
-----------------------------
* Deltabest Widget
  - Add "deltabest_source" option,
    which sets lap time source for deltabest display.
    Available values are:
      "Best" = all time best lap time,
      "Session" = session best lap time,
      "Stint" = stint best lap time,
      "Last" = last lap time.

* Delta Module
  - Stint deltabest now only resets if
    vehicle stops in pit lane.

* Vehicle Brand Editor & Vehicle Class Editor
  - "Add" button will now add all vehicle data
    found from current active session.
    Note, existing data will not be changed.

* Misc
  - Updated Deltabest Widget, Brands preset, Classes preset
    sections in User Guide.

2.10.0 (2024-03-10)
-----------------------------
* Relative, Rivals, Standings Widget
  - [New]Added "show_brand_logo" option,
    which shows user-defined brand logo if available.
    A new "brandlogo" is added to TinyPedal folder,
    which is used for storing brand logo image.
    Note: TinyPedal does not provide brand logo image assets,
    it is up to user to prepare images.
    Maximum "PNG" file size is limited to "1MB".
    See "Brand logo" section in User Guide for customization guide.
  - Added "brand_logo_width" option,
    which sets maximum brand logo display width in pixels.
    Note, maximum brand logo display height is
    automatically adapted to "font_size".

* Fuel Widget
  - Renamed all "*_mins" options to "*_minutes"
    for better readability & consistency.

* Tyre wear Widget
  - [New]Added "show_lifespan_minutes" option,
    which shows tyre lifespan in minutes.
  - Added "warning_threshold_minutes" option,
    which sets warning threshold for
    estimated tyre lifespan in minutes.
    Default is "6" minutes.
  - Renamed "show_lifespan" option to "show_lifespan_laps".

* Instrument Widget
  - Improved wheel radius sampling and calculation.

* Vehicle Brand Editor
  - No longer overrides existing brand name
    when importing data that contains existing vehicle name.

* Misc
  - Added "Brand logo" section under "User files" in User Guide.

2.9.4 (2024-03-07)
-----------------------------
* General
  - Added "driver_name_shorten" option for
    Relative, Rivals, Standings Widgets,
    which shortens driver's first name to a single letter
    with a period separating driver's last name,
    and any middle names will not be displayed.
    Note, if a driver is using nickname that consists only a single word,
    the name will not be shortened.

* Vehicle Brand Editor
  - Removed some obsolete code.

* Misc
  - Updated Relative Widget entries in user guide.

2.9.3 (2024-03-05)
-----------------------------
* [New]Rivals Widget
  - Added new Rivals Widget, which displays standings info
    from opponent ahead and behind local player from same vehicle class.
    Most options are same as from Standings or Relative Widget.
  - Added "*_color_time_interval_ahead" & "*_color_time_interval_behind"
    color options for customize time interval display.

* Relative Module
  - Added addition calculation for finding opponent ahead and behind
    local player from same vehicle class.

* Misc
  - Added Rivals Widget entries in user guide.

2.9.2 (2024-03-05)
-----------------------------
* Vehicle Brand Editor
  - Added support for importing vehicle data from RF2.
    How to export vehicle brand data from RF2 API:
    1. Start RF2, then open following link in web browser:
    localhost:5397/rest/race/car
    2. Click "Save" button which saves vehicle data to JSON file.
    Max importing file size is limited to 5mb.
  - Replaced editor List view with Table view,
    which is more efficient when processing large data set.

* Misc
  - Updated Brands preset entries in user guide.

2.9.1 (2024-03-04)
-----------------------------
* Relative Widget
  - Added "driver_name_align_center" & "vehicle_name_align_center" options,
    which align driver or vehicle name in the center when enabled.
    Default is left alignment when disabled.

* Standings Widget
  - Added "driver_name_align_center" & "vehicle_name_align_center" options,
    same as Relative Widget.

* Misc
  - Updated Relative, Standings Widget entries in user guide.

2.9.0 (2024-03-04)
-----------------------------
* [New]Vehicle Brand Editor
  - Added a new Vehicle Brand Editor,
    which can be used for substituting vehicle names
    with custom vehicle brand names.
    The new editor supports functions including:
    import, add, sort, batch rename, reset.
    The import function allows user to import
    vehicle JSON data file that exported from game API.
    See "Brands preset" section in user guide for details.

* Flag Widget
  - [New]Added "show_pit_request" option,
    which shows pit request state.
  - [New]Added "show_finish_state" option,
    which shows finish or disqualify state.

* Relative Widget
  - [New]Added "show_vehicle_brand_as_name" option,
    which shows vehicle brand name instead of vehicle name.
    Vehicle brand names are defined in "brands.json" file in "Settings" folder.
    If brand name does not exist, vehicle name will be displayed instead.

* Standings Widget
  - [New]Added "show_best_laptime" option,
    which shows driver's session best lap time.
    This option is disabled by default.
    Note: when this option is disabled,
    the other "show_laptime" option will
    show best lap time in none-race sessions.
  - [New]Added "show_vehicle_brand_as_name" option,
    same as Relative Widget.

* Tyre carcass Widget
  - [New]Added "show_rate_of_change" option,
    which shows carcass temperature rate of change for a specific time interval.
  - Added "rate_of_change_interval" option,
    which sets time interval (in seconds) for rate of change calculation.
    Default is 5 seconds.
  - Added "layout" & "column_index_*" options.

* Shared memory API Config
  - Added "character_encoding" option,
    which sets character encoding for displaying text in correct encoding.
    Default encoding is "UTF-8", which fixed some wrong text in LMU game.
    Note, "UTF-8" may not work well for some Latin characters in RF2,
    try use "ISO-8859-1" instead.

* Misc
  - "brands" filename is now reserved for vehicle brands preset.
  - Added "Brands preset" section in user guide.
  - Updated Shared memory API, Flag, Relative, Standings,
    Tyre carcass Widget entries in user guide.
  - Updated README info for LMU.

2.8.0 (2024-02-23)
-----------------------------
* [New]Damage Widget
  - Show visualized vehicle body damage, wheel damage info.
  - Show vehicle body integrity percentage reading.

* Standings Widget
  - Added "show_time_interval_from_same_class" option,
    which shows time interval from same class instead.
    This option is enabled by default, and only takes effect
    while "enable_multi_class_split_mode" is enabled.

* Steering Widget
  - Added "manual_steering_range" option,
    which sets steering display range in degrees.
    Set to "0" to read physical steering range from API.
    This option may be useful when steering range value
    is not provided by some vehicles.

* Misc
  - Added "Hyper" class to default classes.json setting.
  - Updated "rF2 Shared Memory Map Plugin" download link in README file.
  - Added new entries in Damage, Standings, Steering Widget sections in User Guide.

2.7.0 (2024-02-05)
-----------------------------
* [New]Deltabest extended Widget
  - Added new Deltabest extended widget that shows deltabest
    against multiple lap time sources.
    Note: default layout is set on horizontal.
    Set layout value to 0 to show vertical layout.
  - Show deltabest against personal all time best lap time.
  - Show deltabest against current personal session best lap time.
    Note: session deltabest will be reset upon
    changing session, or reload preset/restart APP.
  - Show deltabest against current personal stint best lap time.
    Note: stint deltabest will be reset upon entering pit.
  - Show delta against personal last lap time (deltalast).
    Note: deltalast will be reset upon ESC.

* Session Widget
  - Added "show_session_name" option,
    which show current session name that includes
    testday, practice, qualify, warmup, race.
  - Added "session_text_*" options
    for customizing session name text.
  - Added "column_index_session_name" option.
    Default value is set to 0.
    Note, user may still need to check the new "column_index_session_name" value
    to ensure no overlapping with other column_index values.

* Timing Widget
  - Added "show_stint_best" option,
    which shows personal stint best lap time.
    Note: stint best lap time will be reset upon entering pit.

* Delta Module
  - Added session deltabest, stint deltabest, delta last data output.
  - Added new laptime validation method,
    which fixed best lap time sometimes failed to validate.
    Extended validation duration to 10s.

* User guide
  - Added new entries in Deltabest extended, Session, Timing Widget sections.

2.6.1 (2024-01-18)
-----------------------------
* General
  - Added new main window position correction function
    that fixed the issue with main window being forced
    to move to first screen.
    The new correction function will now correctly detect
    multi-screen monitors, verifying and auto-correcting
    main window position if necessary.
    Thanks to DanRZ for helping with extensive testing
    and providing valuable feedback.
  - Added "enable_window_position_correction" option in Compatibility,
    which user can enable or disable main window position correction.
    This option is enabled by default.
  - Added new command line argument "--log-level="
    that can be used to set logging output level.
    "--log-level=0" outputs only warning or error log to console.
    "--log-level=1" outputs all log to console.
    "--log-level=2" outputs all log to both console & tinypedal.log file.
    Default logging output level is set on "1" if argument is not set.
    Example usage:
    ".\tinypedal.exe --log-level=2"
    Note:
    On windows, tinypedal.log is located under APP root folder.
    On linux, tinypedal.log is located under /home/.config/TinyPedal/ folder.
  - Added "Show log" option in Help menu for easy accessing to application log.
  - "Reset data" option is now also accessible from tray menu.

* [New]Heatmap Editor
  - "Heatmap editor" can now be accessed from "Config" menu in main window,
    see User Guide "Heatmap preset" section for details.

* Linux
  - Fixed wrong "button" argument that breaks "Reset" button in config dialog.

* User guide
  - Added "Heatmap Editor" info in "Heatmap preset" section.
  - Added "Command line arguments" section guide.

2.6.0 (2024-01-06)
-----------------------------
* General
  - Optimized and improved performance of most modules and widgets,
    with roughly 50-100% less overall CPU usage than previously.
  - Significantly optimized some resource-heavy Widgets
    with 5-10 times less CPU usage than previously, notably:
    Navigation, Trailing, Track map Widgets.

* Engine Widget
  - Added "show_rpm_maximum" option,
    which shows maximum engine RPM (rev limit).

* Trailing Widget
  - Removed "show_vertical_style" option.

2.5.3 (2023-12-26)
-----------------------------
* General
  - Fixed a main APP window disappearing issue
    when using with multiple screens setup.
    Added auto position correction function to force
    main APP window stay on visible screen area.
    Thanks to @Capeta for helping with test.
  - Fixed incorrect enabled module count display on Module tab.
    Further improved module load/reload functions.
  - Fixed Reset dialog title text.

2.5.2 (2023-12-23)
-----------------------------
* General
  - Improved APP, API and modules closing speed.
  - Improved vehicle-class color selection function.
  - Improved heatmap color selection function.
  - Re-verify delta data after auto-correction.
  - Added minimum threshold for force ratio calculation.
  - Simplified module import & toggle function.
  - Ignore JSON file extension name case when loading.
  - Correctly restore minimized config window when accessing from tray menu.
  - Simplified tyre compound selection function.
  - Accessing "Restart API" will no longer trigger auto-hide while driving.

* User guide
  - Updated Navigation & Track map info.

2.5.1 (2023-12-05)
-----------------------------
* General
  - Fixed APP malfunction while switching API or reloading under rare cases.
  - Sort heatmap on load.
  - Add User guide & FAQ link to main window Help menu.
  - Reworked About window, add contributors tab.
  - Don't draw sector line on map if not available.
  - Various corrections & fixes.
  - Removed additional index check methods (introduced in 2.3.0 update)
    in API access module that may potentially cause issues.

* Fuel Module
  - Fixed several incorrect lap number reference (introduced in 2.3.0 update).

2.5.0 (2023-11-27)
-----------------------------
* General
  - Rename "Display units" config dialog to "Units and symbols",
    which is now used for unified units and symbols configuration.
  - Moved all (five) "tyre_compound_list" options to "Units and symbols"
    config dialog, and is now called "tyre_compound_symbol".
  - Adjusted & unified default value for "bkg_color_circle" options
    that used in Friction circle, Heading, Navigation, Radar Widgets.
  - "show_fade_out" option no longer crops background.
  - Add option reset confirmation to various config dialog.
    Note, option reset will still only be saved and take effect
    after clicking apply or save button.

* [New]Vehicle class editor
  - Add "Vehicle class editor" that can be accessed from "Config" menu in main window,
    which provides easy-to-use vehicle class name customization.
  - The new editor can auto-detect and fill-in "full vehicle class name"
    from current active session.
    It is recommended to join or start a session with corresponding vehicle
    before adding new class entries.
    See user guide for details.

* Force Widget
  - Add "show_front_downforce" & "show_rear_downforce" options,
    which show front & rear downforce reading in Newtons.
  - Add "warning_color_liftforce" that shows color indicator
    when generating lift force.

* Navigation Widget
  - Add "show_circle_background" & "bkg_color_circle" options (enabled by default),
    which shows circle background color below navigation map.
  - Add "circle_outline_color" & "circle_outline_width" options,
    which draw outline for circle background.

* Radar Widget
  - Add "show_circle_background" & "bkg_color_circle" options (disabled by default),
    which shows circle background color below vehicle radar.

* [New]Suspension position Widget
  - Show visualized suspension position (millimeter).

* Timing Widget
  - Add "show_session_personal_best" option (disabled by default),
    which shows personal best lap time from current session.

* [New]Tyre carcass temperature Widget (by Sasker)
  - Show carcass temperature of each tyres
    based on Tyre temperature Widget design,
    which helps analyzing and managing tyre grip
    and wear relative to carcass temperature change.
  - Many customizable options.

* Misc
  - Updated user guide.
  - Updated contributors.md with new contributor (Sasker).

2.4.0 (2023-11-19)
-----------------------------
* General
  - [New]Add "Grid move" option under overlay menu and tray menu (by Bernat),
    which enables grid-snap effect while moving widget
    for easy alignment and repositioning.
    "Grid move size" option is accessible from compatibility config dialog.
  - Add "Reset data" submenu to "Overlay" menu from main window,
    which allows user to reset data from active session only.
    Currently includes deltabest, fuel delta, trackmap data.

* Linux support
  - "enable_bypass_window_manager" option is now enabled by default
    for new preset created on Linux (by Bernat).

* [New]Heading Widget
  - Show vehicle yaw angle, slip angle, & direction of travel lines on compass bearings
    that similar to flight instrument "heading indicator".
  - Show vehicle yaw angle, slip angle readings in degrees.
  - New "icon_compass.png" compass bearings background in "images" folder.
  - Many customizable options.

* [New]Navigation Widget
  - Show navigation map and orientation centered on player's vehicle.
  - Show optional vehicle standings on navigation map.
  - Many customizable options.

* Vehicles Module
  - Add "lap_difference_ahead_threshold" & "lap_difference_behind_threshold" options,
    which sets lap difference (percentage) threshold
    for tagging opponents as ahead or behind.
    Default value is "0.9" lap.
    Those options are used by lap difference color indicator
    in Trackmap, Relative, Radar, Navigation Widgets.

* Misc
  - Updated user guide.

2.3.1 (2023-11-12) Hotfix
-----------------------------
* Trailing Widget
  - Fixed FFB plot not displaying full range (absolute value).
  - Fixed small desync issue between different pedal or FFB plots.

* General
  - Removed string format on "id" key word.
  - Fixed fuel data loading error in fuel module.

2.3.0 (2023-11-11)
-----------------------------
* General
  - Fixed error in loading a different preset
    while previous preset is in saving process.
  - Change option name "rF2_process_id" to "process_id".
  - Rename unit option "elevation_unit" to "distance_unit",
    and currently is used by elevation & yellow flag distance display.
  - Fixed text string decode setting.

* [New]Trailing Widget (designed by DanRZ)
  - Show pedal trail history plot display,
    includes throttle, brake, clutch, force feedback.
  - Customizable size, scale, style, orientation, reference lines, etc.

* Relative Module
  - Fixed index out of range when returning
    to monitor while in spectate mode.

* Shared memory API
  - Add API control & data adapter to support different sims API in the future.
  - Add API name selector in Shared memory API config dialog.
  - Show API name & version info on main window status bar.

* Misc
  - Updated user guide.
  - Updated contributors.md with new contributor (DanRZ).

2.2.0 (2023-10-27)
-----------------------------
* General
  - Add "enable_translucent_background" option in Compatibility,
    which turns off translucent background if disabled.
  - Add "global_bkg_color" option in Compatibility,
    which sets global background color for all widgets.
    Note 1, global background color will only be visible
    when "enable_translucent_background" option is disabled
    or translucent background is not supported by system.
    Note 2, some widgets with own background setting may override this option.
  - Fixed window color theme when system style is set to dark-mode.

* Linux support
  - Add customizable installation path option for installer,
    improved installer error prompt,
    removing old files before installing (by Bernat).
  - Add workaround in launcher to force X11 session type
    which fixed non-draggable issue found on Wayland (by Bernat).
  - Fixed tray menu not synced with main Config window (by Bernat).

* [New]Sectors Module
  - Separated sector time calculation from Sectors Widget to this new module.

* Friction Circle Widget
  - Add "show_circle_background" & "bkg_color_circle" options,
    which shows customized circle background color.
    Note, the "show_background" option shows background color
    that covers entire Friction Circle widget.
  - Add "show_fade_out" option,
    which fades out circle background edge.
  - Add "fade_in_radius" & "fade_out_radius" options,
    which sets fade in/out radius, value range in 0.0 to 1.0.
  - Removed "background_style" option as replaced by "show_fade_out" option.

* Radar Widget
  - Add "show_background" & "bkg_color" options,
    which shows customized radar background color.
  - Add "show_fade_out" option,
    which fades out radar edge.
  - Add "fade_in_radius" & "fade_out_radius" options,
    which sets fade in/out radius, value range in 0.0 to 1.0.

* Sectors Widget
  - Now reads sectors data from Sectors Module.
  - Moved & re-implemented speed display to Speedometer Widget.

* [New]Speedometer Widget
  - Show current vehicle speed.
  - Show minimum speed that is updated while off throttle.
  - Show maximum speed that is updated while on throttle.
  - Show fastest recorded speed.
    To reset current record, shift gear into reverse, or reload preset.
    See User Guide "Speedometer" section for details.

* Misc
  - Updated README.md with Linux usage info (by Bernat).
  - Updated customization.md.

2.1.10 (2023-10-09)
-----------------------------
* Relative Widget
  - Fixed index out of range issue when configuring display rows.

* Timing Widget
  - Removed prefix alignment padding when using horizontal layout.

2.1.9 (2023-07-14)
-----------------------------
* [New]Spectate mode
  - Add "Spectate" tab that is accessible from main window.
  - Click "Enabled" or "Disabled" button to quickly toggle spectate mode on & off.
    Note, spectate mode can also be enabled by setting
    "enable_player_index_override" option to "true"
    in "Shared Memory API" config.
  - While Spectate mode is enabled, double-click on a player name in the list
    to access telemetry data and overlay readings from selected player.
    Alternatively, select a player name and click "Spectate" button.
    Current spectating player name is displayed on top of player name list.
  - Select "Anonymous" for unspecified player,
    which is equivalent to player index "-1" in JSON file.
  - Click "Refresh" button to manually refresh player name list.

2.1.8 (2023-07-13)
-----------------------------
* [New]Shared Memory API configuration
  - Add "Restart API" option to main menu bar & tray context menu,
    which can be used to quickly restart shared memory API accessing.
  - Add "Shared Memory API" config dialog,
    which can be accessed from main menu bar "Config" menu.
  - Add "shared_memory_api" section in user config file.
  - Add "access_mode" option,
    which sets access mode for shared memory API.
    Mode value "0" uses copy access and additional data check
    to avoid data desync or interruption issues.
    Mode value "1" uses direct access, which may result
    data desync or interruption issues.
    Default mode is copy access.
  - Add "rF2_process_id" option,
    which sets rF2 process ID string for accessing API from server.
    Currently this option is a placeholder, and should be left blank.
  - Add "enable_active_state_override" option,
    which enables "active state" manual override.
  - Add "active_state" option,
    which overrides local player on-track status check,
    and updates or stops overlay & data processing accordingly.
    Set "true" to activate state.
    Set "false" to deactivate state.
    This option works only when "enable_active_state_override" enabled.
  - Add "enable_player_index_override" option,
    which enables "player index" manual override.
  - Add "player_index" option,
    which sets "player index" override for displaying data from specific player.
    Valid player index range starts from "0" to max number players minus one,
    and must not exceed "127".
    Set value to "-1" for unspecified player, which can be useful
    for display general standings and trackmap info (ex. broadcasting).
    This option works only when "enable_player_index_override" enabled.

* Vehicles Module
  - Renamed "Standings Module" to "Vehicles Module",
    which provides vehicles data.

* Force Widget
  - Fixed a display issue with very large readings.

* Track map Widget
  - Add "show_map_background" & "bkg_color_map" options,
    which shows background of the inner map area.
    This option only works for circular type tracks.

2.1.7 (2023-06-16)
-----------------------------
* Flag Widget
  - Add "pit_closed_text" option, which sets custom pit closed text.
  - Add "show_traffic" option, which shows incoming on-track
    traffic indicator (time gap) while in pitlane or after pit-out.
  - Add "traffic_maximum_time_gap" option, which sets
    maximum time gap (seconds) of incoming on-track traffic.
  - Add "traffic_pitout_duration" option, which sets
    traffic indicator extended duration (seconds) after pit-out.

* Delta & Fuel Module
  - Add additional delta data validation and error correction methods,
    which auto corrects potential data desynced & disordered issue
    between recorded laptime and corresponding distance data
    that could happen in rare cases.

* Misc
  - Updated user guide with new options for Flag Widget.

2.1.6 (2023-06-12)
-----------------------------
* Deltabest Widget
  - Add "delta_display_range" option,
    which sets max display range (gain or loss) in seconds
    for delta reading, accepts decimal place.
    Default value is "99.999" seconds.

* Fuel Widget
  - Add "*early" option, which shows estimate number of pit stop counts
    when making an early pit stop at end of current lap.
    This value can be used to determine whether an early pit stop
    is worth performing comparing to "pits" value.
    More example usage and explanation in user guide.
  - Add "show_refueling_level_mark" option,
    which shows estimated fuel level after refueling.
    If the mark is not visible on fuel level bar,
    it indicates total refueling has exceeded fuel tank capacity.
    Default mark color is green.
  - Add "decimal_places" options for each individual fuel info.
    Maximum value is limited to "3".
  - Add "bar_width" options, which sets each column width in chars.
    Default value is "5". Minimum width is limited to "3".
  - Add "caption_text" options, which sets custom caption text.
  - Renamed several fuel options for consistency.
  - Removed "*start" option and starting fuel reading.

* Fuel Module
  - Add early pit stop calculation.
  - Improved calculation accuracy under certain conditions.
  - Exclude delta fuel calculation from estimated fuel consumption reading
    while vehicle is in garage stall.

* Force Module
  - Use standard deviation for max average g force comparison.

* Misc
  - Updated user guide with new options for Fuel Widget.

2.1.5 (2023-06-04)
-----------------------------
* Fuel Widget
  - Fixed a display issue with very large number formatting.

* Pedal Widget
  - Add "enable_horizontal_style" option,
    which shows pedal bar in horizontal style.
    This option is disabled by default.
  - Add "inner_gap" option,
    which sets gap between pedal and max indicator.
    Note, to completely hide indicator & extra gap space,
    set both "inner_gap" & "max_indicator_height" value to 0.

* Rake angle Widget
  - Add "show_ride_height_difference" option,
    which shows average front & rear ride height difference in millimeters.

* Delta Module
  - Improved accuracy of delta data calculation.
  - Fixed inaccurate reading issue that could happen
    during first lap of race or garage-out lap.

* Fuel Module
  - Improved accuracy & consistency of estimated fuel usage calculation.
    First lap of race & pit-in/out laps no longer affect overall fuel calculation,
    which gives more consistent stint fuel readings.
  - Accurate estimated fuel consumption & fuel delta readings
    from race first lap & pit-in/out laps.
  - Record delta fuel data from valid lap only.
  - Fixed invalid delta fuel data readings from
    tracks that uses fast timing mechanism.

* Core
  - Various improvements to sharedmemory data access methods.

* Misc
  - Updated user guide with new options for Pedal & Rake angle Widget.

2.1.4 (2023-05-29)
-----------------------------
* Relative Widget
  - Fixed "font_color" setting not correctly applied to
    "position", "driver name", "vehicle name" options
    when "show_lap_difference" is disabled.

* Misc
  - Updated user guide with additional info for "show_lap_difference" option.

2.1.3 (2023-05-29)
-----------------------------
* General
  - Adjusted all default values of "bar_padding_horizontal" to 0.5.

* Gear Widget
  - Add "show_speed_below_gear" option,
    which shows speed reading below gear.
    This option is disabled by default.
  - Add "font_scale_speed" option,
    which sets font scale for speed reading.
    This option only takes effect when
    "show_speed_below_gear" is enabled.
    Default value is 0.5.
  - Add "inner_gap" option,
    which sets inner gap between gear & speed readings.
    Negative value reduces gap,
    while positive value increases gap.
    Default value is 0.

* Relative & Standings Widget
  - Add "show_vehicle_name" option,
    which displays vehicle name in separated column.
    This option is disabled by default.
  - Removed "driver_name_mode" option.

* Misc
  - Updated contributors.md with new contributor (Sergio Rafael Lemke).
  - Updated user guide.

2.1.2 (2023-05-26)
-----------------------------
* General
  - Add "enable_auto_font_offset" option to widgets
    that have "font_offset_vertical" option.
    Enabling this option will automatically adjust font vertical offset
    based on font geometry for better vertical alignment,
    and sould give good result in most case.
    This option is enabled by default.
  - "font_offset_vertical" option now only takes effect
    when "enable_auto_font_offset" is disabled.
  - Fixed wrong vertical alignment on Friction Circle & Gear Widget.

* Core
  - Add "Global Font Override" option to "Config menu" on main window,
    which provides options to change font setting globally for all widgets.
    Options explain:
    [Font Name]
    Select a font name to replace "font_name" setting of all widgets.
    Default selection is "no change", which no changes will be applied.
    [Font Size Addend]
    Set a value that will be added (or subtracted if negative)
    to "font_size" value of all widgets.
    Default value is "0", which no changes will be applied.
    [Font Weight]
    Set font weight to replace "font_weight" setting of all widgets.
    Default selection is "no change", which no changes will be applied.
  - Add "Reset to Default" context menu to widget & module Config dialog,
    user can now right-click on an option and select "Reset to Default"
    to reset individual option.
  - Add "compatibility" option to "Config menu" on main window for easy access.
  - Moved "show_at_startup", "minimize_to_tray", "remember_position" options
    to "Window menu" on main window.
  - Removed "thick black border" from all widgets that could be visible
    when running on certain window manager, or using certain window capture APPs.

* Misc
  - Updated user guide.

2.1.1 (2023-05-24)
-----------------------------
* Flag Widget
  - Removed countdown timer feature.

* Core
  - Add new "compatibility" section in json file for solving platform specific problem.
  - Add "enable_bypass_window_manager" option in "compatibility"
    section for linux platform (thanks to help from srlemke & Bernat).

* Misc
  - Updated customization guide.

2.1.0 (2023-05-22)
-----------------------------
* [New]Friction Circle Widget
  - Show longitudinal & lateral g force as friction circle with 2 orientation layouts.
  - Show longitudinal & lateral g force readings.
  - Show max longitudinal & lateral g force readings.
  - Show reference circle from max average lateral g force reading.
  - Show g force trace plot with customizable sample size, and line or points style.
  - Show center mark and up to 5 customizable reference circles.

* Radar Widget
  - Fixed wrong outline drawing when set "vehicle_outline_width" to 0.

* [New]Force Module
  - Provide vehicle g force and downforce data calculation for Force & Friction Circle Widget,
  - Add customizable options for g force calculation.

* Misc
  - Add "Remember position" position to main window Config menu,
    which auto saves & loads last window position.
  - Minimize main window to taskbar at startup
    if both "minimize_to_tray" & "show_at_startup" are false.
  - Fixed an issue with config value validator under
    certain system language locale setting.
  - Fixed widget windows not show on top on linux (thanks to srlemke for help & testing).

2.0.3 (2023-05-15)
-----------------------------
* Gear Widget
  - Restored "show_speed_limiter" option,
    which shows pit speed limiter indicator.

* Timing Widget
  - Left alignment is now forced on all prefix text,
    and prefix width is based on the longest prefix text of all.

* pyRfactor2SharedMemory
  - Fixed a performance issue while local player is spectating.

* Misc
  - Add information about split PySide2 Linux package. (by Bernat)
  - Fix icon location in Linux desktop file. (by Bernat)

2.0.2 (2023-05-11)
-----------------------------
* Standings Widget
  - Adjusted default setting "max_vehicles_per_split_player" value from 5 to 7.

* Steering Widget
  - Fixed scale marks not shown in correct position.

* Tyre temperature Widget
  - Fixed average temperature layout not shown correctly.

* pyRfactor2SharedMemory
  - Fixed data interruption issue in multiplayer session
    that would interrupt calculation of deltabest & a few other widgets.

* Misc
  - Add additional info in customization guide for Standings widget.

2.0.1 (2023-05-10)
-----------------------------
* pyRfactor2SharedMemory
  - Hotfix to a data freeze issue reintroduced in v2.0.0
    when trying to solve data interruption issue.
    The code has been revert back to earlier version in the meantime.

2.0.0 (2023-05-10)
-----------------------------
* Core
  - TinyPedal now uses Qt GUI for all UI & widget displaying.
  - All UI & widgets have been rewritten using Qt GUI
    and support more visual effects and better performance.
  - The APP can now be launched from any folder path name.
  - There are currently 34 overlay widgets available,
    includes 10 new widgets and many reworked widgets.
  - New application main window with more functionalities,
    includes the new Widget & Module control panels
    that provide easy access to enable & disable function.
  - Add new "Config dialog" for customizing Widget & Module directly in the APP.
  - All widgets color options now support alpha value adjustment,
    which each color's opacity can be changed.
    This can be easily edited by double-clicking on color entry box
    in "Config" dialog, then adjust alpha value.
  - The old preset panel has also been redesigned with additional
    file operation supports via Right-Click context menu,
    where user can duplicate, rename, or delete selected preset.
    And preset can be easily loaded by double-clicking.
  - Add new "Display Units" config dialog,
    which handles all units setting in one place for all widgets.
  - Add "show_at_startup" and "minimize_to_tray" options to "Config" menu in main window.
  - Add "Reload" option to "Overlay" menu in main window,
    which can reload current active preset.
  - Add new customizable "heatmap.json" preset file for displaying color
    that matches specific value range of telemetry data,
    such as brake and tyre temperature.
  - Moved all previously called "real-time" modules into separated Module section,
    with a new Module panel in main window for grouped Module control and config.
  - Reworked tray icon menu:
    Add "Reload" & "Config" options.
    Removed "Widgets" sub menu.
    Show currently loaded preset name.
  - Various fixes & improvements.

* Delta Module
  - Add "IsValidLap" condition check output info,
    which is used for last lap time validation check in other timing widgets.

* Fuel Module
  - Add "Capacity", "AmountFuelStart", "AmountFuelBeforePitstop",
    "DeltaFuelConsumption", "OneLessPitFuelConsumption" data output info.
  - Further improvements to fuel calculation and estimated refueling accuracy,
    now takes consideration of player's current on track position relative to
    amount race time left for estimating more accurate finishing position and remaining distance.

* [New]Hybrid Module
  - The previous "Battery module" is now renamed to "Hybrid module" instead,
    and provide all necessary data calculation for battery and electric motor usage.

* [New]Mapping Module
  - The new "Mapping module" is used for recording track map,
    and processing map data for used in track map widget.
  - Map files are stored as SVG vector format under "TinyPedal\trackmap" folder,
    which can also be view in web browser directly.
  - The SVG vector map file contains two coordinate paths:
    First is the global x,y position path, used for drawing track map.
    Second is the corresponding track distance & elevation path, which is recorded for future use.
  - Each sector position index is also stored in SVG file for finding sector coordinates.

* Relative Module
  - Add new standings index list generator for used by standings widget.
  - Moved all vehicles info to the new "Standings module".
  - Radar widget no longer depends on Relative module.

* [New]Standings Module
    - The new "Standings module" now handles and provides all players & vehicles info
      that is required by widgets such as relative, radar, standings, track map, etc.

* [New]Battery Widget
  - The previous "Hybrid Widget" is now split into two separate widgets,
    which are "Battery Widget" & "Electric motor Widget".
  - Show percentage available battery charge with low charge warning.
  - Show percentage battery charge drained in current lap.
  - Show percentage battery charge regenerated in current lap.
  - Show electric boost motor activation timer.

* [New]Brake bias Widget
  - Show percentage forward Brake bias.
  - Add "decimal_places" option, which sets amount decimal places to keep.
  - Add "show_front_and_rear" option, which shows both front and rear bias.
  - Add "show_percentage_sign" option, which shows percentage sign.

* [New]Brake pressure Widget
  - Show visualized percentage brake pressure of each wheel.

* Brake temperature Widget
  - Add "heatmap_name" option, which user can assign a custom heatmap preset.
  - Renamed "color_swap" option to "swap_style",
    which swaps heatmap color between font & background color.

* Deltabest Widget
  - Remove bar scale options, and replaced with "bar_length" & "bar_height" options,
    which sets delta bar length & height in pixels.
  - Add "show_animated_deltabest" option,
    which deltabest display follows delta bar progress.

* [New]Electric motor Widget
  - Show boost motor temperature.
  - Show boost motor cooler water temperature.
  - Show boost motor RPM.
  - Show boost motor torque.
  - Show overheating warning.

* Flag Widget
  - Add "P CLOSE" warning text on pit timer with customizable color,
    which shows when pit lane is closed while in pit.
  - Add distance display for yellow flag indicator,
    which shows nearest yellow flag vehicle distance to player in meters.
  - Add "yellow_flag_maximum_range" option,
    which only shows yellow flag indicator when there is yellow flag
    within the maximum range (track distance in meters).
    Default is 500 meters.
  - Fixed low fuel & flag indicators not hiding issue.

* Fuel Widget
  - Add "save" fuel display, which shows minimum fuel consumption in order to
    achieve one less pit stops than current estimated number of pit stops.
  - Add new "Start" & "End" fuel display,
    which shows amount fuel at the start of stint,
    and estimated amount fuel left at the end of stint (just before pit stop).
  - Add "show_fuel_level_bar" option,
    which shows a visualized horizontal fuel level bar in the middle.
  - Add "show_starting_fuel_level_mark" option,
    which shows starting fuel level mark of current stint on fuel level bar.

* Gear Widget
  - Add "show_speed" option, which shows speed display when enabled.
  - Add "show_battery_bar" option,
    which shows battery bar that is only visible if electric motor available.
  - Add "rpm_multiplier_critical" option,
    which sets critical RPM range for RPM color indicator.
  - Add "show_rpm_flickering_above_critical" option,
    which shows flickering effects when RPM is above critical range
    and gear is lower than max gear.
  - Add "column_index" options, which can be used to re-arrange layouts.
  - Removed old "layout" option.

* Instrument Widget
  - Add "last_vehicle_info" option,
    which saves the last driven vehicle name for matching wheel radius.
  - Significantly improved average wheel radius calculation.
  - Average radius calculation now starts with a small amount samples
    and then gradually increases to highest number of samples.
    If "last_vehicle_info" matches current vehicle,
    then average radius calculation starts from highest number of samples.

* [New]Lap time history Widget
  - Show current lap number, current estimated lap time,
    current estimated fuel consumption, current lap average tyre wear.
  - Show history lap number, history lap time,
    history lap fuel consumption, history lap average tyre wear.
  - The number of lap time history can be set with "lap_time_history_count" option.
  - Show invalid lap time indicate color (default red).
  - Add "show_empty_history" which shows empty lap time history.
    Default is False, which hides empty rows.

* P2P Widget
  - Add "activation_threshold_throttle" option,
    which sets minimum throttle input percentage threshold for P2P ready indicator.
    Default is 0.6, which is 60% of throttle.

* Pedal Widget
  - All pedal & FFB display can now be individually turned off or on.
  - Add "column_index" options, which can be used to re-arrange layouts.

* Radar Widget
  - Now show all vehicles within the radar radius,
    removed "additional_vehicles_front" & "additional_vehicles_behind" options,
  - Now shows different customizable colors for
    player, leader, opponents on same lap or lapped,
    vehicles under yellow flag or in pit lane.
  - Now reads all vehicle info from Standings module.
  - Replaced "radar_scale" with new "global_scale" option,
    which sets global scale of radar display related to screen pixel.
    Default value is "6", which is 6 times of original size.
  - Changed "radar_radius" default value from 25 to 30.
  - Add "vehicle_border_radius" option,
    which sets vehicle visual round border radius.
  - Add "vehicle_outline_width" option,
    which sets vehicle visual outline width.
  - Add "show_overlap_indicator" option,
    which shows overlap indicator when there is nearby side by side vehicle.
  - Add "overlap_detection_range_multiplier" option,
    which sets overlap detection range multiplier that scales with vehicle width.
  - Add "indicator_size_multiplier" option,
    which sets indicator visual size multiplier that scales with vehicle width.
  - Changed "center_mark_radius" default value from 25 to 30.
  - Add "center_mark_width" option,
    which sets center mark line width in pixels.
  - Add "distance_circle_1_width", "distance_circle_2_width" options,
    which sets distance circle line width in pixels.
  - Add "center_mark_style" & "distance_circle_style" options.

* [New]Rake angle Widget
  - Show rake angle in degrees.

* Relative Widget
  - Now reads all vehicle info from Standings module.
  - Now all columns can be turned on or off, and every column color can be customized.
  - No longer show lap difference color in none race session.
  - Add "show_player_highlighted" option,
    which highlights player row with customizable specific color.
  - Add "show_lap_difference" option,
    which shows different font color based on lap difference between player and opponents. 
  - Add "show_position", "show_driver_name", "show_time_gap" options,
    which can be turned on or off individually.
  - Add "driver_name_uppercase" option,
    which sets driver name to uppercase.
  - Add "show_random_color_for_unknown_class" option,
    which show random color for unknown class name that is not defined in classes.json.

* [New]Ride height Widget
  - Show visualized ride height display.
  - Add "ride_height_max_range" option,
    which sets visualized maximum ride height range (millimeter).

* [New]Standings Widget
  - Most options are inherited from relative widget, with some additions noted below.
  - Add "max_vehicles_combined_mode" option,
    which sets maximum amount vehicles to display,
    which takes effect when "enable_multi_class_split_mode" is not enabled.
    When total vehicle number is lower than this value,
    extra rows will auto-hide.
    When total vehicle number is above this value,
    the top 3 vehicles will always show,
    and rest of the vehicles will be selected from
    the nearest front and behind places related to player.
  - Add "max_vehicles_split_mode" option,
    which sets maximum amount vehicles to display,
    which takes effect when in multi-class session and
    "enable_multi_class_split_mode" is enabled.
    If total vehicle number is above this value,
    any extra vehicles will not be shown.
    Default value is "50", which is sufficient in most case. 
  - Reworked "show_time_gap" option.
    For race session, this option shows time gap between leader and all other drivers.
    For other none race sessions, this option shows the time gap
    between session's best lap time and all other drivers.
  - Add "show_time_gap_from_class_best" option, which shows time gap
    from none race session's best lap time of the same vehicle class.
  - Add "time_gap_leader_text" option, which sets text indicator for race leader.
  - Add "time_gap_decimal_places" option, which sets amount decimal places to keep.
  - Add "show_time_interval" option,
    which shows time interval between each closest driver in order.

* Sectors Widget
  - Removed "show_position_lapnumber" option.

* Session Widget
  - Add "prefix_lap_number" & "prefix_position" options.
  - Improved lap number formatting.
  - Removed unnecessary zero padding and decimal places in session timer.

* Steering Widget
  - Add "bar_width" & "bar_height" options,
    which sets steering bar width & height in pixels.
  - Add "show_steering_angle" option,
    which shows steering angle text in degree.

* Stint history Widget
  - Separated tire compound display to its own column.
  - Adjusted default color theme.
  - Add "show_empty_history" which shows empty stint history.
    Default is False, which hides empty rows.

* Timing Widget
  - Show invalid last lap time indicate color (default red).

* [New]Track map Widget
  - Show current track map, which the map is recorded & read from Mapping module.
  - Shows different customizable colors for
    player, leader, opponents on same lap or lapped,
    vehicles under yellow flag or in pit lane.
  - Add "show_background" option, which shows track map background.
  - Add "area_size" option, which sets area display size.
  - Add "area_margin" option, which sets area margin size.
  - Add "map_width" option, which track map line width.
  - Add "map_outline_width" option, which sets track map outline width.
  - Add "show_start_line" option, which shows start line mark.
  - Add "show_sector_line" option, which shows sector line mark.
  - Add "show_vehicle_standings" option, which shows vehicle standings info on map.

* [New]Tyre load Widget
  - Show visualized tyre load display.
  - Add "show_tyre_load_ratio" option,
    which shows percentage ratio of tyre load between each and total tyre load.
    Set "false" to show individual tyre load in Newtons.

* Tyre pressure Widget
  - Renamed old "Pressure widget" to "Tyre pressure Widget"

* Tyre temperature Widget
  - Add "heatmap_name" option, which user can assign a custom heatmap preset.
  - Renamed "color_swap" option to "swap_style",
    which swaps heatmap color between font & background color.
  - Renamed "ICO_mode" option to "show_inner_center_outer",
    which sets inner, center, outer temperature display mode.

* Wheel alignment Widget
  - Renamed old "Wheel widget" to "Wheel alignment Widget".

* Misc
  - Updated Customization guide.
  - Updated README.
  - Updated THIRDPARTYNOTICES and licenses.
  - Removed feature.md, feature info can be found in Customization guide.
  - Updated "icon_instrument.png" with slightly adjustments.
  - Moved icon.png & icon.ico file into "images" folder.
  - Updated executable building script.


1.12.1 (2023-04-07)
-----------------------------
* Relative Widget
  - [New]Add "hide_vehicle_in_garage_for_race" option in JSON,
    which hides vehicles that are stored in garage stall during race (for example, DNF or DQ).
    This option is enabled by default, set to false to disable.

* Hybrid Widget
  - Use plus/minus sign for regen/drain display.

* Core
  - Remove always on top on main(preset) window. (by Bernat)
  - Fixed an issue where app would fail to run if the current working directory isn't the app directory. (by Bernat)
  - Fixed deltabest being interrupted by mid-joining in multiplayer session.
  - Add "Quit" to Config menu in preset window.

* pyRfactor2SharedMemory library
  - Now always stores a separate copy of verified local-player-only data.

* Misc
  - Update README with install instruction for Linux. (by Bernat)
  - Updated customization guide for Relative Widget.

1.12.0 (2023-04-05)
-----------------------------
* [New]Hybrid Widget
  - Show percentage available battery charge.
  - Show percentage battery charge drained in current lap.
  - Show percentage battery charge regenerated in current lap.
  - Show boost motor temperature with customizable unit & overheating indicator.
  - Show boost motor cooler water temperature with customizable unit & overheating indicator.
  - Show boost motor RPM.
  - Show boost motor torque.
  - Show boost motor activation timer.

* [New]P2P Widget
  - Show percentage available battery charge.
  - Show battery drain & regen color indicator.
  - Show P2P (boost motor) activation timer.
  - Customizable P2P activation threshold options.

* Sector Widget
  - Fixed a typo that caused wrong sector index reading.

* Core
  - [New]Add installer script for Linux (by Bernat).
  - [New]Add battery module for calculating battery charge usage.

* pyRfactor2SharedMemory library
  - Add hybrid related entries.
  - Fixed ctypes data types for linux (by Bernat).

* Misc
  - Updated customization guide for Hybrid & P2P Widget.
  - Updated feature.md.

1.11.8 (2023-04-01)
-----------------------------
* Core
  - Fixed an issue where deltabest & fuel delta values would briefly jump around when crossing start/finish line.
  - Fallback to index 99 if player index not found.

1.11.7 (2023-03-22)
-----------------------------
* Gear Widget
  - Add "neutral_warning_time_threshold" additional condition check option in JSON,
    which activates color warning when both speed & time-in-neutral is higher than threshold.
    This helps avoid displaying color warning during normal shifting.
    Default value is "0.3" seconds.

* Core
  - Fixed an index out of range error that related to mSector data,
    which could cause Sector & Flag Widget to freeze.

* Misc
  - Updated customization guide for Gear Widget.

1.11.6 (2023-03-10)
-----------------------------
* Radar Widget
  - Add "auto_hide" option in JSON (default ON),
    which auto hides radar display when no nearby vehicles.
  - Add "auto_hide_time_threshold" option,
    which sets amount time(unit second) before triggering auto hide.
  - Add "minimum_auto_hide_distance" option,
    which sets minimum straight line distance(unit meter) before triggering auto hide.
    Set -1 value to auto scale with "radar_radius" value. Default value is -1.
  - Replaced "vehicle_scale" with new "radar_scale",
    which sets global scale of radar display.
  - Replaced "area_scale" with new "radar_radius",
    which sets radar display area by radius(unit meter).
  - Add "center_mark_radius" option,
    which sets center mark size by radius(unit meter).
  - Add "show_distance_circle" option,
    which shows 2 distance circles for distance reference.
  - Add "distance_circle_1_radius" & "distance_circle_2_radius" option,
    which sets distance circle size by radius(unit meter).
    Distance circle will not be displayed if radius is bigger than "radar_radius".

* Misc
  - Updated customization guide with new configurable options for Radar Widget.

1.11.5 (2023-03-08)
-----------------------------
* pyRfactor2SharedMemory library
  - Fixed a data freeze issue that caused by mismatched player's index between rF2Scoring & rF2Telemetry.
  - Now keeps two separate player's index values of the same local player, one for rF2Scoring, one for rF2Telemetry.
  - Add new mID matching method that uses rF2Scoring player's index
    to match the same mID and retrieves correct player's index in rF2Telemetry,
    which can also be used to match remote player's index in rF2Telemetry.

* Core
  - Updated relative module to use the new mID matching method.

1.11.4 (2023-03-07)
-----------------------------
* Brake Widget
  - Fixed wrong heatmap color display for Fahrenheit temperature unit.

* Relative Widget
  - [New]Add "show_pit_request" option in JSON,
    which shows pit request color indicator on pitstop count column.
  - [New]Add "show_pit_timer" option in JSON,
    which shows pit timer on last laptime column.
  - [New]Add "pit_time_highlight_duration" option in JSON,
    which sets highlight duration for total amount time spent in pit after exit pit.

* Stint Widget
  - [New]Add "stint_history_count" option in JSON,
    which sets the number of stint history display. Default is to show 2 most recent stints.
  - [New]Add "minimum_stint_threshold_minutes" option in JSON,
    which sets the minimum stint time threshold in minutes for updating stint history.
    This only affects ESC.
  - [New]Add "layout" option with 2 available layouts: vertical & reversed vertical.
  - Only update data when not in garage.

* Temperature Widget
  - Fixed wrong heatmap color display for Fahrenheit temperature unit.

* pyRfactor2SharedMemory library
  - Corrected "ctypes data types" in rF2data.py to match "C data types" in rF2State.h from Sharedmemory Plugin.
  - Reverted back to mIsPlayer finding method, removed unused code.
  - Auto set driving status to False after 3 seconds without receiving new data.

* Misc
  - Updated customization guide with new configurable options for Relative & Stint Widget.

1.11.3 (2023-02-26)
-----------------------------
* Radar Widget
  - [New]Now supports displaying up to 126 nearby vehicles! (63 front & 63 behind vehicles).
  - Significantly improved & optimized drawing methods.

* Relative Widget
  - [New]Now dynamically generates relative players list that supports
    displaying up to 126 nearby players! (63 front & 63 behind players).
  - All players on relative list are properly sorted by
    relative distance between each opponent and local player vehicle,
    which also fixed an issue that players list previously
    would jump around the moment crossing finish line.
  - Fixed an issue where sometimes lap difference & color indicator won't get updated.

* Core
  - Various small improvements.

* pyRfactor2SharedMemory library
  - Now uses player name matching for finding player index.

* Misc
  - Updated customization guide with new info for Radar & Relative Widget.
  - Updated feature.md.

1.11.1 (2023-02-20)
-----------------------------
* Core
  - Add delayed setting saving method that limits to one save operation for a given period.
  - Now verifies setting file after saving, and retries if errors found (3 attempts).

1.11.0 (2023-02-16)
-----------------------------
* General
  - Added "column_index" option for most widgets.
  - Added "text_padding" option for most widgets,
    which sets text edge padding value that multiplies & scales with "font_size".
    This option affects how compact widget looks.
    Default is "0.2" for most widgets.
  - Added individual font & background color options for most widgets.
  - Each info display can be individually disabled for most widgets.

* [New]Brake Widget
  - Separated Brake temperature info from Temperature Widget to the new Brake Widget.
  - [New]Show average brake temperature of current lap that calculated in realtime.
  - [New]Highlighting average brake temperature from previous lap after crossing start/finish line.
  - Show/hide degree sign for maximum compact looking.
  - Added "leading_zero" and more options in JSON.

* Engine Widget
  - [New]Added horizontal layout.
  - [New]Added "turbo_pressure_unit" option (bar, psi, kPa) in JSON, default is bar.
  - [New]Added Fahrenheit unit for temperature display via "temp_unit" in JSON.

* [New]Flag Widget
  - Separated flag, pit status, start lights info from Gear Widget to the new Flag Widget.
  - Show pit timer, and total amount time spent in pit after exit pit.
  - Show low fuel indicator when fuel level is below certain amount value.
  - Show speed limiter indicator.
  - Show yellow flag indicator of current & next sectors.
  - Show blue flag indicator with timer.
  - Show race start lights indicator with light frame number for standing-type start.
  - Show race start countdown timer for standing-type start.
  - Two layouts option (vertical & horizontal).

* Force Widget
  - [New]Added horizontal layout.

* Fuel Widget
  - [New]Added "low_fuel_lap_threshold" option in JSON.

* Gear Widget
  - [New]Added "neutral_warning_speed_threshold" option in JSON,
    which sets speed threshold value for color warning
    when gear is in neutral and vehicle speed is higher than the threshold.
    Speed unit in meters per second. Default value is "28", which is close to 100 kph.
    This option is helpful for situation where player mis-shifted gear into neutral at high speed.
  - Added "show_speed_limiter" option in JSON, which can be turned off.

* Instrument Widget
  - [New]Each instrument icon can be individually hide in JSON.

* Pedal Widget
  - [New]Added "show_brake_pressure" option in JSON that
    shows brake pressure changes applied on all wheels,
    which auto scales with max brake pressure and
    indicates amount brake released by ABS on all wheels.
    This option is enabled by default, which replaces
    game's filtered brake input that cannot show ABS.

* Pressure Widget
  - [New]Show percentage brake pressure of each wheel.
  - Tyre load ratio is now calculated against sum of all wheels load.
  - Reworked layouts (vertical & horizontal).
  - [New]Added "show_caption" option in JSON.

* Relative Widget
  - Removes brackets from combined driver name if name is empty.

* Sectors Widget
  - Removed unnecessary "show_best_sector_time" option,
    always shows each best sector time if available.

* Steering Widget
  - [New]Added "scale_mark_degree" option in JSON,
    which set gap between each scale mark in degree.

* Stint Widget
  - Removed "fuel_unit" option, now uses fuel unit setting from Fuel Widget instead.

* [New]Suspension Widget
  - Separated Ride height & Rake angle info from Wheel Widget to the new Suspension Widget.
  - [New]"ride_height_offset" option is now available for all wheels.
  - [New]Separated warning color options as "warning_color_bottoming" for Ride height
    and "warning_color_negative_rake" for Rake angle.
  - [New]Added "show_caption" option in JSON.

* Temperature Widget
  - [New]Added "ICO_mode" option which shows full tyre temperature display mode (inner/center/outer).
  - [New]Added "show_innerlayer" option which shows tyre inner layer temperature.
  - [New]Added "show_tyre_compound" option which shows tyre compound index letter (front/rear).
  - [New]Show/hide degree sign for maximum compact looking.
  - [New]Added "leading_zero" and more options in JSON.
  - Removed Brake temperature info.

* Timing Widget
  - [New]Show current session best laptime from all vehicle classes,
    with additional option to show laptime from same vehicle class only (default ON).
  - [New]Each info prefix text can be customized or hide in JSON.
  - Removed double lines horizontal layout.

* Wear Widget
  - Adjusted options naming in JSON.
  - [New]Added "show_caption" option in JSON.

* Weather Widget
  - Moved "Dry/Wet" label to wetness bar.
  - [New]Show/hide percentage sign for maximum compact looking.

* Core
  - Optimized GUI update methods for all widgets with over 50% less CPU usage.
  - Auto sorts all options in JSON file according to default setting template
    for better readability and consistency.
  - Add Linux instructions to README.md (by Bernat).
  - Improved various calculation.
  - Fixed setting loading errors.
  - Fixed a hanging problem if no widgets enabled while exiting APP.

* pyRfactor2SharedMemory library
  - Fallback to mID matching if mIsPlayer fails to retrieve player index.
  - Add additional auto restart condition check for sharedmemory mapping.

* Misc
  - Updated customization guide with new configurable options for each widget.
  - Updated feature.md.

1.10.3 (2023-01-31)
-----------------------------
* Relative Widget
  - [New]Implemented lazy GUI update method that reduces Relative Widget CPU usage by 80% more.
  - [New]Added pitstop count display (requested by srlemke),
    re-arranged column index order to fit pitstop count display.
  - [New]Added "driver_name_mode" customization options in JSON file,
    which can be set to display either driver name, vehicle(livery) name, or combined (requested by MMartin & srlemke).
  - Added additional customization options.

* Sectors Widget
  - Now freezes and shows current lap fastest speed (thanks to Piervit's suggestion),
    and auto resets when a new lap begins.
  - Now validates session fastest speed at beginning of a new lap,
    and auto restores valid session fastest speed for fastest speed found from invalid lap.
  - Speed value now shows an additional decimal place for more accurate reading.

* Core
  - Fixed alpha opacity issue under linux (by Bernat).

* Misc
  - Updated customization guide with new configurable options.

1.10.2 (2023-01-29)
-----------------------------
* Preset manager
  - [New]Add menu bar with same functionality as tray icon menu for all platform,
    which substitutes tray icon for none-windows platform.
  - Now handles all underlaying widget & module & APP control. 

* Sectors Widget
  - Properly saves current session fastest top speed from valid lap.

* Customization
  - Added "transparent_color" setting in JSON config file.
    This setting is meant to be used by none-Windows platform
    where transparent background color is not supported,
    and user may customize a substitute color.

* Core
  - Added initial cross platform support (by Bernat).
  - Rewritten & improved code structure to support cross platform.
  - Fixed a widget position reset issue that can occur if auto-hide is enabled
    while launching the APP or reloading a preset.

* Misc
  - Updated contributors.md with new contributor (Bernat).
  - Updated customization guide with new configurable setting.

1.10.1 (2023-01-14)
-----------------------------
* Core
  - Fixed invalid deltabest & fuel data filename that contains special characters,
    which would cause saving & loading error.
  - Improved calculation for cruise, pedal, pressure, temperature, wheel widgets.

1.10.0 (2022-12-09)
-----------------------------
* [New]Sectors Widget (created by Nibo)
  - Show accumulated target sector time, with two available options:
      * Show theoretical best sector time from best sectors of current session.
      * Show sector time from personal best laptime of current session.
  - Show accumulated current sector time.
  - Show sector/laptime gap comparing to sector time from personal best laptime of current session.
    Default is set to show for 5 seconds after done previous sector.
    Can be set to always show in config file.
  - Show theoretical best sector time of each sector on 3 separated sector bars.
  - Show sector time gap against session best sector time on sector bars.
  - Auto-freeze previous sector display for 5 seconds after done previous sector.
    Freeze duration can be customized in config file.
  - Auto save "best laptime", "best sector time","personal best sector time" of current session
    in config file when player returns to garage screen, and (re)load when player on track.
    Note: All the saved data is only valid for current session or car/track combo,
          and will be reset if current session ends or car/track combo changes,
          similar to how game handles those data.
  - Show optional current vehicle speed & session fastest speed.
  - Show optional local driver position standing & current lap number, similar to Session Widget.

* Gear Widget
  - Fixed indicators would not hide under certain condition.

* Core
  - [New]Added Sectors options in setting file.
  - Improved laptime format method for various widgets.

* pyRfactor2SharedMemory library
  - Now periodically check & compare shared memory data version.
  - Auto restart memory mapping if data version stopped updating after a period of time.
    This helps avoid data freeze issue during various situation,
    and unexpected lost connection or game crash will no longer cause auto-hide malfunction.

* Misc
  - Updated customization guide with new configurable setting for Sectors Widget.
  - Updated feature.md for Sectors Widget.
  - Updated contributors.md with new contributor (Nibo).

1.9.5 (2022-11-24)
----------------------------
* Fuel Widget
  - [New]Show "estimated fuel consumption" that is constantly updated and calculated
    against the new fuel delta consumption data from last recorded lap.
    The new estimated value replaces the old "last lap fuel usage" value and more accurately reflects
    how each fuel info changes with driver's input or engine mixture levels, etc.
  - [New]Fuel consumption & last laptime values are now stored inside new fuel delta consumption file,
    which corresponds to each matching vehicle-track combo and auto-loads while driving.
    User can quickly jump back in a previously driven combo with all fuel consumption data available right away.

* Core
  - [New]Added fuel consumption recording & delta calculation functions to Fuel module.
  - [New]Fuel delta consumption file is now saved in "TinyPedal\deltabest" folder with *.fuel extension,
    Note: For accuracy purpose, only the fuel delta consumption data from most recent complete lap
          will be recorded and used for delta consumption calculation. 
          This includes full laps that have exceeded track limits, but excludes pitin & pitout laps.
  - Fixed an error that occurred after toggle auto-hide and reload preset.
  - Improved auto-hide function.
  - Improved deltabest recording methods.
  - Removed "fuel_consumption" value from fuel section of setting file.
  - Removed "last_laptime" value from timing section of setting file.

* Misc
  - Updated documents.

* pyRfactor2SharedMemory library
  - Further improved synced methods for reading local player info.
  - Separated none-synced methods from player-synced methods to be compatible
    with apps or functions that uses none-synced methods.
    Note: TinyPedal now uses player-synced methods for reading shared memory.

1.9.4 (2022-11-20)
----------------------------
* pyRfactor2SharedMemory library
  - Fixed "players_mid" variable that could be referenced before assign.

1.9.3 (2022-11-20)
----------------------------
* Core
  - Auto-hide function is reverted back to previous method,
    which depends on player's engine ignition status.
  - Removed all previous driver status check methods,
    as new changes to pyRfactor2SharedMemory library has fixed the issue
    that associated with players joining or disconnecting from server.
  - Now also shows data while "Toggle AI control" enabled.

* pyRfactor2SharedMemory library
  - All Telemetry & Scoring info is now constantly updated in a separated thread.
  - Now uses deep copy on Telemetry & Scoring info
    and verifies mVersionUpdate values to avoid data changes or corruption.
  - Now finds player's index number against a single Scoring info piece.
    Previously this was not done on a single info piece,
    which data could be changed or corrupted while checking.
  - Now uses player's mID from the verified Scoring info
    and compares with the mID from Telemetry info to ensure
    all assigned Telemetry & Scoring info data is correctly synced to local player.

1.9.2 (2022-11-19)
----------------------------
* Preset manager
  - [New]TinyPedal now supports reload & change preset while running.
  - [New]Added "Load Preset" to tray icon menu.
  - Preset manager window no longer opened at launch. TinyPedal will always load last used preset at launch.
  - Due to limitation, active preset name no longer shows on tray icon menu.

* Wear Widget
  - [New]Added "show_lifespan" option to show estimated tyre lifespan in laps.
  - [New]Added "show_realtime_wear" option to show current lap tyre wear that constantly updated in realtime.
  - [New]Added additional "font_color" & "warning_threshold" and many more customization options.
  - Improved and more accurate tyre wear calculation.
    Properly calculates tyre wear for pit in & out lap.
  - Reduced custom layouts to 2 variations, but added new customizable column order.

* Core
  - Auto-hide function is now based on game's FFB output value for high accuracy and stability.
  - Added multiple local driver status check method to eliminate data interrupting
    when other players have joined or disconnected from server.
  - Fixed incorrect laptime validation duration for deltabest module.
    Best laptime data is now saved right after validation.
  - Significantly improved code structure.
    All threads are now properly closed before exiting.

* pyRfactor2SharedMemory library
  - Added additional code to properly close shared memory mapping before exiting.
  - Added number of vehicles difference check.
  - Increased max player index check to 128.

* Misc
  - Updated customization guide with new configurable setting for Wear Widget.

1.9.0 (2022-11-07)
----------------------------
* [New]Preset manager
  - Added new "Preset" list window when launching TinyPedal,
    where user can load exist preset, or create new preset.
    Preset files are sorted by last modified date.
  - All JSON preset files are now saved in "TinyPedal\settings" folder.
    User may manually move all old JSON files into "settings" folder.
    Note: Preset manager does not provide file delete function (to avoid accidental deletion).

* Core
  - [New]Tray icon menu now shows current preset name.
  - [Critical]Fixed an issue that could cause deltabest module to stop updating.
  - Many improvements.

* Misc
  - Updated py2exe building script to use new "freeze" (py2exe v0.12 and above).
  - Updated third-party software libraries.
  - Updated customization guide with info about the new preset manager.

1.8.1 (2022-11-01)
----------------------------
* Core
  - Improved auto-hide function & player status check.
  - Added additional player data verification for deltabest & fuel modules.

* pyRfactor2SharedMemory library
  - [New]Added an argument to pass rf2 PID to SimInfo for reading data from dedicated server.

1.8.0 (2022-10-07)
----------------------------
* Relative Widget
  - [New]Relative Widget now displays up to 6 additional players (3 front & 3 behind, total 13),
    which is customizable via new "additional_players_front" & "additional_players_behind" option in config.json.
    Default is set to show 0 additional players. See customization guide for details.

* Radar Widget
  - [New]Radar Widget now displays up to 18 additional vehicles (9 front & 9 behind, total 25),
    which is customizable via new "additional_vehicles_front" & "additional_vehicles_behind" option in config.json.
    Default is set to show 8 additional vehicles (4 front & 4 behind). See customization guide for details.

* Core
  - Updated Relative Module to support additional players/vehicles display for Relative Widget & Radar Widget.

* Misc
  - Updated customization guide with new configurable setting for Relative & Radar Widget.

1.7.0 (2022-10-03)
----------------------------
* [New]Fuel Module
  - Moved all fuel usage calculation into the new separated "Fuel Module"
    which runs in a separated thread at a much higher 1000hz refresh rate.
  - Fuel Widget as well as other Widgets now have access to fuel usage info from this module.
  - Ignores pit-in & pit-out lap for more accurate fuel usage report for endurance race. 

* Gear Widget
  - [New]Display low fuel warning beside speed gauge. Default is set to show only for race.
  - [New]Display blue flag warning with customizable text beside speed gauge. Default is set to show only for race.
  - [New]Display sector-based yellow flag warning beside speed gauge. Default is set to show only for race.
  - [New]Added "font_weight_indicator" setting for customizing indicator font weight separately.
  - [New]Added "font_color_speed_limiter" & "bkg_color_speed_limiter" for speed limiter indicator.
  - [New]Added large amount customizable options for new indicators,
    see Gear section in customization guide for details.

* Misc
  - Updated customization guide with new configurable setting for Gear Widget.
  - Updated features list.

1.6.10 (2022-09-30)
----------------------------
* Core
  - Extended laptime validation period from 2s to 8s in case of game's new cut detection being triggered.
  - Improved Relative module structure.

* pyRfactor2SharedMemory library
  - Added numeric validation for every sharedmemory data input to eliminate data reading errors during game crash, freeze or unexpected interruption.

1.6.9 (2022-09-11)
----------------------------
* Core
  - Fixed an empty list issue that can result "list index out of range" in Relative module.

1.6.8 (2022-09-03)
----------------------------
* Core
  - Fixed a "list index out of range" issue in Relative module when client lost connection from server.

1.6.7 (2022-08-15)
----------------------------
* Relative Widget
  - [New]Add tyre compound index (front/rear) column with customizable compound letter & color in config.json.
    Note: due to this addition and changes to column order, it is advised to double check for column_index values
    set in config.json to avoid column overlapping.
  - [New]Add "bar_time_gap_width" option in config.json for relative time gap, default value is 5 (char width).

* Core
  - Improved "Time Gap" calculation in Relative module.

* Misc
  - Updated customization guide with new configurable setting for Relative Widget.
  - Updated features list.

1.6.6 (2022-07-31)
----------------------------
* Instrument Widget
  - Improved wheel radius calculation.
  - Now refreshes wheel radius reading when current number of recorded samples has reached "minimum_samples" value,
    which helps make slip indicator more responsive and accurate.

* Cruise Widget
  - Removed some useless calculation.

* Core
  - Fixed a typo that could cause "list index out of range" error in Relative module.

* Misc
  - Minor changes to customization guide.

1.6.5 (2022-07-16)
----------------------------
* Cruise Widget
  - [New]Add "track_clock_time_scale" setting in config.json for time scaled session.
    Default value = 1, which matches "Time Scale: Normal" setting in-game.

* Relative Widget
  - Empty row now has default background color.

* Misc
  - Updated customization guide with new configurable setting for Cruise Widget.

1.6.4 (2022-07-08)
----------------------------
* Core
  - Fixed a rare "list index out of range" error in Relative module when player has lost connection from a server,
    which would stop relative date from updating.

1.6.3 (2022-07-03)
----------------------------
* Core
  - Deltatime module now stores last laptime value to "last_laptime" key value in "timing" section of config.json.
  - Both Fuel & Timing Widget can read this saved last laptime value from Deltatime module & config.json.
  - Estimated laps & time for a given amount fuel can now be accurately calculated & displayed
    based on existing saved last laptime without having to do any additional laps.
  - Fixed a NaN value error that can happen if game crashes.
  - Optimized data handling for Relative module, Radar Widget, Relative Widget.

* Misc
  - Updated customization guide with new configurable setting for Timing Widget.

1.6.2 (2022-06-30)
----------------------------
* Gear Widget
  - [New]Add Startlights display with 20ms(50fps) accuracy, which works the same way as how the game is designed.
  - Race Countdown timer feature is no longer enabled by default, which now requires a special code to enable it.
    See customization guide for details.
  - Fixed missing custom background settings.

* Core
  - Increased Deltatime module refresh rate from 10ms to 1ms.

* Misc
  - Updated customization guide with new configurable setting for Gear Widget.

1.6.1 (2022-06-29)
----------------------------
* Instrument Widget
  - Add new "minimum_speed" setting in config file, default value is 16.5 (m/s),
    which is the minimum speed threshold before APP can record wheel radius samples.
  - Add new "minimum_samples" setting in config file, default value is 400,
    which is the minimum number of radius samples that required for calculating average wheel radius. 
  - Both settings significantly increase accuracy of wheel radius reading.

* Gear Widget
  - [New]Add an optional Race Countdown timer for standing-type start only(includes formation/standing),
    which only shows during countdown game phase, and has a 20ms(50fps) accuracy.
  - Add "show_countdown" setting in config, set value to false to disable Race Countdown timer.
    Note:
    * Countdown timer is calculated using the formula below,
      Seconds to start = mLapStartET - mElapsedTime
    * Both mLapStartET & mElapsedTime values are part of rF2's standard API.

* Wheel Widget
  - Fixed wrong "rideheight_offset_rear" reference.

* Core
  - Various optimization.

* Misc
  - Updated customization guide with new configurable setting for Gear & Instrument Widget.

1.6.0 (2022-06-24)
----------------------------
* [New]Instrument Widget
  - Show Headlights state.
    When Headlights on, icon turns white.
  - Show Ignition & Starter state.
    When Ignition on, icon turns white.
    When Ignition on while Engine off, icon background turns green (default color).
  - Show Auto-Clutch state.
    When Auto-Clutch on, icon turns white.
    When Clutch pressed, icon background turns cyan (default color).
  - Show Wheel Lock state.
    When Brake pressed and Slip Ratio reaches threshold, icon background flashes red (default color).
  - Show Wheel Slip state.
    When Slip Ratio reaches threshold, icon background flashes yellow (default color).
  - Include many customizable options.
  - New instrument icon by Xiang.

* Cruise Widget
  - [New]Show current in-game clock time of the circuit.

* Core
  - Fixed an issue where Deltatime module would fail to record deltabest laptime
    for point to point tracks after certain amount driven distance.
  - Various optimization.
  - Updated build_py2exe.py script.

* Misc
  - Updated customization guide with new configurable setting for Instrument & Cruise Widget.
  - Updated features.md with Instrument Widget info.
  - Updated README.md.

1.5.1 (2022-06-08)
----------------------------
* Radar Widget
  - Now draw vehicle orientation relative to player vehicle.

1.5.0 (2022-06-07)
----------------------------
* [New]Radar Widget
  - Show car radar that displays relative position of player's vehicle against up 6 nearby vehicles.
  - Vehicle changes color if is laps ahead or behind player.
  - Fully customizable size & scale.
  - Default refresh rate at 50 fps.
  - Show center mark.

* Core
  - Deltatime module is now named realtime_delta, and as delta_module in config.ini file.
  - Moved all "relative list" code to new realtime_relative module, added relative_module in config.ini file.
  - Both Relative & Radar widgets now read data from realtime_relative module,
    and calculation is done in a separated thread at constant 5fps(the limit of API).

* Misc
  - Updated customization guide with new configurable setting for Radar Widget.
  - Updated features.md with Radar Widget info.

1.4.2 (2022-06-06)
----------------------------
* Core
  - Replaced mInRealtimeFC with mIgnitionStarter for player status check and auto-hide function.

1.4.1 (2022-06-05)
----------------------------
* Core
  - Removed additional player index check that freezes overlay update.
    Overlay now works correctly with Driver Swap.

1.4.0 (2022-06-01)
----------------------------
* [New]Cruise Widget
  - Show compass directions with three-figure bearings that matches game's cardinal directions.
  - Show elevation difference in game's coordinate system, with meter or feet as display unit.
  - Show odometer that displays total driven distance of local player, with km or mile as display unit.

* Fuel Widget
  - Now auto-saves & loads last lap fuel consumption.

* Core
  - Added additional player status check to make sure only valid data gets updated to overlay.
  - Further improvements to deltabest laptime validation.
  - Add new function that constantly recording meters driven by player for deltatime module.
  - Improved module import order.

* Misc
  - Updated customization guide with new configurable setting for Cruise & Fuel Widget.
  - Updated features.md with Cruise Widget info.

1.3.3 (2022-05-28)
----------------------------
* Core
  - Added additional best laptime validation condition for deltabest module
    that fixed invalid deltabest laptime being saved in some rare cases. 

1.3.2 (2022-05-24)
----------------------------
* Core
  - Add additional player index check before refreshing overlay data,
    to avoid data mismatch that could happen in a multiplayer session
    due to player index change.

1.3.0 (2022-05-16)
----------------------------
* [New]Stint Widget
  - Show realtime stint data, includes:
    * front & rear tire compound index, with customizable letter.
    * total driven laps.
    * total driven time (min:sec).
    * total used fuel in liters or gallons.
    * total average tire wear.
  - Show "last stint" data bar that displays last full stint.
  - Note:
    * All current stint data resets when player makes a full-serviced pit stop (either refueled or tire changed).
    * Current stint data will only be transferred and displayed in "last stint data" bar, if player makes a full-serviced pit stop.
    * ESC & restarting in a session or race will not have stint data transferred to "last stint data".
      This is to prevent incomplete or useless data from overriding normal last stint data.
    * Currently, stint data is not saved to external file.

* Misc
  - Updated customization guide with new configurable setting for Stint Widget.
  - Updated features.md with Stint Widget info.

1.2.0 (2022-05-06)
----------------------------
* [New]Session Widget
  - Show current system clock time, with customizable time format.
  - Show session timer, accuracy is limited by 200ms refresh rate of rF2 API.
  - Show driver's current lap number & max laps (if available), with customizable lap number description text.
  - Displays warning color if driver is about to exceed max-lap in qualify (or indicates the last lap of a lap-type race).
    Note: if warning color appears in qualify, it means you have already reached max allowed laps.
          Do not attempt to across finish line, but ESC immediately to avoid DQ.
  - Show driver's current place against all drivers in a session.

* Misc
  - Updated customization guide with new configurable setting for Session Widget.
  - Updated features.md with Session Widget info.

1.1.11 (2022-05-03)
----------------------------
* Pressure Widget
  - [New]Add option to display tyre load percentage ratio between left & right tyres of same axle (default on).

* Core
  - Added APP running status check when starts TinyPedal,
    and shows notify & closes APP to prevent multiple TinyPedal APP from running at same time.
  - Removed unnecessary method from deltatime module.

* pyRfactor2SharedMemory library
  - Now constantly updating player index number in a separated thread at 10ms refresh rate,
    which helps reduce large amount unnecessary repeated function calls.
  - Removed additional player index code that could freeze data reading in rare cases.
  - Removed duplicated calls to playersDriverNum() method.

* Misc
  - Updated customization guide with new configurable setting for Pressure Widget.
  - Add new contributor to contributors.md.

1.1.10 (2022-04-19)
----------------------------
* Core
  - Fixed shared memory access issue that freezes APP when a player leaves server in multiplayer session.
  - Improved relative calculation code.

1.1.9 (2022-04-18)
----------------------------
* Relative
  - Fixed a player index mismatch issue that happens in multiplayer session when a player leaves server,
    which interrupts Relative data calculation and halt APP.

* Core
  - Improved setting code, removed unnecessary setting groups.
  - Optimized widget code structure, removed redundant codes, easier to create new widget.
  - Simplified widget module import method, removed repetitive references.
  - Improved setting auto-sorting, moved "overlay" setting back to the top of the JSON file.

1.1.8 (2022-04-17)
----------------------------
* Relative
  - [New]Show driver's position standing in class.
  - [New]Show pit status indicator whether driver is currently in pit, with customizable pit status text.
  - [New]Customizable column info display order.
  - "bar_driver_name_width" setting now trims out range chars.
  - Removed unnecessary laptime formatting, added string length slicing

* Core
  - [New]Add new "veh_class_info_list" algorithm to calculate position in class.
  - Moved place & class info to "veh_class_info_list".
  - Various code clean up.

* Misc
  - Updated customization guide with new configurable setting.
  - Updated features list.

1.1.7 (2022-04-16)
----------------------------
* Relative
  - Fixed a variable name typo from new setting code, which causes vehicle class not shown correctly.

* Core
  - Renamed various "temp" reference to "temperature" for temperature widget.

1.1.6 (2022-04-16)
----------------------------
* Core
  - New algorithm for handling setting validating.
  - Each widget setting is now separately validated.
  - Invalid & missing setting keys are removed or added individually,
    which helps for keeping valid widget setting untouched,
    and will benefit any future updates greatly.
  - Due to this new validating method, it is now recommended to exit APP
    before manually saving changes to JSON file.

* Misc
  - Updated document files to reflect the new changes to setting validating.

1.1.5 (2022-04-02)
----------------------------
* [New]Pressure widget
  - Tyre pressure is now a separated widget that shows pressure & load.
  - Tyre load display can be turned off separately.

* Wear Widget
  - Show new Tyre wear usage from last lap.
  - No longer shows Tyre pressure. 

* Core
  - [New]Add additional unit types (by thoraxe) for Fuel, Temperature, Weather widgets.
  - Improved laptime validating function for "deltatime" module.
  - Moved most string formatting from calculation.py to individual widgets,
    which avoids repetitive string & number conversion.
  - Updated setting entries & code cleanup

* Misc
  - Updated README.md, moved Feature section to features.md file.
  - Updated customization.md with new config options (by thoraxe).
  - Updated contributors.md with new contributor (thoraxe).

1.1.3 (2022-03-22)
----------------------------
* Core
  - Add laptime validating function for "deltatime" module.
    Invalid laptime will no longer be saved as best laptime.
    Delta best now fully works under any track or condition.

* Misc
  - Fixed a few typo in README.md & previous changelog.
  - Added missing contributors.md reference to build_py2exe.py.

1.1.0 (2022-03-21)
----------------------------
* [New]Delta best widget
  - Show delta best based on personal best laptime.
  - Show delta bar with customizable range, size and color.
  - Record, save, and load player's best laptime data automatically.
  - Best laptime file is stored in "deltabest" folder, and can be
    used by other players.
  - 2 different layouts.

* Core
  - Add "deltatime" module, which runs in separated thread at 100fps.
  - Add "delta_timing" switch in config.json.
  - Add auto-backup function for config.json.
  - Restructured "readapi" module.
  - Sort all widgets and references in alphabetical order.

* Timing widget
  - Add delta estimated laptime.
  - Add 3 different layouts.
  - Now reads timing data from deltatime module.

* Temperature widget
  - Add color swap setting in config.json, which swaps heat map color
    between font & background color.

* Fuel widget
  - Now reads mLapStartET from "Telemetry" which has higher accuracy.

* Wear widget
  - Add unit "bar" for tyre pressure.

1.0.0 (2022-03-14)
----------------------------
* Initial release

```

# File: images/CC-BY-SA-4.0.txt
```
Attribution-ShareAlike 4.0 International

=======================================================================

Creative Commons Corporation ("Creative Commons") is not a law firm and
does not provide legal services or legal advice. Distribution of
Creative Commons public licenses does not create a lawyer-client or
other relationship. Creative Commons makes its licenses and related
information available on an "as-is" basis. Creative Commons gives no
warranties regarding its licenses, any material licensed under their
terms and conditions, or any related information. Creative Commons
disclaims all liability for damages resulting from their use to the
fullest extent possible.

Using Creative Commons Public Licenses

Creative Commons public licenses provide a standard set of terms and
conditions that creators and other rights holders may use to share
original works of authorship and other material subject to copyright
and certain other rights specified in the public license below. The
following considerations are for informational purposes only, are not
exhaustive, and do not form part of our licenses.

     Considerations for licensors: Our public licenses are
     intended for use by those authorized to give the public
     permission to use material in ways otherwise restricted by
     copyright and certain other rights. Our licenses are
     irrevocable. Licensors should read and understand the terms
     and conditions of the license they choose before applying it.
     Licensors should also secure all rights necessary before
     applying our licenses so that the public can reuse the
     material as expected. Licensors should clearly mark any
     material not subject to the license. This includes other CC-
     licensed material, or material used under an exception or
     limitation to copyright. More considerations for licensors:
     wiki.creativecommons.org/Considerations_for_licensors

     Considerations for the public: By using one of our public
     licenses, a licensor grants the public permission to use the
     licensed material under specified terms and conditions. If
     the licensor's permission is not necessary for any reason--for
     example, because of any applicable exception or limitation to
     copyright--then that use is not regulated by the license. Our
     licenses grant only permissions under copyright and certain
     other rights that a licensor has authority to grant. Use of
     the licensed material may still be restricted for other
     reasons, including because others have copyright or other
     rights in the material. A licensor may make special requests,
     such as asking that all changes be marked or described.
     Although not required by our licenses, you are encouraged to
     respect those requests where reasonable. More considerations
     for the public:
     wiki.creativecommons.org/Considerations_for_licensees

=======================================================================

Creative Commons Attribution-ShareAlike 4.0 International Public
License

By exercising the Licensed Rights (defined below), You accept and agree
to be bound by the terms and conditions of this Creative Commons
Attribution-ShareAlike 4.0 International Public License ("Public
License"). To the extent this Public License may be interpreted as a
contract, You are granted the Licensed Rights in consideration of Your
acceptance of these terms and conditions, and the Licensor grants You
such rights in consideration of benefits the Licensor receives from
making the Licensed Material available under these terms and
conditions.


Section 1 -- Definitions.

  a. Adapted Material means material subject to Copyright and Similar
     Rights that is derived from or based upon the Licensed Material
     and in which the Licensed Material is translated, altered,
     arranged, transformed, or otherwise modified in a manner requiring
     permission under the Copyright and Similar Rights held by the
     Licensor. For purposes of this Public License, where the Licensed
     Material is a musical work, performance, or sound recording,
     Adapted Material is always produced where the Licensed Material is
     synched in timed relation with a moving image.

  b. Adapter's License means the license You apply to Your Copyright
     and Similar Rights in Your contributions to Adapted Material in
     accordance with the terms and conditions of this Public License.

  c. BY-SA Compatible License means a license listed at
     creativecommons.org/compatiblelicenses, approved by Creative
     Commons as essentially the equivalent of this Public License.

  d. Copyright and Similar Rights means copyright and/or similar rights
     closely related to copyright including, without limitation,
     performance, broadcast, sound recording, and Sui Generis Database
     Rights, without regard to how the rights are labeled or
     categorized. For purposes of this Public License, the rights
     specified in Section 2(b)(1)-(2) are not Copyright and Similar
     Rights.

  e. Effective Technological Measures means those measures that, in the
     absence of proper authority, may not be circumvented under laws
     fulfilling obligations under Article 11 of the WIPO Copyright
     Treaty adopted on December 20, 1996, and/or similar international
     agreements.

  f. Exceptions and Limitations means fair use, fair dealing, and/or
     any other exception or limitation to Copyright and Similar Rights
     that applies to Your use of the Licensed Material.

  g. License Elements means the license attributes listed in the name
     of a Creative Commons Public License. The License Elements of this
     Public License are Attribution and ShareAlike.

  h. Licensed Material means the artistic or literary work, database,
     or other material to which the Licensor applied this Public
     License.

  i. Licensed Rights means the rights granted to You subject to the
     terms and conditions of this Public License, which are limited to
     all Copyright and Similar Rights that apply to Your use of the
     Licensed Material and that the Licensor has authority to license.

  j. Licensor means the individual(s) or entity(ies) granting rights
     under this Public License.

  k. Share means to provide material to the public by any means or
     process that requires permission under the Licensed Rights, such
     as reproduction, public display, public performance, distribution,
     dissemination, communication, or importation, and to make material
     available to the public including in ways that members of the
     public may access the material from a place and at a time
     individually chosen by them.

  l. Sui Generis Database Rights means rights other than copyright
     resulting from Directive 96/9/EC of the European Parliament and of
     the Council of 11 March 1996 on the legal protection of databases,
     as amended and/or succeeded, as well as other essentially
     equivalent rights anywhere in the world.

  m. You means the individual or entity exercising the Licensed Rights
     under this Public License. Your has a corresponding meaning.


Section 2 -- Scope.

  a. License grant.

       1. Subject to the terms and conditions of this Public License,
          the Licensor hereby grants You a worldwide, royalty-free,
          non-sublicensable, non-exclusive, irrevocable license to
          exercise the Licensed Rights in the Licensed Material to:

            a. reproduce and Share the Licensed Material, in whole or
               in part; and

            b. produce, reproduce, and Share Adapted Material.

       2. Exceptions and Limitations. For the avoidance of doubt, where
          Exceptions and Limitations apply to Your use, this Public
          License does not apply, and You do not need to comply with
          its terms and conditions.

       3. Term. The term of this Public License is specified in Section
          6(a).

       4. Media and formats; technical modifications allowed. The
          Licensor authorizes You to exercise the Licensed Rights in
          all media and formats whether now known or hereafter created,
          and to make technical modifications necessary to do so. The
          Licensor waives and/or agrees not to assert any right or
          authority to forbid You from making technical modifications
          necessary to exercise the Licensed Rights, including
          technical modifications necessary to circumvent Effective
          Technological Measures. For purposes of this Public License,
          simply making modifications authorized by this Section 2(a)
          (4) never produces Adapted Material.

       5. Downstream recipients.

            a. Offer from the Licensor -- Licensed Material. Every
               recipient of the Licensed Material automatically
               receives an offer from the Licensor to exercise the
               Licensed Rights under the terms and conditions of this
               Public License.

            b. Additional offer from the Licensor -- Adapted Material.
               Every recipient of Adapted Material from You
               automatically receives an offer from the Licensor to
               exercise the Licensed Rights in the Adapted Material
               under the conditions of the Adapter's License You apply.

            c. No downstream restrictions. You may not offer or impose
               any additional or different terms or conditions on, or
               apply any Effective Technological Measures to, the
               Licensed Material if doing so restricts exercise of the
               Licensed Rights by any recipient of the Licensed
               Material.

       6. No endorsement. Nothing in this Public License constitutes or
          may be construed as permission to assert or imply that You
          are, or that Your use of the Licensed Material is, connected
          with, or sponsored, endorsed, or granted official status by,
          the Licensor or others designated to receive attribution as
          provided in Section 3(a)(1)(A)(i).

  b. Other rights.

       1. Moral rights, such as the right of integrity, are not
          licensed under this Public License, nor are publicity,
          privacy, and/or other similar personality rights; however, to
          the extent possible, the Licensor waives and/or agrees not to
          assert any such rights held by the Licensor to the limited
          extent necessary to allow You to exercise the Licensed
          Rights, but not otherwise.

       2. Patent and trademark rights are not licensed under this
          Public License.

       3. To the extent possible, the Licensor waives any right to
          collect royalties from You for the exercise of the Licensed
          Rights, whether directly or through a collecting society
          under any voluntary or waivable statutory or compulsory
          licensing scheme. In all other cases the Licensor expressly
          reserves any right to collect such royalties.


Section 3 -- License Conditions.

Your exercise of the Licensed Rights is expressly made subject to the
following conditions.

  a. Attribution.

       1. If You Share the Licensed Material (including in modified
          form), You must:

            a. retain the following if it is supplied by the Licensor
               with the Licensed Material:

                 i. identification of the creator(s) of the Licensed
                    Material and any others designated to receive
                    attribution, in any reasonable manner requested by
                    the Licensor (including by pseudonym if
                    designated);

                ii. a copyright notice;

               iii. a notice that refers to this Public License;

                iv. a notice that refers to the disclaimer of
                    warranties;

                 v. a URI or hyperlink to the Licensed Material to the
                    extent reasonably practicable;

            b. indicate if You modified the Licensed Material and
               retain an indication of any previous modifications; and

            c. indicate the Licensed Material is licensed under this
               Public License, and include the text of, or the URI or
               hyperlink to, this Public License.

       2. You may satisfy the conditions in Section 3(a)(1) in any
          reasonable manner based on the medium, means, and context in
          which You Share the Licensed Material. For example, it may be
          reasonable to satisfy the conditions by providing a URI or
          hyperlink to a resource that includes the required
          information.

       3. If requested by the Licensor, You must remove any of the
          information required by Section 3(a)(1)(A) to the extent
          reasonably practicable.

  b. ShareAlike.

     In addition to the conditions in Section 3(a), if You Share
     Adapted Material You produce, the following conditions also apply.

       1. The Adapter's License You apply must be a Creative Commons
          license with the same License Elements, this version or
          later, or a BY-SA Compatible License.

       2. You must include the text of, or the URI or hyperlink to, the
          Adapter's License You apply. You may satisfy this condition
          in any reasonable manner based on the medium, means, and
          context in which You Share Adapted Material.

       3. You may not offer or impose any additional or different terms
          or conditions on, or apply any Effective Technological
          Measures to, Adapted Material that restrict exercise of the
          rights granted under the Adapter's License You apply.


Section 4 -- Sui Generis Database Rights.

Where the Licensed Rights include Sui Generis Database Rights that
apply to Your use of the Licensed Material:

  a. for the avoidance of doubt, Section 2(a)(1) grants You the right
     to extract, reuse, reproduce, and Share all or a substantial
     portion of the contents of the database;

  b. if You include all or a substantial portion of the database
     contents in a database in which You have Sui Generis Database
     Rights, then the database in which You have Sui Generis Database
     Rights (but not its individual contents) is Adapted Material,
     including for purposes of Section 3(b); and

  c. You must comply with the conditions in Section 3(a) if You Share
     all or a substantial portion of the contents of the database.

For the avoidance of doubt, this Section 4 supplements and does not
replace Your obligations under this Public License where the Licensed
Rights include other Copyright and Similar Rights.


Section 5 -- Disclaimer of Warranties and Limitation of Liability.

  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE
     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS
     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF
     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,
     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,
     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR
     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,
     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT
     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT
     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.

  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE
     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,
     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,
     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,
     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR
     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR
     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR
     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.

  c. The disclaimer of warranties and limitation of liability provided
     above shall be interpreted in a manner that, to the extent
     possible, most closely approximates an absolute disclaimer and
     waiver of all liability.


Section 6 -- Term and Termination.

  a. This Public License applies for the term of the Copyright and
     Similar Rights licensed here. However, if You fail to comply with
     this Public License, then Your rights under this Public License
     terminate automatically.

  b. Where Your right to use the Licensed Material has terminated under
     Section 6(a), it reinstates:

       1. automatically as of the date the violation is cured, provided
          it is cured within 30 days of Your discovery of the
          violation; or

       2. upon express reinstatement by the Licensor.

     For the avoidance of doubt, this Section 6(b) does not affect any
     right the Licensor may have to seek remedies for Your violations
     of this Public License.

  c. For the avoidance of doubt, the Licensor may also offer the
     Licensed Material under separate terms or conditions or stop
     distributing the Licensed Material at any time; however, doing so
     will not terminate this Public License.

  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public
     License.


Section 7 -- Other Terms and Conditions.

  a. The Licensor shall not be bound by any additional or different
     terms or conditions communicated by You unless expressly agreed.

  b. Any arrangements, understandings, or agreements regarding the
     Licensed Material not stated herein are separate from and
     independent of the terms and conditions of this Public License.


Section 8 -- Interpretation.

  a. For the avoidance of doubt, this Public License does not, and
     shall not be interpreted to, reduce, limit, restrict, or impose
     conditions on any use of the Licensed Material that could lawfully
     be made without permission under this Public License.

  b. To the extent possible, if any provision of this Public License is
     deemed unenforceable, it shall be automatically reformed to the
     minimum extent necessary to make it enforceable. If the provision
     cannot be reformed, it shall be severed from this Public License
     without affecting the enforceability of the remaining terms and
     conditions.

  c. No term or condition of this Public License will be waived and no
     failure to comply consented to unless expressly agreed to by the
     Licensor.

  d. Nothing in this Public License constitutes or may be interpreted
     as a limitation upon, or waiver of, any privileges and immunities
     that apply to the Licensor or You, including from the legal
     processes of any jurisdiction or authority.


=======================================================================

Creative Commons is not a party to its public licenses.
Notwithstanding, Creative Commons may elect to apply one of its public
licenses to material it publishes and in those instances will be
considered the â€œLicensor.â€ The text of the Creative Commons public
licenses is dedicated to the public domain under the CC0 Public Domain
Dedication. Except for the limited purpose of indicating that material
is shared under a Creative Commons public license or as otherwise
permitted by the Creative Commons policies published at
creativecommons.org/policies, Creative Commons does not authorize the
use of the trademark "Creative Commons" or any other trademark or logo
of Creative Commons without its prior written consent including,
without limitation, in connection with any unauthorized modifications
to any of its public licenses or any other arrangements,
understandings, or agreements concerning use of licensed material. For
the avoidance of doubt, this paragraph does not form part of the public
licenses.

Creative Commons may be contacted at creativecommons.org.

```

# File: tests/test_about.py
```python
import sys

sys.path.append(".")


if __name__ == "__main__":
    from PySide2.QtWidgets import QApplication

    root = QApplication(sys.argv)

    from tinypedal.ui.about import About

    about = About(None)
    sys.exit(about.exec_())

```

# File: tinypedal/__init__.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Init logger, state, signal
"""

import logging

from PySide2.QtCore import QObject, Signal

# Create logger
logger = logging.getLogger(__package__)


class RealtimeState:
    """Realtime state

    Check realtime data update state without calling methods.
    State control: APIControl, OverlayControl.

    Attributes:
        active: whether is active (driving or overriding) state.
        paused: whether data stopped updating.
        overriding: whether is state override mode enabled.
        spectating: whether is spectate mode enabled.
    """

    __slots__ = (
        "active",
        "paused",
        "overriding",
        "spectating",
    )

    def __init__(self):
        self.active: bool = False
        self.paused: bool = True
        self.overriding: bool = False
        self.spectating: bool = False


class OverlaySignal(QObject):
    """Overlay signal

    Attributes:
        hidden: signal for toggling auto hide state.
        locked: signal for toggling lock state.
        reload: signal for reloading preset, should only be emitted after app fully loaded.
        paused: signal for pausing and resuming overlay timer.
        iconify: signal for toggling taskbar icon visibility state (for VR compatibility).
        updates: signal for checking version updates.
    """

    hidden = Signal(bool)
    locked = Signal(bool)
    reload = Signal(bool)
    paused = Signal(bool)
    iconify = Signal(bool)
    updates = Signal(bool)
    __slots__ = ()


realtime_state = RealtimeState()
overlay_signal = OverlaySignal()

```

# File: tinypedal/api_connector.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
API connector
"""

from abc import ABC, abstractmethod
from functools import partial

# Import APIs
from .adapter import (
    APIDataReader,
    lmu_connector,
    lmu_reader,
    restapi_connector,
    rf2_connector,
    rf2_reader,
    rf2_restapi,
)
from .const_api import API_LMU_NAME, API_LMULEGACY_NAME, API_RF2_NAME
from .const_app import PLATFORM
from .validator import bytes_to_str


class Connector(ABC):
    """API Connector"""

    __slots__ = ()

    @abstractmethod
    def start(self):
        """Start API & load info access function"""

    @abstractmethod
    def stop(self):
        """Stop API"""

    @abstractmethod
    def reader(self) -> APIDataReader:
        """Data reader"""

    @abstractmethod
    def setup(self, config: dict):
        """Setup API parameters"""


class SimLMU(Connector):
    """Le Mans Ultimate - LMU Native Sharedmemory API"""

    __slots__ = (
        # Primary API
        "shmmapi",
        # Secondary API
        "restapi",
    )
    NAME = API_LMU_NAME

    def __init__(self):
        self.shmmapi = lmu_connector.LMUInfo()
        self.restapi = restapi_connector.RestAPIInfo(rf2_restapi.TASKSET_LMU, rf2_restapi.RestAPIData())

    def start(self):
        self.shmmapi.start()  # 1 load first
        self.restapi.start()  # 2

    def stop(self):
        self.restapi.stop()  # 1 unload first
        self.shmmapi.stop()  # 2

    def reader(self) -> APIDataReader:
        shmm = self.shmmapi
        rest = self.restapi
        return APIDataReader(
            lmu_reader.State(shmm, rest),
            lmu_reader.Brake(shmm, rest),
            lmu_reader.ElectricMotor(shmm, rest),
            lmu_reader.Engine(shmm, rest),
            lmu_reader.Inputs(shmm, rest),
            lmu_reader.Lap(shmm, rest),
            lmu_reader.Session(shmm, rest),
            lmu_reader.Switch(shmm, rest),
            lmu_reader.Timing(shmm, rest),
            lmu_reader.Tyre(shmm, rest),
            lmu_reader.Vehicle(shmm, rest),
            lmu_reader.Wheel(shmm, rest),
        )

    def setup(self, config: dict):
        self.shmmapi.setMode(config["access_mode"])
        self.shmmapi.setStateOverride(config["enable_active_state_override"])
        self.shmmapi.setActiveState(config["active_state"])
        self.shmmapi.setPlayerOverride(config["enable_player_index_override"])
        self.shmmapi.setPlayerIndex(config["player_index"])
        self.restapi.setConnection(config.copy())
        lmu_reader.tostr = partial(bytes_to_str, char_encoding=config["character_encoding"].lower())


class SimRF2(Connector):
    """rFactor 2 - RF2 Sharedmemory Map Plugin API"""

    __slots__ = (
        # Primary API
        "shmmapi",
        # Secondary API
        "restapi",
    )
    NAME = API_RF2_NAME

    def __init__(self):
        self.shmmapi = rf2_connector.RF2Info()
        self.restapi = restapi_connector.RestAPIInfo(rf2_restapi.TASKSET_RF2, rf2_restapi.RestAPIData())

    def start(self):
        self.shmmapi.start()  # 1 load first
        self.restapi.start()  # 2

    def stop(self):
        self.restapi.stop()  # 1 unload first
        self.shmmapi.stop()  # 2

    def reader(self) -> APIDataReader:
        shmm = self.shmmapi
        rest = self.restapi
        return APIDataReader(
            rf2_reader.State(shmm, rest),
            rf2_reader.Brake(shmm, rest),
            rf2_reader.ElectricMotor(shmm, rest),
            rf2_reader.Engine(shmm, rest),
            rf2_reader.Inputs(shmm, rest),
            rf2_reader.Lap(shmm, rest),
            rf2_reader.Session(shmm, rest),
            rf2_reader.Switch(shmm, rest),
            rf2_reader.Timing(shmm, rest),
            rf2_reader.Tyre(shmm, rest),
            rf2_reader.Vehicle(shmm, rest),
            rf2_reader.Wheel(shmm, rest),
        )

    def setup(self, config: dict):
        if self.NAME == API_RF2_NAME:
            self.shmmapi.setPID(config["process_id"])
        self.shmmapi.setMode(config["access_mode"])
        self.shmmapi.setStateOverride(config["enable_active_state_override"])
        self.shmmapi.setActiveState(config["active_state"])
        self.shmmapi.setPlayerOverride(config["enable_player_index_override"])
        self.shmmapi.setPlayerIndex(config["player_index"])
        self.restapi.setConnection(config.copy())
        rf2_reader.tostr = partial(bytes_to_str, char_encoding=config["character_encoding"].lower())


class SimLMULegacy(SimRF2):
    """Le Mans Ultimate (legacy) - RF2 Sharedmemory Map Plugin API"""

    __slots__ = (
        # Primary API
        "shmmapi",
        # Secondary API
        "restapi",
    )
    NAME = API_LMULEGACY_NAME

    def __init__(self):
        self.shmmapi = rf2_connector.RF2Info()
        self.restapi = restapi_connector.RestAPIInfo(rf2_restapi.TASKSET_LMU, rf2_restapi.RestAPIData())


def _set_available_api():
    """Set available API for specific platform"""
    platform_all = (
        SimLMULegacy,
        SimRF2,
    )
    platform_win = (
        SimLMU,
    )
    if PLATFORM == "Windows":
        platform_all += platform_win
    # Sort API by name
    return tuple(sorted((_api for _api in platform_all), key=lambda cls:cls.NAME))


API_PACK = _set_available_api()

```

# File: tinypedal/api_control.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
API control
"""

import logging

from . import realtime_state
from .api_connector import API_PACK
from .setting import cfg

logger = logging.getLogger(__name__)


class APIControl:
    """API Control"""

    __slots__ = (
        "_api",
        "_same_api_loaded",
        "read",
    )

    def __init__(self):
        self._api = None
        self._same_api_loaded = False
        self.read = None

    def connect(self, name: str = ""):
        """Connect to API

        Args:
            name: API full name
        """
        if not name:
            name = cfg.api_name

        # Do not create new instance if same API already loaded
        self._same_api_loaded = bool(self._api is not None and self._api.NAME == name)
        if self._same_api_loaded:
            logger.info("CONNECTING: same API detected, fast restarting")
            return

        for _api in API_PACK:
            if _api.NAME == name:
                self._api = _api()
                return

        logger.warning("CONNECTING: Invalid API name, fall back to default")
        self._api = API_PACK[0]()
        cfg.api_name = self._api.NAME

    def start(self):
        """Start API"""
        logger.info("CONNECTING: %s API", self._api.NAME)
        self.setup()
        self._api.start()

        # Reload dataset if API changed
        if self.read is None or not self._same_api_loaded:
            init_read = self._api.reader()
            self.read = init_read
            self._same_api_loaded = True

        logger.info("ENCODING: %s", cfg.api["character_encoding"])
        logger.info("CONNECTED: %s API (%s)", self._api.NAME, self.read.state.version())

    def stop(self):
        """Stop API"""
        logger.info("DISCONNECTING: %s API (%s)", self._api.NAME, self.read.state.version())
        self._api.stop()
        logger.info("DISCONNECTED: %s API", self._api.NAME)

    def restart(self):
        """Restart API"""
        self.stop()
        self.connect()
        self.start()

    def setup(self):
        """Setup & apply API changes"""
        setting_api = cfg.api
        realtime_state.overriding = setting_api["enable_active_state_override"]
        realtime_state.spectating = setting_api["enable_player_index_override"]
        self._api.setup(setting_api)

    @property
    def name(self) -> str:
        """API full name output"""
        return self._api.NAME


api = APIControl()

```

# File: tinypedal/async_request.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Asynchronous request
"""

from __future__ import annotations

from asyncio import StreamReader, open_connection, wait_for
from contextlib import asynccontextmanager
from time import perf_counter
from typing import Awaitable

# Default limit from asyncio.open_connection is 2 ** 16
# Lower limit to avoid getting incomplete data
BUFFER_LIMIT = 32768  # 2 ** 15


def set_header_get(uri: str = "/", host: str = "localhost", *headers: str) -> bytes:
    """Set GET request header"""
    # "Accept: application/json"
    extra_headers = "\r\n" + "\r\n".join(headers) if headers else ""
    return f"GET {uri} HTTP/1.1\r\nHost: {host}{extra_headers}\r\n\r\n".encode()


async def parse_response(reader: StreamReader) -> bytes:
    """Parse response"""
    # Get headers
    header_bytes = await reader.readuntil(b"\r\n\r\n")
    if b"200" not in header_bytes:  # check http status code
        return b""
    # Get non-chunked data
    if b"chunked" not in header_bytes:
        # Get body length
        body_length = 0
        pos_beg = header_bytes.find(b"Content-Length")
        if pos_beg >= 0:
            try:
                pos_beg += 15  # offset
                pos_end = header_bytes.find(b"\r\n", pos_beg)
                body_length = int(header_bytes[pos_beg:pos_end])
            except (AttributeError, TypeError, IndexError, ValueError):
                body_length = 0
        if body_length <= 0:
            return b""
        if body_length <= BUFFER_LIMIT:
            return await reader.read(body_length)
        # Exceeded buffer limit
        temp_bytes = bytearray()
        while body_length > 0:
            temp_bytes.extend(await reader.read(BUFFER_LIMIT))
            body_length -= BUFFER_LIMIT
        return bytes(temp_bytes)
    # Get chunked data
    temp_bytes = bytearray()
    while (await reader.readuntil()) != b"0\r\n":  # end chunk
        temp_bytes[-2:] = await reader.readuntil()  # cut off CRLF
    return bytes(temp_bytes)


@asynccontextmanager
async def http_get(request: bytes, host: str, port: int, time_out: float):
    """Async request - HTTP get response"""
    writer = None
    try:
        reader, writer = await wait_for(open_connection(host, port), time_out)
        writer.write(request)
        await writer.drain()
        yield await wait_for(parse_response(reader), time_out)
    finally:
        if writer is not None:
            writer.close()
            await writer.wait_closed()


@asynccontextmanager
async def https_get(request: bytes, host: str, port: int, time_out: float):
    """Async request - HTTPS get response"""
    writer = None
    try:
        reader, writer = await wait_for(open_connection(host, port, ssl=True), time_out)
        writer.write(request)
        await writer.drain()
        yield await wait_for(parse_response(reader), time_out)
    finally:
        if writer is not None:
            writer.close()
            await writer.wait_closed()


async def get_response(request: bytes, host: str, port: int, time_out: float, ssl: bool = False) -> bytes:
    """Get response data (bytes)"""
    try:
        func_get = https_get if ssl else http_get
        async with func_get(request, host, port, time_out) as raw_bytes:
            return raw_bytes
    except (ConnectionError, TimeoutError, OSError, BaseException):
        return b""


async def _print_result(test_func: Awaitable):
    """Test result"""
    start = perf_counter()
    result = await test_func
    end = perf_counter()
    is_timeout = " (timeout)" if not result else " (done)"
    print(f"{end - start:.6f}s{is_timeout},", result)


async def _test_async_get(timeout: float):
    """Test run"""
    req1 = set_header_get("/rest/sessions/setting/SESSSET_race_timescale")
    req2 = set_header_get("/rest/sessions/weather")
    req3 = set_header_get("/rest/sessions")
    req4 = set_header_get("/rest/garage/getPlayerGarageData")
    task_rf2 = [
        _print_result(get_response(req1, "localhost", 5397, timeout)),  # RF2
        _print_result(get_response(req2, "localhost", 5397, timeout)),  # RF2
    ]
    task_lmu = [
        _print_result(get_response(req3, "localhost", 6397, timeout)),  # LMU
        _print_result(get_response(req4, "localhost", 6397, timeout)),  # LMU
    ]
    await asyncio.gather(*task_rf2, *task_lmu)


if __name__ == "__main__":
    import asyncio

    asyncio.run(_test_async_get(1))

```

# File: tinypedal/calculation.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Calculation function
"""

from __future__ import annotations

from math import acos, atan, atan2, ceil, cos, degrees, dist, hypot, radians, sin
from statistics import fmean
from typing import Sequence, Tuple

from .const_common import FLOAT_INF

CoordXY = Tuple[float, float]

distance = dist  # coordinates distance
mean = fmean
vel2speed = hypot  # velocity to speed
rad2deg = degrees  # radians to degrees
oriyaw2rad = atan2  # orientation yaw to radians
deg2rad = radians  # degrees to radians


# Common
def sym_max(value: float, rng: float) -> float:
    """Symmetric min-max value range"""
    if value > rng:
        return rng
    if value < -rng:
        return -rng
    return value


def asym_max(value: float, min_rng: float, max_rng: float) -> float:
    """Asymmetric min-max value range"""
    if value > max_rng:
        return max_rng
    if value < min_rng:
        return min_rng
    return value


def zero_max(value: float, max_rng: float) -> float:
    """Zero to max value range"""
    if value > max_rng:
        return max_rng
    if value < 0:
        return 0
    return value


def zero_one(value: float) -> float:
    """Zero to one value range"""
    if value > 1:
        return 1
    if value < 0:
        return 0
    return value


def min_nonzero(data: tuple[float, ...]) -> float:
    """Minimum non-zero positive value"""
    return min(value for value in data if value > 0)


def decimal_strip(raw_range: float, max_decimals: int) -> float:
    """Strip off unwanted decimal places according to max number of decimals"""
    value_str = str(raw_range)
    pos = value_str.find(".") + 1
    if pos <= 0:
        return raw_range
    return float(value_str[:pos + max_decimals])


def mean_iter(average: float, value: float, num_samples: int) -> float:
    """Average value"""
    return (average * num_samples + value) / (num_samples + 1)


def min_vs_avg(data: Sequence) -> float:
    """Min vs average"""
    return abs(min(data) - mean(data))


def max_vs_avg(data: Sequence) -> float:
    """Max vs average"""
    return abs(max(data) - mean(data))


def max_vs_min(data: Sequence) -> float:
    """Max vs min"""
    return max(data) - min(data)


def engine_power(torque: float, rpm: float) -> float:
    """Engine power (kW)"""
    if torque > 0:
        return torque * rpm / 9549.3
    return 0


def rake(height_fl: float, height_fr: float, height_rl: float, height_rr: float) -> float:
    """Raw rake (front & rear ride height difference in millimeters)"""
    return (height_rr + height_rl - height_fr - height_fl) * 0.5


def gforce(value: float, g_accel: float = 9.8) -> float:
    """G force"""
    if g_accel:
        return value / g_accel
    return 0


def force_ratio(value1: float, value2: float, min_limit: float = 1) -> float:
    """Force ratio from Newtons"""
    if value2 > min_limit or value2 < -min_limit:
        return abs(100 * value1 / value2)
    return 0


def part_to_whole_ratio(part: float, whole: float, median: float = 0) -> float:
    """Part to whole ratio"""
    abs_part = abs(part)
    abs_whole = abs(whole)
    if abs_whole > 0:
        if abs_part < abs_whole:
            return 100 * part / whole
        return 100
    return median


def braking_rate(lgt_gforce: float, is_braking: bool, not_impacted: bool = True) -> float:
    """Braking rate (longitudinal G force)"""
    if is_braking and not_impacted:
        return lgt_gforce
    return 0.0


def rotate_coordinate(ori_rad: float, pos_x: float, pos_y: float) -> CoordXY:
    """Rotate x y coordinates"""
    sin_rad = sin(ori_rad)
    cos_rad = cos(ori_rad)
    return (cos_rad * pos_x - sin_rad * pos_y,
            cos_rad * pos_y + sin_rad * pos_x)


def lap_progress_distance(dist_into: float, length: float) -> float:
    """Current lap progress (distance into lap) fraction"""
    if length < 1:
        return 0
    value = dist_into / length
    if value > 1:
        return 1
    if value < 0:
        return 0
    return value


def lap_progress_correction(percent: float, laptime: float) -> float:
    """Lap progress desync correction"""
    if percent > 0.5 > laptime:
        return 0
    return percent


def lap_progress_offset(laptime: float, lap_into: float, seconds_delay: float) -> float:
    """Lap progress offset (fraction) by seconds delay, such as pit stop"""
    if laptime:
        return lap_into - seconds_delay / laptime
    return 0


def lap_progress_difference(ahead_laptime: float, behind_laptime: float) -> float:
    """Lap progress difference (fraction) between player ahead & behind"""
    if behind_laptime > ahead_laptime > 0:
        return (behind_laptime - ahead_laptime) / behind_laptime
    if ahead_laptime > behind_laptime > 0:
        return (ahead_laptime - behind_laptime) / ahead_laptime
    return 0


def circular_relative_distance(circle_length: float, plr_dist: float, opt_dist: float) -> float:
    """Relative distance between opponent & player in a circle"""
    rel_dist = opt_dist - plr_dist
    # Relative dist is greater than half of track length
    if abs(rel_dist) > circle_length * 0.5:
        if opt_dist > plr_dist:
            rel_dist -= circle_length  # opponent is behind player
        elif opt_dist < plr_dist:
            rel_dist += circle_length  # opponent is ahead player
    return rel_dist


def lap_difference(
    opt_laps: float, plr_laps: float, lap_ahead: float = 1, lap_behind: float = 1) -> float:
    """Calculate lap difference between target opponent and player

    Positive: lap(s) ahead.
    Negative: lap(s) behind.
    Zero: on same lap.
    """
    lap_diff = opt_laps - plr_laps
    if lap_diff > lap_ahead or lap_diff < -lap_behind:
        return lap_diff
    return 0


def relative_time_gap(rel_dist: float, plr_speed: float, opt_speed: float) -> float:
    """Relative time gap between opponent & player"""
    speed = max(plr_speed, opt_speed)
    if speed > 1:
        return abs(rel_dist / speed)
    return 0


def pitlane_length(track_length: float, pit_entry: float, pit_exit: float) -> float:
    """Calculate pitlane length"""
    if pit_entry != 0 != pit_exit:  # check valid position
        pit_length = pit_exit - pit_entry
        if pit_entry > pit_exit:
            pit_length += track_length
    else:
        pit_length = 0.0
    return pit_length


def linear_interp(x: float, x1: float, y1: float, x2: float, y2: float) -> float:
    """Linear interpolation"""
    x_diff = x2 - x1
    if x_diff:
        return y1 + (x - x1) * (y2 - y1) / x_diff
    return y1


def slope_percent(height: float, length: float) -> float:
    """Slope percent"""
    if length:
        return height / length
    return 0


def slope_angle(height: float, length: float) -> float:
    """Slope angle (degree)"""
    if length:
        return rad2deg(atan(height / length))
    return 0


def arc_length(angle: float, radius: float) -> float:
    """Arc length"""
    return abs(angle * radius * 3.14159265 / 180)


def arc_angle(length: float, radius: float) -> float:
    """Arc angle (degree)"""
    if radius:
        return length * 180 / (radius * 3.14159265)
    return 0


def curvature(radius: float) -> float:
    """Curvature"""
    if radius:
        return 1 / radius
    return 0


def tri_coords_circle_center(
    x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> CoordXY:
    """Tri-coordinates circle center x, y"""
    p = 0.00000001  # bypass zero division
    k1 = (y2 - y1 + p) / (x2 - x1 + p)
    k2 = (y3 - y2 + p) / (x3 - x2 + p)
    s1 = (x1 + x2) / (2 * k1)
    s2 = 1 / k2 - 1 / k1 + p
    x = ((x2 + x3) / (2 * k2) + (y3 - y1) / 2 - s1) / s2
    y =  s1 - x / k1 + (y1 + y2) / 2
    return x, y


def tri_coords_angle(a_len: float, b_len: float, c_len: float) -> float:
    """Tri-coordinates angle (radians)"""
    bc2_len = 2 * b_len * c_len
    if bc2_len:
        cos_a = (b_len * b_len + c_len * c_len - a_len * a_len) / bc2_len
        return acos(cos_a)
    return 0


def quad_coords_angle(
    coords_center: CoordXY, coords_start: CoordXY, coords_mid: CoordXY, coords_end: CoordXY) -> float:
    """Quad-coordinates angle (degree)"""
    center1_edge = distance(coords_start, coords_mid)
    center2_edge = distance(coords_mid, coords_end)
    start_edge = distance(coords_center, coords_start)
    mid_edge = distance(coords_center, coords_mid)
    end_edge = distance(coords_center, coords_end)
    rad1 = tri_coords_angle(center1_edge, start_edge, mid_edge)
    rad2 = tri_coords_angle(center2_edge, mid_edge, end_edge)
    return rad2deg(rad1 + rad2)


def turning_direction(yaw_rad: float, x1: float, y1: float, x2: float, y2: float) -> int:
    """Calculate turning direction

    Returns:
        -1 = left turning, 1 = right turning, 0 = no turning.
    """
    point_y = rotate_coordinate(-yaw_rad, x2 - x1, y2 - y1)[1]
    if point_y > 0:
        return 1
    if point_y < 0:
        return -1
    return 0


# Timing
def clock_time(seconds: float, start: float = 0, scale: float = 1) -> float:
    """Clock time (seconds) looped in full 24 hours, 0 to 86400"""
    time_curr = start + seconds * scale
    return time_curr - time_curr // 86400 * 86400


def sec2hourminute(seconds: float) -> str:
    """Seconds to hour:minute (hour:min)"""
    return f"{seconds // 3600:02.0f}:{seconds // 60 % 60:02.0f}"


def sec2sessiontime(seconds: float) -> str:
    """Session time (hour:min:sec)"""
    return f"{seconds // 3600:02.0f}:{seconds // 60 % 60:02.0f}:{round(seconds) % 60:02.0f}"


def sec2laptime(seconds: float) -> str:
    """Lap time (min:sec.ms)"""
    if seconds > 60:
        return f"{seconds // 60:.0f}:{seconds % 60:06.3f}"
    return f"{seconds % 60:.3f}"


def sec2laptime_full(seconds: float) -> str:
    """Lap time full (min:sec.ms)"""
    return f"{seconds // 60:.0f}:{seconds % 60:06.3f}"


def sec2stinttime(seconds: float) -> str:
    """Stint time (min:sec)"""
    return f"{seconds // 60:02.0f}:{int(seconds) % 60:02.0f}"


def delta_telemetry(
    dataset: list, position: float, target: float,
    condition: bool = True, position_column: int = 0, target_column: int = 1) -> float:
    """Calculate delta telemetry data"""
    if not condition:
        return 0
    index_higher = binary_search_higher_column(
        dataset, position, 0, len(dataset) - 1, position_column)
    if index_higher > 0:
        index_lower = index_higher - 1
        return target - linear_interp(
            position,
            dataset[index_lower][position_column],
            dataset[index_lower][target_column],
            dataset[index_higher][position_column],
            dataset[index_higher][target_column],
        )
    return 0


def clock_time_scale_sync(scaled_sec: float, elapsed_sec: float, start_sec: float) -> int:
    """Synchronize clock time scale multiplier

    Args:
        scaled_sec: scaled track clock time (seconds)
        elapsed_sec: current non-scaled session elapsed time (seconds)
        start_sec: current session start time stamp (seconds)
    """
    if elapsed_sec:
        return round((scaled_sec // 86400 * 86400 + scaled_sec - start_sec) / elapsed_sec)
    return 1


def exp_mov_avg(factor: float, ema_last: float, source: float) -> float:
    """Calculate exponential moving average"""
    return ema_last + factor * (source - ema_last)


def ema_factor(samples: int, min_samples: int = 1) -> float:
    """Calculate smoothing factor for exponential moving average"""
    return 2 / (max(samples, min_samples) + 1)


def accumulated_sum(data: list, end_index: int) -> float:
    """Calculate accumulated sum"""
    return sum(data[:end_index + 1])


# Search
def search_column_key(key: Sequence, column: int | None = None):
    """Search column key"""
    if column is None:
        return key
    return key[column]


def linear_search_higher(data: Sequence, target: float, column: int | None = None) -> int:
    """linear search nearest value higher index from unordered list"""
    #key = lambda x:x[column] if column >= 0 else x
    end = len(data) - 1
    nearest = FLOAT_INF
    for index, data_row in enumerate(data):
        if target <= search_column_key(data_row, column) < nearest:
            nearest = search_column_key(data_row, column)
            end = index
    return end


def binary_search_lower(data: Sequence, target: float, start: int, end: int) -> int:
    """Binary search nearest value lower index from ordered list"""
    while start <= end:
        center = (start + end) // 2
        if target == data[center]:
            return center
        if target > data[center]:
            start = center + 1
        else:
            end = center - 1
    return end


def binary_search_higher(data: Sequence, target: float, start: int, end: int) -> int:
    """Binary search nearest value higher index from ordered list"""
    while start < end:
        center = (start + end) // 2
        if target == data[center]:
            return center
        if target > data[center]:
            start = center + 1
        else:
            end = center
    return end


def binary_search_lower_column(
    data: Sequence, target: float, start: int, end: int, column: int = 0) -> int:
    """Binary search nearest value lower index from ordered list with column index"""
    while start <= end:
        center = (start + end) // 2
        if target == data[center][column]:
            return center
        if target > data[center][column]:
            start = center + 1
        else:
            end = center - 1
    return end


def binary_search_higher_column(
    data: Sequence[Sequence], target: float, start: int, end: int, column: int = 0) -> int:
    """Binary search nearest value higher index from ordered list with column index"""
    while start < end:
        center = (start + end) // 2
        if target == data[center][column]:
            return center
        if target > data[center][column]:
            start = center + 1
        else:
            end = center
    return end


def select_grade(data: Sequence[Sequence], source: float) -> str:
    """Select grade (linear lower) from reference list (column: 0 target, 1 value)"""
    last = data[0][1]
    for target, value in data:
        if target > source:
            return last
        last = value
    return last


# Plot
def zoom_map(coords: Sequence[CoordXY], map_scale: float, margin: int = 0):
    """Zoom map data to specific scale, then add margin"""
    # Separate X & Y coordinates
    x_range, y_range = tuple(zip(*coords))
    # Offset X, Y
    map_offset = min(x_range) * map_scale - margin, min(y_range) * map_scale - margin
    # Map width, height
    map_size = max(x_range) * map_scale + margin, max(y_range) * map_scale + margin
    # Scale map coordinates
    x_range_scaled = (x_pos * map_scale - map_offset[0] for x_pos in x_range)
    y_range_scaled = (y_pos * map_scale - map_offset[1] for y_pos in y_range)
    return tuple(zip(x_range_scaled, y_range_scaled)), map_size, map_offset


def rotate_map(coords: Sequence[CoordXY], angle: int):
    """Rotate map coordinates"""
    rot_rad = deg2rad(angle)
    for x, y in coords:
        yield rotate_coordinate(rot_rad, x, y)


def scale_map(coords: Sequence[CoordXY], area_size: int, margin: int = 0, angle: int = 0):
    """Scale map data"""
    # Rotate & separate X & Y coordinates
    if angle != 0:
        x_range, y_range = tuple(zip(*rotate_map(coords, angle)))
    else:
        x_range, y_range = tuple(zip(*coords))
    # Map size: x=width, y=height
    map_range = min(x_range), max(x_range), min(y_range), max(y_range)
    map_size = map_range[1] - map_range[0], map_range[3] - map_range[2]
    # Display area / map_size
    map_scale = (area_size - margin * 2) / max(map_size[0], map_size[1])
    # Alignment offset
    if map_size[0] > map_size[1]:
        map_offset = margin, (area_size - map_size[1] * map_scale) * 0.5
    else:
        map_offset = (area_size - map_size[0] * map_scale) * 0.5, margin
    x_range_scaled = ((x_pos - map_range[0]) * map_scale + map_offset[0] for x_pos in x_range)
    y_range_scaled = ((y_pos - map_range[2]) * map_scale + map_offset[1] for y_pos in y_range)
    return tuple(zip(x_range_scaled, y_range_scaled)), map_range, map_scale, map_offset


def scale_elevation(coords: Sequence[CoordXY], area_width: int, area_height: int):
    """Scale elevation data"""
    # Separate X & Y coordinates
    x_range, y_range = tuple(zip(*coords))
    # Map size: x=width, y=height
    map_range = min(x_range), max(x_range), min(y_range), max(y_range)
    map_size = map_range[1] - map_range[0], map_range[3] - map_range[2]
    # Display area / map_size
    map_scale = area_width / map_size[0], area_height / map_size[1]
    x_range_scaled = ((x_pos - map_range[0]) * map_scale[0] for x_pos in x_range)
    y_range_scaled = ((y_pos - map_range[2]) * map_scale[1] for y_pos in y_range)
    return tuple(zip(x_range_scaled, y_range_scaled)), map_range, map_scale


def svg_view_box(coords: Sequence[CoordXY], margin: int = 0) -> str:
    """Map bounding box"""
    # Separate X & Y coordinates
    x_range, y_range = tuple(zip(*coords))
    # Map size: x=width, y=height
    map_range = min(x_range), max(x_range), min(y_range), max(y_range)
    map_size = map_range[1] - map_range[0], map_range[3] - map_range[2]
    x1 = map_range[0] - margin
    y1 = map_range[2] - margin
    x2 = map_size[0] + margin * 2
    y2 = map_size[1] + margin * 2
    return f"{x1:.4f} {y1:.4f} {x2:.4f} {y2:.4f}"


def skip_map_nodes(total: int, limit: int, detail_level: int) -> int:
    """Skip map nodes"""
    if detail_level <= 0:
        skip_node = 0
    else:
        skip_node = total // limit + (detail_level - 1)
    return skip_node


def line_intersect_coords(
    coord_a: CoordXY, coord_b: CoordXY, rad: float, length: float):
    """Create intersect line coordinates from 2 coordinates

    coord_a: coordinate A
    coord_b: coordinate B
    rad: amount rotation (radians) to apply
    length: length between coordinates
    """
    yaw_rad = oriyaw2rad(
        coord_b[1] - coord_a[1],
        coord_b[0] - coord_a[0]
    )
    pos_x1, pos_y1 = rotate_coordinate(
        yaw_rad + rad,
        length,  # x pos
        0  # y pos
    )
    pos_x2, pos_y2 = rotate_coordinate(
        yaw_rad - rad,
        length,  # x pos
        0  # y pos
    )
    return (pos_x1 + coord_a[0],
            pos_y1 + coord_a[1],
            pos_x2 + coord_a[0],
            pos_y2 + coord_a[1])


# Fuel
def lap_type_full_laps_remain(laps_total: int, laps_finished: int) -> int:
    """Lap type race remaining laps count from finish line"""
    return laps_total - laps_finished


def lap_type_laps_remain(full_laps_remain: int, lap_into: float) -> float:
    """Lap type race remaining laps count from current on track position"""
    return full_laps_remain - lap_into


def end_timer_laps_remain(lap_into: float, laptime_last: float, seconds_remain: float) -> float:
    """Estimated remaining laps(fraction) count from finish line after race timer ended"""
    if laptime_last:
        if seconds_remain <= 0:
            return lap_into
        return seconds_remain / laptime_last + lap_into
    return 0


def time_type_full_laps_remain(laptime_last: float, seconds_remain: float) -> int:
    """Estimated full remaining laps count from finish line after race timer ended"""
    # alternative-lap-into = laptime_current / laptime_last % 1
    return ceil(end_timer_laps_remain(0, laptime_last, seconds_remain))


def time_type_laps_remain(full_laps_remain: int, lap_into: float) -> float:
    """Time type race remaining laps count from current on track position"""
    return max(full_laps_remain - lap_into, 0)


def total_fuel_needed(laps_remain: float, consumption: float, fuel_in_tank: float) -> float:
    """Total additional fuel needed"""
    return laps_remain * consumption - fuel_in_tank


def end_lap_consumption(consumption: float, consumption_delta: float, condition: bool) -> float:
    """Estimate fuel consumption"""
    if condition:
        return consumption + consumption_delta
    return consumption


def end_stint_fuel(fuel_in_tank: float, consumption_into_lap: float, consumption: float) -> float:
    """Estimate end-stint remaining fuel before pitting"""
    if consumption:
        # Total fuel at start of current lap
        fuel_at_lap_start = fuel_in_tank + consumption_into_lap
        # Fraction of lap counts * estimate fuel consumption
        return fuel_at_lap_start / consumption % 1 * consumption
    return 0


def end_stint_laps(fuel_in_tank: float, consumption: float) -> float:
    """Estimate laps current fuel can last to end of stint"""
    if consumption:
        # Laps = remaining fuel / estimate fuel consumption
        return fuel_in_tank / consumption
    return 0


def end_stint_minutes(laps_runnable: float, laptime_last: float) -> float:
    """Estimate minutes current fuel can last (based on estimate laps) to end of stint"""
    return laps_runnable * laptime_last / 60


def pit_in_countdown_laps(laps_remain: float, lap_into: float) -> float:
    """Estimate countdown laps till last chance to pit-in"""
    return laps_remain - (laps_remain + lap_into) % 1


def end_lap_empty_capacity(capacity_total: float, fuel_in_tank: float, consumption: float) -> float:
    """Estimate empty capacity at end of current lap"""
    # Total capacity - fuel at start of current lap + estimate fuel consumption
    return capacity_total - fuel_in_tank + consumption


def end_stint_pit_counts(fuel_needed: float, capacity_total: float) -> float:
    """Estimate end-stint pit stop counts"""
    if capacity_total:
        # Pit counts = required fuel / empty capacity
        return fuel_needed / capacity_total
    return 0


def end_lap_pit_counts(fuel_needed: float, capacity_empty: float, capacity_total: float) -> float:
    """Estimate end-lap pit stop counts"""
    if capacity_empty < 0:
        capacity_empty = 0
    # Amount fuel can be added without exceeding capacity
    fuel_addable = min(fuel_needed, capacity_empty)
    # Pit count of current stint, 1 if exceed empty capacity or no empty space
    pit_counts_before = fuel_addable / capacity_empty if capacity_empty else 1
    # Pit counts after current stint
    pit_counts_after = (fuel_needed - fuel_addable) / capacity_total if capacity_total else 0
    # Total pit counts add together
    return pit_counts_before + pit_counts_after


def one_less_pit_stop_consumption(
    pit_counts_late: float, capacity_total: float, fuel_in_tank: float, laps_remain: float) -> float:
    """Estimate fuel consumption for one less pit stop"""
    if laps_remain:
        pit_counts = ceil(pit_counts_late) - 1
        # Consumption = total fuel / laps
        return (pit_counts * capacity_total + fuel_in_tank) / laps_remain
    return 0


def fuel_to_energy_ratio(fuel: float, energy: float) -> float:
    """Fuel to energy ratio"""
    if energy:
        return fuel / energy
    return 0


# Wear
def wear_lifespan_in_laps(remaining: float, wear_last_lap: float) -> float:
    """Wear lifespan in laps = remaining / last lap wear"""
    if wear_last_lap > 0:
        est_laps = remaining / wear_last_lap
    else:
        est_laps = 999
    if est_laps > 999:
        est_laps = 999
    return est_laps


def wear_lifespan_in_mins(remaining: float, wear_last_lap: float, laptime: float) -> float:
    """Wear lifespan in minutes = remaining / last lap wear * laptime / 60"""
    if laptime <= 0:
        return 999
    if wear_last_lap > 0:
        est_mins = remaining / wear_last_lap * laptime / 60
    else:
        est_mins = 999
    if est_mins > 999:
        est_mins = 999
    return est_mins


def end_stint_tread(remaining: float, wear_last_lap: float, laps_remain: float) -> float:
    """Estimate end-stint remaining tyre tread (%) before pitting"""
    return remaining - wear_last_lap * laps_remain


def wear_weighted(wear_curr_lap: float, wear_last_lap: float, lap_into: float) -> float:
    """Weighted wear difference between last and current lap based on lap progression"""
    if wear_curr_lap >= wear_last_lap:
        return wear_curr_lap
    lap_into *= lap_into  # square
    return wear_curr_lap * lap_into + wear_last_lap * (1 - lap_into)


# Wheel
def rot2radius(speed: float, angular_speed: float) -> float:
    """Angular speed to radius"""
    if angular_speed:
        return abs(speed / angular_speed)
    return 0


def slip_ratio(w_rot: float, w_radius: float, v_speed: float) -> float:
    """Slip ratio (percentage), speed unit in m/s"""
    if v_speed > 1:
        return abs(w_rot) * w_radius / v_speed - 1
    return 0


def slip_angle(v_lat: float, v_lgt: float) -> float:
    """Slip angle (radians)"""
    if v_lgt:
        return atan(v_lat / v_lgt)
    return 0


def wheel_axle_rotation(rot_left: float, rot_right: float) -> float:
    """Wheel axle rotation"""
    # Make sure both wheels rotate towards same direction
    if rot_left >= 0 <= rot_right or rot_left <= 0 >= rot_right:
        return (rot_left + rot_right) / 2
    return 0


def wheel_rotation_bias(rot_axle: float, rot_left: float, rot_right: float) -> float:
    """Wheel rotation bias (difference) against axle rotation"""
    if rot_axle:
        return abs((rot_left - rot_right) / rot_axle)
    return 0


def wheel_rotation_ratio(rot_axle: float, rot_left: float) -> float:
    """Calculate wheel rotation ratio between left and right wheel on same axle"""
    if rot_axle:
        return rot_left / rot_axle / 2
    return 0.5


def differential_locking_percent(rot_axle: float, rot_left: float) -> float:
    """Differential (wheel) locking percent

    0% = one wheel completely spinning or locked, 100% = both wheel rotated at same speed.
    """
    if rot_axle:
        return 1 - abs(rot_left / rot_axle - 1)
    return 0

```

# File: tinypedal/const_api.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
API constants
"""

from types import MappingProxyType

API_LMU_NAME = "Le Mans Ultimate"
API_LMU_ALIAS = "LMU"
API_LMU_CONFIG = "api_lmu"

API_LMULEGACY_NAME = "Le Mans Ultimate (legacy)"
API_LMULEGACY_ALIAS = "LMU*"
API_LMULEGACY_CONFIG = "api_lmu"

API_RF2_NAME = "rFactor 2"
API_RF2_ALIAS = "RF2"
API_RF2_CONFIG = "api_rf2"

# Reference
API_MAP_ALIAS = MappingProxyType({
    API_LMU_NAME: API_LMU_ALIAS,
    API_LMULEGACY_NAME: API_LMULEGACY_ALIAS,
    API_RF2_NAME: API_RF2_ALIAS,
})
API_MAP_CONFIG = MappingProxyType({
    API_LMU_NAME: API_LMU_CONFIG,
    API_LMULEGACY_NAME: API_LMULEGACY_CONFIG,
    API_RF2_NAME: API_RF2_CONFIG,
})

```

# File: tinypedal/const_app.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Constants
"""

import platform

from . import version_check
from .userfile import set_global_user_path

# System info
PLATFORM = platform.system()

# App version
VERSION = version_check.tinypedal()

# App info
APP_NAME = "TinyPedal"
REPO_NAME = "TinyPedal/TinyPedal"
COPYRIGHT = "Copyright (C) 2022-2026 TinyPedal developers"
DESCRIPTION = "Free and Open Source telemetry overlay application for racing simulation."
LICENSE = "Licensed under the GNU General Public License v3.0 or later."

# URL
URL_WEBSITE = f"unlinked: github_com/{REPO_NAME}"
URL_USER_GUIDE = f"{URL_WEBSITE}/wiki/User-Guide"
URL_FAQ = f"{URL_WEBSITE}/wiki/Frequently-Asked-Questions"
URL_RELEASE = f"{URL_WEBSITE}/releases"

# Global path
PATH_GLOBAL = set_global_user_path(APP_NAME, PLATFORM)

```

# File: tinypedal/const_common.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Common constants
"""

from types import MappingProxyType

# Numeric
FLOAT_INF = float("inf")
MAX_VEHICLES = 128  # set vehicle data size limit
MAX_SECONDS = 99999.0  # for lap or sector time limit
MAX_METERS = 999999.0  # for distance limit

MAX_FORECASTS = 5  # for weather forecast
MAX_FORECAST_MINUTES = 9999.0  # for weather forecast
ABS_ZERO_CELSIUS = -273.15  # absolute zero celsius

# Text
TEXT_PLACEHOLDER = "-"
TEXT_NA = "n/a"
TEXT_NOTAVAILABLE = "NOT AVAILABLE"
TEXT_NOLAPTIME = "-:--.---"
TEXT_TREND_SIGN = "â—â–²â–¼"  # 0 = constant, 1 = increasing, -1 = decreasing
CRLF = "\r\n"

# Data set
EMPTY_DICT: MappingProxyType = MappingProxyType({})
DELTA_ZERO = (0.0, 0.0)  # pos, target
DELTA_DEFAULT = (DELTA_ZERO,)
POS_XY_ZERO = (0.0, 0.0)  # world origin position
POS_XYZ_ZERO = (0.0, 0.0, 0.0)  # world origin position
POS_XYZ_INF = (FLOAT_INF, FLOAT_INF, FLOAT_INF)  # infinite position
WHEELS_ZERO = (0.0, 0.0, 0.0, 0.0)  # FL, FR, RL, RR
WHEELS_NA = (-1.0, -1.0, -1.0, -1.0)  # FL, FR, RL, RR
WHEELS_DELTA_DEFAULT = (0.0, *WHEELS_ZERO)  # pos, target set
STINT_USAGE_DEFAULT = (-1.0, -1.0, -1.0, 0.0, 0)
REL_TIME_DEFAULT = (0.0, -1)  # relative time gap, player index

# Version & date
VERSION_NA = (0, 0, 0)  # major, minor, patch
DATE_NA = (0, 0, 0)  # year, month, day

# Type set
TYPE_NUMBER = (float, int)
TYPE_JSON = (dict, list)

# ID selector
ENERGY_TYPE_ID = (
    "FUEL",  # fuel
    "NRG",  # virtual energy
)
RACELENGTH_TYPE_ID = (
    "TIME",  # time-based race length
    "LAPS",  # laps-based race length
)
SECTOR_ABBR_ID = ("S1", "S2", "S3")  # sector abbreviation
PREV_SECTOR_INDEX = (2, 0, 1)  # select previous sector index with current index
GEAR_SEQUENCE = {  # max 9 in RF2
    -1: "R",
    0: "N",
    1: "1",
    2: "2",
    3: "3",
    4: "4",
    5: "5",
    6: "6",
    7: "7",
    8: "8",
    9: "9",
}.get
COMPASS_BEARINGS = (
    (0, "N"),
    (22.5, "NE"),
    (67.5, "E"),
    (112.5, "SE"),
    (157.5, "S"),
    (202.5, "SW"),
    (247.5, "W"),
    (292.5, "NW"),
    (337.5, "N"),
)

```

# File: tinypedal/formatter.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Formatter function
"""

from __future__ import annotations

import random
import re
from functools import lru_cache

from .regex_pattern import ABBR_PATTERN, rex_invalid_char


def uppercase_abbr(name: str) -> str:
    """Convert abbreviation name to uppercase"""
    return re.sub(ABBR_PATTERN, upper_matched_abbr, name, flags=re.IGNORECASE)


def upper_matched_abbr(matchobj: re.Match) -> str:
    """Convert abbreviation name to uppercase"""
    return matchobj.group().upper()


def format_module_name(name: str) -> str:
    """Format widget & module name"""
    return uppercase_abbr(
        name
        .replace("module_", "")
        .replace("_", " ")
        .title()
    )


def format_option_name(name: str) -> str:
    """Format option name"""
    return uppercase_abbr(
        name
        .replace("bkg", "background")
        .replace("_", " ")
        .title()
    )


def strip_filename_extension(name: str, extension: str) -> str:
    """Strip file name extension"""
    if name.lower().endswith(extension):
        return name[:-len(extension)]
    return name


def rgb_to_gray(rgb: list[int]) -> int:
    """RGB value to gray (0-255)"""
    return (rgb[0] * 3 + rgb[1] * 6 + rgb[2]) // 10


@lru_cache(maxsize=20)
def random_color_class(name: str) -> str:
    """Generate random color for vehicle class"""
    max_value = 225
    min_value = 25
    target_brightness = 100
    # Generate random RGB color
    random.seed(name)
    rgb = [min_value + 10, max_value - 10, random.randint(min_value, max_value)]
    random.seed(name)
    random.shuffle(rgb)
    # Brightness correction
    brightness = rgb_to_gray(rgb)
    if brightness > target_brightness:
        while brightness > target_brightness:
            ran_index = random.randint(0, 2)
            if rgb[ran_index] >= min_value:
                rgb[ran_index] -= 5
            else:
                rgb[ran_index] += random.randint(10, 30)
            brightness = rgb_to_gray(rgb)
    elif brightness < target_brightness:
        while brightness < target_brightness:
            ran_index = random.randint(0, 2)
            if rgb[ran_index] <= max_value:
                rgb[ran_index] += 5
            else:
                rgb[ran_index] -= random.randint(10, 30)
            brightness = rgb_to_gray(rgb)
    return f"#{rgb[0]:02X}{rgb[1]:02X}{rgb[2]:02X}"


@lru_cache(maxsize=128)
def shorten_driver_name(name: str) -> str:
    """Shorten driver name"""
    name_split = name.strip(" ").split(" ")
    if len(name_split) > 1:
        return f"{name_split[0][:1]}.{name_split[-1]}".title()
    return name_split[-1]


def strip_invalid_char(name: str) -> str:
    """Strip invalid characters"""
    return rex_invalid_char.sub("", name)


def laptime_string_to_seconds(laptime: str) -> float:
    """Convert laptime "minutes:seconds" string to seconds"""
    string = laptime.split(":")
    split = [0] * (2 - len(string)) + string
    return float(split[0]) * 60 + float(split[1])

```

# File: tinypedal/loader.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Loader function
"""

import logging
import os
import signal
import sys
import time

from .api_control import api
from .const_file import FileExt
from .module_control import mctrl, wctrl
from .overlay_control import octrl
from .setting import cfg
from .update import update_checker

logger = logging.getLogger(__name__)


def int_signal_handler(sign, frame):
    """Quit by keyboard interrupt"""
    close()
    sys.exit()


def start():
    """Start api, modules, widgets, etc. Call once per launch."""
    logger.info("STARTING............")
    signal.signal(signal.SIGINT, int_signal_handler)
    # 1 load user preset
    cfg.set_next_to_load(f"{cfg.preset_files()[0]}{FileExt.JSON}")
    cfg.load_user()
    cfg.save()
    # 2 start api
    api.connect()
    api.start()
    # 3 start modules
    mctrl.start()
    # 4 start widgets
    wctrl.start()
    # 5 start main window
    from .ui.app import AppWindow
    AppWindow()
    # Finalize loading after main GUI fully loaded
    logger.info("FINALIZING............")
    # 1 Enable overlay control
    octrl.enable()
    # 2 Check for updates
    if cfg.application["check_for_updates_on_startup"]:
        update_checker.check(False)


def close():
    """Close api, modules, widgets. Call before quit APP."""
    logger.info("CLOSING............")
    # 1 unload modules
    unload_modules()
    # 2 stop api
    api.stop()


def restart():
    """Restart APP"""
    logger.info("RESTARTING............")
    # Set restart env for skipping single instance check
    os.environ["TINYPEDAL_RESTART"] = "TRUE"
    if "tinypedal.exe" in sys.executable:  # if run as exe
        os.execl(sys.executable, *sys.argv)
    else:  # if run as script
        os.execl(sys.executable, sys.executable, *sys.argv)


def reload(reload_preset: bool = False):
    """Reload preset, api, modules, widgets

    Args:
        reload_preset:
            Whether to reload preset file.
            Should only done if changed global setting,
            or reloading from preset tab,
            or auto-loading preset.
    """
    logger.info("RELOADING............")
    # 0 wait unfinished saving
    if cfg.is_saving:
        cfg.save(0)  # trigger immediate saving
        while cfg.is_saving:
            time.sleep(0.01)
    # 1 unload modules
    unload_modules()
    # 2 reload user preset from file
    if reload_preset:
        cfg.load_user()
        cfg.save(0)  # save new changes in case preset was edited externally
    # 3 restart api
    api.restart()
    # 4 load modules
    load_modules()


def load_modules():
    """Load modules, widgets"""
    octrl.enable()  # 1 overlay control
    mctrl.start()  # 2 module
    wctrl.start()  # 3 widget


def unload_modules():
    """Unload modules, widgets"""
    wctrl.close()  # 1 widget
    mctrl.close()  # 2 module
    octrl.disable()  # 3 overlay control

```

# File: tinypedal/log_handler.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Log handler setup
"""

import logging
import sys

from .const_app import PATH_GLOBAL
from .const_file import LogFile


def new_stream_handler(_logger: logging.Logger, stream) -> logging.StreamHandler:
    """Create new stream handler

    Args:
        _logger: logger instance.
        stream: stream object.
    Returns:
        Stream handler.
    """
    format_console = logging.Formatter(
        "%(asctime)s %(levelname)s: %(message)s", datefmt="%H:%M:%S"
    )
    _handler = logging.StreamHandler(stream)
    _handler.setFormatter(format_console)
    _handler.setLevel(logging.INFO)
    _logger.addHandler(_handler)
    return _handler


def new_file_handler(_logger: logging.Logger, filepath: str, filename: str) -> logging.FileHandler:
    """Create new file handler

    Args:
        _logger: logger instance.
        filepath: log file path.
        filename: log file name.
    Returns:
        File handler.
    """
    format_file = logging.Formatter("%(asctime)s %(levelname)s: %(message)s")
    _handler = logging.FileHandler(f"{filepath}{filename}")
    _handler.setFormatter(format_file)
    _handler.setLevel(logging.INFO)
    _logger.addHandler(_handler)
    return _handler


def set_logging_level(_logger: logging.Logger, log_stream=None, log_level=1) -> None:
    """Set logging level

    Args:
        _logger: logger instance.
        log_stream: log stream object.
        log_level:
            0 = output only warning or error to console.
            1 = output all log to console.
            2 = output all log to both console & file.
    """
    _logger.setLevel(logging.INFO)
    if log_stream is not None:
        new_stream_handler(_logger, log_stream)
    if log_level >= 1:
        new_stream_handler(_logger, sys.stdout)
        _logger.info("LOGGING: output to console")
    if log_level == 2:
        new_file_handler(_logger, PATH_GLOBAL, LogFile.APP_LOG)
        _logger.info("LOGGING: output to %s", LogFile.APP_LOG)

```

# File: tinypedal/main.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Launcher
"""

import io
import logging
import os
import sys

import psutil
from PySide2.QtCore import QCoreApplication, QLocale, Qt
from PySide2.QtGui import QFont, QGuiApplication, QIcon, QPixmapCache
from PySide2.QtWidgets import QApplication, QMessageBox

from . import version_check
from .const_app import (
    APP_NAME,
    PATH_GLOBAL,
    PLATFORM,
    VERSION,
)
from .const_file import ConfigType, ImageFile, LogFile
from .log_handler import set_logging_level
from .setting import cfg

logger = logging.getLogger(__package__)
log_stream = io.StringIO()


def save_pid_file():
    """Save PID info to file"""
    with open(f"{PATH_GLOBAL}{LogFile.PID}", "w", encoding="utf-8") as f:
        current_pid = os.getpid()
        pid_create_time = psutil.Process(current_pid).create_time()
        pid_str = f"{current_pid},{pid_create_time}"
        f.write(pid_str)


def is_pid_exist() -> bool:
    """Check and verify PID existence"""
    try:
        # Load last recorded PID and creation time from pid log file
        with open(f"{PATH_GLOBAL}{LogFile.PID}", "r", encoding="utf-8") as f:
            pid_read = f.readline()
        pid = pid_read.split(",")
        pid_last = int(pid[0])
        pid_last_create_time = pid[1]
        # Verify if last PID is running and belongs to TinyPedal
        if psutil.pid_exists(pid_last):
            if str(psutil.Process(pid_last).create_time()) == pid_last_create_time:
                return True  # already running
    except (ProcessLookupError, psutil.NoSuchProcess, ValueError, IndexError, FileNotFoundError):
        logger.info("PID not found or invalid")
    return False  # no running


#def is_exe_running() -> bool:
#    """Check running executable (windows only), this is only used as fallback"""
#    # Skip exe check if not on windows system
#    if PLATFORM != "Windows":
#        return False
#    app_pid = os.getpid()
#    EXE_FILE = "tinypedal.exe"
#    for app in psutil.process_iter(["name", "pid"]):
#        # Compare found APP name & pid
#        if app.info["name"] == EXE_FILE and app.info["pid"] != app_pid:
#            return True
#    return False


def single_instance_check(is_single_instance: bool):
    """Single instance check"""
    # Check if single instance mode enabled
    if not is_single_instance:
        logger.info("Single instance mode: OFF")
        return
    logger.info("Single instance mode: ON")
    # Skip if restarted
    if os.getenv("TINYPEDAL_RESTART") == "TRUE":
        os.environ.pop("TINYPEDAL_RESTART", None)
        save_pid_file()
        return
    # Check existing PID file first, then exe PID
    if not is_pid_exist():  # (is_pid_exist() or is_exe_running())
        save_pid_file()
        return
    # Show warning to console and popup dialog
    warning_text = (
        "TinyPedal is already running.\n\n"
        "Only one TinyPedal may be run at a time.\n"
        "Check system tray for hidden icon."
    )
    logger.warning(warning_text)
    QMessageBox.warning(None, f"{APP_NAME} v{VERSION}", warning_text)
    sys.exit()


def get_version():
    """Get version info"""
    logger.info("TinyPedal: %s", VERSION)
    logger.info("Python: %s", version_check.python())
    logger.info("Qt: %s", version_check.qt())
    logger.info("PySide: %s", version_check.pyside())
    logger.info("psutil: %s", version_check.psutil())


def init_gui() -> QApplication:
    """Initialize Qt Gui"""
    # Set global locale
    loc = QLocale(QLocale.C)
    loc.setNumberOptions(QLocale.RejectGroupSeparator)
    QLocale.setDefault(loc)
    # Set DPI scale
    if cfg.application["enable_high_dpi_scaling"]:
        QCoreApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        QGuiApplication.setHighDpiScaleFactorRoundingPolicy(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)
    # Set GUI
    QApplication.setStyle("Fusion")
    root = QApplication(sys.argv)
    root.setQuitOnLastWindowClosed(False)
    root.setApplicationName(APP_NAME)
    root.setWindowIcon(QIcon(ImageFile.APP_ICON))
    # Set window icon for X11/Wayland (workaround)
    if PLATFORM != "Windows":
        root.setDesktopFileName("TinyPedal-overlay")
    # Set default font
    font = root.font()
    if os.getenv("PYSIDE_OVERRIDE") != "6":  # don't set family for pyside6
        font.setFamily("sans-serif")
    font.setPointSize(10)
    font.setStyleHint(QFont.SansSerif)
    root.setFont(font)
    # Disable global pixmap cache
    QPixmapCache.setCacheLimit(0)
    logger.info("Screen pixel ratio: %s", root.devicePixelRatio())
    logger.info("Platform plugin: %s", root.platformName())
    return root


def unset_environment():
    """Clear any previous environment variable (required after auto-restarted APP)"""
    os.environ.pop("QT_QPA_PLATFORM", None)
    os.environ.pop("QT_ENABLE_HIGHDPI_SCALING", None)
    os.environ.pop("QT_MEDIA_BACKEND", None)
    os.environ.pop("QT_MULTIMEDIA_PREFERRED_PLUGINS", None)


def set_environment():
    """Set environment before starting GUI"""
    # Windows only
    if PLATFORM == "Windows":
        if os.getenv("PYSIDE_OVERRIDE") == "6":
            # Use "freetype" to avoid high memory usage in pyside6
            os.environ["QT_QPA_PLATFORM"] = "windows:fontengine=freetype"
            os.environ["QT_MEDIA_BACKEND"] = "windows"
        else:
            if cfg.compatibility["multimedia_plugin_on_windows"] == "WMF":
                multimedia_plugin = "windowsmediafoundation"
            else:
                multimedia_plugin = "directshow"
            os.environ["QT_MULTIMEDIA_PREFERRED_PLUGINS"] = multimedia_plugin

    # Linux only
    else:
        if cfg.compatibility["enable_x11_platform_plugin_override"]:
            os.environ["QT_QPA_PLATFORM"] = "xcb"

    # Common
    if cfg.application["enable_high_dpi_scaling"]:
        logger.info("High DPI scaling: ON")
    else:
        os.environ["QT_ENABLE_HIGHDPI_SCALING"] = "0"  # force disable (qt6 only)
        logger.info("High DPI scaling: OFF")


def start_app(cli_args):
    """Init main window"""
    unset_environment()
    set_logging_level(logger, log_stream, cli_args.log_level)
    get_version()
    # load global config
    cfg.load_global()
    cfg.save(cfg_type=ConfigType.CONFIG)
    set_environment()
    # Main GUI
    root = init_gui()
    single_instance_check(cli_args.single_instance)
    # Load core modules
    from . import loader
    loader.start()
    # Start mainloop
    sys.exit(root.exec_())

```

# File: tinypedal/module_info.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Module info
"""

from __future__ import annotations

from array import array
from collections import deque
from itertools import islice
from typing import Mapping, NamedTuple

from .calculation import circular_relative_distance, linear_interp
from .const_common import (
    DELTA_DEFAULT,
    EMPTY_DICT,
    MAX_METERS,
    MAX_SECONDS,
    MAX_VEHICLES,
    REL_TIME_DEFAULT,
    WHEELS_ZERO,
)


class ConsumptionDataSet(NamedTuple):
    """Consumption history data set"""

    lapNumber: int = 0
    isValidLap: int = 0
    lapTimeLast: float = 0.0
    lastLapUsedFuel: float = 0.0
    lastLapUsedEnergy: float = 0.0
    batteryDrainLast: float = 0.0
    batteryRegenLast: float = 0.0
    tyreAvgWearLast: float = 0.0
    capacityFuel: float = 0.0


class DeltaLapTime(array):
    """Delta lap time history data

    Recent lap time index range: 0 - 4.
    Recent best lap time index: 5 (-2).
    Last lap start time index: 6 (-1).
    """

    __slots__ = ()

    def update(self, lap_start: float, lap_elapsed: float, laptime_last: float):
        """Update delta lap time history"""
        # Check 2 sec after start new lap (for validating last lap time)
        # Store lap start time in index 5
        if self[-1] != lap_start and lap_elapsed - lap_start > 2:
            if self[-1] < lap_start:
                self[0], self[1], self[2], self[3] = self[1], self[2], self[3], self[4]
                if laptime_last > 0:  # valid last lap time
                    self[4] = laptime_last
                else:
                    self[4] = 0.0
            else:  # reset all laptime on session change
                self[0] = self[1] = self[2] = self[3] = self[4] = 0.0
            self[-1] = lap_start
            self[-2] = min(self._filter_laptime())

    def delta(self, target: DeltaLapTime, max_output: int):
        """Generate delta from target player's lap time data set"""
        for index in range(5 - max_output, 5):  # max 5 records
            if target[index] > 0 < self[index]:  # check invalid lap time
                yield target[index] - self[index]
            else:
                yield MAX_SECONDS

    def best(self) -> float:
        """Best lap time from recent laps"""
        return self[-2]

    def _filter_laptime(self):
        """Filter invalid lap time"""
        for laptime in islice(self, 5):
            if laptime > 0:
                yield laptime
            else:
                yield MAX_SECONDS


class VehicleSpeedTrap:
    """Vehicle speed trap"""

    __slots__ = (
        "_record_next",
        "_speed_before",
        "_distance_last",
        "_distance_before",
        "speed",
    )

    def __init__(self):
        self._record_next = False
        self._speed_before = 0.0
        self._distance_last = 0.0
        self._distance_before = 0.0
        self.speed = 0.0

    def update(self, speed: float, distance_into: float, speedtrap_distance: float, track_length: float):
        """Update speed trap data"""
        if self._distance_last == distance_into:
            return
        self._distance_last = distance_into

        # Center distance to speed trap position
        distance_into = circular_relative_distance(track_length, speedtrap_distance, distance_into)

        if self._record_next:
            # Distance before speed trap
            if 0 > distance_into:
                self._distance_before = distance_into
                self._speed_before = speed
            else:
                # Distance after speed trap
                if distance_into - self._distance_before < 200:
                    self.speed = linear_interp(
                        0,
                        self._distance_before,
                        self._speed_before,
                        distance_into,
                        speed,
                    )
                # Turn off record until distance circles back
                self._record_next = False
        elif 0 > distance_into:
            self._record_next = True


class VehiclePitTimer:
    """Vehicle pit timer"""

    __slots__ = (
        "elapsed",
        "stopped",
        "pitting",
        "lap_stopped",
        "_slot_id",
        "_pitin_time",
        "_pitstop_time",
        "_last_state",
        "_last_pit_lap",
    )

    def __init__(self):
        self.elapsed: float = 0.0
        self.stopped: float = 0.0
        self.pitting: bool = False
        self.lap_stopped: int = 0
        self._slot_id: int = -1
        self._pitin_time: float = 0.0
        self._pitstop_time: float = 0.0
        self._last_state: int = 0
        self._last_pit_lap: int = 99999

    def update(self, slot_id: int, in_pit: int, elapsed_time: float, laps_done: int, speed: float):
        """Calculate pit time

        Pit state: 0 = not in pit, 1 = in pit, 2 = in garage.
        """
        # Reset if slot (vehicle) id changed
        if self._slot_id != slot_id:
            self._slot_id = slot_id
            self.elapsed = 0.0
            self.stopped = 0.0
            self.pitting = False
            self._pitin_time = elapsed_time
            self._pitstop_time = elapsed_time
            self._last_state = 0
            self._last_pit_lap = laps_done
        # Reset if session changed
        if self._last_pit_lap > laps_done:
            self._last_pit_lap = laps_done
        # Pit status check
        if self._last_state != in_pit:
            self._last_state = in_pit
            self._pitin_time = elapsed_time
            self._pitstop_time = elapsed_time
            if in_pit:  # reset after enter pit
                self.elapsed = 0.0
                self.stopped = 0.0
        if in_pit:
            # Ignore pit timer in garage
            if in_pit == 2:
                self.elapsed = 0.0
                self.stopped = 0.0
                self._last_pit_lap = laps_done
            # Calculating time while in pit
            else:
                # Total elapsed time in pit
                self.elapsed += elapsed_time - self._pitin_time
                # Total stopped time in pit
                if speed < 0.1:
                    self.stopped += elapsed_time - self._pitstop_time
            # Reset delta
            self._pitin_time = elapsed_time
            self._pitstop_time = elapsed_time
            # Save last in pit lap number
            # Pit state can desync, wait minimum 2 seconds before update
            if self.elapsed > 2 and self.stopped > 1:  # stop for more than 1 seconds
                self._last_pit_lap = laps_done
        # Check whether is pitting lap
        self.pitting = (in_pit > 0 or laps_done == self._last_pit_lap)
        self.lap_stopped = self._last_pit_lap


class VehicleDataSet:
    """Vehicle data set"""

    __slots__ = (
        "isPlayer",
        "elapsedTime",
        "positionOverall",
        "positionInClass",
        "qualifyOverall",
        "qualifyInClass",
        "driverName",
        "vehicleName",
        "vehicleClass",
        "classBestLapTime",
        "bestLapTime",
        "lastLapTime",
        "currentLapProgress",
        "totalLapProgress",
        "gapBehindNext",
        "gapBehindNextInClass",
        "gapBehindLeader",
        "gapBehindLeaderInClass",
        "isLapped",
        "isYellow",
        "inPit",
        "isClassFastestLastLap",
        "numPitStops",
        "pitRequested",
        "tireCompoundFront",
        "tireCompoundRear",
        "relativeOrientationRadians",
        "relativeStraightDistance",
        "worldPositionX",
        "worldPositionY",
        "relativeRotatedPositionX",
        "relativeRotatedPositionY",
        "vehicleIntegrity",
        "energyRemaining",
        "estimatedStintLaps",
        "currentStintLaps",
        "pitTimer",
        "speedTrap",
        "lapTimeHistory",
    )

    def __init__(self):
        self.isPlayer: bool = False
        self.elapsedTime: float = 0.0
        self.positionOverall: int = 0
        self.positionInClass: int = 0
        self.qualifyOverall: int = 0
        self.qualifyInClass: int = 0
        self.driverName: str = ""
        self.vehicleName: str = ""
        self.vehicleClass: str = ""
        self.classBestLapTime: float = MAX_SECONDS
        self.bestLapTime: float = MAX_SECONDS
        self.lastLapTime: float = MAX_SECONDS
        self.currentLapProgress: float = 0.0
        self.totalLapProgress: float = 0.0
        self.gapBehindNext: float = 0.0
        self.gapBehindNextInClass: float = 0.0
        self.gapBehindLeader: float = 0.0
        self.gapBehindLeaderInClass: float = 0.0
        self.isLapped: float = 0.0
        self.isYellow: bool = False
        self.inPit: int = 0
        self.isClassFastestLastLap: bool = False
        self.numPitStops: int = 0
        self.pitRequested: bool = False
        self.tireCompoundFront: str = ""
        self.tireCompoundRear: str = ""
        self.relativeOrientationRadians: float = 0.0
        self.relativeStraightDistance: float = 0.0
        self.worldPositionX: float = 0.0
        self.worldPositionY: float = 0.0
        self.relativeRotatedPositionX: float = 0.0
        self.relativeRotatedPositionY: float = 0.0
        self.vehicleIntegrity: float = 0.0
        self.energyRemaining: float = 0.0
        self.estimatedStintLaps: float = 0.0
        self.currentStintLaps: int = 0
        self.pitTimer: VehiclePitTimer = VehiclePitTimer()
        self.speedTrap: VehicleSpeedTrap = VehicleSpeedTrap()
        self.lapTimeHistory: DeltaLapTime = DeltaLapTime("d", [0.0] * 7)


class DeltaInfo:
    """Delta module output data"""

    __slots__ = (
        "deltaBestData",
        "deltaBest",
        "deltaLast",
        "deltaSession",
        "deltaStint",
        "isValidLap",
        "lapTimeCurrent",
        "lapTimeLast",
        "lapTimeBest",
        "lapTimeEstimated",
        "lapTimeSession",
        "lapTimeStint",
        "lapTimePace",
        "lapDistance",
    )

    def __init__(self):
        self.deltaBestData: tuple[tuple[float, float], ...] = DELTA_DEFAULT
        self.deltaBest: float = 0.0
        self.deltaLast: float = 0.0
        self.deltaSession: float = 0.0
        self.deltaStint: float = 0.0
        self.isValidLap: bool = False
        self.lapTimeCurrent: float = 0.0
        self.lapTimeLast: float = 0.0
        self.lapTimeBest: float = 0.0
        self.lapTimeEstimated: float = 0.0
        self.lapTimeSession: float = 0.0
        self.lapTimeStint: float = 0.0
        self.lapTimePace: float = 0.0
        self.lapDistance: float = 0.0


class ForceInfo:
    """Force module output data"""

    __slots__ = (
        "lgtGForceRaw",
        "latGForceRaw",
        "maxAvgLatGForce",
        "maxLgtGForce",
        "maxLatGForce",
        "downForceFront",
        "downForceRear",
        "downForceRatio",
        "brakingRate",
        "transientMaxBrakingRate",
        "maxBrakingRate",
        "deltaBrakingRate",
    )

    def __init__(self):
        self.lgtGForceRaw: float = 0.0
        self.latGForceRaw: float = 0.0
        self.maxAvgLatGForce: float = 0.0
        self.maxLgtGForce: float = 0.0
        self.maxLatGForce: float = 0.0
        self.downForceFront: float = 0.0
        self.downForceRear: float = 0.0
        self.downForceRatio: float = 0.0
        self.brakingRate: float = 0.0
        self.transientMaxBrakingRate: float = 0.0
        self.maxBrakingRate: float = 0.0
        self.deltaBrakingRate: float = 0.0


class FuelInfo:
    """Fuel module output data"""

    __slots__ = (
        "capacity",
        "amountStart",
        "amountCurrent",
        "amountUsedCurrent",
        "amountEndStint",
        "neededRelative",
        "neededAbsolute",
        "lastLapConsumption",
        "estimatedConsumption",
        "estimatedValidConsumption",
        "estimatedLaps",
        "estimatedMinutes",
        "estimatedNumPitStopsEnd",
        "estimatedNumPitStopsEarly",
        "deltaConsumption",
        "oneLessPitConsumption",
    )

    def __init__(self):
        self.reset()

    def reset(self):
        """Reset"""
        self.capacity: float = 0.0
        self.amountStart: float = 0.0
        self.amountCurrent: float = 0.0
        self.amountUsedCurrent: float = 0.0
        self.amountEndStint: float = 0.0
        self.neededRelative: float = 0.0
        self.neededAbsolute: float = 0.0
        self.lastLapConsumption: float = 0.0
        self.estimatedConsumption: float = 0.0
        self.estimatedValidConsumption: float = 0.0
        self.estimatedLaps: float = 0.0
        self.estimatedMinutes: float = 0.0
        self.estimatedNumPitStopsEnd: float = 0.0
        self.estimatedNumPitStopsEarly: float = 0.0
        self.deltaConsumption: float = 0.0
        self.oneLessPitConsumption: float = 0.0


class HistoryInfo:
    """History output data"""

    __slots__ = (
        "consumptionDataName",
        "consumptionDataVersion",
        "consumptionDataSet",
    )

    def __init__(self):
        self.consumptionDataName: str = ""
        self.consumptionDataVersion: int = 0
        self.consumptionDataSet: deque[ConsumptionDataSet] = deque([ConsumptionDataSet()], 100)

    def reset_consumption(self):
        """Reset consumption data"""
        self.consumptionDataName = ""
        self.consumptionDataVersion = 0
        self.consumptionDataSet.clear()
        self.consumptionDataSet.appendleft(ConsumptionDataSet())


class HybridInfo:
    """Hybrid module output data"""

    __slots__ = (
        "batteryCharge",
        "batteryDrain",
        "batteryRegen",
        "batteryDrainLast",
        "batteryRegenLast",
        "batteryNetChange",
        "motorActiveTimer",
        "motorInactiveTimer",
        "motorState",
        "fuelEnergyRatio",
        "fuelEnergyBias",
    )

    def __init__(self):
        self.batteryCharge: float = 0.0
        self.batteryDrain: float = 0.0
        self.batteryRegen: float = 0.0
        self.batteryDrainLast: float = 0.0
        self.batteryRegenLast: float = 0.0
        self.batteryNetChange: float = 0.0
        self.motorActiveTimer: float = 0.0
        self.motorInactiveTimer: float = 0.0
        self.motorState: int = 0
        self.fuelEnergyRatio: float = 0.0
        self.fuelEnergyBias: float = 0.0


class MappingInfo:
    """Mapping module output data"""

    __slots__ = (
        "coordinates",
        "elevations",
        "sectors",
        "lastModified",
        "speedTrapPosition",
        "pitEntryPosition",
        "pitExitPosition",
        "pitLaneLength",
        "pitSpeedLimit",
        "pitPassTime",
    )

    def __init__(self):
        self.reset()

    def reset(self):
        """Reset"""
        self.coordinates: tuple[tuple[float, float], ...] | None = None
        self.elevations: tuple[tuple[float, float], ...] | None = None
        self.sectors: tuple[int, int] | None = None
        self.lastModified: float = 0.0
        self.speedTrapPosition: float = 0.0
        self.pitEntryPosition: float = 0.0
        self.pitExitPosition: float = 0.0
        self.pitLaneLength: float = 0.0
        self.pitSpeedLimit: float = 0.0
        self.pitPassTime: float = 0.0


class NotesInfo:
    """Notes module output data"""

    __slots__ = (
        "currentIndex",
        "currentNote",
        "nextIndex",
        "nextNote",
    )

    def __init__(self):
        self.reset()

    def reset(self):
        """Reset"""
        self.currentIndex: int = 0
        self.currentNote: Mapping[str, float | str] = EMPTY_DICT
        self.nextIndex: int = 0
        self.nextNote: Mapping[str, float | str] = EMPTY_DICT


class RelativeInfo:
    """Relative module output data"""

    __slots__ = (
        "relative",
        "standings",
        "classes",
        "drawOrder",
    )

    def __init__(self):
        self.relative: list[tuple[float, int]] = [REL_TIME_DEFAULT]
        self.standings: list[int] = [-1]
        self.classes: list[list] = [[0, 1, "", 0.0, -1, -1, -1, False]]
        self.drawOrder: list = [0]


class SectorsInfo:
    """Sectors module output data"""

    __slots__ = (
        "noDeltaSector",
        "sectorIndex",
        "sectorPrev",
        "sectorBestTB",
        "sectorBestPB",
        "deltaSectorBestPB",
        "deltaSectorBestTB",
    )

    def __init__(self):
        self.noDeltaSector: bool = True
        self.sectorIndex: int = -1
        self.sectorPrev: list[float] = [MAX_SECONDS] * 3
        self.sectorBestTB: list[float] = [MAX_SECONDS] * 3
        self.sectorBestPB: list[float] = [MAX_SECONDS] * 3
        self.deltaSectorBestPB: list[float] = [MAX_SECONDS] * 3
        self.deltaSectorBestTB: list[float] = [MAX_SECONDS] * 3


class StatsInfo:
    """Stats module output data"""

    __slots__ = (
        "metersDriven",
    )

    def __init__(self):
        self.metersDriven: float = 0.0


class VehiclesInfo:
    """Vehicles module output data"""

    __slots__ = (
        "dataSet",
        "dataSetVersion",
        "leaderIndex",
        "playerIndex",
        "totalOutPits",
        "totalInPits",
        "totalStoppedPits",
        "totalPitRequests",
        "totalCompletedLaps",
        "totalVehicles",
        "nearestLine",
        "nearestTraffic",
        "nearestYellowAhead",
        "nearestYellowBehind",
        "leaderBestLapTime",
    )

    def __init__(self):
        self.dataSet: tuple[VehicleDataSet, ...] = tuple(
            VehicleDataSet() for _ in range(MAX_VEHICLES)
        )
        self.dataSetVersion: int = -1
        self.leaderIndex: int = 0
        self.playerIndex: int = -1
        self.totalOutPits: int = 0
        self.totalInPits: int = 0
        self.totalStoppedPits: int = 0
        self.totalPitRequests: int = 0
        self.totalCompletedLaps: int = 0
        self.totalVehicles: int = 0
        self.nearestLine: float = MAX_METERS
        self.nearestTraffic: float = MAX_SECONDS
        self.nearestYellowAhead: float = MAX_METERS
        self.nearestYellowBehind: float = -MAX_METERS
        self.leaderBestLapTime: float = MAX_SECONDS


class WheelsInfo:
    """Wheels module output data"""

    __slots__ = (
        "lockingPercentFront",
        "lockingPercentRear",
        "corneringRadius",
        "slipRatio",
        "currentTreadDepth",
        "currentLapTreadWear",
        "lastLapTreadWear",
        "estimatedTreadWear",
        "estimatedValidTreadWear",
        "maxBrakeThickness",
        "failureBrakeThickness",
        "currentBrakeThickness",
        "currentlapBrakeWear",
        "lastLapBrakeWear",
        "estimatedBrakeWear",
        "estimatedValidBrakeWear",
        "currentSuspensionPosition",
        "staticSuspensionPosition",
        "minSuspensionPosition",
        "maxSuspensionPosition",
    )

    def __init__(self):
        self.lockingPercentFront: float = 0.0
        self.lockingPercentRear: float = 0.0
        self.corneringRadius: float = 0.0
        self.slipRatio: list[float] = list(WHEELS_ZERO)
        self.currentTreadDepth: list[float] = list(WHEELS_ZERO)
        self.currentLapTreadWear: list[float] = list(WHEELS_ZERO)
        self.lastLapTreadWear: list[float] = list(WHEELS_ZERO)
        self.estimatedTreadWear: list[float] = list(WHEELS_ZERO)
        self.estimatedValidTreadWear: list[float] = list(WHEELS_ZERO)
        self.maxBrakeThickness: list[float] = list(WHEELS_ZERO)
        self.failureBrakeThickness: list[float] = list(WHEELS_ZERO)
        self.currentBrakeThickness: list[float] = list(WHEELS_ZERO)
        self.currentlapBrakeWear: list[float] = list(WHEELS_ZERO)
        self.lastLapBrakeWear: list[float] = list(WHEELS_ZERO)
        self.estimatedBrakeWear: list[float] = list(WHEELS_ZERO)
        self.estimatedValidBrakeWear: list[float] = list(WHEELS_ZERO)
        self.currentSuspensionPosition: list[float] = list(WHEELS_ZERO)
        self.staticSuspensionPosition: list[float] = list(WHEELS_ZERO)
        self.minSuspensionPosition: list[float] = list(WHEELS_ZERO)
        self.maxSuspensionPosition: list[float] = list(WHEELS_ZERO)


class ModuleInfo:
    """Modules output data"""

    __slots__ = (
        "delta",
        "energy",
        "force",
        "fuel",
        "history",
        "hybrid",
        "mapping",
        "pacenotes",
        "relative",
        "sectors",
        "stats",
        "tracknotes",
        "vehicles",
        "wheels",
    )

    def __init__(self):
        self.delta = DeltaInfo()
        self.energy = FuelInfo()
        self.force = ForceInfo()
        self.fuel = FuelInfo()
        self.history = HistoryInfo()
        self.hybrid = HybridInfo()
        self.mapping = MappingInfo()
        self.pacenotes = NotesInfo()
        self.relative = RelativeInfo()
        self.sectors = SectorsInfo()
        self.stats = StatsInfo()
        self.tracknotes = NotesInfo()
        self.vehicles = VehiclesInfo()
        self.wheels = WheelsInfo()


minfo = ModuleInfo()

```

# File: tinypedal/overlay_control.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Overlay Control
"""

import logging
import threading
from time import sleep

from . import overlay_signal, realtime_state
from .api_control import api
from .setting import cfg

logger = logging.getLogger(__name__)


class OverlayToggle:
    """Overlay state toggle"""

    __slots__ = ()

    def vr(self):
        """Toggle VR state"""
        self.__toggle_option("vr_compatibility")
        overlay_signal.iconify.emit(cfg.overlay["vr_compatibility"])

    def lock(self):
        """Toggle lock state"""
        self.__toggle_option("fixed_position")
        overlay_signal.locked.emit(cfg.overlay["fixed_position"])

    def hide(self):
        """Toggle hide state"""
        self.__toggle_option("auto_hide")

    def grid(self):
        """Toggle grid move state"""
        self.__toggle_option("enable_grid_move")

    @staticmethod
    def __toggle_option(option_name: str):
        """Toggle option"""
        cfg.overlay[option_name] = not cfg.overlay[option_name]
        cfg.save()


class OverlayControl:
    """Overlay control"""

    __slots__ = (
        "toggle",
        "_stopped",
        "_event",
        "_last_active_state",
        "_last_hide_state",
    )

    def __init__(self):
        self.toggle = OverlayToggle()
        self._stopped = True
        self._event = threading.Event()

        self._last_active_state = None
        self._last_hide_state = None

    def enable(self):
        """Enable overlay control"""
        if self._stopped:
            self._stopped = False
            self._event.clear()
            threading.Thread(target=self.__updating, daemon=True).start()
            logger.info("ENABLED: overlay control")

    def disable(self):
        """Disable overlay control"""
        self._event.set()
        while not self._stopped:
            sleep(0.01)

    def __updating(self):
        """Update global state"""
        _event_wait = self._event.wait
        while not _event_wait(0.2):
            # Read state
            active = api.read.state.active()
            paused = api.read.state.paused()
            # Update state
            realtime_state.active = active
            realtime_state.paused = paused
            # Auto hide state check
            hide_state = cfg.overlay["auto_hide"] and not active
            if self._last_hide_state != hide_state:
                self._last_hide_state = hide_state
                overlay_signal.hidden.emit(hide_state)
            # Active state check
            if self._last_active_state != active:
                self._last_active_state = active
                # Update auto load state only once when player enters track
                if active and cfg.application["enable_auto_load_preset"]:
                    self.__check_preset_class()
                # Set overlay timer state
                overlay_signal.paused.emit(not active)

        self._stopped = True
        logger.info("DISABLED: overlay control")

    def __check_preset_class(self) -> bool:
        """Check primary preset from class"""
        class_name = api.read.vehicle.class_name()
        class_data = cfg.user.classes.get(class_name)
        if class_data is None:
            return False
        class_preset_name = class_data["preset"]
        if class_preset_name == "":
            return False
        preset_name = cfg.get_primary_preset_name(class_preset_name)
        self.__auto_load_preset(class_name, preset_name)
        return True

    def __auto_load_preset(self, target_name, preset_name):
        """Auto load primary preset"""
        logger.info("AUTOLOADING: %s detected, attempt loading %s (primary preset)", target_name, preset_name)
        # Abort if preset file does not exist
        if preset_name == "":
            logger.info("AUTOLOADING: %s (primary preset) not found, abort auto loading", preset_name)
            return
        # Check if already loaded
        if cfg.is_loaded(preset_name):
            logger.info("AUTOLOADING: %s (primary preset) already loaded", preset_name)
            return
        # Update preset name & signal reload
        cfg.set_next_to_load(preset_name)
        overlay_signal.reload.emit(True)


octrl = OverlayControl()

```

# File: tinypedal/regex_pattern.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Regular expression, pattern, string constants
"""

import re
from types import MappingProxyType

from .const_api import API_MAP_ALIAS

# Compiled regex function
rex_hex_color = re.compile(r"^#[0-9A-F]{3}$|^#[0-9A-F]{6}$|^#[0-9A-F]{8}$", flags=re.IGNORECASE)
rex_invalid_char = re.compile(r'[\\/:*?"<>|]')
rex_number_extract = re.compile(r"\d*\.?\d+")

# Bool
CFG_BOOL = (
    # Exact match
    "^active_state$|"
    "^auto_hide$|"
    "^auto_hide_if_not_available$|"
    "^auto_hide_in_private_qualifying$|"
    "^check_for_updates_on_startup$|"
    "^fixed_position$|"
    "^minimize_to_tray$|"
    "^remember_position$|"
    "^remember_size$|"
    "^vr_compatibility$|"
    # Partial match
    "align_center|"
    "enable|"
    "shorten|"
    "show|"
    "swap_upper_caption|"
    "swap_lower_caption|"
    "swap_style|"
    "uppercase"
)

# String with unique validator
CFG_COLOR = "color"
CFG_CLOCK_FORMAT = "clock_format"

# String choice
CFG_API_NAME = "api_name"
CFG_CHARACTER_ENCODING = "character_encoding"
CFG_DELTABEST_SOURCE = "deltabest_source"
CFG_FONT_WEIGHT = "font_weight"
CFG_TARGET_LAPTIME = "target_laptime"
CFG_TEXT_ALIGNMENT = "text_alignment"
CFG_MULTIMEDIA_PLUGIN = "multimedia_plugin"
CFG_STATS_CLASSIFICATION = "vehicle_classification"
CFG_WINDOW_COLOR_THEME = "window_color_theme"

# String common
CFG_FONT_NAME = "font_name"
CFG_HEATMAP = "heatmap"
CFG_USER_PATH = "_path"
CFG_USER_IMAGE = "_image_file"
CFG_STRING = (
    # Exact match
    "^process_id$|"
    "^version$|"
    # Partial match
    "file_name|"
    "prefix|"
    "sound_format|"
    "suffix|"
    "text|"
    "unit|"
    "url_host"
)

# Integer
CFG_INTEGER = (
    # Exact match
    "^access_mode$|"
    "^electric_braking_allocation$|"
    "^grid_move_size$|"
    "^lap_time_history_count$|"
    "^leading_zero$|"
    "^manual_steering_range$|"
    "^maximum_saving_attempts$|"
    "^player_index$|"
    "^parts_width$|"
    "^parts_max_height$|"
    "^parts_max_width$|"
    "^position_x$|"
    "^position_y$|"
    "^snap_distance$|"
    "^snap_gap$|"
    "^stint_history_count$|"
    "^window_width$|"
    "^window_height$|"
    # Partial match
    "area_margin|"
    "area_size|"
    "bar_edge_width|"
    "bar_gap|"
    "bar_height|"
    "bar_length|"
    "bar_width|"
    "column_index|"
    "decimal_places|"
    "display_detail_level|"
    "display_height|"
    "display_margin|"
    "display_size|"
    "display_width|"
    "draw_order_index|"
    "font_size|"
    "horizontal_gap|"
    "icon_size|"
    "inner_gap|"
    "layout|"
    "max_queue|"
    "number_of|"
    "samples|"
    "sampling_interval|"
    "sound_volume|"
    "split_gap|"
    "update_interval|"
    "url_port|"
    "vehicles|"
    "vertical_gap"
)

# Filename
CFG_INVALID_FILENAME = (
    # Exact match
    "^$|"
    "^brakes$|"
    "^brands$|"
    "^classes$|"
    "^compounds$|"
    "^config$|"
    "^heatmap$|"
    "^tracks$|"
    # Partial match
    "backup"
)

# Abbreviation
ABBR_PATTERN = (
    "^id | id$| id |"
    "^ui | ui$| ui |"
    "^led | led$| led |"
    "api|"
    "dpi|"
    "drs|"
    "ffb|"
    "lmu|"
    "p2p|"
    "rpm|"
    "rf2|"
    "url"
)

# Choice dictionary
CHOICE_COMMON = MappingProxyType({
    CFG_API_NAME: tuple(API_MAP_ALIAS),
    CFG_CHARACTER_ENCODING: ("UTF-8", "ISO-8859-1"),
    CFG_DELTABEST_SOURCE: ("Best", "Session", "Stint", "Last"),
    CFG_FONT_WEIGHT: ("normal", "bold"),
    CFG_TARGET_LAPTIME: ("Theoretical", "Personal"),
    CFG_TEXT_ALIGNMENT: ("Left", "Center", "Right"),
    CFG_MULTIMEDIA_PLUGIN: ("WMF", "DirectShow"),
    CFG_STATS_CLASSIFICATION: ("Class - Brand", "Class", "Vehicle"),
    CFG_WINDOW_COLOR_THEME: ("Light", "Dark"),
})
CHOICE_UNITS = MappingProxyType({
    "distance_unit": ("Meter", "Feet"),
    "fuel_unit": ("Liter", "Gallon"),
    "odometer_unit": ("Kilometer", "Mile", "Meter"),
    "power_unit": ("Kilowatt", "Horsepower", "Metric Horsepower"),
    "speed_unit": ("KPH", "MPH", "m/s"),
    "temperature_unit": ("Celsius", "Fahrenheit"),
    "turbo_pressure_unit": ("bar", "psi", "kPa"),
    "tyre_pressure_unit": ("kPa", "psi", "bar"),
})

# Misc
COMMON_TYRE_COMPOUNDS = (
    ("super", "Q"),  # super soft
    ("inter", "I"),  # intermediate
    ("soft", "S"),
    ("med", "M"),  # medium
    ("hard", "H"),
    ("rain|wet", "W"),
    ("slick|dry", "S"),
    ("road|radial|tread", "R"),
    ("bias", "B"),  # bias ply
)

```

# File: tinypedal/setting_preupdate.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Setting pre update function
"""

from __future__ import annotations

import logging

logger = logging.getLogger(__name__)


def preupdate_specific_version(preset_version: tuple[int, int, int], dict_user: dict):
    """Pre update old setting from specific version"""
    # Create target version and update function list
    # Very old version may be removed later
    target_versions = (
        ((2, 39, 1), _user_prior_2_39_1),  # 2026-01-16
        ((2, 39, 0), _user_prior_2_39_0),  # 2026-01-13
        ((2, 37, 0), _user_prior_2_37_0),  # 2025-12-24
        ((2, 36, 0), _user_prior_2_36_0),  # 2025-12-13
        ((2, 33, 1), _user_prior_2_33_1),  # 2025-08-22
    )
    for _version, _update in reversed(target_versions):
        if preset_version < _version:
            _update(dict_user)
            logger.info("USERDATA: updated old setting prior to %s.%s.%s", *_version)


def _user_prior_2_39_1(dict_user: dict):
    """Update user setting prior to 2.39.1"""
    track_map = dict_user.get("track_map")
    if isinstance(track_map, dict):
        if "pitstop_duration_minimum" in track_map:
            track_map["pitout_duration_minimum"] = track_map["pitstop_duration_minimum"]
        if "pitstop_duration_increment" in track_map:
            track_map["pitout_duration_increment"] = track_map["pitstop_duration_increment"]


def _user_prior_2_39_0(dict_user: dict):
    """Update user setting prior to 2.39.0"""
    suspension_position = dict_user.get("suspension_position")
    if isinstance(suspension_position, dict):
        if suspension_position["negative_position_color"] == "#FF2200":
            suspension_position["negative_position_color"] = "#00AAFF"


def _user_prior_2_37_0(dict_user: dict):
    """Update user setting prior to 2.37.0"""
    # Transfer wheel_alignment setting to new widgets
    wheel_alignment = dict_user.get("wheel_alignment")
    if isinstance(wheel_alignment, dict):
        wheel_alignment["bar_gap"] = 0
        dict_user["wheel_camber"] = wheel_alignment.copy()
        dict_user["wheel_toe"] = wheel_alignment.copy()
        dict_user["wheel_toe"]["position_y"] += 60


def _user_prior_2_36_0(dict_user: dict):
    """Update user setting prior to 2.36.0"""
    # Copy old telemetry_api setting
    telemetry_api = dict_user.get("telemetry_api")
    if isinstance(telemetry_api, dict):
        dict_user["api_lmu"] = telemetry_api.copy()
        dict_user["api_rf2"] = telemetry_api.copy()
    # Correct default update interval in module_vehicles
    module_vehicles = dict_user.get("module_vehicles")
    if isinstance(module_vehicles, dict):
        if module_vehicles["update_interval"] == 20:
            module_vehicles["update_interval"] = 10


def _user_prior_2_33_1(dict_user: dict):
    """Update user setting prior to 2.33.1"""
    # Fix option name typo "predication"
    relative_finish_order = dict_user.get("relative_finish_order")
    if isinstance(relative_finish_order, dict):
        _rename_key(relative_finish_order, "predication", "prediction")

    track_map = dict_user.get("track_map")
    if isinstance(track_map, dict):
        _rename_key(track_map, "predication", "prediction")


# Misc function
def _rename_key(data: dict, old: str, new: str):
    """Rename key name"""
    for key in tuple(data):
        if old in key:
            data[key.replace(old, new)] = data.pop(key)

```

# File: tinypedal/units.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Units conversion function, selector, symbol
"""

from __future__ import annotations

from typing import Callable


def pass_value(v: float) -> float:
    """Pass value"""
    return v


# Unit conversion
def meter_to_millimeter(meter: float) -> float:
    """Meter to Millimeter"""
    return meter * 1000


def meter_to_feet(meter: float) -> float:
    """Meter to Feet"""
    return meter * 3.2808399


def meter_to_kilometer(meter: float) -> float:
    """Meter to Kilometer"""
    return meter * 0.001


def meter_to_mile(meter: float) -> float:
    """Meter to Mile"""
    return meter / 1609.344


def mps_to_kph(meter: float) -> float:
    """Meter per sec to Kilometers per hour"""
    return meter * 3.6


def mps_to_mph(meter: float) -> float:
    """Meter per sec to Miles per hour"""
    return meter * 2.23693629


def celsius_to_fahrenheit(temperature: float) -> float:
    """Celsius to Fahrenheit"""
    return temperature * 1.8 + 32


def liter_to_gallon(liter: float) -> float:
    """Liter to Gallon"""
    return liter * 0.26417205


def kelvin_to_celsius(kelvin: float) -> float:
    """Kelvin to Celsius"""
    return kelvin - 273.15


def kpa_to_psi(kilopascal: float) -> float:
    """Kilopascal to Pounds per square inch (psi)"""
    return kilopascal * 0.14503774


def kpa_to_bar(kilopascal: float) -> float:
    """Kilopascal to bar"""
    return kilopascal * 0.01


def kw_to_hp(kilowatt: float) -> float:
    """Kilowatt to Imperial Horsepower (hp)"""
    return kilowatt * 1.341


def kw_to_ps(kilowatt: float) -> float:
    """Kilowatt to Metric Horsepower (ps)"""
    return kilowatt * 1.3596


# Set unit conversion function
def set_unit_distance(unit_name: str = "Meter") -> Callable:
    """Set unit distance"""
    if unit_name == "Feet":
        return meter_to_feet
    if unit_name == "Kilometer":
        return meter_to_kilometer
    if unit_name == "Mile":
        return meter_to_mile
    return pass_value


def set_unit_fuel(unit_name: str = "Liter") -> Callable:
    """Set unit fuel"""
    if unit_name == "Gallon":
        return liter_to_gallon
    return pass_value


def set_unit_power(unit_name: str = "Kilowatt") -> Callable:
    """Set unit power"""
    if unit_name == "Horsepower":
        return kw_to_hp
    if unit_name == "Metric Horsepower":
        return kw_to_ps
    return pass_value


def set_unit_pressure(unit_name: str = "kPa") -> Callable:
    """Set unit pressure"""
    if unit_name == "psi":
        return kpa_to_psi
    if unit_name == "bar":
        return kpa_to_bar
    return pass_value


def set_unit_speed(unit_name: str = "m/s") -> Callable:
    """Set unit speed"""
    if unit_name == "KPH":
        return mps_to_kph
    if unit_name == "MPH":
        return mps_to_mph
    return pass_value


def set_unit_temperature(unit_name: str = "Celsius") -> Callable:
    """Set unit temperature"""
    if unit_name == "Fahrenheit":
        return celsius_to_fahrenheit
    return pass_value


# Set unit symbol string
def set_symbol_distance(unit_name: str = "Meter") -> str:
    """Set symbol distance"""
    if unit_name == "Feet":
        return "ft"
    if unit_name == "Kilometer":
        return "km"
    if unit_name == "Mile":
        return "mi"
    return "m"


def set_symbol_fuel(unit_name: str = "Liter") -> str:
    """Set symbol fuel"""
    if unit_name == "Gallon":
        return "gal"
    return "L"


def set_symbol_power(unit_name: str = "Kilowatt") -> str:
    """Set symbol power"""
    if unit_name == "Horsepower":
        return "hp"
    if unit_name == "Metric Horsepower":
        return "ps"
    return "kW"


def set_symbol_pressure(unit_name: str = "kPa") -> str:
    """Set symbol pressure"""
    if unit_name == "psi":
        return "psi"
    if unit_name == "bar":
        return "bar"
    return "kPa"


def set_symbol_speed(unit_name: str = "m/s") -> str:
    """Set symbol speed"""
    if unit_name == "KPH":
        return "km/h"
    if unit_name == "MPH":
        return "mph"
    return "m/s"


def set_symbol_temperature(unit_name: str = "Celsius") -> str:
    """Set symbol temperature"""
    if unit_name == "Fahrenheit":
        return "Â°F"
    return "Â°C"

```

# File: tinypedal/update.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Check for updates
"""

from __future__ import annotations

import asyncio
import logging
import threading

from . import overlay_signal, version
from .async_request import get_response, set_header_get
from .const_app import APP_NAME, REPO_NAME
from .const_common import DATE_NA, VERSION_NA
from .version_check import is_new_version, parse_version_string

logger = logging.getLogger(__name__)


def request_latest_release():
    """Setup request for latest release data from github Rest API"""
    uri_path = f"/repos/{REPO_NAME}/releases/latest"
    host = "api.github.com"
    port = 443
    timeout = 5
    user_agent = f"User-Agent: {APP_NAME}/{version.__version__}"
    request_header = set_header_get(
        uri_path,
        host,
        user_agent,
        "Accept: application/vnd.github+json",
        "X-GitHub-Api-Version: 2022-11-28",
    )
    return get_response(request_header, host, port, timeout, ssl=True)


def parse_version(data: bytes) -> tuple[int, int, int]:
    """Parse release version"""
    try:
        pos_beg = data.find(b'"', data.find(b":", data.find(b"tag_name"))) + 1
        if pos_beg > 0:
            pos_end = data.find(b'"', pos_beg)
            ver_raw = data[pos_beg:pos_end]
            ver_strip = ver_raw.lstrip(b"v").split(b"-")[0]
            ver_split = ver_strip.split(b".")
            return int(ver_split[0]), int(ver_split[1]), int(ver_split[2])
    except (AttributeError, TypeError, IndexError, ValueError):
        logger.error("UPDATES: error while fetching latest release version info")
    return VERSION_NA


def parse_date(data: bytes) -> tuple[int, int, int]:
    """Parse release date"""
    try:
        pos_beg = data.find(b'"', data.find(b":", data.find(b"published_at"))) + 1
        if pos_beg > 0:
            pos_end = data.find(b'"', pos_beg)
            date_raw = data[pos_beg:pos_end]
            date_strip = date_raw.strip().split(b"T")[0]
            date_split = date_strip.split(b"-")
            return int(date_split[0]), int(date_split[1]), int(date_split[2])
    except (AttributeError, TypeError, IndexError, ValueError):
        logger.error("UPDATES: error while fetching latest release date info")
    return DATE_NA


class UpdateChecker:
    """Check for updates"""

    __slots__ = (
        "_is_checking",
        "_update_available",
        "_manual_checking",
        "_last_checked_version",
        "_last_checked_date",
    )

    def __init__(self):
        self._is_checking = False
        self._update_available = False
        self._manual_checking = False
        self._last_checked_version = VERSION_NA
        self._last_checked_date = DATE_NA

    def is_manual(self) -> bool:
        """Is manual checking"""
        return self._manual_checking

    def is_updates(self) -> bool:
        """Is updates available"""
        return self._update_available

    def check(self, manual: bool):
        """Run update check in separated thread"""
        self._manual_checking = manual
        if not self._is_checking:
            self._is_checking = True
            overlay_signal.updates.emit(True)
            threading.Thread(target=self.__checking, daemon=True).start()

    def __checking(self):
        """Fetch version info from github Rest API"""
        raw_bytes = asyncio.run(request_latest_release())
        checked_version = parse_version(raw_bytes)
        checked_date = parse_date(raw_bytes)
        current_version = parse_version_string(version.__version__)
        self._update_available = is_new_version(checked_version, current_version, version.DEVELOPMENT)
        # Save info
        self._last_checked_version = checked_version
        self._last_checked_date = checked_date
        # Send update signal
        overlay_signal.updates.emit(False)
        self._is_checking = False
        # Output log
        logger.info("UPDATES: %s", self.message())

    def message(self) -> str:
        """Get message"""
        if self._last_checked_version == VERSION_NA:
            return "Unable To Find Updates"
        if not self._update_available:
            return "No Updates Available"
        return "New Updates: v{0}.{1}.{2} ({3}-{4}-{5})".format(
            *self._last_checked_version,
            *self._last_checked_date,
        )


update_checker = UpdateChecker()

```

# File: tinypedal/validator.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Validator function
"""

from __future__ import annotations

import logging
import os
import re
import time
from functools import wraps
from math import isfinite
from time import monotonic
from typing import Any, Iterable

from .const_common import MAX_SECONDS
from .const_file import FileExt
from .regex_pattern import CFG_INVALID_FILENAME, rex_hex_color

logger = logging.getLogger(__name__)


# Decorator
def generator_init(func):
    """Initialize generator for send() method"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        generator = func(*args, **kwargs)
        next(generator)
        return generator
    return wrapper


# Value validate
def infnan_to_zero(value: Any) -> float:
    """Convert invalid value (inf or nan) to zero"""
    if isfinite(value):  # isinstance(value, TYPE_NUMBER)
        return value
    return 0


def bytes_to_str(bytestring: bytes | Any, char_encoding: str = "utf-8") -> str:
    """Convert bytes to string"""
    if isinstance(bytestring, bytes):
        return bytestring.decode(encoding=char_encoding, errors="replace").rstrip()
    return ""


def is_allowed_filename(filename: str) -> bool:
    """Is allowed setting file name"""
    return re.search(CFG_INVALID_FILENAME, filename, flags=re.IGNORECASE) is None


def invalid_save_name(name: str) -> bool:
    """Is invalid save name"""
    return name == "" or name[:3] == " - " or name[-3:] == " - "


def is_string_number(value: str) -> bool:
    """Validate string number"""
    try:
        float(value)
        return True
    except ValueError:
        return False


def valid_sectors(sector_time: list | Any, max_time: float = MAX_SECONDS) -> bool:
    """Is valid sector time"""
    if isinstance(sector_time, list):
        return max_time not in sector_time
    return max_time != sector_time


def is_same_session(
    combo_name: str, session_id: tuple[int, int, int],
    last_session_id: tuple[str, int, int, int]) -> bool:
    """Check if same session, car, track combo"""
    return (
        combo_name == last_session_id[0] and
        last_session_id[1] == session_id[0] and  # session time stamp
        last_session_id[2] <= session_id[1] and  # session elapsed time
        last_session_id[3] <= session_id[2]  # total completed laps
    )


def purge_data_key(loaded_dict: dict, ref_keys: Iterable[str]) -> dict:
    """Purge unwanted key from dict"""
    for key in tuple(loaded_dict):
        if key not in ref_keys:
            loaded_dict.pop(key)
    return loaded_dict


# File validate
def file_last_modified(filepath: str = "", filename: str = "", extension: str = "") -> float:
    """Check file last modified time, 0 if file not exist"""
    filename_full = f"{filepath}{filename}{extension}"
    if os.path.exists(filename_full):
        return os.path.getmtime(filename_full)
    return 0


def image_exists(filepath: str, extension: str = FileExt.PNG, max_size: int = 5120000) -> bool:
    """Validate image file path, file format (default PNG), max file size (default < 5MB)"""
    return (
        os.path.exists(filepath) and
        os.path.getsize(filepath) < max_size and
        filepath.lower().endswith(extension)
    )


# Delta list validate
def valid_delta_set(data: tuple) -> tuple:
    """Validate delta data set"""
    # Final row value(second column) must be higher than previous row
    if data[-1][1] < data[-2][1]:
        raise ValueError
    # Check distance greater than next row for first 10 rows
    for idx in range(11, 0, -1):
        if data[idx][0] > data[idx + 1][0]:
            raise ValueError
    # Delta list must have at least 10 lines of samples
    if len(data) < 10:
        raise ValueError
    return data


def valid_delta_raw(dataset: list[tuple[float, float]], final: float, column: int) -> bool:
    """Validate raw delta data set"""
    try:
        if len(dataset) <= 1:
            return False
        # Remove rows if source value higher than final value
        while dataset[-1][column] > final:
            dataset.pop()
            if not dataset:
                return False
        return True
    except (AttributeError, TypeError, IndexError):
        return False


# Value type validate
def valid_value_type(value: Any, default: Any) -> Any:
    """Validate if value is same type as default, return default value if False"""
    if isinstance(value, type(default)):
        return value
    return default


def convert_value_type(value: Any, default: Any, target_type: type) -> Any:
    """Convert any value type to target type, revert to default if fails"""
    try:
        return target_type(value)
    except (TypeError, ValueError, OverflowError):
        return default


def dict_value_type(data: dict, default_data: dict) -> dict:
    """Validate and correct dictionary value type"""
    return {
        key: type(def_value)(data.get(key, def_value))
        for key, def_value in default_data.items()
    }


# Color validate
def is_hex_color(color_str: str | Any) -> bool:
    """Validate HEX color string"""
    if isinstance(color_str, str):
        return rex_hex_color.search(color_str) is not None
    return False


# Time format validate
def is_clock_format(_format: str) -> bool:
    """Validate clock time format"""
    try:
        time.strftime(_format)
        return True
    except ValueError:
        return False


# Timer
def state_timer(interval: float, last: float = 0):
    """State timer

    Args:
        interval: time interval in seconds.
        last: last time stamp in seconds.
    Yield:
        is_timeout: bool.
    """
    while True:
        seconds = monotonic()
        if seconds - last >= interval:
            last = seconds
            yield True
        else:
            yield False


# Desync check
@generator_init
def vehicle_position_sync(max_diff: float = 200, max_desync: int = 20):
    """Vehicle position synchronization

    Args:
        max_diff: max delta position (meters). Exceeding max delta counts as new lap.
        max_desync: max desync counts.

    Sends:
        pos_curr: current position (meters).

    Yields:
        Synchronized position (meters).
    """
    pos_synced = 0
    desync_count = 0

    while True:
        pos_curr = yield pos_synced
        if pos_curr is None:  # reset
            pos_curr = 0
            pos_synced = 0
            desync_count = 0
            continue
        if pos_synced > pos_curr:
            if desync_count > max_desync or pos_synced - pos_curr > max_diff:
                desync_count = 0  # reset
                pos_synced = pos_curr
            else:
                desync_count += 1
        elif pos_synced < pos_curr:
            pos_synced = pos_curr
            if desync_count:
                desync_count = 0

```

# File: tinypedal/version.py
```python
# Core version (MAJOR.MINOR.PATCH)
__version__ = "2.39.1"
# Development version tag (set to "" for release-version)
DEVELOPMENT = "dev"

```

# File: tinypedal/version_check.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Version check function
"""

from __future__ import annotations

import sys

from .const_common import VERSION_NA


def parse_version_string(ver: str) -> tuple[int, int, int]:
    """Parse version string to tuple (major, minor, patch)"""
    try:
        version = ver.split(".")
        return int(version[0]), int(version[1]), int(version[2])
    except (AttributeError, ValueError, TypeError, IndexError):
        return 0, 0, 0


def is_new_version(
    checked_version: tuple[int, int, int],
    current_version: tuple[int, int, int],
    version_tag: str,
) -> bool:
    """Is new version"""
    # Invalid version
    if checked_version == VERSION_NA:
        return False
    # New version
    if checked_version > current_version:
        return True
    # Pre-release version
    if checked_version == current_version and version_tag:
        return True
    # Same version
    return False


def tinypedal() -> str:
    from . import version

    ver_number = (version.__version__, version.DEVELOPMENT)
    return "-".join(ver for ver in ver_number if ver != "")


def python() -> str:
    return ".".join(map(str, sys.version_info))


def qt() -> str:
    from PySide2.QtCore import qVersion

    return qVersion()


def pyside() -> str:
    import PySide2

    return PySide2.__version__


def psutil() -> str:
    import psutil

    return psutil.__version__

```

# File: tinypedal/const_file.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
File constants
"""


def qfile_filter(extension: str, description: str) -> str:
    """File format filter for QFile dialog

    Returns:
        "File description (*.extension)"
    """
    return f"{description} (*{extension})"


class ConfigType:
    """Configuration types"""

    # Global preset
    CONFIG = "config"
    FILELOCK = "filelock"
    # User preset
    SETTING = "setting"
    # Module ID
    MODULE = "module"
    WIDGET = "widget"
    # Style preset
    BRAKES = "brakes"
    BRANDS = "brands"
    CLASSES = "classes"
    COMPOUNDS = "compounds"
    HEATMAP = "heatmap"
    TRACKS = "tracks"


class FileExt:
    """File extension constants"""

    # Common
    ALL = ".*"
    LOG = ".log"
    CSV = ".csv"
    TXT = ".txt"
    INI = ".ini"
    BAK = ".bak"
    JSON = ".json"
    # Image
    SVG = ".svg"
    PNG = ".png"
    # Specific
    CONSUMPTION = ".consumption"
    ENERGY = ".energy"
    FUEL = ".fuel"
    SECTOR = ".sector"
    TPPN = ".tppn"
    TPTN = ".tptn"
    STATS = ".stats"
    LOCK = ".lock"


class FileFilter:
    """File filter constants (for used in QFileDialog)"""

    # Common
    ALL = qfile_filter(FileExt.ALL, "All files")
    LOG = qfile_filter(FileExt.LOG, "LOG file")
    TXT = qfile_filter(FileExt.TXT, "Text file")
    CSV = qfile_filter(FileExt.CSV, "CSV file")
    INI = qfile_filter(FileExt.INI, "INI file")
    JSON = qfile_filter(FileExt.JSON, "JSON file")
    # Image
    SVG = qfile_filter(FileExt.SVG, "SVG image")
    PNG = qfile_filter(FileExt.PNG, "PNG image")
    # Specific
    CONSUMPTION = qfile_filter(FileExt.CONSUMPTION, "Consumption History")
    TPPN = qfile_filter(FileExt.TPPN, "TinyPedal Pace Notes")
    TPTN = qfile_filter(FileExt.TPTN, "TinyPedal Track Notes")
    GPLINI = qfile_filter(FileExt.INI, "GPL Pace Notes")


class ImageFile:
    """Built-in image file constants"""

    APP_ICON = "images/icon.png"
    COMPASS = "images/icon_compass.png"
    INSTRUMENT = "images/icon_instrument.png"
    STEERING_WHEEL = "images/icon_steering_wheel.png"
    WEATHER = "images/icon_weather.png"


class StatsFile:
    """Stats file name constants"""

    DRIVER = "driver"


class LogFile:
    """Log file name constants"""

    APP_LOG = "tinypedal.log"
    PID = "pid.log"

```

# File: tinypedal/module_control.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Module and widget control
"""

from __future__ import annotations

import logging
from time import sleep
from types import MappingProxyType
from typing import Any, KeysView

from . import module, widget
from .const_file import ConfigType
from .setting import cfg

logger = logging.getLogger(__name__)


def create_module_pack(target: Any) -> dict:
    """Create module reference pack as dictionary

    Args:
        target: module.

    Returns:
        Dictionary, key = module name. value = imported module.
    """
    return {name: getattr(target, name) for name in target.__all__}


class ModuleControl:
    """Module and widget control

    Args:
        target: module.

    Attributes:
        type_id: module type indentifier, either "module" or "widget".
        active_modules: active module reference dict (read-only).
    """

    __slots__ = (
        "_imported_modules",
        "_active_modules",
        "type_id",
        "active_modules",
    )

    def __init__(self, target: Any, type_id: str):
        self._imported_modules = MappingProxyType(create_module_pack(target))
        self._active_modules: dict = {}
        self.type_id = type_id
        self.active_modules: MappingProxyType = MappingProxyType(self._active_modules)

    def start(self, name: str = ""):
        """Start module, specify name for selected module"""
        if name:
            self.__start_selected(name)
        else:
            self.__start_enabled()

    def close(self, name: str = ""):
        """Close module, specify name for selected module"""
        if name:
            self.__close_selected(name)
        else:
            self.__close_enabled()

    def reload(self, name: str = ""):
        """Reload module"""
        self.close(name)
        self.start(name)

    def toggle(self, name: str):
        """Toggle module"""
        if cfg.user.setting[name]["enable"]:
            cfg.user.setting[name]["enable"] = False
            self.__close_selected(name)
        else:
            cfg.user.setting[name]["enable"] = True
            self.__start_selected(name)
        cfg.save()

    def enable_all(self):
        """Enable all modules"""
        for _name in self._imported_modules:
            cfg.user.setting[_name]["enable"] = True
        self.start()
        cfg.save()
        logger.info("ENABLED: all %s(s)", self.type_id)

    def disable_all(self):
        """Disable all modules"""
        for _name in self._imported_modules:
            cfg.user.setting[_name]["enable"] = False
        self.close()
        cfg.save()
        logger.info("DISABLED: all %s(s)", self.type_id)

    def __start_enabled(self):
        """Start all enabled module"""
        for _name in self._imported_modules:
            self.__start_selected(_name)

    def __start_selected(self, name: str):
        """Start selected module"""
        if cfg.user.setting[name]["enable"] and name not in self._active_modules:
            # Create module instance and add to dict
            self._active_modules[name] = self._imported_modules[name].Realtime(cfg, name)
            self._active_modules[name].start()

    def __close_enabled(self):
        """Close all enabled module"""
        for _name in tuple(self._active_modules):
            self.__close_selected(_name)

    def __close_selected(self, name: str):
        """Close selected module"""
        if name in self._active_modules:
            _module = self._active_modules[name]  # get instance
            self._active_modules.pop(name)  # remove active reference
            _module.stop()  # close module
            while not _module.closed:  # wait finish
                sleep(0.01)
            _module = None  # remove final reference

    @property
    def number_active(self) -> int:
        """Number of active modules"""
        return len(self._active_modules)

    @property
    def number_total(self) -> int:
        """Number of total modules"""
        return len(self._imported_modules)

    @property
    def names(self) -> KeysView[str]:
        """List of module names"""
        return self._imported_modules.keys()


mctrl = ModuleControl(target=module, type_id=ConfigType.MODULE)
wctrl = ModuleControl(target=widget, type_id=ConfigType.WIDGET)

```

# File: tinypedal/setting.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Setting
"""

from __future__ import annotations

import logging
import os
import threading
from collections import ChainMap
from time import sleep
from types import MappingProxyType
from typing import Any

from .const_api import API_MAP_CONFIG
from .const_app import PATH_GLOBAL
from .const_common import EMPTY_DICT
from .const_file import ConfigType, FileExt
from .setting_validator import PresetValidator, StyleValidator
from .template.setting_api import API_DEFAULT
from .template.setting_brakes import BRAKES_DEFAULT
from .template.setting_classes import CLASSES_DEFAULT
from .template.setting_common import COMMON_DEFAULT
from .template.setting_compounds import COMPOUNDS_DEFAULT
from .template.setting_filelock import FILELOCK_DEFAULT
from .template.setting_global import GLOBAL_DEFAULT
from .template.setting_heatmap import HEATMAP_DEFAULT
from .template.setting_module import MODULE_DEFAULT
from .template.setting_tracks import TRACKS_DEFAULT
from .template.setting_widget import WIDGET_DEFAULT
from .userfile import set_user_data_path
from .userfile.json_setting import (
    copy_setting,
    load_setting_json_file,
    load_style_json_file,
    save_and_verify_json_file,
)
from .validator import is_allowed_filename

logger = logging.getLogger(__name__)


class FileName:
    """File name"""

    __slots__ = (
        "config",
        "filelock",
        "setting",
        "brakes",
        "brands",
        "classes",
        "compounds",
        "heatmap",
        "tracks",
    )

    def __init__(self):
        # Global preset
        self.config = f"config{FileExt.JSON}"
        self.filelock = f"config{FileExt.LOCK}"
        # User preset
        self.setting = f"default{FileExt.JSON}"
        # Style preset
        self.brakes = f"brakes{FileExt.JSON}"
        self.brands = f"brands{FileExt.JSON}"
        self.classes = f"classes{FileExt.JSON}"
        self.compounds = f"compounds{FileExt.JSON}"
        self.heatmap = f"heatmap{FileExt.JSON}"
        self.tracks = f"tracks{FileExt.JSON}"


class FilePath:
    """File path"""

    __slots__ = (
        "config",
        "settings",
        "brand_logo",
        "delta_best",
        "energy_delta",
        "fuel_delta",
        "pace_notes",
        "sector_best",
        "track_map",
        "track_notes",
    )

    def __init__(self):
        # Fixed path, reference only
        self.config = PATH_GLOBAL
        # User setting path
        self.settings = ""
        # User data path
        self.brand_logo = ""
        self.delta_best = ""
        self.energy_delta = ""
        self.fuel_delta = ""
        self.pace_notes = ""
        self.sector_best = ""
        self.track_map = ""
        self.track_notes = ""

    def update(self, user_path: dict, default_path: dict):
        """Update path variables from global user path dictionary"""
        for key in user_path:
            # Reset path if invalid
            if not set_user_data_path(user_path[key]):
                user_path[key] = default_path[key]
                set_user_data_path(user_path[key])
            # Assign path
            setattr(self, key.replace("_path", ""), user_path[key])


class Preset:
    """Preset setting"""

    __slots__ = (
        "config",
        "filelock",
        "setting",
        "brakes",
        "brands",
        "classes",
        "compounds",
        "heatmap",
        "tracks",
    )

    def __init__(self, default: bool = False):
        if not default:
            return
        # Global preset
        self.config = MappingProxyType(GLOBAL_DEFAULT)
        self.filelock = MappingProxyType(FILELOCK_DEFAULT)
        # User preset
        self.setting = MappingProxyType(ChainMap(WIDGET_DEFAULT, MODULE_DEFAULT, API_DEFAULT, COMMON_DEFAULT))
        # Style preset
        self.brakes = MappingProxyType(BRAKES_DEFAULT)
        self.brands = EMPTY_DICT
        self.classes = MappingProxyType(CLASSES_DEFAULT)
        self.compounds = MappingProxyType(COMPOUNDS_DEFAULT)
        self.heatmap = MappingProxyType(HEATMAP_DEFAULT)
        self.tracks = MappingProxyType(TRACKS_DEFAULT)


class Setting:
    """APP setting"""

    __slots__ = (
        "_save_delay",
        "_save_queue",
        "_setting_to_load",
        "is_saving",
        "version_update",
        "filename",
        "default",
        "user",
        "path",
    )

    def __init__(self):
        # States
        self._save_delay = 0
        self._save_queue = {}
        self._setting_to_load = ""
        self.is_saving = False
        self.version_update = 0
        # Settings
        self.filename = FileName()
        self.default = Preset(default=True)
        self.user = Preset()
        self.path = FilePath()

    @property
    def api(self) -> dict[str, Any]:
        """API setting (quick reference)"""
        return self.user.setting[self.api_key]

    @property
    def application(self) -> dict[str, Any]:
        """Application (global) setting (quick reference)"""
        return self.user.config["application"]

    @property
    def compatibility(self) -> dict[str, Any]:
        """Compatibility (global) setting (quick reference)"""
        return self.user.config["compatibility"]

    @property
    def overlay(self) -> dict[str, Any]:
        """Overlay setting (quick reference)"""
        return self.user.setting["overlay"]

    @property
    def telemetry(self) -> dict[str, Any]:
        """Telemetry (global) setting (quick reference)"""
        return self.user.config["telemetry"]

    @property
    def units(self) -> dict[str, Any]:
        """Units setting (quick reference)"""
        return self.user.setting["units"]

    def is_loaded(self, filename: str) -> bool:
        """Check if selected setting file is already loaded"""
        return self.filename.setting == filename

    def set_next_to_load(self, filename: str):
        """Set next setting filename to load"""
        self._setting_to_load = filename

    def get_primary_preset_name(self, preset_name: str) -> str:
        """Get primary preset name and verify"""
        if is_allowed_filename(preset_name):
            full_preset_name = f"{preset_name}{FileExt.JSON}"
            if os.path.exists(f"{self.path.settings}{full_preset_name}"):
                return full_preset_name
        return ""

    def load_global(self):
        """Load global setting, should only done once per launch"""
        self.user.config = load_setting_json_file(
            filename=self.filename.config,
            filepath=self.path.config,
            dict_def=self.default.config,
            file_info="global preset",
            validator=PresetValidator.global_preset,
        )
        self.user.filelock = load_style_json_file(
            filename=self.filename.filelock,
            filepath=self.path.config,
            dict_def=self.default.filelock,
            file_info="file lock",
            validator=StyleValidator.filelock,
        )
        # Assign global path
        self.path.update(
            user_path=self.user.config["user_path"],
            default_path=self.default.config["user_path"],
        )

    def update_path(self):
        """Update global path, call this if "user_path" changed"""
        old_settings_path = os.path.abspath(self.path.settings)
        self.path.update(
            user_path=self.user.config["user_path"],
            default_path=self.default.config["user_path"],
        )
        new_settings_path = os.path.abspath(self.path.settings)
        # Update preset name if settings path changed
        if new_settings_path != old_settings_path:
            self.set_next_to_load(f"{self.preset_files()[0]}{FileExt.JSON}")

    def load_user(self):
        """Load user settings, should be called after loaded global setting"""
        # Load preset JSON file
        if self._setting_to_load != "":
            filename_setting_temp = self._setting_to_load
            self._setting_to_load = ""
        else:
            filename_setting_temp = self.filename.setting
        self.user.setting = load_setting_json_file(
            filename=filename_setting_temp,
            filepath=self.path.settings,
            dict_def=self.default.setting,
        )
        self.filename.setting = filename_setting_temp
        # Load style JSON file
        self.user.brakes = load_style_json_file(
            filename=self.filename.brakes,
            filepath=self.path.settings,
            dict_def=self.default.brakes,
            validator=StyleValidator.brakes,
        )
        self.user.brands = load_style_json_file(
            filename=self.filename.brands,
            filepath=self.path.settings,
            dict_def=self.default.brands,
        )
        self.user.classes = load_style_json_file(
            filename=self.filename.classes,
            filepath=self.path.settings,
            dict_def=self.default.classes,
            validator=StyleValidator.classes,
        )
        self.user.compounds = load_style_json_file(
            filename=self.filename.compounds,
            filepath=self.path.settings,
            dict_def=self.default.compounds,
            validator=StyleValidator.compounds,
        )
        self.user.heatmap = load_style_json_file(
            filename=self.filename.heatmap,
            filepath=self.path.settings,
            dict_def=self.default.heatmap,
            validator=StyleValidator.heatmap,
        )
        self.user.tracks = load_style_json_file(
            filename=self.filename.tracks,
            filepath=self.path.settings,
            dict_def=self.default.tracks,
            validator=StyleValidator.tracks,
        )

    @property
    def api_name(self) -> str:
        """Get selected api name"""
        if self.telemetry["enable_api_selection_from_preset"]:
            return self.user.setting["preset"]["api_name"]
        return self.telemetry["api_name"]

    @api_name.setter
    def api_name(self, name: str) -> None:
        """Set selected api name"""
        if self.telemetry["enable_api_selection_from_preset"]:
            self.user.setting["preset"]["api_name"] = name
        else:
            self.telemetry["api_name"] = name

    @property
    def api_key(self) -> str:
        """Get selected api config key name"""
        return API_MAP_CONFIG[self.api_name]

    def preset_files(self) -> list[str]:
        """Get user preset JSON filename list, sort by modified date in descending order

        Returns:
            JSON filename (without file extension) list.
        """
        gen_cfg_list = (
            (os.path.getmtime(f"{self.path.settings}{_filename}"), _filename[:-5])
            for _filename in os.listdir(self.path.settings)
            if _filename.lower().endswith(FileExt.JSON)
        )
        valid_cfg_list = [
            _filename[1]
            for _filename in sorted(gen_cfg_list, reverse=True)
            if is_allowed_filename(_filename[1])
        ]
        if valid_cfg_list:
            return valid_cfg_list
        return ["default"]

    def create(self, filename: str):
        """Create default setting"""
        save_and_verify_json_file(
            dict_user=copy_setting(self.default.setting),
            filename=filename,
            filepath=self.path.settings,
            max_attempts=self.max_saving_attempts,
        )

    def save(self, delay: int = 66, cfg_type: str = ConfigType.SETTING, next_task: bool = False):
        """Save trigger, limit to one save operation for a given period.

        Args:
            count:
                Set time delay(count) that can be refreshed before starting saving thread.
                Default is roughly one sec delay, use 0 for instant saving.
            cfg_type:
                Set saving config type.
            next_task:
                Skip adding save task, run next save task in queue.
        """
        if not next_task:
            filename = getattr(self.filename, cfg_type, None)
            # Check if valid file name
            if filename is None:
                logger.error("USERDATA: invalid config type %s, abort saving", cfg_type)
            # Check if file is locked
            elif filename in self.user.filelock:
                logger.info("USERDATA: %s is locked, changes not saved", filename)
            # Add to save queue
            elif filename not in self._save_queue:
                # Save to global config path
                if cfg_type in (
                    ConfigType.CONFIG,
                    ConfigType.FILELOCK,
                ):
                    filepath = self.path.config
                # Save to settings (preset) path
                else:
                    filepath = self.path.settings
                dict_user = getattr(self.user, cfg_type)
                self._save_queue[filename] = (filepath, dict_user)

        for queue_filename, queue_filedata in self._save_queue.items():
            break  # get next file in queue
        else:
            return

        self._save_delay = delay

        if not self.is_saving:
            self.is_saving = True
            threading.Thread(
                target=self.__saving,
                args=(queue_filename, *queue_filedata),
            ).start()

    def __saving(self, filename: str, filepath: str, dict_user: dict):
        """Saving thread"""
        # Update save delay
        while self._save_delay > 0:
            self._save_delay -= 1
            sleep(0.01)

        save_and_verify_json_file(
            dict_user=dict_user,
            filename=filename,
            filepath=filepath,
            max_attempts=self.max_saving_attempts,
        )

        self._save_queue.pop(filename, None)
        self.is_saving = False
        self.version_update += 1

        # Run next save task in save queue if any
        if self._save_queue:
            self.save(0, next_task=True)

    @property
    def max_saving_attempts(self) -> int:
        """Get max saving attempts"""
        return max(self.application["maximum_saving_attempts"], 3)


# Assign config setting
cfg = Setting()

```

# File: tinypedal/setting_validator.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Setting validator function
"""

from __future__ import annotations

import re
from typing import Any, Mapping

from . import regex_pattern as rxp
from . import version
from .const_common import VERSION_NA
from .setting_preupdate import preupdate_specific_version
from .template.setting_brakes import BRAKEINFO_DEFAULT
from .template.setting_classes import CLASSINFO_DEFAULT
from .template.setting_compounds import COMPOUNDINFO_DEFAULT
from .template.setting_filelock import FILELOCKINFO_DEFAULT
from .template.setting_heatmap import HEATMAP_DEFAULT
from .template.setting_tracks import TRACKINFO_DEFAULT
from .validator import is_clock_format, is_hex_color
from .version_check import parse_version_string


def validate_style(dict_user: dict[str, dict], dict_def: Mapping[str, Any]) -> bool:
    """Validate style dict entries"""
    save_change = False
    for name, data in dict_user.items():
        # Reset invalid data set
        if not isinstance(data, dict):
            dict_user[name] = dict_def.copy()
            save_change = True
            continue
        # Reset invalid value or add missing
        for key, default_value in dict_def.items():
            if key not in data or not isinstance(
                data[key], type(default_value)
            ):
                data[key] = default_value
                save_change = True
    return save_change


class StyleValidator:
    """Style validator"""

    @staticmethod
    def classes(dict_user: dict[str, dict]) -> bool:
        """Classes style validator"""
        return validate_style(dict_user, CLASSINFO_DEFAULT)

    @staticmethod
    def brakes(dict_user: dict[str, dict]) -> bool:
        """Brakes style validator"""
        return validate_style(dict_user, BRAKEINFO_DEFAULT)

    @staticmethod
    def compounds(dict_user: dict[str, dict]) -> bool:
        """Compounds style validator"""
        return validate_style(dict_user, COMPOUNDINFO_DEFAULT)

    @staticmethod
    def heatmap(dict_user: dict[str, dict]) -> bool:
        """Heatmap style validator"""
        save_change = PresetValidator.add_missing_key(dict_user, HEATMAP_DEFAULT)
        # Sort styles
        if save_change:
            # Place default keys in front
            key_list_def = list(HEATMAP_DEFAULT)
            # Append user keys at end
            for key in dict_user:
                if key not in HEATMAP_DEFAULT:
                    key_list_def.append(key)
            for d_key in key_list_def:
                dict_user[d_key] = dict_user.pop(d_key)
        return save_change

    @staticmethod
    def tracks(dict_user: dict[str, dict]) -> bool:
        """Tracks style validator"""
        return validate_style(dict_user, TRACKINFO_DEFAULT)

    @staticmethod
    def filelock(dict_user: dict[str, dict]) -> bool:
        """File lock validator"""
        return validate_style(dict_user, FILELOCKINFO_DEFAULT)


class ValueValidator:
    """Value validator"""

    @staticmethod
    def boolean(key: str, dict_user: dict) -> bool:
        """Value - Boolean"""
        if not re.search(rxp.CFG_BOOL, key):
            return False
        if not isinstance(dict_user[key], bool):
            dict_user[key] = bool(dict_user[key])
        return True

    @staticmethod
    def choice_units(key: str, dict_user: dict) -> bool:
        """Value - units choice list"""
        for ref_key, choice_list in rxp.CHOICE_UNITS.items():
            if re.search(ref_key, key):
                if dict_user[key] not in choice_list:
                    dict_user.pop(key)
                return True
        return False

    @staticmethod
    def choice_common(key: str, dict_user: dict) -> bool:
        """Value - common choice list"""
        for ref_key, choice_list in rxp.CHOICE_COMMON.items():
            if re.search(ref_key, key):
                if dict_user[key] not in choice_list:
                    dict_user.pop(key)
                return True
        return False

    @staticmethod
    def color(key: str, dict_user: dict) -> bool:
        """Value - Color string"""
        if not re.search(rxp.CFG_COLOR, key):
            return False
        if not is_hex_color(dict_user[key]):
            dict_user.pop(key)
        return True

    @staticmethod
    def clock_format(key: str, dict_user: dict) -> bool:
        """Value - clock format string"""
        if not re.search(rxp.CFG_CLOCK_FORMAT, key):
            return False
        if not is_clock_format(dict_user[key]):
            dict_user.pop(key)
        return True

    @staticmethod
    def string(key: str, dict_user: dict) -> bool:
        """Value - string"""
        for strings in (
            rxp.CFG_FONT_NAME,
            rxp.CFG_HEATMAP,
            rxp.CFG_USER_PATH,
            rxp.CFG_USER_IMAGE,
            rxp.CFG_STRING,
        ):
            if re.search(strings, key):
                break
        else:
            return False
        if not isinstance(dict_user[key], str):
            dict_user.pop(key)
        return True

    @staticmethod
    def integer(key: str, dict_user: dict) -> bool:
        """Value - integer"""
        if not re.search(rxp.CFG_INTEGER, key):
            return False
        if not isinstance(dict_user[key], int) or isinstance(dict_user[key], bool):
            dict_user.pop(key)
        return True

    @staticmethod
    def numeric(key: str, dict_user: dict) -> bool:
        """Value - numeric"""
        if not isinstance(dict_user[key], (float, int)) or isinstance(dict_user[key], bool):
            dict_user.pop(key)
        return True


class PresetValidator:
    """Preset validator"""

    # Set validator methods in order
    _value_validators = tuple(
        getattr(ValueValidator, key)
        for key, value in ValueValidator.__dict__.items()
        if isinstance(value, staticmethod)
    )

    @classmethod
    def remove_invalid_key(cls, dict_user: dict, dict_def: dict) -> None:
        """Remove invalid key & value from user dictionary"""
        key_list_user = tuple(dict_user)  # create user key list

        for key in key_list_user:  # loop through user key list
            # Remove invalid key
            if key not in dict_def:  # check in default list
                dict_user.pop(key)
                continue
            # Skip sub_level dict
            if isinstance(dict_user[key], dict):
                continue
            # Validate values
            for _validator in cls._value_validators:
                if _validator(key, dict_user):
                    break

    @staticmethod
    def add_missing_key(dict_user: dict, dict_def: dict) -> bool:
        """Add missing default key to user list"""
        is_modified = False
        key_list_user = tuple(dict_user)  # create user key list

        for key in dict_def:  # loop through default keys
            if key not in key_list_user:  # check each default key in user list
                data_def = dict_def[key]
                # Add missing item to user
                if isinstance(data_def, dict):
                    dict_user[key] = data_def.copy()  # copy sub-dict
                else:
                    dict_user[key] = data_def
                is_modified = True

        return is_modified

    @staticmethod
    def sort_key_order(dict_user: dict, dict_def: dict) -> None:
        """Sort user key order according to default key list"""
        for d_key in dict_def:  # loop through default keys
            dict_user[d_key] = dict_user.pop(d_key)  # append user key at the end

    @classmethod
    def validate_key_pair(cls, dict_user: dict, dict_def: dict) -> None:
        """Create key-only check list, then validate key"""
        cls.remove_invalid_key(dict_user, dict_def)
        cls.add_missing_key(dict_user, dict_def)
        cls.sort_key_order(dict_user, dict_def)

    @staticmethod
    def preupdate_global_preset(dict_user: dict):
        """Pre update global preset, run before validation"""
        telemetry_api = dict_user.get("telemetry_api")
        if isinstance(telemetry_api, dict):
            dict_user["telemetry"] = telemetry_api.copy()

    @staticmethod
    def preupdate_user_preset(dict_user: dict, dict_def: dict):
        """Pre update user preset, run before validation"""
        # Check preset version
        preset_info = dict_user.get("preset")
        if not isinstance(preset_info, dict):
            dict_user["preset"] = {}
            preset_info = dict_user["preset"]
        preset_version = parse_version_string(preset_info.get("version", "0.0.0"))

        # Update preset version
        dict_user["preset"]["version"] = dict_def["preset"]["version"]

        # Skip check if already newest version
        build_version = parse_version_string(version.__version__)
        if preset_version == VERSION_NA or preset_version < build_version:
            preupdate_specific_version(preset_version, dict_user)

    @classmethod
    def global_preset(cls, dict_user: dict, dict_def: dict) -> dict:
        """Validate global preset"""
        cls.preupdate_global_preset(dict_user)
        return cls._validate(dict_user, dict_def)

    @classmethod
    def user_preset(cls, dict_user: dict, dict_def: dict) -> dict:
        """Validate user preset"""
        cls.preupdate_user_preset(dict_user, dict_def)
        return cls._validate(dict_user, dict_def)

    @classmethod
    def _validate(cls, dict_user: dict, dict_def: dict) -> dict:
        """Validate setting"""
        # Check top-level key
        cls.validate_key_pair(dict_user, dict_def)
        # Check sub-level key
        for item in dict_user:
            cls.validate_key_pair(dict_user[item], dict_def[item])
        return dict_user

```

# File: tinypedal/adapter/__init__.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
API data adapter
"""
from typing import NamedTuple

from . import _reader


class APIDataReader(NamedTuple):
    """API data reader"""

    state: _reader.State
    brake: _reader.Brake
    emotor: _reader.ElectricMotor
    engine: _reader.Engine
    inputs: _reader.Inputs
    lap: _reader.Lap
    session: _reader.Session
    switch: _reader.Switch
    timing: _reader.Timing
    tyre: _reader.Tyre
    vehicle: _reader.Vehicle
    wheel: _reader.Wheel

```

# File: tinypedal/adapter/_reader.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
API data reader (abstract class)
"""

from __future__ import annotations

from abc import ABC, abstractmethod

from ..process.weather import WeatherNode


class State(ABC):
    """State"""

    __slots__ = ()

    @abstractmethod
    def active(self) -> bool:
        """Is active (driving or overriding)"""

    @abstractmethod
    def paused(self) -> bool:
        """Is paused"""

    @abstractmethod
    def desynced(self, index: int | None = None) -> bool:
        """Is player data desynced from others"""

    @abstractmethod
    def version(self) -> str:
        """Identify API version"""


class Brake(ABC):
    """Brake"""

    __slots__ = ()

    @abstractmethod
    def bias_front(self, index: int | None = None) -> float:
        """Brake bias front (fraction)"""

    @abstractmethod
    def pressure(self, index: int | None = None, scale: float = 1) -> tuple[float, ...]:
        """Brake pressure (fraction)"""

    @abstractmethod
    def temperature(self, index: int | None = None) -> tuple[float, ...]:
        """Brake temperature (Celsius)"""

    @abstractmethod
    def wear(self, index: int | None = None) -> tuple[float, ...]:
        """Brake remaining thickness (meters)"""


class ElectricMotor(ABC):
    """Electric motor"""

    __slots__ = ()

    @abstractmethod
    def state(self, index: int | None = None) -> int:
        """Motor state, 0 = n/a, 1 = off, 2 = drain, 3 = regen"""

    @abstractmethod
    def battery_charge(self, index: int | None = None) -> float:
        """Battery charge (fraction)"""

    @abstractmethod
    def rpm(self, index: int | None = None) -> float:
        """Motor RPM (rev per minute)"""

    @abstractmethod
    def torque(self, index: int | None = None) -> float:
        """Motor torque (Nm)"""

    @abstractmethod
    def motor_temperature(self, index: int | None = None) -> float:
        """Motor temperature (Celsius)"""

    @abstractmethod
    def water_temperature(self, index: int | None = None) -> float:
        """Motor water temperature (Celsius)"""


class Engine(ABC):
    """Engine"""

    __slots__ = ()

    @abstractmethod
    def gear(self, index: int | None = None) -> int:
        """Gear"""

    @abstractmethod
    def gear_max(self, index: int | None = None) -> int:
        """Max gear"""

    @abstractmethod
    def rpm(self, index: int | None = None) -> float:
        """RPM (rev per minute)"""

    @abstractmethod
    def rpm_max(self, index: int | None = None) -> float:
        """Max RPM (rev per minute)"""

    @abstractmethod
    def torque(self, index: int | None = None) -> float:
        """Torque (Nm)"""

    @abstractmethod
    def turbo(self, index: int | None = None) -> float:
        """Turbo pressure (Pa)"""

    @abstractmethod
    def oil_temperature(self, index: int | None = None) -> float:
        """Oil temperature (Celsius)"""

    @abstractmethod
    def water_temperature(self, index: int | None = None) -> float:
        """Water temperature (Celsius)"""


class Inputs(ABC):
    """Inputs"""

    __slots__ = ()

    @abstractmethod
    def throttle(self, index: int | None = None) -> float:
        """Throttle filtered (fraction)"""

    @abstractmethod
    def throttle_raw(self, index: int | None = None) -> float:
        """Throttle raw (fraction)"""

    @abstractmethod
    def brake(self, index: int | None = None) -> float:
        """Brake filtered (fraction)"""

    @abstractmethod
    def brake_raw(self, index: int | None = None) -> float:
        """Brake raw (fraction)"""

    @abstractmethod
    def clutch(self, index: int | None = None) -> float:
        """Clutch filtered (fraction)"""

    @abstractmethod
    def clutch_raw(self, index: int | None = None) -> float:
        """Clutch raw (fraction)"""

    @abstractmethod
    def steering(self, index: int | None = None) -> float:
        """Steering filtered (fraction)"""

    @abstractmethod
    def steering_raw(self, index: int | None = None) -> float:
        """Steering raw (fraction)"""

    @abstractmethod
    def steering_shaft_torque(self, index: int | None = None) -> float:
        """Steering shaft torque (Nm)"""

    @abstractmethod
    def steering_range_physical(self, index: int | None = None) -> float:
        """Steering physical rotation range (degrees)"""

    @abstractmethod
    def steering_range_visual(self, index: int | None = None) -> float:
        """Steering visual rotation range (degrees)"""

    @abstractmethod
    def force_feedback(self) -> float:
        """Steering force feedback (fraction)"""


class Lap(ABC):
    """Lap"""

    __slots__ = ()

    @abstractmethod
    def number(self, index: int | None = None) -> int:
        """Current lap number"""

    @abstractmethod
    def completed_laps(self, index: int | None = None) -> int:
        """Total completed laps"""

    @abstractmethod
    def track_length(self) -> float:
        """Full lap or track length (meters)"""

    @abstractmethod
    def distance(self, index: int | None = None) -> float:
        """Distance into lap (meters)"""

    @abstractmethod
    def progress(self, index: int | None = None) -> float:
        """Lap progress (fraction), distance into lap"""

    @abstractmethod
    def maximum(self) -> int:
        """Maximum lap"""

    @abstractmethod
    def sector_index(self, index: int | None = None) -> int:
        """Sector index, 0 = S1, 1 = S2, 2 = S3"""

    @abstractmethod
    def behind_leader(self, index: int | None = None) -> int:
        """Laps behind leader"""

    @abstractmethod
    def behind_next(self, index: int | None = None) -> int:
        """Laps behind next place"""


class Session(ABC):
    """Session"""

    __slots__ = ()

    @abstractmethod
    def combo_name(self) -> str:
        """Track & vehicle combo name, strip off invalid char"""

    @abstractmethod
    def track_name(self) -> str:
        """Track name, strip off invalid char"""

    @abstractmethod
    def identifier(self) -> tuple[int, int, int]:
        """Identify session"""

    @abstractmethod
    def elapsed(self) -> float:
        """Session elapsed time (seconds)"""

    @abstractmethod
    def start(self) -> float:
        """Session start time (seconds)"""

    @abstractmethod
    def end(self) -> float:
        """Session end time (seconds)"""

    @abstractmethod
    def remaining(self) -> float:
        """Session time remaining (seconds)"""

    @abstractmethod
    def session_type(self) -> int:
        """Session type, 0 = TESTDAY, 1 = PRACTICE, 2 = QUALIFY, 3 = WARMUP, 4 = RACE"""

    @abstractmethod
    def lap_type(self) -> bool:
        """Is lap type session, false for time type"""

    @abstractmethod
    def in_race(self) -> bool:
        """Is in race session"""

    @abstractmethod
    def private_qualifying(self) -> bool:
        """Is private qualifying"""

    @abstractmethod
    def in_countdown(self) -> bool:
        """Is in countdown phase before race"""

    @abstractmethod
    def in_formation(self) -> bool:
        """Is in formation phase before race"""

    @abstractmethod
    def pit_open(self) -> bool:
        """Is pit lane open"""

    @abstractmethod
    def pre_race(self) -> bool:
        """Before race starts (green flag)"""

    @abstractmethod
    def green_flag(self) -> bool:
        """Green flag (race starts)"""

    @abstractmethod
    def blue_flag(self, index: int | None = None) -> bool:
        """Is under blue flag"""

    @abstractmethod
    def yellow_flag(self) -> bool:
        """Is there yellow flag in any sectors"""

    @abstractmethod
    def start_lights(self) -> int:
        """Start lights countdown sequence"""

    @abstractmethod
    def track_temperature(self) -> float:
        """Track temperature (Celsius)"""

    @abstractmethod
    def ambient_temperature(self) -> float:
        """Ambient temperature (Celsius)"""

    @abstractmethod
    def raininess(self) -> float:
        """Rain severity (fraction)"""

    @abstractmethod
    def wetness_minimum(self) -> float:
        """Road minimum wetness (fraction)"""

    @abstractmethod
    def wetness_maximum(self) -> float:
        """Road maximum wetness (fraction)"""

    @abstractmethod
    def wetness_average(self) -> float:
        """Road average wetness (fraction)"""

    @abstractmethod
    def wetness(self) -> tuple[float, float, float]:
        """Road wetness set (fraction)"""

    @abstractmethod
    def weather_forecast(self) -> tuple[WeatherNode, ...]:
        """Weather forecast nodes"""

    @abstractmethod
    def time_scale(self) -> int:
        """Time scale"""


class Switch(ABC):
    """Switch"""

    __slots__ = ()

    @abstractmethod
    def headlights(self, index: int | None = None) -> int:
        """Headlights"""

    @abstractmethod
    def ignition_starter(self, index: int | None = None) -> int:
        """Ignition"""

    @abstractmethod
    def speed_limiter(self, index: int | None = None) -> int:
        """Speed limiter"""

    @abstractmethod
    def drs_status(self, index: int | None = None) -> int:
        """DRS status, 0 not_available, 1 available, 2 allowed(not activated), 3 activated"""

    @abstractmethod
    def auto_clutch(self) -> bool:
        """Auto clutch"""


class Timing(ABC):
    """Timing"""

    __slots__ = ()

    @abstractmethod
    def start(self, index: int | None = None) -> float:
        """Current lap start time (seconds)"""

    @abstractmethod
    def elapsed(self, index: int | None = None) -> float:
        """Current lap elapsed time (seconds)"""

    @abstractmethod
    def current_laptime(self, index: int | None = None) -> float:
        """Current lap time (seconds)"""

    @abstractmethod
    def last_laptime(self, index: int | None = None) -> float:
        """Last lap time (seconds)"""

    @abstractmethod
    def best_laptime(self, index: int | None = None) -> float:
        """Best lap time (seconds)"""

    @abstractmethod
    def reference_laptime(self, index: int | None = None):
        """Reference lap time (seconds)"""

    @abstractmethod
    def estimated_laptime(self, index: int | None = None) -> float:
        """Estimated lap time (seconds)"""

    @abstractmethod
    def estimated_time_into(self, index: int | None = None) -> float:
        """Estimated time into lap (seconds)"""

    @abstractmethod
    def current_sector1(self, index: int | None = None) -> float:
        """Current lap sector 1 time (seconds)"""

    @abstractmethod
    def current_sector2(self, index: int | None = None) -> float:
        """Current lap sector 1+2 time (seconds)"""

    @abstractmethod
    def last_sector1(self, index: int | None = None) -> float:
        """Last lap sector 1 time (seconds)"""

    @abstractmethod
    def last_sector2(self, index: int | None = None) -> float:
        """Last lap sector 1+2 time (seconds)"""

    @abstractmethod
    def best_sector1(self, index: int | None = None) -> float:
        """Best lap sector 1 time (seconds)"""

    @abstractmethod
    def best_sector2(self, index: int | None = None) -> float:
        """Best lap sector 1+2 time (seconds)"""

    @abstractmethod
    def behind_leader(self, index: int | None = None) -> float:
        """Time behind leader (seconds)"""

    @abstractmethod
    def behind_next(self, index: int | None = None) -> float:
        """Time behind next place (seconds)"""


class Tyre(ABC):
    """Tyre"""

    __slots__ = ()

    @abstractmethod
    def compound_front(self, index: int | None = None) -> int:
        """Tyre compound (front)"""

    @abstractmethod
    def compound_rear(self, index: int | None = None) -> int:
        """Tyre compound (rear)"""

    @abstractmethod
    def compound(self, index: int | None = None) -> tuple[int, int]:
        """Tyre compound set (front, rear)"""

    @abstractmethod
    def compound_name_front(self, index: int | None = None) -> str:
        """Tyre compound name (front)"""

    @abstractmethod
    def compound_name_rear(self, index: int | None = None) -> str:
        """Tyre compound name (rear)"""

    @abstractmethod
    def compound_name(self, index: int | None = None) -> tuple[str, str]:
        """Tyre compound name set (front, rear)"""

    @abstractmethod
    def surface_temperature_avg(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre surface temperature set (Celsius) average"""

    @abstractmethod
    def surface_temperature_ico(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre surface temperature set (Celsius) inner,center,outer"""

    @abstractmethod
    def inner_temperature_avg(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre inner temperature set (Celsius) average"""

    @abstractmethod
    def inner_temperature_ico(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre inner temperature set (Celsius) inner,center,outer"""

    @abstractmethod
    def pressure(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre pressure (kPa)"""

    @abstractmethod
    def load(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre load (Newtons)"""

    @abstractmethod
    def wear(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre wear (fraction)"""

    @abstractmethod
    def carcass_temperature(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre carcass temperature (Celsius)"""

    @abstractmethod
    def vertical_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre vertical deflection (millimeters)"""


class Vehicle(ABC):
    """Vehicle"""

    __slots__ = ()

    @abstractmethod
    def is_player(self, index: int=0) -> bool:
        """Is local player"""

    @abstractmethod
    def is_driving(self) -> bool:
        """Is local player driving or in monitor"""

    @abstractmethod
    def player_index(self) -> int:
        """Get Local player index"""

    @abstractmethod
    def slot_id(self, index: int | None = None) -> int:
        """Vehicle slot id"""

    @abstractmethod
    def driver_name(self, index: int | None = None) -> str:
        """Driver name"""

    @abstractmethod
    def vehicle_name(self, index: int | None = None) -> str:
        """Vehicle name"""

    @abstractmethod
    def class_name(self, index: int | None = None) -> str:
        """Vehicle class name"""

    @abstractmethod
    def same_class(self, index: int | None = None) -> bool:
        """Is same vehicle class"""

    @abstractmethod
    def total_vehicles(self) -> int:
        """Total vehicles"""

    @abstractmethod
    def place(self, index: int | None = None) -> int:
        """Vehicle overall place"""

    @abstractmethod
    def qualification(self, index: int | None = None) -> int:
        """Vehicle qualification place"""

    @abstractmethod
    def in_pits(self, index: int | None = None) -> bool:
        """Is in pits"""

    @abstractmethod
    def in_garage(self, index: int | None = None) -> bool:
        """Is in garage"""

    @abstractmethod
    def in_paddock(self, index: int | None = None) -> int:
        """Is in paddock (either pit lane or garage), 0 = on track, 1 = pit lane, 2 = garage"""

    @abstractmethod
    def number_pitstops(self, index: int | None = None, penalty: int = 0) -> int:
        """Number of pit stops"""

    @abstractmethod
    def number_penalties(self, index: int | None = None) -> int:
        """Number of penalties"""

    @abstractmethod
    def pit_request(self, index: int | None = None) -> bool:
        """Is requested pit, 0 = none, 1 = request, 2 = entering, 3 = stopped, 4 = exiting"""

    @abstractmethod
    def pit_stop_time(self) -> float:
        """Estimated pit stop time (seconds)"""

    @abstractmethod
    def absolute_refill(self) -> float:
        """Absolute refill fuel (liter) or virtual energy (percent)"""

    @abstractmethod
    def stint_usage(self, driver_name: str) -> tuple[float, float, float, float, int]:
        """Stint usage data"""

    @abstractmethod
    def finish_state(self, index: int | None = None) -> int:
        """Finish state, 0 = none, 1 = finished, 2 = DNF, 3 = DQ"""

    @abstractmethod
    def fuel(self, index: int | None = None) -> float:
        """Remaining fuel (liters)"""

    @abstractmethod
    def tank_capacity(self, index: int | None = None) -> float:
        """Fuel tank capacity (liters)"""

    @abstractmethod
    def virtual_energy(self, index: int | None = None) -> float:
        """Remaining virtual energy (joule)"""

    @abstractmethod
    def max_virtual_energy(self, index: int | None = None) -> float:
        """Max virtual energy (joule)"""

    @abstractmethod
    def orientation_yaw_radians(self, index: int | None = None) -> float:
        """Orientation yaw (radians)"""

    @abstractmethod
    def position_xyz(self, index: int | None = None) -> tuple[float, float, float]:
        """Raw x,y,z position (meters)"""

    @abstractmethod
    def position_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal axis position (meters) related to world plane"""

    @abstractmethod
    def position_lateral(self, index: int | None = None) -> float:
        """Lateral axis position (meters) related to world plane"""

    @abstractmethod
    def position_vertical(self, index: int | None = None) -> float:
        """Vertical axis position (meters) related to world plane"""

    @abstractmethod
    def accel_lateral(self, index: int | None = None) -> float:
        """Lateral acceleration (m/s^2)"""

    @abstractmethod
    def accel_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal acceleration (m/s^2)"""

    @abstractmethod
    def accel_vertical(self, index: int | None = None) -> float:
        """Vertical acceleration (m/s^2)"""

    @abstractmethod
    def velocity_lateral(self, index: int | None = None) -> float:
        """Lateral velocity (m/s) x"""

    @abstractmethod
    def velocity_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal velocity (m/s) y"""

    @abstractmethod
    def velocity_vertical(self, index: int | None = None) -> float:
        """Vertical velocity (m/s) z"""

    @abstractmethod
    def speed(self, index: int | None = None) -> float:
        """Speed (m/s)"""

    @abstractmethod
    def downforce_front(self, index: int | None = None) -> float:
        """Downforce front (Newtons)"""

    @abstractmethod
    def downforce_rear(self, index: int | None = None) -> float:
        """Downforce rear (Newtons)"""

    @abstractmethod
    def damage_severity(self, index: int | None = None) -> tuple[int, int, int, int, int, int, int, int]:
        """Damage severity, sort row by row from left to right, top to bottom"""

    @abstractmethod
    def aero_damage(self, index: int | None = None) -> float:
        """Aerodynamic damage (fraction), 0.0 no damage, 1.0 totaled"""

    @abstractmethod
    def integrity(self, index: int | None = None) -> float:
        """Vehicle integrity"""

    @abstractmethod
    def is_detached(self, index: int | None = None) -> bool:
        """Whether any vehicle parts are detached"""

    @abstractmethod
    def impact_time(self, index: int | None = None) -> float:
        """Last impact time stamp (seconds)"""

    @abstractmethod
    def impact_magnitude(self, index: int | None = None) -> float:
        """Last impact magnitude"""

    @abstractmethod
    def impact_position(self, index: int | None = None) -> tuple[float, float]:
        """Last impact position x,y coordinates"""


class Wheel(ABC):
    """Wheel & suspension"""

    __slots__ = ()

    @abstractmethod
    def camber(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel camber (radians)"""

    @abstractmethod
    def toe(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel toe (radians)"""

    @abstractmethod
    def toe_symmetric(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel toe symmetric (radians)"""

    @abstractmethod
    def rotation(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel rotation (radians per second)"""

    @abstractmethod
    def velocity_lateral(self, index: int | None = None) -> tuple[float, ...]:
        """Lateral velocity (m/s) x"""

    @abstractmethod
    def velocity_longitudinal(self, index: int | None = None) -> tuple[float, ...]:
        """Longitudinal velocity (m/s) y"""

    @abstractmethod
    def slip_angle_fl(self, index: int | None = None) -> float:
        """Slip angle (radians) front left"""

    @abstractmethod
    def slip_angle_fr(self, index: int | None = None) -> float:
        """Slip angle (radians) front right"""

    @abstractmethod
    def slip_angle_rl(self, index: int | None = None) -> float:
        """Slip angle (radians) rear left"""

    @abstractmethod
    def slip_angle_rr(self, index: int | None = None) -> float:
        """Slip angle (radians) rear right"""

    @abstractmethod
    def ride_height(self, index: int | None = None) -> tuple[float, ...]:
        """Ride height (convert meters to millimeters)"""

    @abstractmethod
    def third_spring_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Third spring deflection front & rear (convert meters to millimeters)"""

    @abstractmethod
    def suspension_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension deflection (convert meters to millimeters)"""

    @abstractmethod
    def suspension_force(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension force (Newtons)"""

    @abstractmethod
    def suspension_damage(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension damage (fraction), 0.0 no damage, 1.0 totaled"""

    @abstractmethod
    def position_vertical(self, index: int | None = None) -> tuple[float, ...]:
        """Vertical wheel position (convert meters to millimeters) related to vehicle"""

    @abstractmethod
    def is_detached(self, index: int | None = None) -> tuple[bool, ...]:
        """Whether wheel is detached"""

    @abstractmethod
    def offroad(self, index: int | None = None) -> int:
        """Number of wheels currently off the road"""

```

# File: tinypedal/adapter/lmu_connector.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
LMU API connector
"""

from __future__ import annotations

import ctypes
import logging
import threading
from time import monotonic, sleep
from typing import TYPE_CHECKING, Sequence

if __name__ == "__main__":  # local import check
    import sys
    sys.path.append(".")

if TYPE_CHECKING:  # for type checker only
    from pyLMUSharedMemory import lmu_type as lmu_data
else:  # run time only
    from pyLMUSharedMemory import lmu_data

from pyLMUSharedMemory.lmu_mmap import (
    INVALID_INDEX,
    MAX_VEHICLES,
    LMUConstants,
    MMapControl,
)

logger = logging.getLogger(__name__)


def copy_struct(struct_data):
    """Allow to copy ctypes struct data with __slots__"""
    return type(struct_data).from_buffer_copy(
        ctypes.string_at(
            ctypes.byref(struct_data),
            ctypes.sizeof(struct_data),
        )
    )


def local_scoring_index(scor_veh: Sequence[lmu_data.LMUVehicleScoring]) -> int:
    """Find local player scoring index

    Args:
        scor_veh: scoring array.
    """
    for scor_idx, veh_info in enumerate(scor_veh):
        if veh_info.mIsPlayer:
            return scor_idx
    return INVALID_INDEX


class MMapDataSet:
    """Create mmap data set"""

    __slots__ = (
        "shmm",
    )

    def __init__(self) -> None:
        self.shmm = MMapControl(LMUConstants.LMU_SHARED_MEMORY_FILE, lmu_data.LMUObjectOut)

    def __del__(self):
        logger.info("sharedmemory: GC: MMapDataSet")

    def create_mmap(self, access_mode: int) -> None:
        """Create mmap instance

        Args:
            access_mode: 0 = copy access, 1 = direct access.
        """
        self.shmm.create(access_mode)

    def close_mmap(self) -> None:
        """Close mmap instance"""
        self.shmm.close()

    def update_mmap(self) -> None:
        """Update mmap data"""
        self.shmm.update()


class SyncData:
    """Synchronize data with player ID

    Attributes:
        dataset: mmap data set.
        paused: Data update state (boolean).
        override_player_index: Player index override state (boolean).
        player_scor_index: Local player scoring index.
        player_scor: Local player scoring data.
        player_tele: Local player telemetry data.
    """

    __slots__ = (
        "_updating",
        "_update_thread",
        "_event",
        "_tele_indexes",
        "paused",
        "override_player_index",
        "player_scor_index",
        "player_scor",
        "player_tele",
        "dataset",
    )

    def __init__(self) -> None:
        self._updating = False
        self._update_thread = None
        self._event = threading.Event()
        self._tele_indexes = {_index: _index for _index in range(128)}

        self.paused = False
        self.override_player_index = False
        self.player_scor_index = INVALID_INDEX
        self.player_scor = None
        self.player_tele = None
        self.dataset = MMapDataSet()

    def __del__(self):
        logger.info("sharedmemory: GC: SyncData")

    def __sync_player_scor(self, scor_index: int = INVALID_INDEX) -> None:
        """Sync local player vehicle scoring data"""
        self.player_scor = self.dataset.shmm.data.scoring.vehScoringInfo[scor_index]

    def __sync_player_tele(self, tele_index: int = INVALID_INDEX) -> None:
        """Sync local player vehicle telemetry data"""
        self.player_tele = self.dataset.shmm.data.telemetry.telemInfo[tele_index]

    def __sync_player_data(self) -> bool:
        """Sync local player data

        Returns:
            False, if no valid player scoring index found.
            True, set player data.
        """
        if not self.override_player_index:
            # Update scoring index
            scor_idx = local_scoring_index(self.dataset.shmm.data.scoring.vehScoringInfo)
            if scor_idx == INVALID_INDEX:
                return False  # index not found, not synced
            self.player_scor_index = scor_idx
        # Set player data
        self.__sync_player_scor(self.player_scor_index)
        self.__sync_player_tele(self.sync_tele_index(self.player_scor_index))
        return True  # found index, synced

    @staticmethod
    def __update_tele_indexes(veh_total: int, tele_data: lmu_data.LMUTelemetryData, tele_indexes: dict) -> None:
        """Update telemetry player index dictionary for quick reference

        Telemetry index can be different from scoring index.
        Use mID matching to match telemetry index.

        Args:
            tele_data: Telemetry data.
            tele_indexes: Telemetry mID:index reference dictionary.
        """
        for tele_idx, veh_info in zip(range(veh_total), tele_data.telemInfo):
            tele_indexes[veh_info.mID] = tele_idx

    def sync_tele_index(self, scor_idx: int) -> int:
        """Sync telemetry index

        Use scoring index to find scoring mID,
        then match with telemetry mID in reference dictionary
        to find telemetry index.

        Args:
            scor_idx: Player scoring index.

        Returns:
            Player telemetry index.
        """
        return self._tele_indexes.get(
            self.dataset.shmm.data.scoring.vehScoringInfo[scor_idx].mID, INVALID_INDEX)

    def start(self, access_mode: int) -> None:
        """Update & sync mmap data copy in separate thread

        Args:
            access_mode: 0 = copy access, 1 = direct access.
        """
        if self._updating:
            logger.warning("sharedmemory: UPDATING: already started")
        else:
            self._updating = True
            # Initialize mmap data
            self.dataset.create_mmap(access_mode)
            self.__update_tele_indexes(
                self.dataset.shmm.data.scoring.scoringInfo.mNumVehicles,
                self.dataset.shmm.data.telemetry,
                self._tele_indexes,
            )
            if not self.__sync_player_data():
                self.__sync_player_scor()
                self.__sync_player_tele()
            # Setup updating thread
            self._event.clear()
            self._update_thread = threading.Thread(target=self.__update, daemon=True)
            self._update_thread.start()
            logger.info("sharedmemory: UPDATING: thread started")
            logger.info("sharedmemory: player index override: %s", self.override_player_index)

    def stop(self) -> None:
        """Join and stop updating thread, close mmap"""
        if self._updating:
            self._event.set()
            self._updating = False
            self._update_thread.join()
            # Make final copy before close, otherwise mmap won't close if using direct access
            self.player_scor = copy_struct(self.player_scor)
            self.player_tele = copy_struct(self.player_tele)
            self.dataset.close_mmap()
        else:
            logger.warning("sharedmemory: UPDATING: already stopped")

    def __update(self) -> None:
        """Update synced player data"""
        self.paused = False  # make sure initial pause state is false
        _event_wait = self._event.wait
        freezed_version = 0  # store freezed update version number
        last_version_update = 0  # store last update version number
        last_update_time = 0.0
        data_freezed = True  # whether data is freezed
        reset_counter = 0
        update_delay = 0.5  # longer delay while inactive

        while not _event_wait(update_delay):
            self.dataset.update_mmap()
            self.__update_tele_indexes(
                self.dataset.shmm.data.scoring.scoringInfo.mNumVehicles,
                self.dataset.shmm.data.telemetry,
                self._tele_indexes,
            )
            # Update player data & index
            if not data_freezed:
                # Get player data
                data_synced = self.__sync_player_data()
                # Pause if local player index no longer exists, 5 tries
                if data_synced:
                    reset_counter = 0
                    self.paused = False
                elif reset_counter < 6:
                    reset_counter += 1
                    if reset_counter == 5:
                        self.player_scor_index = INVALID_INDEX
                        self.__sync_player_scor()
                        self.__sync_player_tele()
                        self.paused = True
                        logger.info("sharedmemory: UPDATING: player data paused")

            version_update = self.dataset.shmm.data.scoring.scoringInfo.mCurrentET
            if last_version_update != version_update:
                last_version_update = version_update
                last_update_time = monotonic()

            if data_freezed:
                # Check while IN freeze state
                if freezed_version != last_version_update:
                    update_delay = 0.01
                    self.paused = data_freezed = False
                    logger.info(
                        "sharedmemory: UPDATING: resumed, data version %s",
                        last_version_update,
                    )
            # Check while NOT IN freeze state
            # Set freeze state if data stopped updating after 2s
            elif monotonic() - last_update_time > 2:
                update_delay = 0.5
                self.paused = data_freezed = True
                freezed_version = last_version_update
                logger.info(
                    "sharedmemory: UPDATING: paused, data version %s",
                    freezed_version,
                )

        logger.info("sharedmemory: UPDATING: thread stopped")


class LMUInfo:
    """LMU shared memory data output"""

    __slots__ = (
        "_sync",
        "_access_mode",
        "_state_override",
        "_active_state",
        "_shmm",
        "_tele",
        "_ext",
        "_ffb",
    )

    def __init__(self) -> None:
        self._sync = SyncData()
        self._access_mode = 0
        self._state_override = False
        self._active_state = False
        # Assign mmap instance
        self._shmm = self._sync.dataset.shmm

    def __del__(self):
        logger.info("sharedmemory: GC: LMUInfo")

    def start(self) -> None:
        """Start data updating thread"""
        self._sync.start(self._access_mode)

    def stop(self) -> None:
        """Stop data updating thread"""
        self._sync.stop()

    def setMode(self, mode: int = 0) -> None:
        """Set LMU mmap access mode

        Args:
            mode: 0 = copy access, 1 = direct access
        """
        self._access_mode = mode

    def setStateOverride(self, state: bool = False) -> None:
        """Enable state override"""
        self._state_override = state

    def setActiveState(self, state: bool = False) -> None:
        """Set state override"""
        self._active_state = state

    def setPlayerOverride(self, state: bool = False) -> None:
        """Enable player index override state"""
        self._sync.override_player_index = state

    def setPlayerIndex(self, index: int = INVALID_INDEX) -> None:
        """Manual override player index"""
        self._sync.player_scor_index = min(max(index, INVALID_INDEX), MAX_VEHICLES - 1)

    @property
    def lmuScorInfo(self) -> lmu_data.LMUScoringInfo:
        """LMU scoring info data"""
        return self._shmm.data.scoring.scoringInfo

    def lmuScorVeh(self, index: int | None = None) -> lmu_data.LMUVehicleScoring:
        """LMU scoring vehicle data

        Specify index for specific player.

        Args:
            index: None for local player.
        """
        if index is None:
            return self._sync.player_scor
        return self._shmm.data.scoring.vehScoringInfo[index]

    def lmuTeleVeh(self, index: int | None = None) -> lmu_data.LMUVehicleTelemetry:
        """LMU telemetry vehicle data

        Specify index for specific player.

        Args:
            index: None for local player.
        """
        if index is None:
            return self._sync.player_tele
        return self._shmm.data.telemetry.telemInfo[self._sync.sync_tele_index(index)]

    @property
    def lmuGeneric(self) -> lmu_data.LMUGeneric:
        """LMU generic data"""
        return self._shmm.data.generic

    @property
    def playerIndex(self) -> int:
        """Local player's scoring index"""
        return self._sync.player_scor_index

    @property
    def isPaused(self) -> bool:
        """Check whether data stopped updating"""
        return self._sync.paused or self._sync.player_scor_index < 0

    @property
    def isActive(self) -> bool:
        """Check whether in active (driving or overriding) state"""
        if self._state_override:
            return self._active_state
        return not self._sync.paused and self._sync.player_scor_index >= 0 and (
            self.lmuScorInfo.mInRealtime
            or self.lmuTeleVeh().mIgnitionStarter > 0
        )


def test_api():
    """API test run"""
    # Add logger
    test_handler = logging.StreamHandler()
    logger.setLevel(logging.INFO)
    logger.addHandler(test_handler)

    # Test run
    SEPARATOR = "=" * 50
    print("Test API - Start")
    info = LMUInfo()
    info.setMode(1)  # set direct access
    info.setPlayerOverride(True)  # enable player override
    info.setPlayerIndex(0)  # set player index to 0
    info.start()
    sleep(0.2)

    print(SEPARATOR)
    print("Test API - Restart")
    info.stop()
    info.setMode()  # set copy access
    info.setPlayerOverride()  # disable player override
    info.start()

    print(SEPARATOR)
    print("Test API - Read")
    version = info.lmuGeneric.gameVersion
    driver = info.lmuScorVeh(0).mDriverName.decode()
    track = info.lmuScorInfo.mTrackName.decode()
    print(f"version: {version if version else 'not running'}")
    print(f"driver name   : {driver if version else 'not running'}")
    print(f"track name    : {track if version else 'not running'}")

    print(SEPARATOR)
    print("Test API - Close")
    info.stop()


if __name__ == "__main__":
    test_api()

```

# File: tinypedal/adapter/lmu_reader.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
LMU API data reader

Notes:
    Convert all temperature (kelvin) to Celsius before output.
"""

from __future__ import annotations

from ..calculation import (
    clock_time_scale_sync,
    lap_progress_distance,
    mean,
    min_nonzero,
    oriyaw2rad,
    slip_angle,
    vel2speed,
)
from ..const_common import MAX_SECONDS, STINT_USAGE_DEFAULT
from ..formatter import strip_invalid_char
from ..process.weather import WeatherNode
from ..validator import bytes_to_str as tostr
from ..validator import infnan_to_zero as rmnan
from . import _reader, lmu_connector, restapi_connector


class DataAdapter:
    """Read & sort data into groups"""

    __slots__ = (
        "shmm",
        "rest",
    )

    def __init__(self, shmm: lmu_connector.LMUInfo, rest: restapi_connector.RestAPIInfo) -> None:
        """Initialize API setting

        Args:
            shmm: shared memory API connector.
            rest: rest API connector.
        """
        self.shmm = shmm
        self.rest = rest


class State(_reader.State, DataAdapter):
    """State"""

    __slots__ = ()

    def active(self) -> bool:
        """Is active (driving or overriding)"""
        return self.shmm.isActive

    def paused(self) -> bool:
        """Is paused"""
        return self.shmm.isPaused

    def desynced(self, index: int | None = None) -> bool:
        """Is player data desynced from others"""
        return (
            abs(self.shmm.lmuTeleVeh().mElapsedTime
            - self.shmm.lmuTeleVeh(index).mElapsedTime)
            >= 0.01
        )

    def version(self) -> str:
        """Identify API version"""
        version = str(self.shmm.lmuGeneric.gameVersion)
        if len(version) < 2:
            return "unknown"
        return f"{version[0]}.{version[1:]}"


class Brake(_reader.Brake, DataAdapter):
    """Brake"""

    __slots__ = ()

    def bias_front(self, index: int | None = None) -> float:
        """Brake bias front (fraction)"""
        return 1 - rmnan(self.shmm.lmuTeleVeh(index).mRearBrakeBias)

    def pressure(self, index: int | None = None, scale: float = 1) -> tuple[float, ...]:
        """Brake pressure (fraction)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mBrakePressure) * scale,
            rmnan(wheel_data[1].mBrakePressure) * scale,
            rmnan(wheel_data[2].mBrakePressure) * scale,
            rmnan(wheel_data[3].mBrakePressure) * scale,
        )

    def temperature(self, index: int | None = None) -> tuple[float, ...]:
        """Brake temperature (Celsius)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mBrakeTemp) - 273.15,
            rmnan(wheel_data[1].mBrakeTemp) - 273.15,
            rmnan(wheel_data[2].mBrakeTemp) - 273.15,
            rmnan(wheel_data[3].mBrakeTemp) - 273.15,
        )

    def wear(self, index: int | None = None) -> tuple[float, ...]:
        """Brake remaining thickness (meters)"""
        return self.rest.telemetry().brakeWear


class ElectricMotor(_reader.ElectricMotor, DataAdapter):
    """Electric motor"""

    __slots__ = ()

    def state(self, index: int | None = None) -> int:
        """Motor state, 0 = n/a, 1 = off, 2 = drain, 3 = regen"""
        state = self.shmm.lmuTeleVeh(index).mElectricBoostMotorState
        if state == 0:
            return 0
        if state == 1:
            return 1
        if state == 2:
            return 2
        if state == 3:
            return 3
        return 0

    def battery_charge(self, index: int | None = None) -> float:
        """Battery charge (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mBatteryChargeFraction)

    def rpm(self, index: int | None = None) -> float:
        """Motor RPM (rev per minute)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mElectricBoostMotorRPM)

    def torque(self, index: int | None = None) -> float:
        """Motor torque (Nm)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mElectricBoostMotorTorque)

    def motor_temperature(self, index: int | None = None) -> float:
        """Motor temperature (Celsius)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mElectricBoostMotorTemperature)

    def water_temperature(self, index: int | None = None) -> float:
        """Motor water temperature (Celsius)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mElectricBoostWaterTemperature)


class Engine(_reader.Engine, DataAdapter):
    """Engine"""

    __slots__ = ()

    def gear(self, index: int | None = None) -> int:
        """Gear"""
        return self.shmm.lmuTeleVeh(index).mGear

    def gear_max(self, index: int | None = None) -> int:
        """Max gear"""
        return self.shmm.lmuTeleVeh(index).mMaxGears

    def rpm(self, index: int | None = None) -> float:
        """RPM (rev per minute)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mEngineRPM)

    def rpm_max(self, index: int | None = None) -> float:
        """Max RPM (rev per minute)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mEngineMaxRPM)

    def torque(self, index: int | None = None) -> float:
        """Torque (Nm)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mEngineTorque)

    def turbo(self, index: int | None = None) -> float:
        """Turbo pressure (Pa)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mTurboBoostPressure)

    def oil_temperature(self, index: int | None = None) -> float:
        """Oil temperature (Celsius)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mEngineOilTemp)

    def water_temperature(self, index: int | None = None) -> float:
        """Water temperature (Celsius)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mEngineWaterTemp)


class Inputs(_reader.Inputs, DataAdapter):
    """Inputs"""

    __slots__ = ()

    def throttle(self, index: int | None = None) -> float:
        """Throttle filtered (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mFilteredThrottle)

    def throttle_raw(self, index: int | None = None) -> float:
        """Throttle raw (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mUnfilteredThrottle)

    def brake(self, index: int | None = None) -> float:
        """Brake filtered (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mFilteredBrake)

    def brake_raw(self, index: int | None = None) -> float:
        """Brake raw (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mUnfilteredBrake)

    def clutch(self, index: int | None = None) -> float:
        """Clutch filtered (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mFilteredClutch)

    def clutch_raw(self, index: int | None = None) -> float:
        """Clutch raw (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mUnfilteredClutch)

    def steering(self, index: int | None = None) -> float:
        """Steering filtered (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mFilteredSteering)

    def steering_raw(self, index: int | None = None) -> float:
        """Steering raw (fraction)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mUnfilteredSteering)

    def steering_shaft_torque(self, index: int | None = None) -> float:
        """Steering shaft torque (Nm)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mSteeringShaftTorque)

    def steering_range_physical(self, index: int | None = None) -> float:
        """Steering physical rotation range (degrees)"""
        rot_range = rmnan(self.shmm.lmuTeleVeh(index).mPhysicalSteeringWheelRange)
        if rot_range <= 0:
            rot_range = self.rest.telemetry().steeringWheelRange
        return rot_range

    def steering_range_visual(self, index: int | None = None) -> float:
        """Steering visual rotation range (degrees)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mVisualSteeringWheelRange)

    def force_feedback(self) -> float:
        """Steering force feedback (fraction)"""
        return rmnan(self.shmm.lmuGeneric.FFBTorque)


class Lap(_reader.Lap, DataAdapter):
    """Lap"""

    __slots__ = ()

    def number(self, index: int | None = None) -> int:
        """Current lap number"""
        return self.shmm.lmuTeleVeh(index).mLapNumber

    def completed_laps(self, index: int | None = None) -> int:
        """Total completed laps"""
        return self.shmm.lmuScorVeh(index).mTotalLaps

    def track_length(self) -> float:
        """Full lap or track length (meters)"""
        return rmnan(self.shmm.lmuScorInfo.mLapDist)

    def distance(self, index: int | None = None) -> float:
        """Distance into lap (meters)"""
        return rmnan(self.shmm.lmuScorVeh(index).mLapDist)

    def progress(self, index: int | None = None) -> float:
        """Lap progress (fraction), distance into lap"""
        return rmnan(lap_progress_distance(
            self.shmm.lmuScorVeh(index).mLapDist,
            self.shmm.lmuScorInfo.mLapDist))

    def maximum(self) -> int:
        """Maximum lap"""
        return self.shmm.lmuScorInfo.mMaxLaps

    def sector_index(self, index: int | None = None) -> int:
        """Sector index, 0 = S1, 1 = S2, 2 = S3"""
        # LMU sector index 0 = S3, index 1 = S1, index 2 = S2
        sector = self.shmm.lmuScorVeh(index).mSector
        if sector == 0:
            return 2
        if sector == 1:
            return 0
        return 1

    def behind_leader(self, index: int | None = None) -> int:
        """Laps behind leader"""
        return self.shmm.lmuScorVeh(index).mLapsBehindLeader

    def behind_next(self, index: int | None = None) -> int:
        """Laps behind next place"""
        return self.shmm.lmuScorVeh(index).mLapsBehindNext


class Session(_reader.Session, DataAdapter):
    """Session"""

    __slots__ = ()

    def combo_name(self) -> str:
        """Track & vehicle combo name, strip off invalid char"""
        track_name = tostr(self.shmm.lmuScorInfo.mTrackName)
        class_name = tostr(self.shmm.lmuScorVeh().mVehicleClass)
        return strip_invalid_char(f"{track_name} - {class_name}")

    def track_name(self) -> str:
        """Track name, strip off invalid char"""
        return strip_invalid_char(tostr(self.shmm.lmuScorInfo.mTrackName))

    def identifier(self) -> tuple[int, int, int]:
        """Identify session"""
        session_length = rmnan(self.shmm.lmuScorInfo.mEndET)
        session_type = self.shmm.lmuScorInfo.mSession
        session_stamp = int(session_length * 100 + session_type)
        session_etime = int(rmnan(self.shmm.lmuScorInfo.mCurrentET))
        session_tlaps = self.shmm.lmuScorVeh().mTotalLaps
        return session_stamp, session_etime, session_tlaps

    def elapsed(self) -> float:
        """Session elapsed time (seconds)"""
        return rmnan(self.shmm.lmuScorInfo.mCurrentET)

    def start(self) -> float:
        """Session start time (seconds)"""
        return rmnan(self.shmm.lmuScorInfo.mStartET)

    def end(self) -> float:
        """Session end time (seconds)"""
        return rmnan(self.shmm.lmuScorInfo.mEndET)

    def remaining(self) -> float:
        """Session time remaining (seconds)"""
        scor = self.shmm.lmuScorInfo
        return rmnan(scor.mEndET - scor.mCurrentET)

    def session_type(self) -> int:
        """Session type, 0 = TESTDAY, 1 = PRACTICE, 2 = QUALIFY, 3 = WARMUP, 4 = RACE"""
        session = self.shmm.lmuScorInfo.mSession
        if session >= 10:  # race
            return 4
        if session == 9:  # warmup
            return 3
        if session >= 5:  # qualify
            return 2
        if session >= 1:  # practice
            return 1
        return 0  # test day

    def lap_type(self) -> bool:
        """Is lap type session, false for time type"""
        return self.shmm.lmuScorInfo.mMaxLaps < 99999

    def in_race(self) -> bool:
        """Is in race session"""
        return self.shmm.lmuScorInfo.mSession > 9

    def private_qualifying(self) -> bool:
        """Is private qualifying"""
        return self.rest.telemetry().privateQualifying == 1

    def in_countdown(self) -> bool:
        """Is in countdown phase before race"""
        return self.shmm.lmuScorInfo.mGamePhase == 4

    def in_formation(self) -> bool:
        """Is in formation phase before race"""
        return self.shmm.lmuScorInfo.mGamePhase == 3

    def pit_open(self) -> bool:
        """Is pit lane open"""
        return self.shmm.lmuScorInfo.mGamePhase > 0

    def pre_race(self) -> bool:
        """Before race starts (green flag)"""
        return self.shmm.lmuScorInfo.mGamePhase <= 4

    def green_flag(self) -> bool:
        """Green flag (race starts)"""
        # Inaccurate due to 5FPS refresh rate from API
        return self.shmm.lmuScorInfo.mGamePhase == 5

    def blue_flag(self, index: int | None = None) -> bool:
        """Is under blue flag"""
        return self.shmm.lmuScorVeh(index).mFlag == 6

    def yellow_flag(self) -> bool:
        """Is there yellow flag in any sectors"""
        sec_flag = self.shmm.lmuScorInfo.mSectorFlag
        return any(data == 1 for data in sec_flag)

    def start_lights(self) -> int:
        """Start lights countdown sequence"""
        scor = self.shmm.lmuScorInfo
        return scor.mNumRedLights - scor.mStartLight + 1

    def track_temperature(self) -> float:
        """Track temperature (Celsius)"""
        return rmnan(self.shmm.lmuScorInfo.mTrackTemp)

    def ambient_temperature(self) -> float:
        """Ambient temperature (Celsius)"""
        return rmnan(self.shmm.lmuScorInfo.mAmbientTemp)

    def raininess(self) -> float:
        """Rain severity (fraction)"""
        return rmnan(self.shmm.lmuScorInfo.mRaining)

    def wetness_minimum(self) -> float:
        """Road minimum wetness (fraction)"""
        return rmnan(self.shmm.lmuScorInfo.mMinPathWetness)

    def wetness_maximum(self) -> float:
        """Road maximum wetness (fraction)"""
        return rmnan(self.shmm.lmuScorInfo.mMaxPathWetness)

    def wetness_average(self) -> float:
        """Road average wetness (fraction)"""
        return rmnan(self.shmm.lmuScorInfo.mAvgPathWetness)

    def wetness(self) -> tuple[float, float, float]:
        """Road wetness set (fraction)"""
        scor = self.shmm.lmuScorInfo
        return (rmnan(scor.mMinPathWetness),
                rmnan(scor.mMaxPathWetness),
                rmnan(scor.mAvgPathWetness))

    def weather_forecast(self) -> tuple[WeatherNode, ...]:
        """Weather forecast nodes"""
        session_type = self.session_type()
        if session_type <= 1:  # practice session
            return self.rest.telemetry().forecastPractice
        if session_type == 2:  # qualify session
            return self.rest.telemetry().forecastQualify
        return self.rest.telemetry().forecastRace  # race session

    def time_scale(self) -> int:
        """Time scale"""
        track_time = self.rest.telemetry().trackClockTime
        if track_time == -1:  # trackClockTime unavailable
            time_scale = max(self.rest.telemetry().timeScale, 0)
        else:  # sync time scale
            time_scale = clock_time_scale_sync(track_time, self.elapsed(), self.start())
        return time_scale


class Switch(_reader.Switch, DataAdapter):
    """Switch"""

    __slots__ = ()

    def headlights(self, index: int | None = None) -> int:
        """Headlights"""
        return self.shmm.lmuTeleVeh(index).mHeadlights

    def ignition_starter(self, index: int | None = None) -> int:
        """Ignition"""
        return self.shmm.lmuTeleVeh(index).mIgnitionStarter

    def speed_limiter(self, index: int | None = None) -> int:
        """Speed limiter"""
        return self.shmm.lmuTeleVeh(index).mSpeedLimiter

    def drs_status(self, index: int | None = None) -> int:
        """DRS status, 0 not_available, 1 available, 2 allowed(not activated), 3 activated"""
        tele_veh = self.shmm.lmuTeleVeh(index)
        status = tele_veh.mRearFlapLegalStatus
        if status == 1:
            return 1  # available
        if status == 2:
            if tele_veh.mRearFlapActivated:
                return 3  # activated
            return 2  # allowed
        return 0  # not_available

    def auto_clutch(self) -> bool:
        """Auto clutch"""
        return False


class Timing(_reader.Timing, DataAdapter):
    """Timing"""

    __slots__ = ()

    def start(self, index: int | None = None) -> float:
        """Current lap start time (seconds)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLapStartET)

    def elapsed(self, index: int | None = None) -> float:
        """Current lap elapsed time (seconds)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mElapsedTime)

    def current_laptime(self, index: int | None = None) -> float:
        """Current lap time (seconds)"""
        tele_veh = self.shmm.lmuTeleVeh(index)
        return rmnan(tele_veh.mElapsedTime - tele_veh.mLapStartET)

    def last_laptime(self, index: int | None = None) -> float:
        """Last lap time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mLastLapTime)

    def best_laptime(self, index: int | None = None) -> float:
        """Best lap time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mBestLapTime)

    def reference_laptime(self, index: int | None = None):
        """Reference lap time (seconds)"""
        init_time = min_nonzero((
            self.best_laptime(index),
            self.last_laptime(index),
            MAX_SECONDS,
        ))
        if 0 < init_time < MAX_SECONDS:
            return init_time
        # Set to estimated laptime only if other laptime not available
        # as estimated laptime can be faster than other laptime
        return min_nonzero((
            self.estimated_laptime(index),
            MAX_SECONDS,
        ))

    def estimated_laptime(self, index: int | None = None) -> float:
        """Estimated lap time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mEstimatedLapTime)

    def estimated_time_into(self, index: int | None = None) -> float:
        """Estimated time into lap (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mTimeIntoLap)

    def current_sector1(self, index: int | None = None) -> float:
        """Current lap sector 1 time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mCurSector1)

    def current_sector2(self, index: int | None = None) -> float:
        """Current lap sector 1+2 time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mCurSector2)

    def last_sector1(self, index: int | None = None) -> float:
        """Last lap sector 1 time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mLastSector1)

    def last_sector2(self, index: int | None = None) -> float:
        """Last lap sector 1+2 time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mLastSector2)

    def best_sector1(self, index: int | None = None) -> float:
        """Best lap sector 1 time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mBestSector1)

    def best_sector2(self, index: int | None = None) -> float:
        """Best lap sector 1+2 time (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mBestSector2)

    def behind_leader(self, index: int | None = None) -> float:
        """Time behind leader (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mTimeBehindLeader)

    def behind_next(self, index: int | None = None) -> float:
        """Time behind next place (seconds)"""
        return rmnan(self.shmm.lmuScorVeh(index).mTimeBehindNext)


class Tyre(_reader.Tyre, DataAdapter):
    """Tyre"""

    __slots__ = ()

    def compound_front(self, index: int | None = None) -> int:
        """Tyre compound (front)"""
        return self.shmm.lmuTeleVeh(index).mFrontTireCompoundIndex

    def compound_rear(self, index: int | None = None) -> int:
        """Tyre compound (rear)"""
        return self.shmm.lmuTeleVeh(index).mRearTireCompoundIndex

    def compound(self, index: int | None = None) -> tuple[int, int]:
        """Tyre compound set (front, rear)"""
        tele_veh = self.shmm.lmuTeleVeh(index)
        return tele_veh.mFrontTireCompoundIndex, tele_veh.mRearTireCompoundIndex

    def compound_name_front(self, index: int | None = None) -> str:
        """Tyre compound name (front)"""
        return tostr(self.shmm.lmuTeleVeh(index).mFrontTireCompoundName)

    def compound_name_rear(self, index: int | None = None) -> str:
        """Tyre compound name (rear)"""
        return tostr(self.shmm.lmuTeleVeh(index).mRearTireCompoundName)

    def compound_name(self, index: int | None = None) -> tuple[str, str]:
        """Tyre compound name set (front, rear)"""
        tele_veh = self.shmm.lmuTeleVeh(index)
        return tostr(tele_veh.mFrontTireCompoundName), tostr(tele_veh.mRearTireCompoundName)

    def surface_temperature_avg(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre surface temperature set (Celsius) average"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(mean(wheel_data[0].mTemperature)) - 273.15,
            rmnan(mean(wheel_data[1].mTemperature)) - 273.15,
            rmnan(mean(wheel_data[2].mTemperature)) - 273.15,
            rmnan(mean(wheel_data[3].mTemperature)) - 273.15,
        )

    def surface_temperature_ico(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre surface temperature set (Celsius) inner,center,outer"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mTemperature[0]) - 273.15,
            rmnan(wheel_data[0].mTemperature[1]) - 273.15,
            rmnan(wheel_data[0].mTemperature[2]) - 273.15,
            rmnan(wheel_data[1].mTemperature[0]) - 273.15,
            rmnan(wheel_data[1].mTemperature[1]) - 273.15,
            rmnan(wheel_data[1].mTemperature[2]) - 273.15,
            rmnan(wheel_data[2].mTemperature[0]) - 273.15,
            rmnan(wheel_data[2].mTemperature[1]) - 273.15,
            rmnan(wheel_data[2].mTemperature[2]) - 273.15,
            rmnan(wheel_data[3].mTemperature[0]) - 273.15,
            rmnan(wheel_data[3].mTemperature[1]) - 273.15,
            rmnan(wheel_data[3].mTemperature[2]) - 273.15,
        )

    def inner_temperature_avg(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre inner temperature set (Celsius) average"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(mean(wheel_data[0].mTireInnerLayerTemperature)) - 273.15,
            rmnan(mean(wheel_data[1].mTireInnerLayerTemperature)) - 273.15,
            rmnan(mean(wheel_data[2].mTireInnerLayerTemperature)) - 273.15,
            rmnan(mean(wheel_data[3].mTireInnerLayerTemperature)) - 273.15,
        )

    def inner_temperature_ico(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre inner temperature set (Celsius) inner,center,outer"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mTireInnerLayerTemperature[0]) - 273.15,
            rmnan(wheel_data[0].mTireInnerLayerTemperature[1]) - 273.15,
            rmnan(wheel_data[0].mTireInnerLayerTemperature[2]) - 273.15,
            rmnan(wheel_data[1].mTireInnerLayerTemperature[0]) - 273.15,
            rmnan(wheel_data[1].mTireInnerLayerTemperature[1]) - 273.15,
            rmnan(wheel_data[1].mTireInnerLayerTemperature[2]) - 273.15,
            rmnan(wheel_data[2].mTireInnerLayerTemperature[0]) - 273.15,
            rmnan(wheel_data[2].mTireInnerLayerTemperature[1]) - 273.15,
            rmnan(wheel_data[2].mTireInnerLayerTemperature[2]) - 273.15,
            rmnan(wheel_data[3].mTireInnerLayerTemperature[0]) - 273.15,
            rmnan(wheel_data[3].mTireInnerLayerTemperature[1]) - 273.15,
            rmnan(wheel_data[3].mTireInnerLayerTemperature[2]) - 273.15,
        )

    def pressure(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre pressure (kPa)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mPressure),
            rmnan(wheel_data[1].mPressure),
            rmnan(wheel_data[2].mPressure),
            rmnan(wheel_data[3].mPressure),
        )

    def load(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre load (Newtons)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mTireLoad),
            rmnan(wheel_data[1].mTireLoad),
            rmnan(wheel_data[2].mTireLoad),
            rmnan(wheel_data[3].mTireLoad),
        )

    def wear(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre wear (fraction)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mWear),
            rmnan(wheel_data[1].mWear),
            rmnan(wheel_data[2].mWear),
            rmnan(wheel_data[3].mWear),
        )

    def carcass_temperature(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre carcass temperature (Celsius)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mTireCarcassTemperature) - 273.15,
            rmnan(wheel_data[1].mTireCarcassTemperature) - 273.15,
            rmnan(wheel_data[2].mTireCarcassTemperature) - 273.15,
            rmnan(wheel_data[3].mTireCarcassTemperature) - 273.15,
        )

    def vertical_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre vertical deflection (millimeters)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mVerticalTireDeflection) * 1000,
            rmnan(wheel_data[1].mVerticalTireDeflection) * 1000,
            rmnan(wheel_data[2].mVerticalTireDeflection) * 1000,
            rmnan(wheel_data[3].mVerticalTireDeflection) * 1000,
        )


class Vehicle(_reader.Vehicle, DataAdapter):
    """Vehicle"""

    __slots__ = ()

    def is_player(self, index: int=0) -> bool:
        """Is local player"""
        return self.shmm.playerIndex == index

    def is_driving(self) -> bool:
        """Is local player driving or in monitor"""
        return self.shmm.lmuTeleVeh().mIgnitionStarter > 0

    def player_index(self) -> int:
        """Get Local player index"""
        return self.shmm.playerIndex

    def slot_id(self, index: int | None = None) -> int:
        """Vehicle slot id"""
        return self.shmm.lmuScorVeh(index).mID

    def driver_name(self, index: int | None = None) -> str:
        """Driver name"""
        return tostr(self.shmm.lmuScorVeh(index).mDriverName)

    def vehicle_name(self, index: int | None = None) -> str:
        """Vehicle name"""
        return tostr(self.shmm.lmuScorVeh(index).mVehicleName)

    def class_name(self, index: int | None = None) -> str:
        """Vehicle class name"""
        return tostr(self.shmm.lmuScorVeh(index).mVehicleClass)

    def same_class(self, index: int | None = None) -> bool:
        """Is same vehicle class"""
        return self.shmm.lmuScorVeh(index).mVehicleClass == self.shmm.lmuScorVeh().mVehicleClass

    def total_vehicles(self) -> int:
        """Total vehicles"""
        return self.shmm.lmuScorInfo.mNumVehicles

    def place(self, index: int | None = None) -> int:
        """Vehicle overall place"""
        return self.shmm.lmuScorVeh(index).mPlace

    def qualification(self, index: int | None = None) -> int:
        """Vehicle qualification place"""
        return self.shmm.lmuScorVeh(index).mQualification

    def in_pits(self, index: int | None = None) -> bool:
        """Is in pits"""
        return self.shmm.lmuScorVeh(index).mInPits

    def in_garage(self, index: int | None = None) -> bool:
        """Is in garage"""
        return self.shmm.lmuScorVeh(index).mInGarageStall

    def in_paddock(self, index: int | None = None) -> int:
        """Is in paddock (either pit lane or garage), 0 = on track, 1 = pit lane, 2 = garage"""
        state = self.shmm.lmuScorVeh(index)
        return 2 if state.mInGarageStall else state.mInPits

    def number_pitstops(self, index: int | None = None, penalty: int = 0) -> int:
        """Number of pit stops"""
        return -penalty if penalty else self.shmm.lmuScorVeh(index).mNumPitstops

    def number_penalties(self, index: int | None = None) -> int:
        """Number of penalties"""
        return self.shmm.lmuScorVeh(index).mNumPenalties

    def pit_request(self, index: int | None = None) -> bool:
        """Is requested pit, 0 = none, 1 = request, 2 = entering, 3 = stopped, 4 = exiting"""
        return self.shmm.lmuScorVeh(index).mPitState == 1

    def pit_stop_time(self) -> float:
        """Estimated pit stop time (seconds)"""
        return self.rest.telemetry().pitStopTime

    def absolute_refill(self) -> float:
        """Absolute refill fuel (liter) or virtual energy (percent)"""
        return self.rest.telemetry().absoluteRefill

    def stint_usage(self, driver_name: str) -> tuple[float, float, float, float, int]:
        """Stint usage data"""
        return self.rest.telemetry().stintUsage.get(driver_name, STINT_USAGE_DEFAULT)

    def finish_state(self, index: int | None = None) -> int:
        """Finish state, 0 = none, 1 = finished, 2 = DNF, 3 = DQ"""
        state = self.shmm.lmuScorVeh(index).mFinishStatus
        if state == 0:
            return 0
        if state == 1:
            return 1
        if state == 2:
            return 2
        if state == 3:
            return 3
        return 0

    def fuel(self, index: int | None = None) -> float:
        """Remaining fuel (liters)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mFuel)

    def tank_capacity(self, index: int | None = None) -> float:
        """Fuel tank capacity (liters)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mFuelCapacity)

    def virtual_energy(self, index: int | None = None) -> float:
        """Remaining virtual energy (joule)"""
        return self.rest.telemetry().currentVirtualEnergy

    def max_virtual_energy(self, index: int | None = None) -> float:
        """Max virtual energy (joule)"""
        return self.rest.telemetry().maxVirtualEnergy

    def orientation_yaw_radians(self, index: int | None = None) -> float:
        """Orientation yaw (radians)"""
        ori = self.shmm.lmuTeleVeh(index).mOri[2]
        return rmnan(oriyaw2rad(ori.x, ori.z))

    def position_xyz(self, index: int | None = None) -> tuple[float, float, float]:
        """Raw x,y,z position (meters)"""
        pos = self.shmm.lmuTeleVeh(index).mPos
        return rmnan(pos.x), rmnan(pos.y), rmnan(pos.z)

    def position_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal axis position (meters) related to world plane"""
        return rmnan(self.shmm.lmuTeleVeh(index).mPos.x)  # in LMU coord system

    def position_lateral(self, index: int | None = None) -> float:
        """Lateral axis position (meters) related to world plane"""
        return -rmnan(self.shmm.lmuTeleVeh(index).mPos.z)  # in LMU coord system

    def position_vertical(self, index: int | None = None) -> float:
        """Vertical axis position (meters) related to world plane"""
        return rmnan(self.shmm.lmuTeleVeh(index).mPos.y)  # in LMU coord system

    def accel_lateral(self, index: int | None = None) -> float:
        """Lateral acceleration (m/s^2)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLocalAccel.x)  # X in LMU coord system

    def accel_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal acceleration (m/s^2)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLocalAccel.z)  # Z in LMU coord system

    def accel_vertical(self, index: int | None = None) -> float:
        """Vertical acceleration (m/s^2)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLocalAccel.y)  # Y in LMU coord system

    def velocity_lateral(self, index: int | None = None) -> float:
        """Lateral velocity (m/s) x"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLocalVel.x)  # X in LMU coord system

    def velocity_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal velocity (m/s) y"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLocalVel.z)  # Z in LMU coord system

    def velocity_vertical(self, index: int | None = None) -> float:
        """Vertical velocity (m/s) z"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLocalVel.y)  # Y in LMU coord system

    def speed(self, index: int | None = None) -> float:
        """Speed (m/s)"""
        vel = self.shmm.lmuTeleVeh(index).mLocalVel
        return rmnan(vel2speed(vel.x, vel.y, vel.z))

    def downforce_front(self, index: int | None = None) -> float:
        """Downforce front (Newtons)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mFrontDownforce)

    def downforce_rear(self, index: int | None = None) -> float:
        """Downforce rear (Newtons)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mRearDownforce)

    def damage_severity(self, index: int | None = None) -> tuple[int, int, int, int, int, int, int, int]:
        """Damage severity, sort row by row from left to right, top to bottom"""
        data = self.shmm.lmuTeleVeh(index)
        dmg = data.mDentSeverity
        dmg_rear = 3 if data.mDetached else dmg[4]  # the only body parts can detach in LMU is rear wing
        return dmg[1], dmg[0], dmg[7], dmg[2], dmg[6], dmg[3], dmg_rear, dmg[5]  # LMU order

    def aero_damage(self, index: int | None = None) -> float:
        """Aerodynamic damage (fraction), 0.0 no damage, 1.0 totaled"""
        return self.rest.telemetry().aeroDamage

    def integrity(self, index: int | None = None) -> float:
        """Vehicle integrity"""
        data = self.shmm.lmuTeleVeh(index)
        total = (
            1
            - sum(data.mDentSeverity) / 16
            - any(wheel_data.mDetached for wheel_data in data.mWheels) / 2
            - data.mDetached / 2
        )
        if total < 0:
            return 0
        return total

    def is_detached(self, index: int | None = None) -> bool:
        """Whether any vehicle parts are detached"""
        return self.shmm.lmuTeleVeh(index).mDetached

    def impact_time(self, index: int | None = None) -> float:
        """Last impact time stamp (seconds)"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLastImpactET)

    def impact_magnitude(self, index: int | None = None) -> float:
        """Last impact magnitude"""
        return rmnan(self.shmm.lmuTeleVeh(index).mLastImpactMagnitude)

    def impact_position(self, index: int | None = None) -> tuple[float, float]:
        """Last impact position x,y coordinates"""
        pos = self.shmm.lmuTeleVeh(index).mLastImpactPos
        return -rmnan(pos.x), rmnan(pos.z)


class Wheel(_reader.Wheel, DataAdapter):
    """Wheel & suspension"""

    __slots__ = ()

    def camber(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel camber (radians)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mCamber),
            rmnan(wheel_data[1].mCamber),
            rmnan(wheel_data[2].mCamber),
            rmnan(wheel_data[3].mCamber),
        )

    def toe(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel toe (radians)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mToe),
            rmnan(wheel_data[1].mToe),
            rmnan(wheel_data[2].mToe),
            rmnan(wheel_data[3].mToe),
        )

    def toe_symmetric(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel toe symmetric (radians)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mToe),
            -rmnan(wheel_data[1].mToe),
            rmnan(wheel_data[2].mToe),
            -rmnan(wheel_data[3].mToe),
        )

    def rotation(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel rotation (radians per second)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mRotation),
            rmnan(wheel_data[1].mRotation),
            rmnan(wheel_data[2].mRotation),
            rmnan(wheel_data[3].mRotation),
        )

    def velocity_lateral(self, index: int | None = None) -> tuple[float, ...]:
        """Lateral velocity (m/s) x"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mLateralGroundVel),
            rmnan(wheel_data[1].mLateralGroundVel),
            rmnan(wheel_data[2].mLateralGroundVel),
            rmnan(wheel_data[3].mLateralGroundVel),
        )

    def velocity_longitudinal(self, index: int | None = None) -> tuple[float, ...]:
        """Longitudinal velocity (m/s) y"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mLongitudinalGroundVel),
            rmnan(wheel_data[1].mLongitudinalGroundVel),
            rmnan(wheel_data[2].mLongitudinalGroundVel),
            rmnan(wheel_data[3].mLongitudinalGroundVel),
        )

    def slip_angle_fl(self, index: int | None = None) -> float:
        """Slip angle (radians) front left"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels[0]
        return rmnan(slip_angle(
            wheel_data.mLateralGroundVel,
            wheel_data.mLongitudinalGroundVel))

    def slip_angle_fr(self, index: int | None = None) -> float:
        """Slip angle (radians) front right"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels[1]
        return rmnan(slip_angle(
            wheel_data.mLateralGroundVel,
            wheel_data.mLongitudinalGroundVel))

    def slip_angle_rl(self, index: int | None = None) -> float:
        """Slip angle (radians) rear left"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels[2]
        return rmnan(slip_angle(
            wheel_data.mLateralGroundVel,
            wheel_data.mLongitudinalGroundVel))

    def slip_angle_rr(self, index: int | None = None) -> float:
        """Slip angle (radians) rear right"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels[3]
        return rmnan(slip_angle(
            wheel_data.mLateralGroundVel,
            wheel_data.mLongitudinalGroundVel))

    def ride_height(self, index: int | None = None) -> tuple[float, ...]:
        """Ride height (convert meters to millimeters)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mRideHeight) * 1000,
            rmnan(wheel_data[1].mRideHeight) * 1000,
            rmnan(wheel_data[2].mRideHeight) * 1000,
            rmnan(wheel_data[3].mRideHeight) * 1000,
        )

    def third_spring_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Third spring deflection front & rear (convert meters to millimeters)"""
        wheel_data = self.shmm.lmuTeleVeh(index)
        front = rmnan(wheel_data.mFront3rdDeflection) * 1000
        rear = rmnan(wheel_data.mRear3rdDeflection) * 1000
        return (front, front, rear, rear)

    def suspension_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension deflection (convert meters to millimeters)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mSuspensionDeflection) * 1000,
            rmnan(wheel_data[1].mSuspensionDeflection) * 1000,
            rmnan(wheel_data[2].mSuspensionDeflection) * 1000,
            rmnan(wheel_data[3].mSuspensionDeflection) * 1000,
        )

    def suspension_force(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension force (Newtons)"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mSuspForce),
            rmnan(wheel_data[1].mSuspForce),
            rmnan(wheel_data[2].mSuspForce),
            rmnan(wheel_data[3].mSuspForce),
        )

    def suspension_damage(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension damage (fraction), 0.0 no damage, 1.0 totaled"""
        return self.rest.telemetry().suspensionDamage

    def position_vertical(self, index: int | None = None) -> tuple[float, ...]:
        """Vertical wheel position (convert meters to millimeters) related to vehicle"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mWheelYLocation) * 1000,
            rmnan(wheel_data[1].mWheelYLocation) * 1000,
            rmnan(wheel_data[2].mWheelYLocation) * 1000,
            rmnan(wheel_data[3].mWheelYLocation) * 1000,
        )

    def is_detached(self, index: int | None = None) -> tuple[bool, ...]:
        """Whether wheel is detached"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return (
            wheel_data[0].mDetached,
            wheel_data[1].mDetached,
            wheel_data[2].mDetached,
            wheel_data[3].mDetached,
        )

    def offroad(self, index: int | None = None) -> int:
        """Number of wheels currently off the road"""
        wheel_data = self.shmm.lmuTeleVeh(index).mWheels
        return sum(2 <= data.mSurfaceType <= 4 for data in wheel_data)

```

# File: tinypedal/adapter/restapi_connector.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
RestAPI module
"""

from __future__ import annotations

import asyncio
import json
import logging
import threading
from itertools import chain
from typing import Any, NamedTuple

from .. import realtime_state
from ..async_request import http_get, set_header_get
from ..const_common import TYPE_JSON
from .rf2_restapi import ResRawOutput, RestAPIData

logger = logging.getLogger(__name__)
json_decoder = json.JSONDecoder()


class HttpSetup(NamedTuple):
    """Http connection setup"""

    host: str
    port: int
    timeout: float
    retry: int
    retry_delay: float


class RestAPIInfo:
    """Rest API data output"""

    __slots__ = (
        "_taskset",
        "_dataset",
        "_cfg",
        "_task_cancel",
        "_updating",
        "_update_thread",
        "_active_interval",
        "_event",
    )

    def __init__(self, taskset: tuple, dataset: RestAPIData):
        self._taskset = taskset
        self._dataset = dataset

        self._cfg: dict = None
        self._task_cancel = False
        self._updating = False
        self._update_thread = None
        self._active_interval = 0.2
        self._event = threading.Event()

    def telemetry(self) -> RestAPIData:
        """Rest API telemetry data"""
        return self._dataset

    def __del__(self):
        logger.info("RestAPI: GC: RestAPIInfo")

    def setConnection(self, config: dict):
        """Update connection config"""
        self._cfg = config
        self._active_interval = max(self._cfg["restapi_update_interval"], 100) / 1000

    def start(self):
        """Start update thread"""
        if not self._updating and self._cfg["enable_restapi_access"]:
            self._updating = True
            self._event.clear()
            self._update_thread = threading.Thread(target=self.__update, daemon=True)
            self._update_thread.start()
            logger.info("RestAPI: UPDATING: thread started")

    def stop(self):
        """Stop update thread"""
        if self._updating:
            self._event.set()
            if self._update_thread is not None:
                self._update_thread.join()
            self._updating = False
            logger.info("RestAPI: UPDATING: thread stopped")

    def __update(self):
        """Update Rest API data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = 0.5

        active_task_sim = {}

        while not _event_wait(update_interval):
            if realtime_state.active:

                # Also check task cancel state in case delay
                if not reset or self._task_cancel:
                    reset = True
                    update_interval = self._active_interval
                    self._task_cancel = False
                    self.run_tasks(active_task_sim)

            else:
                if reset:
                    reset = False
                    update_interval = 0.5

        # Reset to default on close
        reset_to_default(self._dataset, active_task_sim)

    def run_tasks(self, active_task_sim: dict):
        """Run tasks"""
        logger.info("RestAPI: CONNECTING")
        # Load http connection setting
        sim_http = HttpSetup(
            host=self._cfg["url_host"],
            port=self._cfg["url_port"],
            timeout=min(max(self._cfg["connection_timeout"], 0.5), 10),
            retry=min(max(int(self._cfg["connection_retry"]), 0), 10),
            retry_delay=min(max(self._cfg["connection_retry_delay"], 0), 60),
        )
        # Run all tasks while on track, this blocks until tasks cancelled
        logger.info("RestAPI: all tasks started")
        asyncio.run(self.task_init(self.sort_taskset(sim_http, active_task_sim, self._taskset)))
        logger.info("RestAPI: all tasks stopped")
        # Reset when finished
        reset_to_default(self._dataset, active_task_sim)

    def sort_taskset(self, http: HttpSetup, active_task: dict, taskset: tuple):
        """Sort task set into dictionary, key - uri_path, value - output_set"""
        for uri_path, output_set, condition, is_repeat, min_interval in taskset:
            if self._cfg.get(condition, True):
                active_task[uri_path] = output_set
                update_interval = max(min_interval, self._active_interval)
                yield asyncio.create_task(
                    self.fetch(http, uri_path, output_set, is_repeat, update_interval)
                )

    async def task_init(self, *task_generator):
        """Run repeatedly updating task"""
        task_group = tuple(chain(*task_generator))
        # Task control
        await asyncio.create_task(self.task_control(task_group))
        # Start task
        for task in task_group:
            try:
                await task
            except (asyncio.CancelledError, BaseException):
                pass

    async def task_control(self, task_group: tuple[asyncio.Task, ...]):
        """Control task running state"""
        _event_is_set = self._event.is_set
        while not _event_is_set() and realtime_state.active:
            await asyncio.sleep(0.1)  # check every 100ms
        # Set cancel state to exit loop in case failed to cancel
        self._task_cancel = True
        # Cancel all running tasks
        for task in task_group:
            task.cancel()

    async def fetch(
        self, http: HttpSetup, uri_path: str, output_set: tuple[ResRawOutput, ...],
        repeat: bool = False, min_interval: float = 0.01):
        """Fetch data and verify"""
        data_available = await self.update_once(http, uri_path, output_set)
        if not data_available:
            logger.info("RestAPI: MISSING: %s", uri_path)
        elif not repeat:
            logger.info("RestAPI: ACTIVE: %s (one time)", uri_path)
        else:
            logger.info("RestAPI: ACTIVE: %s (%sms)", uri_path, int(min_interval * 1000))
            await self.update_repeat(http, uri_path, output_set, min_interval)

    async def update_once(
        self, http: HttpSetup, uri_path: str, output_set: tuple[ResRawOutput, ...]) -> bool:
        """Update once and verify"""
        request_header = set_header_get(uri_path, http.host)
        data_available = False
        total_retry = retry = http.retry
        while not self._task_cancel and retry >= 0:
            resource_output = await get_resource(request_header, http)
            # Verify & retry
            if not isinstance(resource_output, TYPE_JSON):
                logger.info("RestAPI: %s: %s (%s/%s retries left)",
                    resource_output, uri_path, retry, total_retry)
                retry -= 1
                if retry < 0:
                    data_available = False
                    break
                await asyncio.sleep(http.retry_delay)
                continue
            # Output
            for res in output_set:
                if res.update(self._dataset, resource_output):
                    data_available = True
            break
        return data_available

    async def update_repeat(
        self, http: HttpSetup, uri_path: str, output_set: tuple[ResRawOutput, ...], min_interval: float):
        """Update repeat"""
        request_header = set_header_get(uri_path, http.host)
        interval = min_interval
        last_hash = new_hash = -1
        while not self._task_cancel:  # use task control to cancel & exit loop
            new_hash = await output_resource(self._dataset, request_header, http, output_set, last_hash)
            if last_hash != new_hash:
                last_hash = new_hash
                interval = min_interval
            elif interval < 5:  # increase update interval while no new data
                interval += interval / 2
                if interval > 5:
                    interval = 5
            await asyncio.sleep(interval)


def reset_to_default(dataset: RestAPIData, active_task: dict[str, tuple[ResRawOutput, ...]]):
    """Reset active task data to default"""
    if active_task:
        for uri_path, output_set in active_task.items():
            for res in output_set:
                res.reset(dataset)
            logger.info("RestAPI: RESET: %s", uri_path)
        active_task.clear()


async def get_resource(request: bytes, http: HttpSetup) -> Any | str:
    """Get resource from REST API"""
    try:
        async with http_get(request, http.host, http.port, http.timeout) as raw_bytes:
            return json_decoder.decode(raw_bytes.decode())
    except (AttributeError, TypeError, IndexError, KeyError, ValueError,
            OSError, TimeoutError, BaseException):
        return "INVALID"


async def output_resource(
    dataset: RestAPIData, request: bytes, http: HttpSetup, output_set: tuple[ResRawOutput, ...], last_hash: int) -> int:
    """Get resource from REST API and output data, skip unnecessary checking"""
    try:
        async with http_get(request, http.host, http.port, http.timeout) as raw_bytes:
            new_hash = hash(raw_bytes)
            if last_hash != new_hash:
                resource_output = json_decoder.decode(raw_bytes.decode())
                for res in output_set:
                    res.update(dataset, resource_output)
            return new_hash
    except (AttributeError, TypeError, IndexError, KeyError, ValueError,
            OSError, TimeoutError, BaseException):
        return last_hash

```

# File: tinypedal/adapter/rf2_connector.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
rF2 API connector
"""

from __future__ import annotations

import ctypes
import logging
import threading
from time import monotonic, sleep
from typing import TYPE_CHECKING, Sequence

if __name__ == "__main__":  # local import check
    import sys
    sys.path.append(".")

if TYPE_CHECKING:  # for type checker only
    from pyRfactor2SharedMemory import rF2Type as rF2data
else:  # run time only
    from pyRfactor2SharedMemory import rF2data

from pyRfactor2SharedMemory.rF2MMap import (
    INVALID_INDEX,
    MAX_VEHICLES,
    MMapControl,
    rFactor2Constants,
)

logger = logging.getLogger(__name__)


def copy_struct(struct_data):
    """Allow to copy ctypes struct data with __slots__"""
    return type(struct_data).from_buffer_copy(
        ctypes.string_at(
            ctypes.byref(struct_data),
            ctypes.sizeof(struct_data),
        )
    )


def local_scoring_index(scor_veh: Sequence[rF2data.rF2VehicleScoring]) -> int:
    """Find local player scoring index

    Args:
        scor_veh: scoring mVehicles array.
    """
    for scor_idx, veh_info in enumerate(scor_veh):
        if veh_info.mIsPlayer:
            return scor_idx
    return INVALID_INDEX


class MMapDataSet:
    """Create mmap data set"""

    __slots__ = (
        "scor",
        "tele",
        "ext",
        "ffb",
    )

    def __init__(self) -> None:
        self.scor = MMapControl(rFactor2Constants.MM_SCORING_FILE_NAME, rF2data.rF2Scoring)
        self.tele = MMapControl(rFactor2Constants.MM_TELEMETRY_FILE_NAME, rF2data.rF2Telemetry)
        self.ext = MMapControl(rFactor2Constants.MM_EXTENDED_FILE_NAME, rF2data.rF2Extended)
        self.ffb = MMapControl(rFactor2Constants.MM_FORCE_FEEDBACK_FILE_NAME, rF2data.rF2ForceFeedback)

    def __del__(self):
        logger.info("sharedmemory: GC: MMapDataSet")

    def create_mmap(self, access_mode: int, rf2_pid: str) -> None:
        """Create mmap instance

        Args:
            access_mode: 0 = copy access, 1 = direct access.
            rf2_pid: rF2 Process ID for accessing server data.
        """
        self.scor.create(access_mode, rf2_pid)
        self.tele.create(access_mode, rf2_pid)
        self.ext.create(1, rf2_pid)
        self.ffb.create(1, rf2_pid)

    def close_mmap(self) -> None:
        """Close mmap instance"""
        self.scor.close()
        self.tele.close()
        self.ext.close()
        self.ffb.close()

    def update_mmap(self) -> None:
        """Update mmap data"""
        self.scor.update()
        self.tele.update()


class SyncData:
    """Synchronize data with player ID

    Attributes:
        dataset: mmap data set.
        paused: Data update state (boolean).
        override_player_index: Player index override state (boolean).
        player_scor_index: Local player scoring index.
        player_scor: Local player scoring data.
        player_tele: Local player telemetry data.
    """

    __slots__ = (
        "_updating",
        "_update_thread",
        "_event",
        "_tele_indexes",
        "paused",
        "override_player_index",
        "player_scor_index",
        "player_scor",
        "player_tele",
        "dataset",
    )

    def __init__(self) -> None:
        self._updating = False
        self._update_thread = None
        self._event = threading.Event()
        self._tele_indexes = {_index: _index for _index in range(128)}

        self.paused = False
        self.override_player_index = False
        self.player_scor_index = INVALID_INDEX
        self.player_scor = None
        self.player_tele = None
        self.dataset = MMapDataSet()

    def __del__(self):
        logger.info("sharedmemory: GC: SyncData")

    def __sync_player_scor(self, scor_index: int = INVALID_INDEX) -> None:
        """Sync local player vehicle scoring data"""
        self.player_scor = self.dataset.scor.data.mVehicles[scor_index]

    def __sync_player_tele(self, tele_index: int = INVALID_INDEX) -> None:
        """Sync local player vehicle telemetry data"""
        self.player_tele = self.dataset.tele.data.mVehicles[tele_index]

    def __sync_player_data(self) -> bool:
        """Sync local player data

        Returns:
            False, if no valid player scoring index found.
            True, set player data.
        """
        if not self.override_player_index:
            # Update scoring index
            scor_idx = local_scoring_index(self.dataset.scor.data.mVehicles)
            if scor_idx == INVALID_INDEX:
                return False  # index not found, not synced
            self.player_scor_index = scor_idx
        # Set player data
        self.__sync_player_scor(self.player_scor_index)
        self.__sync_player_tele(self.sync_tele_index(self.player_scor_index))
        return True  # found index, synced

    @staticmethod
    def __update_tele_indexes(tele_data: rF2data.rF2Telemetry, tele_indexes: dict) -> None:
        """Update telemetry player index dictionary for quick reference

        Telemetry index can be different from scoring index.
        Use mID matching to match telemetry index.

        Args:
            tele_data: Telemetry data.
            tele_indexes: Telemetry mID:index reference dictionary.
        """
        for tele_idx, veh_info in zip(range(tele_data.mNumVehicles), tele_data.mVehicles):
            tele_indexes[veh_info.mID] = tele_idx

    def sync_tele_index(self, scor_idx: int) -> int:
        """Sync telemetry index

        Use scoring index to find scoring mID,
        then match with telemetry mID in reference dictionary
        to find telemetry index.

        Args:
            scor_idx: Player scoring index.

        Returns:
            Player telemetry index.
        """
        return self._tele_indexes.get(
            self.dataset.scor.data.mVehicles[scor_idx].mID, INVALID_INDEX)

    def start(self, access_mode: int, rf2_pid: str) -> None:
        """Update & sync mmap data copy in separate thread

        Args:
            access_mode: 0 = copy access, 1 = direct access.
            rf2_pid: rF2 Process ID for accessing server data.
        """
        if self._updating:
            logger.warning("sharedmemory: UPDATING: already started")
        else:
            self._updating = True
            # Initialize mmap data
            self.dataset.create_mmap(access_mode, rf2_pid)
            self.__update_tele_indexes(self.dataset.tele.data, self._tele_indexes)
            if not self.__sync_player_data():
                self.__sync_player_scor()
                self.__sync_player_tele()
            # Setup updating thread
            self._event.clear()
            self._update_thread = threading.Thread(target=self.__update, daemon=True)
            self._update_thread.start()
            logger.info("sharedmemory: UPDATING: thread started")
            logger.info("sharedmemory: player index override: %s", self.override_player_index)
            logger.info("sharedmemory: server process ID: %s", rf2_pid if rf2_pid else "DISABLED")

    def stop(self) -> None:
        """Join and stop updating thread, close mmap"""
        if self._updating:
            self._event.set()
            self._updating = False
            self._update_thread.join()
            # Make final copy before close, otherwise mmap won't close if using direct access
            self.player_scor = copy_struct(self.player_scor)
            self.player_tele = copy_struct(self.player_tele)
            self.dataset.close_mmap()
        else:
            logger.warning("sharedmemory: UPDATING: already stopped")

    def __update(self) -> None:
        """Update synced player data"""
        self.paused = False  # make sure initial pause state is false
        _event_wait = self._event.wait
        freezed_version = 0  # store freezed update version number
        last_version_update = 0  # store last update version number
        last_update_time = 0.0
        data_freezed = True  # whether data is freezed
        reset_counter = 0
        update_delay = 0.5  # longer delay while inactive

        while not _event_wait(update_delay):
            self.dataset.update_mmap()
            self.__update_tele_indexes(self.dataset.tele.data, self._tele_indexes)
            # Update player data & index
            if not data_freezed:
                # Get player data
                data_synced = self.__sync_player_data()
                # Pause if local player index no longer exists, 5 tries
                if data_synced:
                    reset_counter = 0
                    self.paused = False
                elif reset_counter < 6:
                    reset_counter += 1
                    if reset_counter == 5:
                        self.player_scor_index = INVALID_INDEX
                        self.__sync_player_scor()
                        self.__sync_player_tele()
                        self.paused = True
                        logger.info("sharedmemory: UPDATING: player data paused")

            version_update = self.dataset.scor.data.mVersionUpdateEnd
            if last_version_update != version_update:
                last_version_update = version_update
                last_update_time = monotonic()

            if data_freezed:
                # Check while IN freeze state
                if freezed_version != last_version_update:
                    update_delay = 0.01
                    self.paused = data_freezed = False
                    logger.info(
                        "sharedmemory: UPDATING: resumed, data version %s",
                        last_version_update,
                    )
            # Check while NOT IN freeze state
            # Set freeze state if data stopped updating after 2s
            elif monotonic() - last_update_time > 2:
                update_delay = 0.5
                self.paused = data_freezed = True
                freezed_version = last_version_update
                logger.info(
                    "sharedmemory: UPDATING: paused, data version %s",
                    freezed_version,
                )

        logger.info("sharedmemory: UPDATING: thread stopped")


class RF2Info:
    """RF2 shared memory data output"""

    __slots__ = (
        "_sync",
        "_access_mode",
        "_rf2_pid",
        "_state_override",
        "_active_state",
        "_scor",
        "_tele",
        "_ext",
        "_ffb",
    )

    def __init__(self) -> None:
        self._sync = SyncData()
        self._access_mode = 0
        self._rf2_pid = ""
        self._state_override = False
        self._active_state = False
        # Assign mmap instance
        self._scor = self._sync.dataset.scor
        self._tele = self._sync.dataset.tele
        self._ext = self._sync.dataset.ext
        self._ffb = self._sync.dataset.ffb

    def __del__(self):
        logger.info("sharedmemory: GC: RF2Info")

    def start(self) -> None:
        """Start data updating thread"""
        self._sync.start(self._access_mode, self._rf2_pid)

    def stop(self) -> None:
        """Stop data updating thread"""
        self._sync.stop()

    def setPID(self, pid: str = "") -> None:
        """Set rF2 process ID for connecting to server data"""
        self._rf2_pid = str(pid)

    def setMode(self, mode: int = 0) -> None:
        """Set rF2 mmap access mode

        Args:
            mode: 0 = copy access, 1 = direct access
        """
        self._access_mode = mode

    def setStateOverride(self, state: bool = False) -> None:
        """Enable state override"""
        self._state_override = state

    def setActiveState(self, state: bool = False) -> None:
        """Set state override"""
        self._active_state = state

    def setPlayerOverride(self, state: bool = False) -> None:
        """Enable player index override state"""
        self._sync.override_player_index = state

    def setPlayerIndex(self, index: int = INVALID_INDEX) -> None:
        """Manual override player index"""
        self._sync.player_scor_index = min(max(index, INVALID_INDEX), MAX_VEHICLES - 1)

    @property
    def rf2ScorInfo(self) -> rF2data.rF2ScoringInfo:
        """rF2 scoring info data"""
        return self._scor.data.mScoringInfo

    def rf2ScorVeh(self, index: int | None = None) -> rF2data.rF2VehicleScoring:
        """rF2 scoring vehicle data

        Specify index for specific player.

        Args:
            index: None for local player.
        """
        if index is None:
            return self._sync.player_scor
        return self._scor.data.mVehicles[index]

    def rf2TeleVeh(self, index: int | None = None) -> rF2data.rF2VehicleTelemetry:
        """rF2 telemetry vehicle data

        Specify index for specific player.

        Args:
            index: None for local player.
        """
        if index is None:
            return self._sync.player_tele
        return self._tele.data.mVehicles[self._sync.sync_tele_index(index)]

    @property
    def rf2Ext(self) -> rF2data.rF2Extended:
        """rF2 extended data"""
        return self._ext.data

    @property
    def rf2Ffb(self) -> rF2data.rF2ForceFeedback:
        """rF2 force feedback data"""
        return self._ffb.data

    @property
    def playerIndex(self) -> int:
        """Local player's scoring index"""
        return self._sync.player_scor_index

    @property
    def isPaused(self) -> bool:
        """Check whether data stopped updating"""
        return self._sync.paused or self._sync.player_scor_index < 0

    @property
    def isActive(self) -> bool:
        """Check whether in active (driving or overriding) state"""
        if self._state_override:
            return self._active_state
        return not self._sync.paused and self._sync.player_scor_index >= 0 and (
            self.rf2ScorInfo.mInRealtime
            or self.rf2TeleVeh().mIgnitionStarter > 0
        )


def test_api():
    """API test run"""
    # Add logger
    test_handler = logging.StreamHandler()
    logger.setLevel(logging.INFO)
    logger.addHandler(test_handler)

    # Test run
    SEPARATOR = "=" * 50
    print("Test API - Start")
    info = RF2Info()
    info.setMode(1)  # set direct access
    info.setPID("")
    info.setPlayerOverride(True)  # enable player override
    info.setPlayerIndex(0)  # set player index to 0
    info.start()
    sleep(0.2)

    print(SEPARATOR)
    print("Test API - Restart")
    info.stop()
    info.setMode()  # set copy access
    info.setPlayerOverride()  # disable player override
    info.start()

    print(SEPARATOR)
    print("Test API - Read")
    version = info.rf2Ext.mVersion.decode()
    driver = info.rf2ScorVeh(0).mDriverName.decode()
    track = info.rf2ScorInfo.mTrackName.decode()
    print(f"version: {version if version else 'not running'}")
    print(f"driver name   : {driver if version else 'not running'}")
    print(f"track name    : {track if version else 'not running'}")

    print(SEPARATOR)
    print("Test API - Close")
    info.stop()


if __name__ == "__main__":
    test_api()

```

# File: tinypedal/adapter/rf2_reader.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
rF2 API data reader

Notes:
    Convert all temperature (kelvin) to Celsius before output.
"""

from __future__ import annotations

from ..calculation import (
    clock_time_scale_sync,
    lap_progress_distance,
    mean,
    min_nonzero,
    oriyaw2rad,
    slip_angle,
    vel2speed,
)
from ..const_common import MAX_SECONDS, STINT_USAGE_DEFAULT
from ..formatter import strip_invalid_char
from ..process.weather import WeatherNode
from ..validator import bytes_to_str as tostr
from ..validator import infnan_to_zero as rmnan
from . import _reader, restapi_connector, rf2_connector


class DataAdapter:
    """Read & sort data into groups"""

    __slots__ = (
        "shmm",
        "rest",
    )

    def __init__(self, shmm: rf2_connector.RF2Info, rest: restapi_connector.RestAPIInfo) -> None:
        """Initialize API setting

        Args:
            shmm: shared memory API connector.
            rest: rest API connector.
        """
        self.shmm = shmm
        self.rest = rest


class State(_reader.State, DataAdapter):
    """State"""

    __slots__ = ()

    def active(self) -> bool:
        """Is active (driving or overriding)"""
        return self.shmm.isActive

    def paused(self) -> bool:
        """Is paused"""
        return self.shmm.isPaused

    def desynced(self, index: int | None = None) -> bool:
        """Is player data desynced from others"""
        return (
            abs(self.shmm.rf2TeleVeh().mElapsedTime
            - self.shmm.rf2TeleVeh(index).mElapsedTime)
            >= 0.01
        )

    def version(self) -> str:
        """Identify API version"""
        version = tostr(self.shmm.rf2Ext.mVersion)
        return version if version else "unknown"


class Brake(_reader.Brake, DataAdapter):
    """Brake"""

    __slots__ = ()

    def bias_front(self, index: int | None = None) -> float:
        """Brake bias front (fraction)"""
        return 1 - rmnan(self.shmm.rf2TeleVeh(index).mRearBrakeBias)

    def pressure(self, index: int | None = None, scale: float = 1) -> tuple[float, ...]:
        """Brake pressure (fraction)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mBrakePressure) * scale,
            rmnan(wheel_data[1].mBrakePressure) * scale,
            rmnan(wheel_data[2].mBrakePressure) * scale,
            rmnan(wheel_data[3].mBrakePressure) * scale,
        )

    def temperature(self, index: int | None = None) -> tuple[float, ...]:
        """Brake temperature (Celsius)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mBrakeTemp) - 273.15,
            rmnan(wheel_data[1].mBrakeTemp) - 273.15,
            rmnan(wheel_data[2].mBrakeTemp) - 273.15,
            rmnan(wheel_data[3].mBrakeTemp) - 273.15,
        )

    def wear(self, index: int | None = None) -> tuple[float, ...]:
        """Brake remaining thickness (meters)"""
        return self.rest.telemetry().brakeWear


class ElectricMotor(_reader.ElectricMotor, DataAdapter):
    """Electric motor"""

    __slots__ = ()

    def state(self, index: int | None = None) -> int:
        """Motor state, 0 = n/a, 1 = off, 2 = drain, 3 = regen"""
        state = self.shmm.rf2TeleVeh(index).mElectricBoostMotorState
        if state == 0:
            return 0
        if state == 1:
            return 1
        if state == 2:
            return 2
        if state == 3:
            return 3
        return 0

    def battery_charge(self, index: int | None = None) -> float:
        """Battery charge (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mBatteryChargeFraction)

    def rpm(self, index: int | None = None) -> float:
        """Motor RPM (rev per minute)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mElectricBoostMotorRPM)

    def torque(self, index: int | None = None) -> float:
        """Motor torque (Nm)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mElectricBoostMotorTorque)

    def motor_temperature(self, index: int | None = None) -> float:
        """Motor temperature (Celsius)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mElectricBoostMotorTemperature)

    def water_temperature(self, index: int | None = None) -> float:
        """Motor water temperature (Celsius)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mElectricBoostWaterTemperature)


class Engine(_reader.Engine, DataAdapter):
    """Engine"""

    __slots__ = ()

    def gear(self, index: int | None = None) -> int:
        """Gear"""
        return self.shmm.rf2TeleVeh(index).mGear

    def gear_max(self, index: int | None = None) -> int:
        """Max gear"""
        return self.shmm.rf2TeleVeh(index).mMaxGears

    def rpm(self, index: int | None = None) -> float:
        """RPM (rev per minute)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mEngineRPM)

    def rpm_max(self, index: int | None = None) -> float:
        """Max RPM (rev per minute)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mEngineMaxRPM)

    def torque(self, index: int | None = None) -> float:
        """Torque (Nm)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mEngineTorque)

    def turbo(self, index: int | None = None) -> float:
        """Turbo pressure (Pa)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mTurboBoostPressure)

    def oil_temperature(self, index: int | None = None) -> float:
        """Oil temperature (Celsius)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mEngineOilTemp)

    def water_temperature(self, index: int | None = None) -> float:
        """Water temperature (Celsius)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mEngineWaterTemp)


class Inputs(_reader.Inputs, DataAdapter):
    """Inputs"""

    __slots__ = ()

    def throttle(self, index: int | None = None) -> float:
        """Throttle filtered (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mFilteredThrottle)

    def throttle_raw(self, index: int | None = None) -> float:
        """Throttle raw (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mUnfilteredThrottle)

    def brake(self, index: int | None = None) -> float:
        """Brake filtered (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mFilteredBrake)

    def brake_raw(self, index: int | None = None) -> float:
        """Brake raw (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mUnfilteredBrake)

    def clutch(self, index: int | None = None) -> float:
        """Clutch filtered (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mFilteredClutch)

    def clutch_raw(self, index: int | None = None) -> float:
        """Clutch raw (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mUnfilteredClutch)

    def steering(self, index: int | None = None) -> float:
        """Steering filtered (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mFilteredSteering)

    def steering_raw(self, index: int | None = None) -> float:
        """Steering raw (fraction)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mUnfilteredSteering)

    def steering_shaft_torque(self, index: int | None = None) -> float:
        """Steering shaft torque (Nm)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mSteeringShaftTorque)

    def steering_range_physical(self, index: int | None = None) -> float:
        """Steering physical rotation range (degrees)"""
        rot_range = rmnan(self.shmm.rf2TeleVeh(index).mPhysicalSteeringWheelRange)
        if rot_range <= 0:
            rot_range = self.rest.telemetry().steeringWheelRange
        return rot_range

    def steering_range_visual(self, index: int | None = None) -> float:
        """Steering visual rotation range (degrees)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mVisualSteeringWheelRange)

    def force_feedback(self) -> float:
        """Steering force feedback (fraction)"""
        return rmnan(self.shmm.rf2Ffb.mForceValue)


class Lap(_reader.Lap, DataAdapter):
    """Lap"""

    __slots__ = ()

    def number(self, index: int | None = None) -> int:
        """Current lap number"""
        return self.shmm.rf2TeleVeh(index).mLapNumber

    def completed_laps(self, index: int | None = None) -> int:
        """Total completed laps"""
        return self.shmm.rf2ScorVeh(index).mTotalLaps

    def track_length(self) -> float:
        """Full lap or track length (meters)"""
        return rmnan(self.shmm.rf2ScorInfo.mLapDist)

    def distance(self, index: int | None = None) -> float:
        """Distance into lap (meters)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mLapDist)

    def progress(self, index: int | None = None) -> float:
        """Lap progress (fraction), distance into lap"""
        return rmnan(lap_progress_distance(
            self.shmm.rf2ScorVeh(index).mLapDist,
            self.shmm.rf2ScorInfo.mLapDist))

    def maximum(self) -> int:
        """Maximum lap"""
        return self.shmm.rf2ScorInfo.mMaxLaps

    def sector_index(self, index: int | None = None) -> int:
        """Sector index, 0 = S1, 1 = S2, 2 = S3"""
        # RF2 sector index 0 = S3, index 1 = S1, index 2 = S2
        sector = self.shmm.rf2ScorVeh(index).mSector
        if sector == 0:
            return 2
        if sector == 1:
            return 0
        return 1

    def behind_leader(self, index: int | None = None) -> int:
        """Laps behind leader"""
        return self.shmm.rf2ScorVeh(index).mLapsBehindLeader

    def behind_next(self, index: int | None = None) -> int:
        """Laps behind next place"""
        return self.shmm.rf2ScorVeh(index).mLapsBehindNext


class Session(_reader.Session, DataAdapter):
    """Session"""

    __slots__ = ()

    def combo_name(self) -> str:
        """Track & vehicle combo name, strip off invalid char"""
        track_name = tostr(self.shmm.rf2ScorInfo.mTrackName)
        class_name = tostr(self.shmm.rf2ScorVeh().mVehicleClass)
        return strip_invalid_char(f"{track_name} - {class_name}")

    def track_name(self) -> str:
        """Track name, strip off invalid char"""
        return strip_invalid_char(tostr(self.shmm.rf2ScorInfo.mTrackName))

    def identifier(self) -> tuple[int, int, int]:
        """Identify session"""
        session_length = rmnan(self.shmm.rf2ScorInfo.mEndET)
        session_type = self.shmm.rf2ScorInfo.mSession
        session_stamp = int(session_length * 100 + session_type)
        session_etime = int(rmnan(self.shmm.rf2ScorInfo.mCurrentET))
        session_tlaps = self.shmm.rf2ScorVeh().mTotalLaps
        return session_stamp, session_etime, session_tlaps

    def elapsed(self) -> float:
        """Session elapsed time (seconds)"""
        return rmnan(self.shmm.rf2ScorInfo.mCurrentET)

    def start(self) -> float:
        """Session start time (seconds)"""
        return rmnan(self.shmm.rf2ScorInfo.mStartET)

    def end(self) -> float:
        """Session end time (seconds)"""
        return rmnan(self.shmm.rf2ScorInfo.mEndET)

    def remaining(self) -> float:
        """Session time remaining (seconds)"""
        scor = self.shmm.rf2ScorInfo
        return rmnan(scor.mEndET - scor.mCurrentET)

    def session_type(self) -> int:
        """Session type, 0 = TESTDAY, 1 = PRACTICE, 2 = QUALIFY, 3 = WARMUP, 4 = RACE"""
        session = self.shmm.rf2ScorInfo.mSession
        if session >= 10:  # race
            return 4
        if session == 9:  # warmup
            return 3
        if session >= 5:  # qualify
            return 2
        if session >= 1:  # practice
            return 1
        return 0  # test day

    def lap_type(self) -> bool:
        """Is lap type session, false for time type"""
        return self.shmm.rf2ScorInfo.mMaxLaps < 99999

    def in_race(self) -> bool:
        """Is in race session"""
        return self.shmm.rf2ScorInfo.mSession > 9

    def private_qualifying(self) -> bool:
        """Is private qualifying"""
        return self.rest.telemetry().privateQualifying == 1

    def in_countdown(self) -> bool:
        """Is in countdown phase before race"""
        return self.shmm.rf2ScorInfo.mGamePhase == 4

    def in_formation(self) -> bool:
        """Is in formation phase before race"""
        return self.shmm.rf2ScorInfo.mGamePhase == 3

    def pit_open(self) -> bool:
        """Is pit lane open"""
        return self.shmm.rf2ScorInfo.mGamePhase > 0

    def pre_race(self) -> bool:
        """Before race starts (green flag)"""
        return self.shmm.rf2ScorInfo.mGamePhase <= 4

    def green_flag(self) -> bool:
        """Green flag (race starts)"""
        # Inaccurate due to 5FPS refresh rate from API
        return self.shmm.rf2ScorInfo.mGamePhase == 5

    def blue_flag(self, index: int | None = None) -> bool:
        """Is under blue flag"""
        return self.shmm.rf2ScorVeh(index).mFlag == 6

    def yellow_flag(self) -> bool:
        """Is there yellow flag in any sectors"""
        sec_flag = self.shmm.rf2ScorInfo.mSectorFlag
        return any(data == 1 for data in sec_flag)

    def start_lights(self) -> int:
        """Start lights countdown sequence"""
        scor = self.shmm.rf2ScorInfo
        return scor.mNumRedLights - scor.mStartLight + 1

    def track_temperature(self) -> float:
        """Track temperature (Celsius)"""
        return rmnan(self.shmm.rf2ScorInfo.mTrackTemp)

    def ambient_temperature(self) -> float:
        """Ambient temperature (Celsius)"""
        return rmnan(self.shmm.rf2ScorInfo.mAmbientTemp)

    def raininess(self) -> float:
        """Rain severity (fraction)"""
        return rmnan(self.shmm.rf2ScorInfo.mRaining)

    def wetness_minimum(self) -> float:
        """Road minimum wetness (fraction)"""
        return rmnan(self.shmm.rf2ScorInfo.mMinPathWetness)

    def wetness_maximum(self) -> float:
        """Road maximum wetness (fraction)"""
        return rmnan(self.shmm.rf2ScorInfo.mMaxPathWetness)

    def wetness_average(self) -> float:
        """Road average wetness (fraction)"""
        return rmnan(self.shmm.rf2ScorInfo.mAvgPathWetness)

    def wetness(self) -> tuple[float, float, float]:
        """Road wetness set (fraction)"""
        scor = self.shmm.rf2ScorInfo
        return (rmnan(scor.mMinPathWetness),
                rmnan(scor.mMaxPathWetness),
                rmnan(scor.mAvgPathWetness))

    def weather_forecast(self) -> tuple[WeatherNode, ...]:
        """Weather forecast nodes"""
        session_type = self.session_type()
        if session_type <= 1:  # practice session
            return self.rest.telemetry().forecastPractice
        if session_type == 2:  # qualify session
            return self.rest.telemetry().forecastQualify
        return self.rest.telemetry().forecastRace  # race session

    def time_scale(self) -> int:
        """Time scale"""
        track_time = self.rest.telemetry().trackClockTime
        if track_time == -1:  # trackClockTime unavailable
            time_scale = max(self.rest.telemetry().timeScale, 0)
        else:  # sync time scale
            time_scale = clock_time_scale_sync(track_time, self.elapsed(), self.start())
        return time_scale


class Switch(_reader.Switch, DataAdapter):
    """Switch"""

    __slots__ = ()

    def headlights(self, index: int | None = None) -> int:
        """Headlights"""
        return self.shmm.rf2TeleVeh(index).mHeadlights

    def ignition_starter(self, index: int | None = None) -> int:
        """Ignition"""
        return self.shmm.rf2TeleVeh(index).mIgnitionStarter

    def speed_limiter(self, index: int | None = None) -> int:
        """Speed limiter"""
        return self.shmm.rf2TeleVeh(index).mSpeedLimiter

    def drs_status(self, index: int | None = None) -> int:
        """DRS status, 0 not_available, 1 available, 2 allowed(not activated), 3 activated"""
        tele_veh = self.shmm.rf2TeleVeh(index)
        status = tele_veh.mRearFlapLegalStatus
        if status == 1:
            return 1  # available
        if status == 2:
            if tele_veh.mRearFlapActivated:
                return 3  # activated
            return 2  # allowed
        return 0  # not_available

    def auto_clutch(self) -> bool:
        """Auto clutch"""
        return bool(self.shmm.rf2Ext.mPhysics.mAutoClutch)


class Timing(_reader.Timing, DataAdapter):
    """Timing"""

    __slots__ = ()

    def start(self, index: int | None = None) -> float:
        """Current lap start time (seconds)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLapStartET)

    def elapsed(self, index: int | None = None) -> float:
        """Current lap elapsed time (seconds)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mElapsedTime)

    def current_laptime(self, index: int | None = None) -> float:
        """Current lap time (seconds)"""
        tele_veh = self.shmm.rf2TeleVeh(index)
        return rmnan(tele_veh.mElapsedTime - tele_veh.mLapStartET)

    def last_laptime(self, index: int | None = None) -> float:
        """Last lap time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mLastLapTime)

    def best_laptime(self, index: int | None = None) -> float:
        """Best lap time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mBestLapTime)

    def reference_laptime(self, index: int | None = None):
        """Reference lap time (seconds)"""
        init_time = min_nonzero((
            self.best_laptime(index),
            self.last_laptime(index),
            MAX_SECONDS,
        ))
        if 0 < init_time < MAX_SECONDS:
            return init_time
        # Set to estimated laptime only if other laptime not available
        # as estimated laptime can be faster than other laptime
        return min_nonzero((
            self.estimated_laptime(index),
            MAX_SECONDS,
        ))

    def estimated_laptime(self, index: int | None = None) -> float:
        """Estimated lap time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mEstimatedLapTime)

    def estimated_time_into(self, index: int | None = None) -> float:
        """Estimated time into lap (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mTimeIntoLap)

    def current_sector1(self, index: int | None = None) -> float:
        """Current lap sector 1 time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mCurSector1)

    def current_sector2(self, index: int | None = None) -> float:
        """Current lap sector 1+2 time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mCurSector2)

    def last_sector1(self, index: int | None = None) -> float:
        """Last lap sector 1 time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mLastSector1)

    def last_sector2(self, index: int | None = None) -> float:
        """Last lap sector 1+2 time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mLastSector2)

    def best_sector1(self, index: int | None = None) -> float:
        """Best lap sector 1 time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mBestSector1)

    def best_sector2(self, index: int | None = None) -> float:
        """Best lap sector 1+2 time (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mBestSector2)

    def behind_leader(self, index: int | None = None) -> float:
        """Time behind leader (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mTimeBehindLeader)

    def behind_next(self, index: int | None = None) -> float:
        """Time behind next place (seconds)"""
        return rmnan(self.shmm.rf2ScorVeh(index).mTimeBehindNext)


class Tyre(_reader.Tyre, DataAdapter):
    """Tyre"""

    __slots__ = ()

    def compound_front(self, index: int | None = None) -> int:
        """Tyre compound (front)"""
        return self.shmm.rf2TeleVeh(index).mFrontTireCompoundIndex

    def compound_rear(self, index: int | None = None) -> int:
        """Tyre compound (rear)"""
        return self.shmm.rf2TeleVeh(index).mRearTireCompoundIndex

    def compound(self, index: int | None = None) -> tuple[int, int]:
        """Tyre compound set (front, rear)"""
        tele_veh = self.shmm.rf2TeleVeh(index)
        return tele_veh.mFrontTireCompoundIndex, tele_veh.mRearTireCompoundIndex

    def compound_name_front(self, index: int | None = None) -> str:
        """Tyre compound name (front)"""
        return tostr(self.shmm.rf2TeleVeh(index).mFrontTireCompoundName)

    def compound_name_rear(self, index: int | None = None) -> str:
        """Tyre compound name (rear)"""
        return tostr(self.shmm.rf2TeleVeh(index).mRearTireCompoundName)

    def compound_name(self, index: int | None = None) -> tuple[str, str]:
        """Tyre compound name set (front, rear)"""
        tele_veh = self.shmm.rf2TeleVeh(index)
        return tostr(tele_veh.mFrontTireCompoundName), tostr(tele_veh.mRearTireCompoundName)

    def surface_temperature_avg(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre surface temperature set (Celsius) average"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(mean(wheel_data[0].mTemperature)) - 273.15,
            rmnan(mean(wheel_data[1].mTemperature)) - 273.15,
            rmnan(mean(wheel_data[2].mTemperature)) - 273.15,
            rmnan(mean(wheel_data[3].mTemperature)) - 273.15,
        )

    def surface_temperature_ico(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre surface temperature set (Celsius) inner,center,outer"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mTemperature[0]) - 273.15,
            rmnan(wheel_data[0].mTemperature[1]) - 273.15,
            rmnan(wheel_data[0].mTemperature[2]) - 273.15,
            rmnan(wheel_data[1].mTemperature[0]) - 273.15,
            rmnan(wheel_data[1].mTemperature[1]) - 273.15,
            rmnan(wheel_data[1].mTemperature[2]) - 273.15,
            rmnan(wheel_data[2].mTemperature[0]) - 273.15,
            rmnan(wheel_data[2].mTemperature[1]) - 273.15,
            rmnan(wheel_data[2].mTemperature[2]) - 273.15,
            rmnan(wheel_data[3].mTemperature[0]) - 273.15,
            rmnan(wheel_data[3].mTemperature[1]) - 273.15,
            rmnan(wheel_data[3].mTemperature[2]) - 273.15,
        )

    def inner_temperature_avg(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre inner temperature set (Celsius) average"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(mean(wheel_data[0].mTireInnerLayerTemperature)) - 273.15,
            rmnan(mean(wheel_data[1].mTireInnerLayerTemperature)) - 273.15,
            rmnan(mean(wheel_data[2].mTireInnerLayerTemperature)) - 273.15,
            rmnan(mean(wheel_data[3].mTireInnerLayerTemperature)) - 273.15,
        )

    def inner_temperature_ico(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre inner temperature set (Celsius) inner,center,outer"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mTireInnerLayerTemperature[0]) - 273.15,
            rmnan(wheel_data[0].mTireInnerLayerTemperature[1]) - 273.15,
            rmnan(wheel_data[0].mTireInnerLayerTemperature[2]) - 273.15,
            rmnan(wheel_data[1].mTireInnerLayerTemperature[0]) - 273.15,
            rmnan(wheel_data[1].mTireInnerLayerTemperature[1]) - 273.15,
            rmnan(wheel_data[1].mTireInnerLayerTemperature[2]) - 273.15,
            rmnan(wheel_data[2].mTireInnerLayerTemperature[0]) - 273.15,
            rmnan(wheel_data[2].mTireInnerLayerTemperature[1]) - 273.15,
            rmnan(wheel_data[2].mTireInnerLayerTemperature[2]) - 273.15,
            rmnan(wheel_data[3].mTireInnerLayerTemperature[0]) - 273.15,
            rmnan(wheel_data[3].mTireInnerLayerTemperature[1]) - 273.15,
            rmnan(wheel_data[3].mTireInnerLayerTemperature[2]) - 273.15,
        )

    def pressure(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre pressure (kPa)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mPressure),
            rmnan(wheel_data[1].mPressure),
            rmnan(wheel_data[2].mPressure),
            rmnan(wheel_data[3].mPressure),
        )

    def load(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre load (Newtons)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mTireLoad),
            rmnan(wheel_data[1].mTireLoad),
            rmnan(wheel_data[2].mTireLoad),
            rmnan(wheel_data[3].mTireLoad),
        )

    def wear(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre wear (fraction)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mWear),
            rmnan(wheel_data[1].mWear),
            rmnan(wheel_data[2].mWear),
            rmnan(wheel_data[3].mWear),
        )

    def carcass_temperature(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre carcass temperature (Celsius)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mTireCarcassTemperature) - 273.15,
            rmnan(wheel_data[1].mTireCarcassTemperature) - 273.15,
            rmnan(wheel_data[2].mTireCarcassTemperature) - 273.15,
            rmnan(wheel_data[3].mTireCarcassTemperature) - 273.15,
        )

    def vertical_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Tyre vertical deflection (millimeters)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mVerticalTireDeflection) * 1000,
            rmnan(wheel_data[1].mVerticalTireDeflection) * 1000,
            rmnan(wheel_data[2].mVerticalTireDeflection) * 1000,
            rmnan(wheel_data[3].mVerticalTireDeflection) * 1000,
        )


class Vehicle(_reader.Vehicle, DataAdapter):
    """Vehicle"""

    __slots__ = ()

    def is_player(self, index: int=0) -> bool:
        """Is local player"""
        return self.shmm.playerIndex == index

    def is_driving(self) -> bool:
        """Is local player driving or in monitor"""
        return self.shmm.rf2TeleVeh().mIgnitionStarter > 0

    def player_index(self) -> int:
        """Get Local player index"""
        return self.shmm.playerIndex

    def slot_id(self, index: int | None = None) -> int:
        """Vehicle slot id"""
        return self.shmm.rf2ScorVeh(index).mID

    def driver_name(self, index: int | None = None) -> str:
        """Driver name"""
        return tostr(self.shmm.rf2ScorVeh(index).mDriverName)

    def vehicle_name(self, index: int | None = None) -> str:
        """Vehicle name"""
        return tostr(self.shmm.rf2ScorVeh(index).mVehicleName)

    def class_name(self, index: int | None = None) -> str:
        """Vehicle class name"""
        return tostr(self.shmm.rf2ScorVeh(index).mVehicleClass)

    def same_class(self, index: int | None = None) -> bool:
        """Is same vehicle class"""
        return self.shmm.rf2ScorVeh(index).mVehicleClass == self.shmm.rf2ScorVeh().mVehicleClass

    def total_vehicles(self) -> int:
        """Total vehicles"""
        return self.shmm.rf2ScorInfo.mNumVehicles

    def place(self, index: int | None = None) -> int:
        """Vehicle overall place"""
        return self.shmm.rf2ScorVeh(index).mPlace

    def qualification(self, index: int | None = None) -> int:
        """Vehicle qualification place"""
        return self.shmm.rf2ScorVeh(index).mQualification

    def in_pits(self, index: int | None = None) -> bool:
        """Is in pits"""
        return self.shmm.rf2ScorVeh(index).mInPits

    def in_garage(self, index: int | None = None) -> bool:
        """Is in garage"""
        return self.shmm.rf2ScorVeh(index).mInGarageStall

    def in_paddock(self, index: int | None = None) -> int:
        """Is in paddock (either pit lane or garage), 0 = on track, 1 = pit lane, 2 = garage"""
        state = self.shmm.rf2ScorVeh(index)
        return 2 if state.mInGarageStall else state.mInPits

    def number_pitstops(self, index: int | None = None, penalty: int = 0) -> int:
        """Number of pit stops"""
        return -penalty if penalty else self.shmm.rf2ScorVeh(index).mNumPitstops

    def number_penalties(self, index: int | None = None) -> int:
        """Number of penalties"""
        return self.shmm.rf2ScorVeh(index).mNumPenalties

    def pit_request(self, index: int | None = None) -> bool:
        """Is requested pit, 0 = none, 1 = request, 2 = entering, 3 = stopped, 4 = exiting"""
        return self.shmm.rf2ScorVeh(index).mPitState == 1

    def pit_stop_time(self) -> float:
        """Estimated pit stop time (seconds)"""
        return self.rest.telemetry().pitStopTime

    def absolute_refill(self) -> float:
        """Absolute refill fuel (liter) or virtual energy (percent)"""
        return self.rest.telemetry().absoluteRefill

    def stint_usage(self, driver_name: str) -> tuple[float, float, float, float, int]:
        """Stint usage data"""
        return self.rest.telemetry().stintUsage.get(driver_name, STINT_USAGE_DEFAULT)

    def finish_state(self, index: int | None = None) -> int:
        """Finish state, 0 = none, 1 = finished, 2 = DNF, 3 = DQ"""
        state = self.shmm.rf2ScorVeh(index).mFinishStatus
        if state == 0:
            return 0
        if state == 1:
            return 1
        if state == 2:
            return 2
        if state == 3:
            return 3
        return 0

    def fuel(self, index: int | None = None) -> float:
        """Remaining fuel (liters)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mFuel)

    def tank_capacity(self, index: int | None = None) -> float:
        """Fuel tank capacity (liters)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mFuelCapacity)

    def virtual_energy(self, index: int | None = None) -> float:
        """Remaining virtual energy (joule)"""
        return self.rest.telemetry().currentVirtualEnergy

    def max_virtual_energy(self, index: int | None = None) -> float:
        """Max virtual energy (joule)"""
        return self.rest.telemetry().maxVirtualEnergy

    def orientation_yaw_radians(self, index: int | None = None) -> float:
        """Orientation yaw (radians)"""
        ori = self.shmm.rf2TeleVeh(index).mOri[2]
        return rmnan(oriyaw2rad(ori.x, ori.z))

    def position_xyz(self, index: int | None = None) -> tuple[float, float, float]:
        """Raw x,y,z position (meters)"""
        pos = self.shmm.rf2TeleVeh(index).mPos
        return rmnan(pos.x), rmnan(pos.y), rmnan(pos.z)

    def position_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal axis position (meters) related to world plane"""
        return rmnan(self.shmm.rf2TeleVeh(index).mPos.x)  # in RF2 coord system

    def position_lateral(self, index: int | None = None) -> float:
        """Lateral axis position (meters) related to world plane"""
        return -rmnan(self.shmm.rf2TeleVeh(index).mPos.z)  # in RF2 coord system

    def position_vertical(self, index: int | None = None) -> float:
        """Vertical axis position (meters) related to world plane"""
        return rmnan(self.shmm.rf2TeleVeh(index).mPos.y)  # in RF2 coord system

    def accel_lateral(self, index: int | None = None) -> float:
        """Lateral acceleration (m/s^2)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLocalAccel.x)  # X in RF2 coord system

    def accel_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal acceleration (m/s^2)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLocalAccel.z)  # Z in RF2 coord system

    def accel_vertical(self, index: int | None = None) -> float:
        """Vertical acceleration (m/s^2)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLocalAccel.y)  # Y in RF2 coord system

    def velocity_lateral(self, index: int | None = None) -> float:
        """Lateral velocity (m/s) x"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLocalVel.x)  # X in RF2 coord system

    def velocity_longitudinal(self, index: int | None = None) -> float:
        """Longitudinal velocity (m/s) y"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLocalVel.z)  # Z in RF2 coord system

    def velocity_vertical(self, index: int | None = None) -> float:
        """Vertical velocity (m/s) z"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLocalVel.y)  # Y in RF2 coord system

    def speed(self, index: int | None = None) -> float:
        """Speed (m/s)"""
        vel = self.shmm.rf2TeleVeh(index).mLocalVel
        return rmnan(vel2speed(vel.x, vel.y, vel.z))

    def downforce_front(self, index: int | None = None) -> float:
        """Downforce front (Newtons)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mFrontDownforce)

    def downforce_rear(self, index: int | None = None) -> float:
        """Downforce rear (Newtons)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mRearDownforce)

    def damage_severity(self, index: int | None = None) -> tuple[int, int, int, int, int, int, int, int]:
        """Damage severity, sort row by row from left to right, top to bottom"""
        dmg = self.shmm.rf2TeleVeh(index).mDentSeverity
        return dmg[1], dmg[0], dmg[7], dmg[2], dmg[6], dmg[3], dmg[4], dmg[5]  # RF2 order

    def aero_damage(self, index: int | None = None) -> float:
        """Aerodynamic damage (fraction), 0.0 no damage, 1.0 totaled"""
        return self.rest.telemetry().aeroDamage

    def integrity(self, index: int | None = None) -> float:
        """Vehicle integrity"""
        data = self.shmm.rf2TeleVeh(index)
        total = (
            1
            - sum(data.mDentSeverity) / 16
            - any(wheel_data.mDetached for wheel_data in data.mWheels) / 2
            - data.mDetached / 2
        )
        if total < 0:
            return 0
        return total

    def is_detached(self, index: int | None = None) -> bool:
        """Whether any vehicle parts are detached"""
        return self.shmm.rf2TeleVeh(index).mDetached

    def impact_time(self, index: int | None = None) -> float:
        """Last impact time stamp (seconds)"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLastImpactET)

    def impact_magnitude(self, index: int | None = None) -> float:
        """Last impact magnitude"""
        return rmnan(self.shmm.rf2TeleVeh(index).mLastImpactMagnitude)

    def impact_position(self, index: int | None = None) -> tuple[float, float]:
        """Last impact position x,y coordinates"""
        pos = self.shmm.rf2TeleVeh(index).mLastImpactPos
        return -rmnan(pos.x), rmnan(pos.z)


class Wheel(_reader.Wheel, DataAdapter):
    """Wheel & suspension"""

    __slots__ = ()

    def camber(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel camber (radians)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mCamber),
            rmnan(wheel_data[1].mCamber),
            rmnan(wheel_data[2].mCamber),
            rmnan(wheel_data[3].mCamber),
        )

    def toe(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel toe (radians)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mToe),
            rmnan(wheel_data[1].mToe),
            rmnan(wheel_data[2].mToe),
            rmnan(wheel_data[3].mToe),
        )

    def toe_symmetric(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel toe symmetric (radians)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mToe),
            -rmnan(wheel_data[1].mToe),
            rmnan(wheel_data[2].mToe),
            -rmnan(wheel_data[3].mToe),
        )

    def rotation(self, index: int | None = None) -> tuple[float, ...]:
        """Wheel rotation (radians per second)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mRotation),
            rmnan(wheel_data[1].mRotation),
            rmnan(wheel_data[2].mRotation),
            rmnan(wheel_data[3].mRotation),
        )

    def velocity_lateral(self, index: int | None = None) -> tuple[float, ...]:
        """Lateral velocity (m/s) x"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mLateralGroundVel),
            rmnan(wheel_data[1].mLateralGroundVel),
            rmnan(wheel_data[2].mLateralGroundVel),
            rmnan(wheel_data[3].mLateralGroundVel),
        )

    def velocity_longitudinal(self, index: int | None = None) -> tuple[float, ...]:
        """Longitudinal velocity (m/s) y"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mLongitudinalGroundVel),
            rmnan(wheel_data[1].mLongitudinalGroundVel),
            rmnan(wheel_data[2].mLongitudinalGroundVel),
            rmnan(wheel_data[3].mLongitudinalGroundVel),
        )

    def slip_angle_fl(self, index: int | None = None) -> float:
        """Slip angle (radians) front left"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels[0]
        return rmnan(slip_angle(
            wheel_data.mLateralGroundVel,
            wheel_data.mLongitudinalGroundVel))

    def slip_angle_fr(self, index: int | None = None) -> float:
        """Slip angle (radians) front right"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels[1]
        return rmnan(slip_angle(
            wheel_data.mLateralGroundVel,
            wheel_data.mLongitudinalGroundVel))

    def slip_angle_rl(self, index: int | None = None) -> float:
        """Slip angle (radians) rear left"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels[2]
        return rmnan(slip_angle(
            wheel_data.mLateralGroundVel,
            wheel_data.mLongitudinalGroundVel))

    def slip_angle_rr(self, index: int | None = None) -> float:
        """Slip angle (radians) rear right"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels[3]
        return rmnan(slip_angle(
            wheel_data.mLateralGroundVel,
            wheel_data.mLongitudinalGroundVel))

    def ride_height(self, index: int | None = None) -> tuple[float, ...]:
        """Ride height (convert meters to millimeters)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mRideHeight) * 1000,
            rmnan(wheel_data[1].mRideHeight) * 1000,
            rmnan(wheel_data[2].mRideHeight) * 1000,
            rmnan(wheel_data[3].mRideHeight) * 1000,
        )

    def third_spring_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Third spring deflection front & rear (convert meters to millimeters)"""
        wheel_data = self.shmm.rf2TeleVeh(index)
        front = rmnan(wheel_data.mFront3rdDeflection) * 1000
        rear = rmnan(wheel_data.mRear3rdDeflection) * 1000
        return (front, front, rear, rear)

    def suspension_deflection(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension deflection (convert meters to millimeters)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mSuspensionDeflection) * 1000,
            rmnan(wheel_data[1].mSuspensionDeflection) * 1000,
            rmnan(wheel_data[2].mSuspensionDeflection) * 1000,
            rmnan(wheel_data[3].mSuspensionDeflection) * 1000,
        )

    def suspension_force(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension force (Newtons)"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mSuspForce),
            rmnan(wheel_data[1].mSuspForce),
            rmnan(wheel_data[2].mSuspForce),
            rmnan(wheel_data[3].mSuspForce),
        )

    def suspension_damage(self, index: int | None = None) -> tuple[float, ...]:
        """Suspension damage (fraction), 0.0 no damage, 1.0 totaled"""
        return self.rest.telemetry().suspensionDamage

    def position_vertical(self, index: int | None = None) -> tuple[float, ...]:
        """Vertical wheel position (convert meters to millimeters) related to vehicle"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            rmnan(wheel_data[0].mWheelYLocation) * 1000,
            rmnan(wheel_data[1].mWheelYLocation) * 1000,
            rmnan(wheel_data[2].mWheelYLocation) * 1000,
            rmnan(wheel_data[3].mWheelYLocation) * 1000,
        )

    def is_detached(self, index: int | None = None) -> tuple[bool, ...]:
        """Whether wheel is detached"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return (
            wheel_data[0].mDetached,
            wheel_data[1].mDetached,
            wheel_data[2].mDetached,
            wheel_data[3].mDetached,
        )

    def offroad(self, index: int | None = None) -> int:
        """Number of wheels currently off the road"""
        wheel_data = self.shmm.rf2TeleVeh(index).mWheels
        return sum(2 <= data.mSurfaceType <= 4 for data in wheel_data)

```

# File: tinypedal/adapter/rf2_restapi.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Rest API task
"""

from __future__ import annotations

from typing import Any, Callable, Mapping, NamedTuple

from ..const_common import EMPTY_DICT, WHEELS_NA
from ..process.vehicle import (
    absolute_refilling,
    expected_usage,
    export_wheels,
    steerlock_to_number,
    stint_ve_usage,
)
from ..process.weather import FORECAST_DEFAULT, WeatherNode, forecast_rf2


class RestAPIData:
    """Rest API data"""

    __slots__ = (
        "timeScale",
        "trackClockTime",
        "privateQualifying",
        "steeringWheelRange",
        "currentVirtualEnergy",
        "maxVirtualEnergy",
        "expectedFuelConsumption",
        "expectedVirtualEnergyConsumption",
        "aeroDamage",
        "pitStopTime",
        "absoluteRefill",
        "forecastPractice",
        "forecastQualify",
        "forecastRace",
        "brakeWear",
        "suspensionDamage",
        "stintUsage",
    )

    def __init__(self):
        self.timeScale: int = 1
        self.trackClockTime: float = -1.0
        self.privateQualifying: int = 0
        self.steeringWheelRange: float = 0.0
        self.currentVirtualEnergy: float = 0.0
        self.maxVirtualEnergy: float = 0.0
        self.expectedFuelConsumption: float = 0.0
        self.expectedVirtualEnergyConsumption: float = 0.0
        self.aeroDamage: float = -1.0
        self.pitStopTime: float = 0.0
        self.absoluteRefill: float = 0.0
        self.forecastPractice: tuple[WeatherNode, ...] = FORECAST_DEFAULT
        self.forecastQualify: tuple[WeatherNode, ...] = FORECAST_DEFAULT
        self.forecastRace: tuple[WeatherNode, ...] = FORECAST_DEFAULT
        self.brakeWear: tuple[float, float, float, float] = WHEELS_NA
        self.suspensionDamage: tuple[float, float, float, float] = WHEELS_NA
        self.stintUsage: Mapping[str, tuple[float, float, float, float, int]] = EMPTY_DICT


class ResRawOutput(NamedTuple):
    """URI resource raw output"""

    name: str
    default: Any
    keys: tuple[str, ...] = ()

    def reset(self, output: RestAPIData):
        """Reset data"""
        setattr(output, self.name, self.default)

    def update(self, output: RestAPIData, data: Any) -> bool:
        """Update data"""
        for key in self.keys:  # get data from dict
            if not isinstance(data, dict):  # not exist, set to default
                setattr(output, self.name, self.default)
                return False
            data = data.get(key)
        # Not exist, set to default
        if data is None:
            setattr(output, self.name, self.default)
            return False
        # Reset to default if value is not same type as default
        if not isinstance(data, type(self.default)):
            data = self.default
        setattr(output, self.name, data)
        return True


class ResParOutput(NamedTuple):
    """URI resource parsed output"""

    name: str
    default: Any
    parser: Callable
    keys: tuple[str, ...] = ()

    def reset(self, output: RestAPIData):
        """Reset data"""
        setattr(output, self.name, self.default)

    def update(self, output: RestAPIData, data: Any) -> bool:
        """Update data"""
        for key in self.keys:  # get data from dict
            if not isinstance(data, dict):  # not exist, set to default
                setattr(output, self.name, self.default)
                return False
            data = data.get(key)
        # Not exist, set to default
        if data is None:
            setattr(output, self.name, self.default)
            return False
        # Parse and output
        setattr(output, self.name, self.parser(data))
        return True


# Common
COMMON_WEATHERFORECAST = (
    ResParOutput("forecastPractice", FORECAST_DEFAULT, forecast_rf2, ("PRACTICE",)),
    ResParOutput("forecastQualify", FORECAST_DEFAULT, forecast_rf2, ("QUALIFY",)),
    ResParOutput("forecastRace", FORECAST_DEFAULT, forecast_rf2, ("RACE",)),
)
# RF2
RF2_TIMESCALE = (
    ResRawOutput("timeScale", 1, ("currentValue",)),
)
RF2_PRIVATEQUALIFY = (
    ResRawOutput("privateQualifying", 0, ("currentValue",)),
)
RF2_GARAGESETUP = (
    ResParOutput("expectedFuelConsumption", 0.0, expected_usage, ("VM_FUEL_LEVEL", "stringValue")),
)
# LMU
LMU_CURRENTSTINT = (
    ResRawOutput("currentVirtualEnergy", 0.0, ("fuelInfo", "currentVirtualEnergy")),
    ResRawOutput("maxVirtualEnergy", 0.0, ("fuelInfo", "maxVirtualEnergy")),
    ResRawOutput("aeroDamage", -1.0, ("wearables", "body", "aero")),
    ResParOutput("brakeWear", WHEELS_NA, export_wheels, ("wearables", "brakes")),
    ResParOutput("suspensionDamage", WHEELS_NA, export_wheels, ("wearables", "suspension")),
    ResRawOutput("trackClockTime", -1.0, ("sessionTime", "timeOfDay")),
    ResParOutput("absoluteRefill", 0.0, absolute_refilling, ("pitMenu", "pitMenu")),
)
LMU_GARAGESETUP = (
    ResParOutput("steeringWheelRange", 0.0, steerlock_to_number, ("VM_STEER_LOCK", "stringValue")),
    ResParOutput("expectedFuelConsumption", 0.0, expected_usage, ("VM_FUEL_CAPACITY", "stringValue")),
    ResParOutput("expectedVirtualEnergyConsumption", 0.0, expected_usage, ("VM_VIRTUAL_ENERGY", "stringValue")),
)
LMU_SESSIONSINFO = (
    ResRawOutput("timeScale", 1, ("SESSSET_race_timescale", "currentValue")),
    ResRawOutput("privateQualifying", 0, ("SESSSET_private_qual", "currentValue")),
)
LMU_PITSTOPTIME = (
    ResRawOutput("pitStopTime", 0.0, ("total",)),
)
LMU_STINTUSAGE = (
    ResParOutput("stintUsage", EMPTY_DICT, stint_ve_usage),
)

# Define task set
# 0 - uri path, 1 - output set, 2 - enabling condition, 3 is repeating task, 4 minimum update interval
TASKSET_RF2 = (
    ("/rest/sessions/weather", COMMON_WEATHERFORECAST, "enable_weather_info", False, 0.1),
    ("/rest/sessions/setting/SESSSET_race_timescale", RF2_TIMESCALE, "enable_session_info", False, 0.1),
    ("/rest/sessions/setting/SESSSET_private_qual", RF2_PRIVATEQUALIFY, "enable_session_info", False, 0.1),
    ("/rest/garage/fuel", RF2_GARAGESETUP, "enable_garage_setup_info", False, 0.1),
)
TASKSET_LMU = (
    ("/rest/sessions/weather", COMMON_WEATHERFORECAST, "enable_weather_info", False, 0.1),
    ("/rest/sessions", LMU_SESSIONSINFO, "enable_session_info", False, 0.1),
    ("/rest/garage/getPlayerGarageData", LMU_GARAGESETUP, "enable_garage_setup_info", False, 0.1),
    ("/rest/garage/UIScreen/RepairAndRefuel", LMU_CURRENTSTINT, "enable_vehicle_info", True, 0.2),
    ("/rest/strategy/pitstop-estimate", LMU_PITSTOPTIME, "enable_vehicle_info", True, 1.0),
    ("/rest/strategy/usage", LMU_STINTUSAGE, "enable_energy_remaining", True, 1.0),
)

```

# File: tinypedal/module/__init__.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Data modules

Add new module to import list below in ascending order,
file name must match corresponding key name
in template/setting_module.py dictionary.
"""

__all__ = [
    "module_delta",
    "module_energy",
    "module_force",
    "module_fuel",
    "module_hybrid",
    "module_mapping",
    "module_notes",
    "module_relative",
    "module_sectors",
    "module_stats",
    "module_vehicles",
    "module_wheels",
]

from . import *

```

# File: tinypedal/module/_base.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Data module base
"""

import logging
import threading
from functools import partial

from ..setting import Setting

logger = logging.getLogger(__name__)
# Function
round4 = partial(round, ndigits=4)
round6 = partial(round, ndigits=6)


class DataModule:
    """Data module base"""

    __slots__ = (
        "module_name",
        "closed",
        "cfg",
        "mcfg",
        "active_interval",
        "idle_interval",
        "_event",
    )

    def __init__(self, config: Setting, module_name: str):
        self.module_name = module_name
        self.closed = True

        # Base config
        self.cfg = config

        # Module config
        self.mcfg: dict = self.cfg.user.setting[module_name]

        # Module update interval
        self._event = threading.Event()
        self.active_interval = max(
            self.mcfg["update_interval"],
            self.cfg.application["minimum_update_interval"]) / 1000
        self.idle_interval = max(
            self.active_interval,
            self.mcfg["idle_update_interval"],
            self.cfg.application["minimum_update_interval"]) / 1000

    def start(self):
        """Start update thread"""
        if self.closed:
            self.closed = False
            self._event.clear()
            threading.Thread(target=self.__tasks, daemon=True).start()
            logger.info("ENABLED: %s", self.module_name.replace("_", " "))

    def stop(self):
        """Stop update thread"""
        self._event.set()

    def update_data(self):
        """Update module data, rewrite in child class"""

    def __tasks(self):
        """Run tasks in separated thread"""
        self.update_data()
        # Wait update_data exit
        self.closed = True
        logger.info("DISABLED: %s", self.module_name.replace("_", " "))

```

# File: tinypedal/module/module_delta.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Delta module
"""

from functools import partial

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_common import (
    DELTA_DEFAULT,
    DELTA_ZERO,
    FLOAT_INF,
    MAX_SECONDS,
    POS_XYZ_ZERO,
)
from ..module_info import minfo
from ..userfile.delta_best import load_delta_best_file, save_delta_best_file
from ..validator import is_same_session, valid_delta_raw, vehicle_position_sync
from ._base import DataModule, round6


class Realtime(DataModule):
    """Delta time data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        userpath_delta_best = self.cfg.path.delta_best
        output = minfo.delta

        last_session_id = ("",-1,-1,-1)
        delta_array_session = DELTA_DEFAULT
        delta_array_stint = DELTA_DEFAULT
        laptime_session_best = MAX_SECONDS
        laptime_stint_best = MAX_SECONDS
        min_delta_distance = self.mcfg["minimum_delta_distance"]

        calc_ema_delta = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.mcfg["delta_smoothing_samples"])
        )
        calc_ema_laptime = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.mcfg["laptime_pace_samples"])
        )
        laptime_pace_margin = max(self.mcfg["laptime_pace_margin"], 0.1)
        gen_position_sync = vehicle_position_sync()

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                    recording = False
                    validating = 0
                    is_pit_lap = 0  # whether pit in or pit out lap

                    gen_position_sync.send(None)
                    combo_name = api.read.session.combo_name()
                    session_id = api.read.session.identifier()

                    # Reset delta session best if not same session
                    if not is_same_session(combo_name, session_id, last_session_id):
                        delta_array_session = DELTA_DEFAULT
                        laptime_session_best = MAX_SECONDS
                        last_session_id = (combo_name, *session_id)

                    delta_array_best, laptime_best = load_delta_best_file(
                        filepath=userpath_delta_best,
                        filename=combo_name,
                        defaults=(DELTA_DEFAULT, MAX_SECONDS)
                    )
                    output.deltaBestData = delta_array_best
                    delta_array_raw = [DELTA_ZERO]  # distance, laptime
                    delta_array_last = DELTA_DEFAULT  # last lap

                    delta_ema_best = 0.0
                    delta_ema_last = 0.0
                    delta_ema_session = 0.0
                    delta_ema_stint = 0.0

                    laptime_curr = 0.0  # current laptime
                    laptime_last = 0.0  # last laptime
                    laptime_pace = init_laptime_pace(laptime_best)  # avearge laptime pace

                    last_lap_stime = FLOAT_INF  # last lap start time
                    pos_recorded = 0.0  # last recorded vehicle position
                    pos_last = 0.0  # last checked vehicle position
                    pos_estimate = 0.0  # estimated vehicle position
                    pos_synced = 0.0  # synced estimated vehicle position
                    pos_synced_last = 0.0  # last synced estimated vehicle position
                    is_pos_synced = False  # vehicle position synced with API
                    gps_last = POS_XYZ_ZERO  # last global position

                # Read telemetry
                lap_stime = api.read.timing.start()
                laptime_curr = max(api.read.timing.current_laptime(), 0)
                laptime_valid = api.read.timing.last_laptime()
                pos_curr = api.read.lap.distance()
                gps_curr = api.read.vehicle.position_xyz()
                in_pits = api.read.vehicle.in_pits()
                is_pit_lap |= in_pits

                # Reset delta stint best if in pit and stopped
                if in_pits and laptime_stint_best != MAX_SECONDS and api.read.vehicle.speed() < 0.1:
                    delta_array_stint = DELTA_DEFAULT
                    laptime_stint_best = MAX_SECONDS

                # Lap start & finish detection
                if lap_stime > last_lap_stime:
                    laptime_last = lap_stime - last_lap_stime
                    if valid_delta_raw(delta_array_raw, laptime_last, 1):  # set end value
                        delta_array_raw.append((round6(pos_last + 10), round6(laptime_last)))
                        delta_array_last = tuple(delta_array_raw)
                        validating = api.read.timing.elapsed()
                    delta_array_raw[:] = DELTA_DEFAULT
                    pos_last = pos_recorded = pos_curr
                    recording = laptime_curr < 1
                    is_pit_lap = 0
                last_lap_stime = lap_stime  # reset

                # 1 sec position distance check after new lap begins
                # Reset to 0 if higher than normal distance
                if 0 < laptime_curr < 1 and pos_curr > 300:
                    pos_last = pos_recorded = pos_curr = 0

                # Update if position value is different & positive
                if 0 <= pos_curr != pos_last:
                    if recording and pos_curr - pos_recorded >= min_delta_distance:
                        delta_array_raw.append((round6(pos_curr), round6(laptime_curr)))
                        pos_recorded = pos_curr
                    pos_last = pos_curr  # reset last position
                    is_pos_synced = True

                # Validating 1s after passing finish line
                if validating:
                    timer = api.read.timing.elapsed() - validating
                    if timer > 10:  # switch off after 10s
                        validating = 0
                    elif (timer > 1 and  # compare current time
                        laptime_valid > 0 and  # is valid laptime
                        abs(laptime_valid - laptime_last) < 0.001):  # is matched laptime
                        # Update laptime pace
                        if not is_pit_lap:
                            # Set initial laptime if invalid, or align to faster laptime
                            if not 0 < laptime_pace < MAX_SECONDS or laptime_valid < laptime_pace:
                                laptime_pace = laptime_valid
                            else:
                                laptime_pace = min(
                                    calc_ema_laptime(laptime_pace, laptime_valid),
                                    laptime_pace + laptime_pace_margin,
                                )
                        # Update delta best list
                        if laptime_best > laptime_last:
                            laptime_best = laptime_last
                            output.deltaBestData = delta_array_best = delta_array_last
                            save_delta_best_file(
                                filepath=userpath_delta_best,
                                filename=combo_name,
                                dataset=delta_array_best,
                            )
                        # Update delta session best list
                        if laptime_session_best > laptime_last:
                            laptime_session_best = laptime_last
                            delta_array_session = delta_array_last
                        # Update delta stint best list
                        if laptime_stint_best > laptime_last:
                            laptime_stint_best = laptime_last
                            delta_array_stint = delta_array_last
                        validating = 0

                # Calc distance
                if gps_last != gps_curr:
                    moved_distance = calc.distance(gps_last, gps_curr)
                    gps_last = gps_curr
                    # Estimate distance into lap
                    if is_pos_synced:
                        pos_estimate = pos_curr
                        is_pos_synced = False
                    else:
                        pos_estimate += moved_distance
                    pos_synced = gen_position_sync.send(pos_estimate)

                # Calc delta
                if pos_synced_last != pos_synced:
                    pos_synced_last = pos_synced
                    delay_update = laptime_curr > 0.3
                    # Smooth delta
                    delta_ema_best = calc_ema_delta(
                        delta_ema_best,
                        calc.delta_telemetry(
                            delta_array_best,
                            pos_synced,
                            laptime_curr,
                            delay_update,
                        ),
                    )
                    delta_ema_last = calc_ema_delta(
                        delta_ema_last,
                        calc.delta_telemetry(
                            delta_array_last,
                            pos_synced,
                            laptime_curr,
                            delay_update,
                        ),
                    )
                    delta_ema_session = calc_ema_delta(
                        delta_ema_session,
                        calc.delta_telemetry(
                            delta_array_session,
                            pos_synced,
                            laptime_curr,
                            delay_update,
                        ),
                    )
                    delta_ema_stint = calc_ema_delta(
                        delta_ema_stint,
                        calc.delta_telemetry(
                            delta_array_stint,
                            pos_synced,
                            laptime_curr,
                            delay_update,
                        ),
                    )

                # Estimated laptime
                laptime_est = laptime_stint_best + delta_ema_stint  # from stint
                if not 0 < laptime_est < MAX_SECONDS:
                    laptime_est = laptime_session_best + delta_ema_session  # fallback to session
                    if not 0 < laptime_est < MAX_SECONDS:
                        laptime_est = laptime_best + delta_ema_best  # fallback to best
                        if not 0 < laptime_est < MAX_SECONDS:
                            laptime_est = 0

                # Output delta time data
                output.deltaBest = delta_ema_best
                output.deltaLast = delta_ema_last
                output.deltaSession = delta_ema_session
                output.deltaStint = delta_ema_stint
                output.isValidLap = laptime_valid > 0
                output.lapTimeCurrent = laptime_curr
                output.lapTimeLast = laptime_last
                output.lapTimeBest = laptime_best
                output.lapTimeEstimated = laptime_est
                output.lapTimeSession = laptime_session_best
                output.lapTimeStint = laptime_stint_best
                output.lapTimePace = laptime_pace
                output.lapDistance = pos_synced

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval
                    last_session_id = (combo_name, *session_id)


def init_laptime_pace(laptime_best: float):
    """Initialize laptime pace value"""
    if 0 < laptime_best < MAX_SECONDS:
        return laptime_best
    return api.read.timing.reference_laptime()

```

# File: tinypedal/module/module_energy.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Energy module
"""

from __future__ import annotations

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_file import FileExt
from ..module_info import minfo
from ._base import DataModule
from .module_fuel import calc_consumption


class Realtime(DataModule):
    """Energy usage data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        userpath_energy_delta = self.cfg.path.energy_delta

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                    combo_name = api.read.session.combo_name()
                    gen_calc_energy = calc_consumption(
                        output=minfo.energy,
                        telemetry_func=telemetry_energy,
                        filepath=userpath_energy_delta,
                        filename=combo_name,
                        extension=FileExt.ENERGY,
                        min_delta_distance=self.mcfg["minimum_delta_distance"],
                    )
                    # Reset module output
                    minfo.energy.reset()

                # Run calculation if virtual energy available
                if api.read.vehicle.max_virtual_energy():
                    gen_calc_energy.send(True)

                    # Update hybrid info
                    minfo.hybrid.fuelEnergyRatio = calc.fuel_to_energy_ratio(
                        minfo.fuel.estimatedConsumption,
                        minfo.energy.estimatedConsumption,
                    )
                    minfo.hybrid.fuelEnergyBias = (
                        minfo.fuel.estimatedLaps - minfo.energy.estimatedLaps
                    )

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval
                    # Trigger save check
                    gen_calc_energy.send(False)


def telemetry_energy() -> tuple[float, float]:
    """Telemetry energy, output in percentage"""
    max_energy = api.read.vehicle.max_virtual_energy()
    if max_energy:
        return 100.0, api.read.vehicle.virtual_energy() / max_energy * 100
    return 100.0, 0.0

```

# File: tinypedal/module/module_force.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Force module
"""

from functools import partial

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..module_info import minfo
from ._base import DataModule


class Realtime(DataModule):
    """Force data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        output = minfo.force
        g_accel = max(self.mcfg["gravitational_acceleration"], 0.01)
        max_g_diff = self.mcfg["max_average_g_force_difference"]
        calc_ema_gforce = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.mcfg["max_average_g_force_samples"], 3)
        )

        calc_max_lgt = TransientMax(self.mcfg["max_g_force_reset_delay"])
        calc_max_lat = TransientMax(self.mcfg["max_g_force_reset_delay"])
        calc_max_avg_lat = TransientMax(self.mcfg["max_average_g_force_reset_delay"], True)
        calc_transient_rate = TransientMax(3)
        calc_max_braking_rate = TransientMax(self.mcfg["max_braking_rate_reset_delay"], True)

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                    calc_max_lgt.reset()
                    calc_max_lat.reset()
                    calc_max_avg_lat.reset()
                    calc_transient_rate.reset()
                    calc_max_braking_rate.reset()

                    avg_lat_gforce_ema = 0
                    max_braking_rate = 0
                    delta_braking_rate = 0

                # Read telemetry
                lap_etime = api.read.timing.elapsed()
                lat_accel = api.read.vehicle.accel_lateral()
                lgt_accel = api.read.vehicle.accel_longitudinal()
                dforce_f = api.read.vehicle.downforce_front()
                dforce_r = api.read.vehicle.downforce_rear()
                brake_raw = api.read.inputs.brake_raw()
                impact_time = api.read.vehicle.impact_time()

                # G raw
                lgt_gforce_raw = lgt_accel / g_accel
                lat_gforce_raw = lat_accel / g_accel

                # Max G
                max_lgt_gforce = calc_max_lgt.update(abs(lgt_gforce_raw), lap_etime)
                max_lat_gforce = calc_max_lat.update(abs(lat_gforce_raw), lap_etime)

                # Max average lateral G
                avg_lat_gforce_ema = calc_ema_gforce(
                    avg_lat_gforce_ema,
                    min(abs(lat_gforce_raw), avg_lat_gforce_ema + max_g_diff)
                )
                max_avg_lat_gforce = calc_max_avg_lat.update(avg_lat_gforce_ema, lap_etime)

                # Downforce
                dforce_ratio = calc.force_ratio(dforce_f, dforce_f + dforce_r)

                # Braking rate
                braking_rate = calc.braking_rate(lgt_gforce_raw, brake_raw > 0.02, lap_etime - impact_time > 2)
                max_transient_rate = calc_transient_rate.update(braking_rate, lap_etime)
                temp_max_rate = calc_max_braking_rate.update(max_transient_rate, lap_etime)
                if max_transient_rate > 0:
                    delta_braking_rate = max_transient_rate - max_braking_rate
                else:  # Set after reset max_transient_rate
                    max_braking_rate = temp_max_rate

                # Output force data
                output.lgtGForceRaw = lgt_gforce_raw
                output.latGForceRaw = lat_gforce_raw
                output.maxAvgLatGForce = max_avg_lat_gforce
                output.maxLgtGForce = max_lgt_gforce
                output.maxLatGForce = max_lat_gforce
                output.downForceFront = dforce_f
                output.downForceRear = dforce_r
                output.downForceRatio = dforce_ratio
                output.brakingRate = braking_rate
                output.transientMaxBrakingRate = max_transient_rate
                output.maxBrakingRate = max_braking_rate
                output.deltaBrakingRate = delta_braking_rate

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval


class TransientMax:
    """Transient max"""

    __slots__ = (
        "_reset_delay",
        "_store_recent",
        "_reset_timer",
        "_max_value",
        "_stored_value",
    )

    def __init__(self, reset_delay: float, store_recent: bool = False):
        """
        Args:
            reset_delay: auto reset delay (seconds).
            store_recent: whether store a recent fallback max value.
        """
        self._reset_delay = reset_delay
        self._store_recent = store_recent
        self._reset_timer = 0.0
        self._max_value = 0.0
        self._stored_value = 0.0

    def update(self, value: float, elapsed_time: float) -> float:
        """Record transient max value, reset periodically

        Args:
            value: current value.
            elapsed_time: elapsed time (seconds).

        Returns:
            Max value.
        """
        if value > self._max_value:
            self._max_value = value
            self._reset_timer = elapsed_time
        elif self._store_recent and self._max_value > value > self._stored_value:
            self._stored_value = value
            self._reset_timer = elapsed_time
        elif elapsed_time - self._reset_timer > self._reset_delay:
            self._max_value = self._stored_value
            self._stored_value = 0
            self._reset_timer = elapsed_time
        return self._max_value

    def reset(self):
        """Reset"""
        self._reset_timer = 0.0
        self._max_value = 0.0
        self._stored_value = 0.0

```

# File: tinypedal/module/module_fuel.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Fuel module
"""

from __future__ import annotations

from math import ceil
from typing import Callable

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_api import API_RF2_NAME
from ..const_common import DELTA_DEFAULT, DELTA_ZERO, FLOAT_INF, POS_XYZ_ZERO
from ..const_file import FileExt
from ..module_info import ConsumptionDataSet, FuelInfo, minfo
from ..userfile.consumption_history import (
    load_consumption_history_file,
    save_consumption_history_file,
)
from ..userfile.fuel_delta import (
    load_fuel_delta_file,
    save_fuel_delta_file,
)
from ..validator import generator_init, valid_delta_raw
from ._base import DataModule, round6


class Realtime(DataModule):
    """Fuel usage data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        userpath_fuel_delta = self.cfg.path.fuel_delta

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                    combo_name = api.read.session.combo_name()
                    gen_calc_fuel = calc_consumption(
                        output=minfo.fuel,
                        telemetry_func=detect_consumption_type(),
                        filepath=userpath_fuel_delta,
                        filename=combo_name,
                        extension=FileExt.FUEL,
                        min_delta_distance=self.mcfg["minimum_delta_distance"],
                    )
                    # Reset module output
                    minfo.fuel.reset()
                    load_consumption_history(userpath_fuel_delta, combo_name)

                # Run calculation
                gen_calc_fuel.send(True)

                # Update consumption history
                update_consumption_history()

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval
                    # Trigger save check
                    gen_calc_fuel.send(False)
                    save_consumption_history(userpath_fuel_delta, combo_name)


def update_consumption_history():
    """Update consumption history"""
    if not (10 > minfo.delta.lapTimeCurrent > 2) or minfo.delta.lapTimeLast < 1:
        return

    lap_number = api.read.lap.completed_laps() - 1
    if (
        minfo.history.consumptionDataSet[0].lapTimeLast != minfo.delta.lapTimeLast
        or minfo.history.consumptionDataSet[0].lapNumber != lap_number
    ):
        minfo.history.consumptionDataSet.appendleft(
            ConsumptionDataSet(
                lapNumber=lap_number,
                isValidLap=int(minfo.delta.isValidLap),
                lapTimeLast=minfo.delta.lapTimeLast,
                lastLapUsedFuel=minfo.fuel.lastLapConsumption,
                lastLapUsedEnergy=minfo.energy.lastLapConsumption,
                batteryDrainLast=minfo.hybrid.batteryDrainLast,
                batteryRegenLast=minfo.hybrid.batteryRegenLast,
                tyreAvgWearLast=calc.mean(minfo.wheels.lastLapTreadWear),
                capacityFuel=minfo.fuel.capacity,
            )
        )
        minfo.history.consumptionDataVersion += 1


def load_consumption_history(filepath: str, combo_name: str):
    """Load consumption history"""
    if minfo.history.consumptionDataName != combo_name:
        dataset = load_consumption_history_file(
            filepath=filepath,
            filename=combo_name,
        )
        minfo.history.consumptionDataSet.clear()
        minfo.history.consumptionDataSet.extend(dataset)
        # Update combo info
        minfo.history.consumptionDataName = combo_name
        minfo.history.consumptionDataVersion = hash(combo_name)  # unique start id


def save_consumption_history(filepath: str, combo_name: str):
    """Save consumption history"""
    if minfo.history.consumptionDataVersion != hash(combo_name):
        save_consumption_history_file(
            dataset=minfo.history.consumptionDataSet,
            filepath=filepath,
            filename=combo_name,
        )
        minfo.history.consumptionDataVersion = hash(combo_name)  # reset


def detect_consumption_type() -> Callable:
    """Detect consumption type, return telemetry function"""
    # Pure electric based vehicle
    if (
        api.name == API_RF2_NAME
        and api.read.vehicle.tank_capacity() == 1
        and api.read.emotor.battery_charge() > 0
    ):
        return telemetry_battery
    # Fuel based vehicle
    return telemetry_fuel


def telemetry_fuel() -> tuple[float, float]:
    """Telemetry fuel"""
    return max(api.read.vehicle.tank_capacity(), 0.01), api.read.vehicle.fuel()


def telemetry_battery() -> tuple[float, float]:
    """Telemetry battery, capacity is always 100%"""
    return 100, api.read.emotor.battery_charge() * 100


@generator_init
def calc_consumption(
    output: FuelInfo, telemetry_func: Callable, filepath: str, filename: str, extension: str,
    min_delta_distance: float):
    """Calculate consumption data"""
    recording = False
    delayed_save = False
    validating = 0
    is_pit_lap = 0  # whether pit in or pit out lap

    delta_array_last, used_last_valid, laptime_last = load_fuel_delta_file(
        filepath=filepath,
        filename=filename,
        extension=extension,
        defaults=(DELTA_DEFAULT, 0.0, 0.0)
    )
    delta_array_raw = [DELTA_ZERO]  # distance, fuel used, laptime
    delta_array_temp = DELTA_DEFAULT  # last lap temp
    delta_fuel = 0.0  # delta fuel consumption compare to last lap

    amount_start = -FLOAT_INF  # start fuel reading
    amount_last = 0.0  # last fuel reading
    amount_need_abs = 0.0  # total fuel (absolute) need to finish race
    amount_need_rel = 0.0  # total additional fuel (relative) need to finish race
    amount_end = 0.0  # amount fuel left at the end of stint before pitting
    used_curr = 0.0  # current lap fuel consumption
    used_last_raw = used_last_valid  # raw usage
    used_est = 0.0  # estimated fuel consumption, for calculation only
    est_runlaps = 0.0  # estimate laps current fuel can last
    est_runmins = 0.0  # estimate minutes current fuel can last
    est_empty = 0.0  # estimate empty capacity at end of current lap
    est_pits_late = 0.0  # estimate end-stint pit stop counts
    est_pits_early = 0.0  # estimate end-lap pit stop counts
    used_est_less = 0.0  # estimate fuel consumption for one less pit stop

    last_lap_stime = FLOAT_INF  # last lap start time
    laps_left = 0.0  # amount laps left at current lap distance
    end_timer_laps_left = 0.0  # amount laps left from start of current lap to end of race timer
    pos_recorded = 0.0  # last recorded vehicle position
    pos_last = 0.0  # last checked vehicle position
    pos_estimate = 0.0  # estimated vehicle position
    is_pos_synced = False  # vehicle position synced with API
    gps_last = POS_XYZ_ZERO  # last global position

    while True:
        updating = yield None

        # Save check
        if not updating:
            if delayed_save:
                save_fuel_delta_file(
                    filepath=filepath,
                    filename=filename,
                    extension=extension,
                    dataset=delta_array_last,
                )
            continue

        # Read telemetry
        capacity, amount_curr = telemetry_func()
        lap_stime = api.read.timing.start()
        laptime_curr = api.read.timing.current_laptime()
        time_left = api.read.session.remaining()
        in_garage = api.read.vehicle.in_garage()
        pos_curr = api.read.lap.distance()
        gps_curr = api.read.vehicle.position_xyz()
        laps_done = api.read.lap.completed_laps()
        lap_into = api.read.lap.progress()
        is_pit_lap |= api.read.vehicle.in_pits()
        laptime_last = minfo.delta.lapTimePace

        # Realtime fuel consumption
        if amount_start < amount_curr:
            amount_start = amount_last = amount_curr

        if amount_last < amount_curr:
            if api.read.vehicle.speed() > 1:  # regen check
                used_curr += amount_last - amount_curr
            else:  # pitstop refilling check
                amount_start = amount_curr
            amount_last = amount_curr
        elif amount_last > amount_curr:
            used_curr += amount_last - amount_curr
            amount_last = amount_curr

        # Lap start & finish detection
        if lap_stime > last_lap_stime:
            if not is_pit_lap and valid_delta_raw(delta_array_raw, used_curr, 1):
                delta_array_raw.append((  # set end value
                    round6(pos_last + 10),
                    round6(used_curr),
                    round6(lap_stime - last_lap_stime)
                ))
                delta_array_temp = tuple(delta_array_raw)
                validating = api.read.timing.elapsed()
            delta_array_raw[:] = DELTA_DEFAULT
            pos_last = pos_recorded = pos_curr
            used_last_raw = used_curr
            used_curr = 0
            recording = laptime_curr < 1
            is_pit_lap = 0
        last_lap_stime = lap_stime  # reset

        # Distance desync check at start of new lap, reset if higher than normal distance
        if 0 < laptime_curr < 1 and pos_curr > 300:
            pos_last = pos_recorded = pos_curr = 0

        # Update if position value is different & positive
        if 0 <= pos_curr != pos_last:
            if recording and pos_curr - pos_recorded >= min_delta_distance:
                delta_array_raw.append((round6(pos_curr), round6(used_curr)))
                pos_recorded = pos_curr
            pos_last = pos_curr  # reset last position
            is_pos_synced = True

        # Validating 1s after passing finish line
        if validating:
            timer = api.read.timing.elapsed() - validating
            if timer > 3:  # switch off after 3s
                validating = 0
            elif (timer > 0.3 and  # compare current time
                api.read.timing.last_laptime() > 0):  # is valid laptime
                used_last_valid = used_last_raw
                delta_array_last = delta_array_temp
                delta_array_temp = DELTA_DEFAULT
                delayed_save = True
                validating = 0

        # Calc delta
        if gps_last != gps_curr:
            if is_pos_synced:
                pos_estimate = pos_curr
                is_pos_synced = False
            else:
                pos_estimate += calc.distance(gps_last, gps_curr)
            gps_last = gps_curr
            # Update delta
            delta_fuel = calc.delta_telemetry(
                delta_array_last,
                pos_estimate,
                used_curr,
                laptime_curr > 0.3 and not in_garage,  # 300ms delay
            )

        # Exclude first lap & pit in/out lap
        used_est = calc.end_lap_consumption(
            used_last_valid, delta_fuel, 0 == is_pit_lap < laps_done)

        # Total refuel = laps left * last consumption - remaining fuel
        if api.read.session.lap_type():  # lap-type
            full_laps_left = calc.lap_type_full_laps_remain(
                api.read.lap.maximum(), laps_done)
            laps_left = calc.lap_type_laps_remain(
                full_laps_left, lap_into)
        elif laptime_last > 0:  # time-type race
            end_timer_laps_left = calc.end_timer_laps_remain(
                lap_into, laptime_last, time_left)
            full_laps_left = ceil(end_timer_laps_left)
            laps_left = calc.time_type_laps_remain(
                full_laps_left, lap_into)

        amount_need_abs = laps_left * used_est

        amount_need_rel = amount_need_abs - amount_curr

        amount_end = calc.end_stint_fuel(
            amount_curr, used_curr, used_est)

        est_runlaps = calc.end_stint_laps(
            amount_curr, used_est)

        est_runmins = calc.end_stint_minutes(
            est_runlaps, laptime_last)

        est_empty = calc.end_lap_empty_capacity(
            capacity, amount_curr + used_curr, used_last_valid + delta_fuel)

        est_pits_late = calc.end_stint_pit_counts(
            amount_need_rel, capacity - amount_end)

        est_pits_early = calc.end_lap_pit_counts(
            amount_need_rel, est_empty, capacity - amount_end)

        used_est_less = calc.one_less_pit_stop_consumption(
            est_pits_late, capacity, amount_curr, laps_left)

        output.capacity = capacity
        output.amountStart = amount_start
        output.amountCurrent = amount_curr
        output.amountUsedCurrent = used_curr
        output.amountEndStint = amount_end
        output.neededRelative = amount_need_rel
        output.neededAbsolute = amount_need_abs
        output.lastLapConsumption = used_last_raw
        output.estimatedConsumption = used_last_valid + delta_fuel
        output.estimatedValidConsumption = used_est
        output.estimatedLaps = est_runlaps
        output.estimatedMinutes = est_runmins
        output.estimatedNumPitStopsEnd = est_pits_late
        output.estimatedNumPitStopsEarly = est_pits_early
        output.deltaConsumption = delta_fuel
        output.oneLessPitConsumption = used_est_less

```

# File: tinypedal/module/module_hybrid.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Hybrid module
"""

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_common import DELTA_DEFAULT, DELTA_ZERO, FLOAT_INF, MAX_SECONDS
from ..module_info import minfo
from ._base import DataModule


class Realtime(DataModule):
    """Hybrid data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        output = minfo.hybrid

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                    battery_drain = 0
                    battery_regen = 0
                    battery_drain_last = 0
                    battery_regen_last = 0
                    last_battery_charge = 0
                    last_motor_state = 0
                    alt_motor_state = 1  # alternative state in case motor state not available
                    alt_motor_state_debounce = 0  # alternative state reset debounce counter
                    motor_active_timer = 0
                    motor_active_timer_start = False
                    motor_inactive_timer = MAX_SECONDS
                    motor_inactive_timer_start = False
                    lap_etime_last = 0
                    last_lap_stime = FLOAT_INF  # last lap start time

                    delta_reset = False
                    delta_recording = False
                    delta_array_raw = [DELTA_ZERO]  # distance, battery net change
                    delta_array_last = DELTA_DEFAULT
                    pos_last = 0.0  # last checked vehicle position
                    net_change_last = 0.0
                    est_net_change = 0.0  # estimated battery charge net change
                    min_delta_distance = self.mcfg["minimum_delta_distance"]
                    is_pit_lap = 0  # whether pit in or pit out lap
                    is_valid_delta = False

                # Read telemetry
                lap_stime = api.read.timing.start()
                lap_etime = api.read.timing.elapsed()
                battery_charge = api.read.emotor.battery_charge() * 100
                motor_state = api.read.emotor.state()

                # Lap start & finish detection
                if lap_stime > last_lap_stime:
                    battery_drain_last = battery_drain
                    battery_regen_last = battery_regen
                    battery_drain = 0
                    battery_regen = 0
                    motor_active_timer = 0
                    delta_reset = True
                last_lap_stime = lap_stime  # reset

                # Battery charge consumption
                if last_battery_charge:
                    if last_battery_charge > battery_charge > 0:  # drain
                        battery_drain += last_battery_charge - battery_charge
                        alt_motor_state_debounce = 0
                        alt_motor_state = 2
                    elif last_battery_charge < battery_charge < 100: # regen
                        battery_regen += battery_charge - last_battery_charge
                        alt_motor_state_debounce = 0
                        alt_motor_state = 3
                    elif alt_motor_state > 1:
                        alt_motor_state_debounce += 1
                        if alt_motor_state_debounce > 5:
                            alt_motor_state = 1
                last_battery_charge = battery_charge

                # Motor state correction
                if motor_state == 0 < battery_charge:
                    motor_state = alt_motor_state

                # Active timer
                if last_motor_state != motor_state and motor_state == 2:
                    motor_active_timer_start = True
                    lap_etime_last = lap_etime
                    last_motor_state = motor_state

                if motor_active_timer_start:
                    motor_active_timer += lap_etime - lap_etime_last
                    lap_etime_last = lap_etime
                    if motor_state != 2:
                        motor_active_timer_start = False
                        motor_inactive_timer_start = lap_etime
                        last_motor_state = motor_state

                if motor_inactive_timer_start:
                    motor_inactive_timer = lap_etime - motor_inactive_timer_start
                    if motor_state == 2:
                        motor_inactive_timer_start = False
                        motor_inactive_timer = MAX_SECONDS

                # Battery charge delta calculation
                if motor_state != 0:
                    laptime_curr = api.read.timing.current_laptime()
                    pos_curr = api.read.lap.distance()
                    is_pit_lap |= api.read.vehicle.in_pits()

                    if delta_reset:
                        delta_reset = False
                        if len(delta_array_raw) > 1 and not is_pit_lap:
                            delta_array_last = tuple(delta_array_raw)
                        delta_array_raw[:] = DELTA_DEFAULT
                        pos_last = pos_curr
                        delta_recording = laptime_curr < 1
                        net_change_last = battery_regen_last - battery_drain_last
                        is_valid_delta = len(delta_array_last) > 1
                        is_pit_lap = 0

                    # Distance desync check at start of new lap, reset if higher than normal distance
                    if 0 < laptime_curr < 1 and pos_curr > 300:
                        pos_last = pos_curr = 0
                    elif pos_last > pos_curr:
                        pos_last = pos_curr

                    # Update if position value is different & positive
                    net_change_curr = battery_regen - battery_drain
                    if delta_recording and pos_curr - pos_last >= min_delta_distance:
                        delta_array_raw.append((pos_curr, net_change_curr))
                        pos_last = pos_curr

                    # Net change delta
                    if is_valid_delta:
                        delta_net_change = calc.delta_telemetry(
                            delta_array_last,
                            pos_curr,
                            net_change_curr,
                            laptime_curr > 0.3,
                        )
                        est_net_change = net_change_last + delta_net_change

                # Output hybrid data
                output.batteryCharge = battery_charge
                output.batteryDrain = battery_drain
                output.batteryRegen = battery_regen
                output.batteryDrainLast = battery_drain_last
                output.batteryRegenLast = battery_regen_last
                output.batteryNetChange = est_net_change
                output.motorActiveTimer = motor_active_timer
                output.motorInactiveTimer = motor_inactive_timer
                output.motorState = motor_state

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval

```

# File: tinypedal/module/module_mapping.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Mapping module
"""

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_file import FileExt
from ..module_info import MappingInfo, minfo
from ..userfile.track_info import load_track_info, save_track_info
from ..userfile.track_map import load_track_map_file, save_track_map_file
from ..validator import file_last_modified, generator_init
from ._base import DataModule, round4


class Realtime(DataModule):
    """Mapping data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        userpath_track_map = self.cfg.path.track_map
        output = minfo.mapping

        recorder = MapRecorder(userpath_track_map)

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                    recorder.load_map(api.read.session.track_name())
                    if recorder.map_exist:
                        output.coordinates = recorder.output.coords
                        output.elevations = recorder.output.dists
                        output.sectors = recorder.output.sectors
                        output.lastModified = recorder.last_modified
                    else:
                        recorder.reset()
                        output.reset()

                    # Load track info
                    gen_track_info = update_track_info(output, api.read.session.track_name())

                # Recording map data
                if not recorder.map_exist:
                    recorder.update()
                    if recorder.map_exist:
                        reset = False  # load recorded map in next loop

                # Update track info
                gen_track_info.send(True)

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval
                    gen_track_info.send(False)


@generator_init
def update_track_info(output: MappingInfo, track_name: str):
    """Update track info"""
    # Load track info
    pit_entry = load_track_info(track_name).get("pit_entry", 0.0)
    pit_exit = load_track_info(track_name).get("pit_exit", 0.0)
    pit_speed = load_track_info(track_name).get("pit_speed", 0.0)
    output.speedTrapPosition = load_track_info(track_name).get("speed_trap", 0.0)
    # Set default
    pos_last = 0.0
    last_speed = 0.0
    pitlane_length = 0.0
    last_in_pits = -1
    while True:
        # Save check
        updating = yield None
        if not updating:
            save_track_info(
                track_name=track_name,
                # kwargs {key: value}
                pit_entry=round4(pit_entry),
                pit_exit=round4(pit_exit),
                pit_speed=round4(pit_speed),
            )
            continue

        in_pits = api.read.vehicle.in_pits()

        # Calibrate pit speed limit
        if in_pits and api.read.switch.speed_limiter():
            pos_curr = api.read.lap.distance()
            if pos_last != pos_curr:  # position check
                pos_last = pos_curr
                speed = api.read.vehicle.speed()
                if (api.read.inputs.throttle_raw() > 0.95 and  # full throttle check
                    api.read.inputs.brake_raw() < 0.01 and  # no braking check
                    speed > 1 and  # moving check
                    0.1 > speed - last_speed > 0):  # limit speed delta in 0.0 - 0.1m/s
                    pit_speed = speed
                last_speed = speed

        # Calculate pit lane length
        if last_in_pits != in_pits:
            if last_in_pits != -1 and api.read.vehicle.speed() > 1:  # avoid ESC desync
                if in_pits > 0:  # entering pit
                    pit_entry = max(api.read.lap.distance(), 0.0)
                else:  # exiting pit
                    pit_exit = max(api.read.lap.distance(), 0.0)
            last_in_pits = in_pits
            pitlane_length = calc.pitlane_length(
                api.read.lap.track_length(),
                pit_entry,
                pit_exit,
            )

        output.pitSpeedLimit = pit_speed
        output.pitEntryPosition = pit_entry
        output.pitExitPosition = pit_exit
        output.pitLaneLength = pitlane_length
        output.pitPassTime = pitlane_length / pit_speed if pit_speed else 0.0


class MapCoords:
    """Map coords data"""

    __slots__ = (
        "coords",
        "dists",
        "sectors",
    )

    def __init__(self, coords=None, dists=None, sectors=None):
        """
        Args:
            coords: x,y coordinates list.
            dists: distance,elevation list.
            sectors: sector node index reference list.
        """
        self.coords = coords
        self.dists = dists
        self.sectors = sectors

    def clear(self):
        """Clear coords data"""
        self.coords = None
        self.dists = None
        self.sectors = None

    def reset(self):
        """Reset coords data"""
        self.coords = []
        self.dists = []
        self.sectors = [0, 0]


class MapRecorder:
    """Map data recorder"""

    def __init__(self, filepath: str):
        self._recording = False
        self._validating = False
        self._last_sector_idx = -1
        self._last_lap_stime = -1.0  # last lap start time
        self._pos_last = 0.0  # last checked player vehicle position
        # File info
        self.map_exist = False
        self.last_modified = 0.0
        self._filepath = filepath
        self._filename = ""
        # Map data
        self.output = MapCoords()
        self._recorder_data = MapCoords()
        self._temp_data = MapCoords()

    def reset(self):
        """Reset to defaults"""
        self._recording = False
        self._validating = False
        self._last_sector_idx = -1
        self._last_lap_stime = -1.0
        self._pos_last = 0.0

    def update(self):
        """Update map data"""
        self.__start(api.read.timing.start())
        if self._validating:
            self.__validate(api.read.timing.elapsed(), api.read.timing.last_laptime())
        if self._recording:
            self.__record_sector(api.read.lap.sector_index())
            self.__record_path(round4(api.read.lap.distance()))

    def __start(self, lap_stime: float):
        """Lap start & finish detection"""
        # Init reset
        if self._last_lap_stime == -1:
            self._recorder_data.reset()
            self._last_lap_stime = lap_stime
        # New lap
        if lap_stime > self._last_lap_stime:
            self.__record_end()
            self._recorder_data.reset()
            self._last_lap_stime = lap_stime
            self._pos_last = 0
            self._recording = True
            #logger.info("map recording")

    def __validate(self, lap_etime: float, laptime_valid: float):
        """Validate map data after crossing finish line"""
        laptime_curr = lap_etime - self._last_lap_stime
        if 1 < laptime_curr <= 8 and laptime_valid > 0:
            self.save_map()
            self._temp_data.clear()
            self._recorder_data.clear()
            self.map_exist = True
            self._recording = False
            self._validating = False
        # Switch off validating after 8s
        elif 8 < laptime_curr < 10:
            self._temp_data.clear()
            self._validating = False

    def __record_sector(self, sector_idx: int):
        """Record sector index"""
        if self._last_sector_idx != sector_idx:
            if sector_idx == 1:
                self._recorder_data.sectors[0] = len(self._recorder_data.coords) - 1
            elif sector_idx == 2:
                self._recorder_data.sectors[1] = len(self._recorder_data.coords) - 1
            self._last_sector_idx = sector_idx

    def __record_path(self, pos_curr: float):
        """Record driving path"""
        # Update if position value is different & positive
        if 0 <= pos_curr != self._pos_last:
            if pos_curr > self._pos_last:  # position further
                gps_curr = (round4(api.read.vehicle.position_longitudinal()),
                            round4(api.read.vehicle.position_lateral()))
                elv_curr = round4(api.read.vehicle.position_vertical())
                self._recorder_data.coords.append(gps_curr)
                self._recorder_data.dists.append((pos_curr, elv_curr))
            self._pos_last = pos_curr  # reset last position

    def __record_end(self):
        """End recording"""
        if self._recorder_data.coords:
            self._temp_data.coords = tuple(self._recorder_data.coords)
            self._temp_data.dists = tuple(self._recorder_data.dists)
            self._temp_data.sectors = tuple(self._recorder_data.sectors)
            self._validating = True

    def load_map(self, filename: str):
        """Load map data file"""
        self._filename = filename
        # Check if same map loaded
        modified = file_last_modified(
            filepath=self._filepath,
            filename=filename,
            extension=FileExt.SVG,
        )
        is_loaded = self.last_modified == modified > 0
        self.last_modified = modified
        if is_loaded:
            self.map_exist = True
            return
        # Load map file
        raw_coords, raw_dists, sectors_index = load_track_map_file(
            filepath=self._filepath,
            filename=filename,
        )
        if raw_coords and raw_dists:
            self.output.coords = raw_coords
            self.output.dists = raw_dists
            self.output.sectors = sectors_index
            self.map_exist = True
            #logger.info("map exist")
        else:
            self.output.clear()
            self.map_exist = False
            #logger.info("map not exist")

    def save_map(self):
        """Store & convert raw coordinates to svg points data"""
        self.output.coords = self._temp_data.coords
        self.output.dists = self._temp_data.dists
        self.output.sectors = self._temp_data.sectors
        # Save to svg file
        save_track_map_file(
            filepath=self._filepath,
            filename=self._filename,
            view_box=calc.svg_view_box(self._temp_data.coords, 20),
            raw_coords=self._temp_data.coords,
            raw_dists=self._temp_data.dists,
            sector_index=self._temp_data.sectors,
        )
        #logger.info("map saved, stopped map recording")

```

# File: tinypedal/module/module_notes.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Notes module
"""

from __future__ import annotations

from typing import Callable, Mapping

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_file import FileExt
from ..module_info import NotesInfo, minfo
from ..userfile.track_notes import (
    COLUMN_DISTANCE,
    HEADER_PACE_NOTES,
    HEADER_TRACK_NOTES,
    load_notes_file,
    parse_csv_notes_only,
)
from ..validator import generator_init
from ._base import DataModule


class Realtime(DataModule):
    """Notes data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        userpath_pace_notes = self.cfg.path.pace_notes
        userpath_track_notes = self.cfg.path.track_notes
        output_pacenotes = minfo.pacenotes
        output_tracknotes = minfo.tracknotes

        setting_playback = self.cfg.user.setting["pace_notes_playback"]

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                    track_name = api.read.session.track_name()

                    # Load pace notes
                    pace_notes = load_pace_notes_file(
                        config=setting_playback,
                        filepath=userpath_pace_notes,
                        filename=track_name,
                        table_header=HEADER_PACE_NOTES,
                        parser=parse_csv_notes_only,
                        extension=FileExt.TPPN,
                    )
                    if pace_notes:
                        gen_pacenotes = notes_selector(
                            output=output_pacenotes,
                            dataset=pace_notes,
                        )

                    # Load track notes
                    track_notes = load_notes_file(
                        filepath=userpath_track_notes,
                        filename=track_name,
                        table_header=HEADER_TRACK_NOTES,
                        parser=parse_csv_notes_only,
                        extension=FileExt.TPTN,
                    )
                    if track_notes:
                        gen_tracknotes = notes_selector(
                            output=output_tracknotes,
                            dataset=track_notes,
                        )

                # Update position
                pos_synced = minfo.delta.lapDistance

                # Update pace notes
                if pace_notes:
                    gen_pacenotes.send(pos_synced + setting_playback["pace_notes_global_offset"])

                # Update track notes
                if track_notes:
                    gen_tracknotes.send(pos_synced)

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval
                    output_pacenotes.reset()
                    output_tracknotes.reset()


def load_pace_notes_file(
    config: dict, filepath: str, filename: str,
    table_header: tuple, parser: Callable, extension: str):
    """Load pace notes"""
    if config["enable_manual_file_selector"]:
        filepath = ""
        filename = config["pace_notes_file_name"]
        extension = ""
    return load_notes_file(
        filepath=filepath,
        filename=filename,
        table_header=table_header,
        parser=parser,
        extension=extension,
    )


@generator_init
def notes_selector(output: NotesInfo, dataset: list[Mapping]):
    """Notes selector

    Args:
        output: module info.
        dataset: list of notes.
    """
    last_index = -99999  # make sure initial index is different
    next_index = 0  # next note line index
    end_index = len(dataset) - 1  # end note line index
    pos_reference = reference_position(dataset)
    pos_final = pos_reference[-1]  # final reference position
    output.reset()  # initial reset before updating

    while True:
        pos_curr = yield
        curr_index = calc.binary_search_lower(pos_reference, pos_curr, 0, end_index)

        if last_index == curr_index:
            continue

        last_index = curr_index
        next_index = (curr_index + 1) * (pos_curr < pos_final)

        output.currentIndex = curr_index
        output.currentNote = dataset[curr_index]
        output.nextIndex = next_index
        output.nextNote = dataset[next_index]


def reference_position(notes: list[Mapping]) -> tuple[float, ...]:
    """Reference notes position list"""
    return tuple(note_line[COLUMN_DISTANCE] for note_line in notes)

```

# File: tinypedal/module/module_relative.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Relative module
"""

from __future__ import annotations

from functools import lru_cache
from itertools import chain
from operator import itemgetter

from .. import realtime_state
from ..api_control import api
from ..calculation import asym_max, zero_max
from ..const_common import MAX_SECONDS, MAX_VEHICLES, REL_TIME_DEFAULT
from ..module_info import minfo
from ._base import DataModule

REF_PLACES = tuple(range(1, MAX_VEHICLES + 1))
TEMP_RELATIVE_AHEAD = [[0, -1] for _ in range(MAX_VEHICLES)]
TEMP_RELATIVE_BEHIND = [[0, -1] for _ in range(MAX_VEHICLES)]
TEMP_CLASSES = [["", -1, -1, -1.0, -1.0] for _ in range(MAX_VEHICLES)]
TEMP_CLASSES_POS = [[0, 1, "", 0.0, -1, -1, -1, False] for _ in range(MAX_VEHICLES)]
TEMP_DRAW_ORDER = list(range(MAX_VEHICLES))


class Realtime(DataModule):
    """Relative & standings data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        output = minfo.relative
        setting_relative = self.cfg.user.setting["relative"]
        setting_standings = self.cfg.user.setting["standings"]
        last_version_update = None

        while not _event_wait(update_interval):
            if not realtime_state.paused:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                # Check setting
                if last_version_update != self.cfg.version_update:
                    last_version_update = self.cfg.version_update
                    show_in_garage = setting_relative["show_vehicle_in_garage"]
                    is_exclusive_mode = setting_standings["enable_single_class_exclusive_mode"]
                    is_split_mode = setting_standings["enable_multi_class_split_mode"]
                    max_veh_front = max_relative_vehicles(
                        setting_relative["additional_players_front"])
                    max_veh_behind = max_relative_vehicles(
                        setting_relative["additional_players_behind"])
                    min_top_veh = min_top_vehicles_in_class(
                        setting_standings["min_top_vehicles"])
                    veh_limit_exclusive = max_vehicles_in_class(
                        setting_standings["max_vehicles_exclusive_mode"], min_top_veh, 2)
                    veh_limit_combined = max_vehicles_in_class(
                        setting_standings["max_vehicles_combined_mode"], min_top_veh, 2)
                    veh_limit_other = max_vehicles_in_class(
                        setting_standings["max_vehicles_per_split_others"], min_top_veh, 0)
                    veh_limit_player = max_vehicles_in_class(
                        setting_standings["max_vehicles_per_split_player"], min_top_veh, 2)

                # Base info
                veh_total = max(api.read.vehicle.total_vehicles(), 1)
                plr_index = api.read.vehicle.player_index()
                plr_place = api.read.vehicle.place()

                # Get vehicles info
                (relative_ahead, relative_behind, classes_list, draw_order_list, is_multi_class,
                 ) = get_vehicles_info(veh_total, plr_index, show_in_garage)

                # Create relative index list
                relative_index_list = create_relative_index(
                    relative_ahead, relative_behind, plr_index, max_veh_front, max_veh_behind)

                # Create vehicle class position list (initially ordered by class name)
                class_pos_list, plr_class_name, plr_class_place = create_position_in_class(
                    classes_list, plr_index)

                # Create standings index list
                if is_exclusive_mode:  # single class exclusive list
                    standings_index_list = standings_index_from_same_class(
                        min_top_veh, class_pos_list, plr_class_name, plr_class_place,
                        veh_limit_exclusive)
                elif is_split_mode and is_multi_class:  # multi-class split list
                    standings_index_list = list(chain(*list(standings_index_from_all_classes(
                        min_top_veh, class_pos_list, plr_class_name, plr_class_place,
                        veh_limit_other, veh_limit_player))))
                else:  # mixed class list
                    classes_list.sort(key=itemgetter(1))  # sort by overall position
                    standings_index_list = calc_standings_index(
                        min_top_veh, veh_limit_combined, plr_place, classes_list, 2)

                # Sort vehicle class position list (by player index) for output
                class_pos_list.sort()

                # Output data
                output.relative = relative_index_list
                output.standings = standings_index_list
                output.classes = class_pos_list
                output.drawOrder = draw_order_list

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval
                    create_reference_place.cache_clear()


def get_vehicles_info(veh_total: int, plr_index: int, show_in_garage: bool):
    """Get vehicles info: relative time gap, classes, places, laptime"""
    laptime_est = api.read.timing.estimated_laptime()
    plr_time = api.read.timing.estimated_time_into()
    last_class_name = None
    classes_count = 0
    recorded_index = 0
    leader_index = 0
    pitter_index = 0
    draw_order = TEMP_DRAW_ORDER[:veh_total]

    for index in range(veh_total):
        in_garage = api.read.vehicle.in_garage(index)
        in_pitlane = api.read.vehicle.in_pits(index) or in_garage

        # Update relative time gap list
        if index != plr_index and laptime_est and (show_in_garage or not in_garage):
            opt_time = api.read.timing.estimated_time_into(index)
            diff_time = opt_time - plr_time
            diff_time_ahead = diff_time_behind = diff_time - diff_time // laptime_est * laptime_est
            if diff_time_ahead < 0:
                diff_time_ahead += laptime_est
            if diff_time_behind > 0:
                diff_time_behind -= laptime_est

            TEMP_RELATIVE_AHEAD[recorded_index][:] = (
                diff_time_ahead,  # 0 relative time gap
                index,  # 1 player index
            )
            TEMP_RELATIVE_BEHIND[recorded_index][:] = (
                diff_time_behind,  # 0 relative time gap
                index,  # 1 player index
            )
            recorded_index += 1

        # Update classes list
        class_name = api.read.vehicle.class_name(index)
        place_overall = api.read.vehicle.place(index)
        laptime_best = api.read.timing.best_laptime(index)
        laptime_last = api.read.timing.last_laptime(index)

        if laptime_last > 0 and not in_pitlane:
            laptime_personal_last = laptime_last
        else:
            laptime_personal_last = MAX_SECONDS

        if laptime_best > 0:
            laptime_personal_best = laptime_best
        else:
            laptime_personal_best = MAX_SECONDS

        TEMP_CLASSES[index][:] = (
            class_name,  # 0 vehicle class name
            place_overall,  # 1 overall position/place
            index,  # 2 player index
            laptime_personal_best,  # 3 best lap time
            laptime_personal_last,  # 4 last lap time (for fastest last lap check)
        )

        # Update draw order list
        if place_overall == 1:  # save leader index
            leader_index = index
        elif in_pitlane:  # swap opponent in pit/garage to start
            draw_order[index], draw_order[pitter_index] = draw_order[pitter_index], draw_order[index]
            pitter_index += 1

        # Check is multi classes
        if classes_count < 2 and last_class_name != class_name:
            last_class_name = class_name
            classes_count += 1

    # Finalize draw order list
    if 0 <= leader_index < veh_total and leader_index != draw_order[-1]:  # move leader to end
        leader_pos = draw_order.index(leader_index)
        draw_order[leader_pos], draw_order[-1] = draw_order[-1], draw_order[leader_pos]
    if 0 <= plr_index < veh_total and plr_index != leader_index:   # move player to 2nd end if not leader
        player_pos = draw_order.index(plr_index)
        draw_order[player_pos], draw_order[-2] = draw_order[-2], draw_order[player_pos]

    # Sort output in-place
    relative_ahead = TEMP_RELATIVE_AHEAD[:recorded_index]
    relative_ahead.sort(reverse=True)  # by reversed time gap

    relative_behind = TEMP_RELATIVE_BEHIND[:recorded_index]
    relative_behind.sort(reverse=True)  # by reversed time gap

    new_classes = TEMP_CLASSES[:veh_total]
    new_classes.sort()  # by vehicle class

    return (
        relative_ahead,
        relative_behind,
        new_classes,  # classes_list
        draw_order,
        classes_count > 1,  # is_multi_class
    )


def create_relative_index(
    relative_ahead: list, relative_behind: list, plr_index: int, max_veh_ahead: int, max_veh_behind: int):
    """Create player-centered relative (time, index) list"""
    ahead_cut = relative_ahead[max(len(relative_ahead) - max_veh_ahead, 0):]
    ahead_diff = max_veh_ahead - len(ahead_cut)
    if ahead_diff > 0:
        ahead_cut = [REL_TIME_DEFAULT] * ahead_diff + ahead_cut
    behind_cut = relative_behind[:min(len(relative_behind), max_veh_behind)]
    behind_diff = max_veh_behind - len(behind_cut)
    if behind_diff > 0:
        behind_cut += [REL_TIME_DEFAULT] * behind_diff
    return ahead_cut + [(0, plr_index)] + behind_cut


def create_position_in_class(sorted_veh_class: list, plr_index: int):
    """Create vehicle position in class list"""
    last_class_name = None
    place_in_class = 0
    opt_index_ahead = -1
    opt_index_leader = -1
    laptime_class_best = MAX_SECONDS
    last_fastest_laptime = MAX_SECONDS
    last_fastest_index = -1
    veh_total = len(sorted_veh_class)
    plr_class_name = ""
    plr_class_place = 0
    slot_index = 0

    for class_name, _, opt_index, laptime_best, laptime_last in sorted_veh_class:
        if last_class_name == class_name:
            place_in_class += 1
            TEMP_CLASSES_POS[slot_index - 1][5] = opt_index  # set opponent index behind
        else:
            last_class_name = class_name  # reset class name
            place_in_class = 1  # reset position counter
            opt_index_ahead = -1  # no opponent ahead of class leader
            opt_index_leader = opt_index
            laptime_class_best = laptime_best
            last_fastest_laptime = MAX_SECONDS  # reset last fastest
            if last_fastest_index != -1:  # mark fastest last lap
                TEMP_CLASSES_POS[last_fastest_index][7] = True
                last_fastest_index = -1  # reset last fastest index

        if opt_index == plr_index:
            plr_class_name = class_name
            plr_class_place = place_in_class

        if last_fastest_laptime > laptime_last:
            last_fastest_laptime = laptime_last
            last_fastest_index = slot_index

        TEMP_CLASSES_POS[slot_index][:] = (
            opt_index,  # 0 - 2 player index
            place_in_class,  # 1 - position in class
            class_name,  # 2 - 0 class name
            laptime_class_best,  # 3 classes best
            opt_index_ahead,  # 4 opponent index ahead
            -1,  # 5 opponent index behind
            opt_index_leader,  # 6 class leader index
            False,  # 7 is class fastest last laptime
        )
        opt_index_ahead = opt_index  # store opponent index for next
        slot_index += 1

    if last_fastest_index != -1:  # mark for last class
        TEMP_CLASSES_POS[last_fastest_index][7] = True

    return TEMP_CLASSES_POS[:veh_total], plr_class_name, plr_class_place


def standings_index_from_all_classes(
    min_top_veh: int, class_pos_list: list, plr_class_name: str, plr_class_place: int,
    veh_limit_other: int, veh_limit_player: int):
    """Generate class standings index list from all classes"""
    class_collection = sorted(split_class_list(class_pos_list), key=sort_class_collection)
    for class_list in class_collection:
        if plr_class_name == class_list[0][2]:  # match class name
            veh_limit = veh_limit_player
            plr_place = plr_class_place  # 1 position in class
        else:
            veh_limit = veh_limit_other
            plr_place = 0
        yield calc_standings_index(min_top_veh, veh_limit, plr_place, class_list, 0)


def standings_index_from_same_class(
    min_top_veh: int, class_pos_list: list, plr_class_name: str, plr_class_place: int,
    veh_limit_player: int):
    """Generate class standings index list from same class only"""
    class_list = list(class_data for class_data in class_pos_list if plr_class_name == class_data[2])
    if not class_list:
        return [-1]
    return calc_standings_index(min_top_veh, veh_limit_player, plr_class_place, class_list, 0)


def calc_standings_index(
    min_top_veh: int, veh_limit: int, plr_place: int, class_index_list: list, column: int):
    """Calculate vehicle standings index list"""
    veh_total = len(class_index_list)
    ref_place_list = create_reference_place(min_top_veh, veh_total, plr_place, veh_limit)
    # Create final standing index list
    return list(standings_index_from_place_reference(ref_place_list, class_index_list, veh_total, column))


@lru_cache(maxsize=20)
def create_reference_place(
    min_top_veh: int, veh_total: int, plr_place: int, veh_limit: int):
    """Create reference place list"""
    if veh_total <= veh_limit:
        return REF_PLACES[:veh_total]
    if plr_place <= min_top_veh:
        return REF_PLACES[:veh_limit]
    # Find nearby slice range relative to player
    max_cut_range = veh_limit - min_top_veh
    # Number of rear slots, should be equal or less than front slots (exclude player slot)
    rear_cut_count = (max_cut_range - 1) // 2  # exclude player slot, then floor divide
    front_cut_count = max_cut_range - rear_cut_count  # include player slot
    # Find front slice limit
    front_cut_raw = plr_place - front_cut_count
    if front_cut_raw < min_top_veh:
        front_cut_raw = min_top_veh
    # Find rear slice limit
    rear_cut_max = front_cut_raw + max_cut_range
    if rear_cut_max > veh_total:
        rear_cut_max = veh_total
    front_cut_max = rear_cut_max - max_cut_range
    return REF_PLACES[:min_top_veh] + REF_PLACES[front_cut_max:rear_cut_max]


def standings_index_from_place_reference(
    ref_place_list: tuple, class_index_list: list, veh_total: int, column: int):
    """Match place from reference list to generate standings player index list"""
    for ref_index in ref_place_list:
        if 0 < ref_index <= veh_total:  # prevent out of range
            yield class_index_list[ref_index - 1][column]  # column - player index
        else:
            break
    yield -1  # append an empty index as gap between classes


def split_class_list(class_list: list):
    """Split class list into class collection"""
    class_name = class_list[0][2]
    index_start = 0
    index_end = 0
    for vehicle in class_list:
        if vehicle[2] == class_name:
            index_end +=1
        elif vehicle[2] != class_name:
            class_name = vehicle[2]
            yield class_list[index_start:index_end]
            index_start = index_end
            index_end +=1
    # Final split
    yield class_list[index_start:index_end]


def max_relative_vehicles(add_veh: int):
    """Maximum number of vehicles in relative list"""
    return int(zero_max(add_veh, 60)) + 3


def min_top_vehicles_in_class(min_top_veh: int) -> int:
    """Minimum number of top vehicles in class list

    min_top_veh: value range limited in 1 to 5
    """
    return int(asym_max(min_top_veh, 1, 5))


def max_vehicles_in_class(max_cls_veh: int, min_top_veh: int, min_add_veh: int = 0) -> int:
    """Maximum number of vehicles in class list

    max_cls_veh: maximum vehicles per class limit
    min_top_veh: minimum top vehicles limit
    min_add_veh: minimum addition vehicles limit (for class has local player)
    """
    return max(int(max_cls_veh), min_top_veh + min_add_veh)


def sort_class_collection(collection: list) -> float:
    """Sort class collection by class best laptime"""
    return collection[0][3]  # 3 class best laptime

```

# File: tinypedal/module/module_sectors.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Sectors module
"""

from __future__ import annotations

from .. import realtime_state
from ..api_control import api
from ..const_common import MAX_SECONDS
from ..module_info import SectorsInfo, minfo
from ..userfile.sector_best import load_sector_best_file, save_sector_best_file
from ..validator import generator_init, valid_sectors
from ._base import DataModule, round6


class Realtime(DataModule):
    """Sectors data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        userpath_sector_best = self.cfg.path.sector_best

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                    combo_name = api.read.session.combo_name()
                    session_id = api.read.session.identifier()
                    (best_s_tb, best_s_pb, all_best_s_tb, all_best_s_pb
                     ) = load_sector_best_file(
                        filepath=userpath_sector_best,
                        filename=combo_name,
                        session_id=session_id,
                        defaults=[MAX_SECONDS, MAX_SECONDS, MAX_SECONDS],
                    )

                    if self.mcfg["enable_all_time_best_sectors"]:
                        gen_calc_sectors_session = calc_sectors(None, best_s_tb, best_s_pb)
                        gen_calc_sectors_alltime = calc_sectors(minfo.sectors, all_best_s_tb, all_best_s_pb)
                    else:
                        gen_calc_sectors_session = calc_sectors(minfo.sectors, best_s_tb, best_s_pb)
                        gen_calc_sectors_alltime = calc_sectors(None, all_best_s_tb, all_best_s_pb)

                # Run calculation
                tele_sectors = telemetry_sectors()
                gen_calc_sectors_session.send(tele_sectors)
                gen_calc_sectors_alltime.send(tele_sectors)

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval

                    best_s_tb, best_s_pb, new_best_session = gen_calc_sectors_session.send(tele_sectors)
                    all_best_s_tb, all_best_s_pb, new_best_all = gen_calc_sectors_alltime.send(tele_sectors)
                    if new_best_all or new_best_session:
                        save_sector_best_file(
                            filepath=userpath_sector_best,
                            filename=combo_name,
                            dataset=(
                                session_id,
                                list(map(round6, best_s_tb)),
                                list(map(round6, best_s_pb)),
                                list(map(round6, all_best_s_tb)),
                                list(map(round6, all_best_s_pb))
                            ),
                        )


def telemetry_sectors() -> tuple[int, float, float, float, float]:
    """Telemetry sectors"""
    sector_idx = api.read.lap.sector_index()
    laptime_valid = api.read.timing.last_laptime()
    curr_sector1 = api.read.timing.current_sector1()
    curr_sector2 = api.read.timing.current_sector2()
    last_sector2 = api.read.timing.last_sector2()
    return sector_idx, laptime_valid, curr_sector1, curr_sector2, last_sector2


@generator_init
def calc_sectors(output: SectorsInfo, best_s_tb: list[float], best_s_pb: list[float]):
    """Calculate sectors data"""
    no_delta_s = True
    new_best = False  # save check whether new sector best time is set
    last_sector_idx = -1  # previous recorded sector index value
    delta_s_tb = [0.0] * 3  # deltabest times against all time best sector
    delta_s_pb = [0.0] * 3  # deltabest times against best laptime sector
    prev_s = [MAX_SECONDS, MAX_SECONDS, MAX_SECONDS]  # previous sector times
    laptime_best = sum(best_s_pb)

    while True:
        (sector_idx, laptime_valid, curr_sector1, curr_sector2, last_sector2
         ) = yield best_s_tb, best_s_pb, new_best

        # Update previous & best sector time
        if last_sector_idx != sector_idx:  # keep checking until conditions met

            # While vehicle in S1, update S3 data
            if sector_idx == 0 and laptime_valid > 0 and last_sector2 > 0:
                last_sector_idx = sector_idx  # reset & stop checking

                prev_s[2] = laptime_valid - last_sector2

                # Update (time gap) deltabest bestlap sector 3
                if valid_sectors(best_s_pb[2]):
                    delta_s_pb[2] = prev_s[2] - best_s_pb[2]

                # Update deltabest sector 3
                if valid_sectors(best_s_tb[2]):
                    delta_s_tb[2] = prev_s[2] - best_s_tb[2]
                    no_delta_s = False
                else:
                    no_delta_s = True

                # Save best sector 3 time
                if prev_s[2] < best_s_tb[2]:
                    best_s_tb[2] = prev_s[2]
                    new_best = True

                # Save sector time from personal best laptime
                if laptime_valid < laptime_best and valid_sectors(prev_s):
                    laptime_best = laptime_valid
                    best_s_pb = prev_s.copy()
                    new_best = True

            # While vehicle in S2, update S1 data
            elif sector_idx == 1 and curr_sector1 > 0:
                last_sector_idx = sector_idx  # reset

                prev_s[0] = curr_sector1

                # Update (time gap) deltabest bestlap sector 1
                if valid_sectors(best_s_pb[0]):
                    delta_s_pb[0] = prev_s[0] - best_s_pb[0]

                # Update deltabest sector 1
                if valid_sectors(best_s_tb[0]):
                    delta_s_tb[0] = prev_s[0] - best_s_tb[0]
                    no_delta_s = False
                else:
                    no_delta_s = True

                # Save best sector 1 time
                if prev_s[0] < best_s_tb[0]:
                    best_s_tb[0] = prev_s[0]
                    new_best = True

            # While vehicle in S3, update S2 data
            elif sector_idx == 2 and curr_sector2 > 0 and curr_sector1 > 0:
                last_sector_idx = sector_idx  # reset

                prev_s[1] = curr_sector2 - curr_sector1

                # Update (time gap) deltabest bestlap sector 2
                if valid_sectors(best_s_pb[1]):
                    delta_s_pb[1] = prev_s[1] - best_s_pb[1]

                # Update deltabest sector 2
                if valid_sectors(best_s_tb[1]):
                    delta_s_tb[1] = prev_s[1] - best_s_tb[1]
                    no_delta_s = False
                else:
                    no_delta_s = True

                # Save best sector 2 time
                if prev_s[1] < best_s_tb[1]:
                    best_s_tb[1] = prev_s[1]
                    new_best = True

            # Output sectors data
            if output:
                output.noDeltaSector = no_delta_s
                output.sectorIndex = sector_idx
                output.sectorPrev[:] = prev_s
                output.sectorBestTB[:] = best_s_tb
                output.sectorBestPB[:] = best_s_pb
                output.deltaSectorBestPB[:] = delta_s_pb
                output.deltaSectorBestTB[:] = delta_s_tb

```

# File: tinypedal/module/module_stats.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Stats module
"""

from __future__ import annotations

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_common import FLOAT_INF, POS_XYZ_INF
from ..module_info import minfo
from ..userfile.driver_stats import DriverStats, load_driver_stats, save_driver_stats
from ._base import DataModule


class Realtime(DataModule):
    """Delta time data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        output = minfo.stats
        max_moved_distance = 1500 * update_interval
        podium_by_class = self.mcfg["enable_podium_by_class"]
        vehicle_class = self.mcfg["vehicle_classification"]

        while not _event_wait(update_interval):

            # Ignore stats while in spectate or override mode
            if realtime_state.spectating or realtime_state.overriding:
                if reset:
                    reset = False  # make sure stats not saved
                    update_interval = self.idle_interval
                continue

            if realtime_state.active:
                if not reset:

                    reset = True
                    update_interval = self.active_interval

                    # Load driver stats
                    loaded_stats = load_driver_stats(
                        key_list=self.stats_keys(vehicle_class),
                        filepath=self.cfg.path.config,
                    )
                    driver_stats = DriverStats()
                    is_pit_lap = 0
                    last_lap_stime = FLOAT_INF
                    last_lap_etime = FLOAT_INF
                    last_best_laptime = FLOAT_INF
                    last_raw_laptime = FLOAT_INF
                    last_num_penalties = 99999
                    fuel_last = 0.0
                    last_finish_state = 99999
                    gps_last = POS_XYZ_INF

                # General
                lap_stime = api.read.timing.start()
                lap_etime = api.read.timing.elapsed()
                is_pit_lap |= api.read.vehicle.in_pits()
                session_type = api.read.session.session_type()

                # Best lap time
                last_valid_laptime = api.read.timing.last_laptime()
                if (last_best_laptime > last_valid_laptime > 1 and
                    abs(last_valid_laptime - last_raw_laptime) < 0.001):  # validate lap time
                    last_best_laptime = last_valid_laptime
                    # Personal best (any session)
                    if driver_stats.pb > last_valid_laptime:
                        driver_stats.pb = last_valid_laptime
                    # Qualifying best
                    if session_type == 2:
                        if driver_stats.qb > last_valid_laptime:
                            driver_stats.qb = last_valid_laptime
                    # Race best
                    elif session_type == 4:
                        if driver_stats.rb > last_valid_laptime:
                            driver_stats.rb = last_valid_laptime

                # Driven distance
                gps_curr = api.read.vehicle.position_xyz()
                if gps_last != gps_curr:
                    moved_distance = calc.distance(gps_last, gps_curr)
                    if moved_distance < max_moved_distance:
                        driver_stats.meters += moved_distance
                    gps_last = gps_curr

                # Laps complete
                if last_lap_stime > lap_stime:
                    last_lap_stime = lap_stime
                elif last_lap_stime < lap_stime and lap_etime - lap_stime > 2:
                    last_raw_laptime = lap_stime - last_lap_stime
                    if last_valid_laptime > 0: # valid lap check
                        driver_stats.valid += 1  # 1 lap at a time
                    elif not is_pit_lap:  # only count non-pit invalid lap
                        driver_stats.invalid += 1
                    is_pit_lap = 0
                    last_lap_stime = lap_stime

                # Seconds spent
                if last_lap_etime > lap_etime:
                    last_lap_etime = lap_etime
                elif last_lap_etime < lap_etime:
                    if api.read.vehicle.speed() > 1:  # while speed > 1m/s
                        driver_stats.seconds += lap_etime - last_lap_etime
                    last_lap_etime = lap_etime

                # Fuel consumed (liter)
                fuel_curr = api.read.vehicle.fuel()
                if fuel_last < fuel_curr:
                    fuel_last = fuel_curr
                elif fuel_last > fuel_curr:
                    driver_stats.liters += fuel_last - fuel_curr
                    fuel_last = fuel_curr

                # Race session stats
                if session_type == 4:
                    # Penalties
                    num_penalties = api.read.vehicle.number_penalties()
                    if last_num_penalties > num_penalties:
                        last_num_penalties = num_penalties
                    elif last_num_penalties < num_penalties:
                        driver_stats.penalties += num_penalties - last_num_penalties
                        last_num_penalties = num_penalties

                    # Finish place
                    finish_state = api.read.vehicle.finish_state()
                    if last_finish_state > finish_state:
                        last_finish_state = finish_state
                    elif 0 == last_finish_state < finish_state:
                        last_finish_state = finish_state
                        if finish_state == 1:  # finished
                            driver_stats.races += 1
                            finish_place = finish_position(podium_by_class)
                            if finish_place == 1:
                                driver_stats.wins += 1
                            if finish_place <= 3:
                                driver_stats.podiums += 1

                # Output stats data
                output.metersDriven = driver_stats.meters + loaded_stats.meters

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval
                    save_driver_stats(
                        key_list=self.stats_keys(vehicle_class),
                        stats_update=driver_stats,
                        filepath=self.cfg.path.config,
                    )

    def stats_keys(self, vehicle_class: str) -> tuple[str, str]:
        """Stats key names"""
        if vehicle_class == "Class":
            name = api.read.vehicle.class_name()
        elif vehicle_class == "Class - Brand":
            brand_name = self.cfg.user.brands.get(api.read.vehicle.vehicle_name(), "")
            class_name = api.read.vehicle.class_name()
            if brand_name:
                name = f"{class_name} - {brand_name}"
            else:  # fallback to class name
                name = class_name
        else:
            name = api.read.vehicle.vehicle_name()
        return api.read.session.track_name(), name


def finish_position(podium_by_class: bool) -> int:
    """Get finish position"""
    # Overall position
    plr_place = api.read.vehicle.place()
    if not podium_by_class:
        return plr_place
    # Position in class
    veh_total = api.read.vehicle.total_vehicles()
    plr_class = api.read.vehicle.class_name()
    total_class_vehicle = 0
    place_higher = 0
    for index in range(veh_total):
        if api.read.vehicle.class_name(index) == plr_class:
            total_class_vehicle += 1
            if api.read.vehicle.place(index) > plr_place:
                place_higher += 1
    return total_class_vehicle - place_higher

```

# File: tinypedal/module/module_vehicles.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Vehicles module
"""

from __future__ import annotations

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_common import MAX_METERS, MAX_SECONDS
from ..module_info import VehicleDataSet, VehiclesInfo, minfo
from ..validator import state_timer
from ._base import DataModule


class Realtime(DataModule):
    """Vehicles info"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        output = minfo.vehicles
        max_lap_diff_ahead = self.mcfg["lap_difference_ahead_threshold"]
        max_lap_diff_behind = self.mcfg["lap_difference_behind_threshold"]

        gen_low_priority_timer = state_timer(0.2)

        while not _event_wait(update_interval):
            if not realtime_state.paused:

                if not reset:
                    reset = True
                    update_interval = self.active_interval
                    output.dataSetVersion = -1
                    last_veh_total = 0

                veh_total = output.totalVehicles = api.read.vehicle.total_vehicles()
                if veh_total > 0:
                    update_vehicle_data(
                        output,
                        max_lap_diff_ahead,
                        max_lap_diff_behind,
                        next(gen_low_priority_timer),
                    )

                if last_veh_total != veh_total:
                    last_veh_total = veh_total
                    if veh_total > 0:
                        update_qualify_position(output)

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval


def update_vehicle_data(
    output: VehiclesInfo,
    max_lap_diff_ahead: float,
    max_lap_diff_behind: float,
    update_low_priority: bool,
) -> None:
    """Update vehicle data"""
    nearest_line = MAX_METERS
    nearest_time_behind = -MAX_SECONDS
    nearest_yellow_ahead = MAX_METERS
    nearest_yellow_behind = -MAX_METERS

    # Counter
    total_completed_laps = 0
    total_out_pits = 0
    total_in_pits = 0
    total_stopped_pits = 0
    total_pit_requests = 0

    # General data
    track_length = api.read.lap.track_length()
    in_race = api.read.session.in_race()
    speedtrap_distance = minfo.mapping.speedTrapPosition

    # Local player data
    elapsed_time = api.read.timing.elapsed()
    plr_lap_distance = api.read.lap.distance()
    plr_lap_progress_total = api.read.lap.completed_laps() + calc.lap_progress_distance(plr_lap_distance, track_length)
    plr_laptime_est = api.read.timing.estimated_laptime()
    plr_timeinto_est = api.read.timing.estimated_time_into()
    plr_pos_x = api.read.vehicle.position_longitudinal()
    plr_pos_y = api.read.vehicle.position_lateral()
    plr_ori_yaw = api.read.vehicle.orientation_yaw_radians()

    # Update dataset from all vehicles in current session
    for index, data, class_pos in zip(range(output.totalVehicles), output.dataSet, minfo.relative.classes):
        # Temp var only
        laps_completed = api.read.lap.completed_laps(index)
        lap_distance = api.read.lap.distance(index)
        speed = api.read.vehicle.speed(index)

        # Update high priority info
        data.isPlayer = api.read.vehicle.is_player(index)
        data.currentLapProgress = calc.lap_progress_distance(lap_distance, track_length)
        data.totalLapProgress = laps_completed + data.currentLapProgress
        data.isYellow = speed < 8
        data.inPit = api.read.vehicle.in_paddock(index)
        data.pitTimer.update(api.read.vehicle.slot_id(index), data.inPit, elapsed_time, laps_completed, speed)

        if not data.inPit:
            data.speedTrap.update(speed, lap_distance, speedtrap_distance, track_length)

        if data.isPlayer:
            data.elapsedTime = elapsed_time
            data.worldPositionX = plr_pos_x
            data.worldPositionY = plr_pos_y
            output.playerIndex = index
            if data.isYellow:
                nearest_yellow_ahead = 0.0
                nearest_yellow_behind = 0.0
        else:
            # Relative position & orientation
            opt_etime = api.read.timing.elapsed(index)
            if data.elapsedTime != opt_etime:
                opt_pos_x = api.read.vehicle.position_longitudinal(index)
                opt_pos_y = api.read.vehicle.position_lateral(index)
                opt_ori_yaw = api.read.vehicle.orientation_yaw_radians(index)
                # Player data update rate may be (twice) higher than opponents
                # Interpolate coordinates to avoid desync
                est_pos_x, est_pos_y = interp_coordinate(
                    opt_pos_x,
                    data.worldPositionX,
                    opt_pos_y,
                    data.worldPositionY,
                    opt_etime,
                    data.elapsedTime,
                    elapsed_time,
                )
                data.worldPositionX = opt_pos_x
                data.worldPositionY = opt_pos_y
                data.elapsedTime = opt_etime

                data.relativeOrientationRadians = opt_ori_yaw - plr_ori_yaw
                data.relativeRotatedPositionX, data.relativeRotatedPositionY = calc.rotate_coordinate(
                    plr_ori_yaw - 3.14159265,  # plr_ori_rad, rotate view
                    est_pos_x - plr_pos_x,  # x position related to player
                    est_pos_y - plr_pos_y,  # y position related to player
                )
                # Relative distance & time gap
                data.relativeStraightDistance = calc.distance(
                    (plr_pos_x, plr_pos_y),
                    (est_pos_x, est_pos_y)
                )

                data.isLapped = calc.lap_difference(
                    data.totalLapProgress, plr_lap_progress_total,
                    max_lap_diff_ahead, max_lap_diff_behind
                ) if in_race else 0

            # Nearest straight line distance (non local players)
            if nearest_line > data.relativeStraightDistance:
                nearest_line = data.relativeStraightDistance
            # Nearest traffic time gap (opponents behind local players)
            if not data.inPit:
                opt_time_behind = calc.circular_relative_distance(
                    plr_laptime_est,
                    plr_timeinto_est,
                    api.read.timing.estimated_time_into(index),
                )
                if 0 > opt_time_behind > nearest_time_behind:
                    nearest_time_behind = opt_time_behind
            # Nearest yellow flag distance
            if data.isYellow:
                opt_rel_distance = calc.circular_relative_distance(
                    track_length, plr_lap_distance, lap_distance)
                if nearest_yellow_ahead > opt_rel_distance >= 0:
                    nearest_yellow_ahead = opt_rel_distance
                if nearest_yellow_behind < opt_rel_distance <= 0:
                    nearest_yellow_behind = opt_rel_distance

        # Update low priority info
        if update_low_priority:
            opt_index_ahead = class_pos[4]
            opt_index_leader = class_pos[6]
            data.positionInClass = class_pos[1]
            data.classBestLapTime = class_pos[3]
            data.isClassFastestLastLap = class_pos[7]

            data.positionOverall = api.read.vehicle.place(index)
            data.lastLapTime = api.read.timing.last_laptime(index)
            data.bestLapTime = api.read.timing.best_laptime(index)
            data.numPitStops = api.read.vehicle.number_pitstops(index, api.read.vehicle.number_penalties(index))
            data.pitRequested = api.read.vehicle.pit_request(index)
            data.driverName = api.read.vehicle.driver_name(index)
            data.vehicleName = api.read.vehicle.vehicle_name(index)
            data.vehicleClass = api.read.vehicle.class_name(index)
            data.tireCompoundFront = f"{data.vehicleClass} - {api.read.tyre.compound_name_front(index)}"
            data.tireCompoundRear = f"{data.vehicleClass} - {api.read.tyre.compound_name_rear(index)}"

            data.gapBehindNext = calc_gap_behind_next(index)
            data.gapBehindLeader = calc_gap_behind_leader(index)
            data.gapBehindNextInClass = calc_time_gap_behind(opt_index_ahead, index, track_length, data.totalLapProgress)
            data.gapBehindLeaderInClass = calc_time_gap_behind(opt_index_leader, index, track_length, data.totalLapProgress)

            data.vehicleIntegrity = api.read.vehicle.integrity(index)
            data.lapTimeHistory.update(api.read.timing.start(index), elapsed_time, data.lastLapTime)

            update_stint_usage(data, laps_completed)

            # Update counter
            total_completed_laps += laps_completed

            if data.inPit == 1:  # in pit (exclude garage)
                total_in_pits += 1
                total_stopped_pits += (speed < 0.1)
            elif data.inPit == 0:  # out pit
                total_out_pits += 1
                total_pit_requests += data.pitRequested

            # Save leader info
            if data.positionOverall == 1:
                output.leaderIndex = index
                output.leaderBestLapTime = data.bestLapTime

    # Output extra info
    output.nearestLine = nearest_line
    output.nearestTraffic = -nearest_time_behind
    output.nearestYellowAhead = nearest_yellow_ahead
    output.nearestYellowBehind = nearest_yellow_behind
    output.dataSetVersion += 1

    if update_low_priority:
        output.totalOutPits = total_out_pits
        output.totalInPits = total_in_pits
        output.totalStoppedPits = total_stopped_pits
        output.totalPitRequests = total_pit_requests
        output.totalCompletedLaps = total_completed_laps


def interp_coordinate(
    pos_curr_x: float,
    pos_last_x: float,
    pos_curr_y: float,
    pos_last_y: float,
    etime_curr: float,
    etime_last: float,
    etime_player: float,
) -> tuple[float, float]:
    """Interpolate coordinates based on time & coordinate delta"""
    etime_diff = etime_player - etime_curr
    if etime_diff <= 0:
        return pos_curr_x, pos_curr_y
    etime_frac = etime_diff / (etime_curr - etime_last)
    return (
        (pos_curr_x - pos_last_x) * etime_frac + pos_curr_x,
        (pos_curr_y - pos_last_y) * etime_frac + pos_curr_y,
    )


def update_qualify_position(output: VehiclesInfo) -> None:
    """Update qualify position"""
    temp_class = sorted((
        api.read.vehicle.class_name(index),  # 0 class name
        api.read.vehicle.qualification(index),  # 1 qualification position
        index,  # 2 player index
    ) for index in range(output.totalVehicles))
    # Update position
    qualify_in_class = 0
    last_class_name = None
    for class_name, qualify_overall, plr_index in temp_class:
        if last_class_name != class_name:
            last_class_name = class_name
            qualify_in_class = 1
        else:
            qualify_in_class += 1
        output.dataSet[plr_index].qualifyOverall = qualify_overall
        output.dataSet[plr_index].qualifyInClass = qualify_in_class


def calc_time_gap_behind(
    ahead_index: int,
    behind_index: int,
    track_length: float,
    lap_progress_total: float,
) -> float:
    """Calculate interval behind next in class"""
    if ahead_index < 0:
        return 0.0
    opt_lap_progress = calc.lap_progress_distance(api.read.lap.distance(ahead_index), track_length)
    opt_lap_progress_total = api.read.lap.completed_laps(ahead_index) + opt_lap_progress
    lap_diff = opt_lap_progress_total - lap_progress_total
    if lap_diff >= 1 or lap_diff <= -1:  # laps
        return int(abs(lap_diff))
    # Time gap between driver ahead and behind
    time_gap = api.read.timing.estimated_time_into(ahead_index) - api.read.timing.estimated_time_into(behind_index)
    # Check lap diff (positive) for position correction
    # in case the ahead driver is momentarily behind (such as during double-file formation lap)
    if time_gap < 0 < lap_diff:
        time_gap += api.read.timing.estimated_laptime(behind_index)
    return abs(time_gap)


def calc_gap_behind_next(index: int) -> float:
    """Calculate interval behind next"""
    laps_behind_next = api.read.lap.behind_next(index)
    if laps_behind_next > 0:
        return laps_behind_next
    return api.read.timing.behind_next(index)


def calc_gap_behind_leader(index: int) -> float:
    """Calculate interval behind leader"""
    laps_behind_leader = api.read.lap.behind_leader(index)
    if laps_behind_leader > 0:
        return laps_behind_leader
    return api.read.timing.behind_leader(index)


def update_stint_usage(data: VehicleDataSet, laps_completed: int) -> None:
    """Update stint usage data"""
    (ve_remaining, ve_used, total_laps_done, stint_laps_est, stint_laps_done
     ) = api.read.vehicle.stint_usage(data.driverName)

    # Estimated stint laps
    data.estimatedStintLaps = stint_laps_est
    if stint_laps_done > 0:
        data.currentStintLaps = stint_laps_done
    else:
        data.currentStintLaps = laps_completed - data.pitTimer.lap_stopped

    # Stint energy usage
    if ve_remaining <= -1.0 or ve_used <= 0 or (data.pitTimer.pitting and not data.inPit):
        data.energyRemaining = ve_remaining
    else:  # Apply linear interpolation at 95% of expected lap usage
        data.energyRemaining = ve_remaining - ve_used * 0.95 * (data.totalLapProgress - total_laps_done)

```

# File: tinypedal/module/module_wheels.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Wheels module
"""

import logging
from collections import deque

from .. import calculation as calc
from .. import realtime_state
from ..api_control import api
from ..const_common import FLOAT_INF, POS_XY_ZERO, WHEELS_DELTA_DEFAULT, WHEELS_ZERO
from ..module_info import WheelsInfo, minfo
from ..userfile.heatmap import (
    brake_failure_thickness,
    save_brake_failure_thickness,
    set_predefined_brake_name,
)
from ..validator import generator_init
from ._base import DataModule

logger = logging.getLogger(__name__)


class Realtime(DataModule):
    """Wheels data"""

    __slots__ = ()

    def __init__(self, config, module_name):
        super().__init__(config, module_name)

    def update_data(self):
        """Update module data"""
        _event_wait = self._event.wait
        reset = False
        update_interval = self.idle_interval

        gen_wheel_rotation = calc_wheel_rotation(
            output=minfo.wheels,
            max_rot_bias_f=max(self.mcfg["maximum_rotation_difference_front"], 0.00001),
            max_rot_bias_r=max(self.mcfg["maximum_rotation_difference_rear"], 0.00001),
            min_rot_axle=max(self.mcfg["minimum_axle_rotation"], 0.0),
        )
        gen_tyre_wear = calc_tyre_wear(
            output=minfo.wheels,
            min_delta_distance=self.mcfg["minimum_delta_distance"],
        )
        gen_brake_wear = calc_brake_wear(
            output=minfo.wheels,
            min_delta_distance=self.mcfg["minimum_delta_distance"],
        )
        gen_susp_travel = calc_suspension_travel(
            output=minfo.wheels,
            average_samples=self.mcfg["average_suspension_position_samples"],
            average_margin=max(self.mcfg["average_suspension_position_margin"], 0.1),
            wheel_liftoff=self.mcfg["wheel_lift_off_threshold"],
            enable_offroad=self.mcfg["enable_suspension_measurement_while_offroad"]
        )
        gen_cornering_radius = calc_cornering_radius(
            output=minfo.wheels,
            sampling_interval=self.mcfg["cornering_radius_sampling_interval"],
        )
        last_session_elapsed = -1

        while not _event_wait(update_interval):
            if realtime_state.active:

                if not reset:
                    reset = True
                    update_interval = self.active_interval

                # Reset condition
                session_elapsed = api.read.session.elapsed()
                is_new_session = (last_session_elapsed > session_elapsed)
                last_session_elapsed = session_elapsed

                in_garage = api.read.vehicle.in_garage() or is_new_session
                in_pits = api.read.vehicle.in_pits() or is_new_session

                # Run calculate
                gen_wheel_rotation.send(in_garage)
                gen_tyre_wear.send(in_garage)
                gen_brake_wear.send(in_garage)
                gen_susp_travel.send(in_pits)
                gen_cornering_radius.send(True)

            else:
                if reset:
                    reset = False
                    update_interval = self.idle_interval


@generator_init
def calc_wheel_rotation(output: WheelsInfo, max_rot_bias_f: float, max_rot_bias_r: float, min_rot_axle: float):
    """Calculate wheel rotation, radius, locking percent, slip ratio"""
    last_reset = None  # reset check

    vehicle_name = ""
    radius_front_ema = 0.0
    radius_rear_ema = 0.0
    last_accel_max = 0.0
    locking_f = 1.0
    locking_r = 1.0

    while True:
        reset = yield None

        # Reset
        if last_reset != reset:
            last_reset = reset
            last_accel_max = 0.0
            locking_f = 1.0
            locking_r = 1.0
            if vehicle_name != api.read.vehicle.vehicle_name():
                vehicle_name = api.read.vehicle.vehicle_name()
                radius_front_ema = 0.0
                radius_rear_ema = 0.0

        wheel_rot = api.read.wheel.rotation()
        speed = api.read.vehicle.speed()
        accel_max = max(
            abs(api.read.vehicle.accel_lateral()),
            abs(api.read.vehicle.accel_longitudinal()),
        )

        # Get wheel axle rotation and difference
        rot_axle_f = calc.wheel_axle_rotation(wheel_rot[0], wheel_rot[1])
        rot_axle_r = calc.wheel_axle_rotation(wheel_rot[2], wheel_rot[3])
        rot_bias_f = calc.wheel_rotation_bias(rot_axle_f, wheel_rot[0], wheel_rot[1])
        rot_bias_r = calc.wheel_rotation_bias(rot_axle_r, wheel_rot[2], wheel_rot[3])

        if rot_axle_f < -min_rot_axle:
            locking_f = calc.differential_locking_percent(rot_axle_f, wheel_rot[0])
        if rot_axle_r < -min_rot_axle:
            locking_r = calc.differential_locking_percent(rot_axle_r, wheel_rot[2])

        # Record wheel radius value within max rotation difference
        if last_accel_max != accel_max:  # check if game paused
            last_accel_max = accel_max
            d_factor = 2 / max(40 * accel_max, 20)  # scale ema factor with max accel
            # Front average wheel radius
            if rot_axle_f < -min_rot_axle and 0 < rot_bias_f < max_rot_bias_f:
                radius_front_ema = calc.exp_mov_avg(d_factor, radius_front_ema, calc.rot2radius(speed, rot_axle_f))
            # Rear average wheel radius
            if rot_axle_r < -min_rot_axle and 0 < rot_bias_r < max_rot_bias_r:
                radius_rear_ema = calc.exp_mov_avg(d_factor, radius_rear_ema, calc.rot2radius(speed, rot_axle_r))

        # Output wheels data
        output.lockingPercentFront = locking_f
        output.lockingPercentRear = locking_r
        output.slipRatio[0] = calc.slip_ratio(wheel_rot[0], radius_front_ema, speed)
        output.slipRatio[1] = calc.slip_ratio(wheel_rot[1], radius_front_ema, speed)
        output.slipRatio[2] = calc.slip_ratio(wheel_rot[2], radius_rear_ema, speed)
        output.slipRatio[3] = calc.slip_ratio(wheel_rot[3], radius_rear_ema, speed)


@generator_init
def calc_tyre_wear(output: WheelsInfo, min_delta_distance: float):
    """Calculate tyre wear & delta wear"""
    last_reset = None  # reset check

    last_lap_stime = 0.0  # last lap start time
    tread_last = list(WHEELS_ZERO)  # last moment remaining tread
    tread_wear_curr = list(WHEELS_ZERO)  # current lap tread wear
    tread_wear_valid = list(WHEELS_ZERO)  # valid last lap tread wear

    is_pit_lap = 0  # whether pit in or pit out lap
    delta_recording = False
    delta_array_raw = [WHEELS_DELTA_DEFAULT]  # distance, wear diff
    delta_array_last = tuple(delta_array_raw)
    is_valid_delta = False
    pos_last = 0.0  # last checked vehicle position

    while True:
        reset = yield None

        # Reset
        if last_reset != reset:
            last_reset = reset
            tread_last[:] = WHEELS_ZERO
            tread_wear_curr[:] = WHEELS_ZERO
            tread_wear_valid[:] = WHEELS_ZERO
            delta_array_raw[:] = (WHEELS_DELTA_DEFAULT,)
            delta_array_last = (WHEELS_DELTA_DEFAULT,)
            is_valid_delta = False
            last_lap_stime = 0.0
            output.lastLapTreadWear[:] = WHEELS_ZERO

        tread_curr_set = api.read.tyre.wear()
        lap_stime = api.read.timing.start()
        laptime_curr = api.read.timing.current_laptime()
        pos_curr = api.read.lap.distance()
        in_pits = api.read.vehicle.in_pits()
        is_pit_lap |= in_pits

        if lap_stime != last_lap_stime:
            last_lap_stime = lap_stime  # reset time stamp counter
            output.lastLapTreadWear[:] = tread_wear_curr
            # Update delta array for non-pit lap
            if len(delta_array_raw) > 1 and not is_pit_lap:
                delta_array_last = tuple(delta_array_raw)
                tread_wear_valid[:] = tread_wear_curr
            elif not is_valid_delta:  # save for first/out lap
                tread_wear_valid[:] = tread_wear_curr
            tread_wear_curr[:] = WHEELS_ZERO
            delta_array_raw[:] = (WHEELS_DELTA_DEFAULT,)
            delta_recording = laptime_curr < 1
            is_valid_delta = len(delta_array_last) > 1
            pos_last = pos_curr
            is_pit_lap = 0

        # Distance desync check at start of new lap, reset if higher than normal distance
        if 0 < laptime_curr < 1 and pos_curr > 300:
            pos_last = pos_curr = 0
        elif pos_last > pos_curr:
            pos_last = pos_curr

        # Update if position value is different & positive
        if delta_recording and pos_curr - pos_last >= min_delta_distance:
            delta_array_raw.append((pos_curr, *tread_wear_curr))
            pos_last = pos_curr

        # Find delta data index
        if is_valid_delta and laptime_curr > 0.3:
            index_higher = calc.binary_search_higher_column(
                delta_array_last, pos_curr, 0, len(delta_array_last) - 1)
        else:
            index_higher = 0

        # Calculate wear difference & accumulated wear
        for idx, tread_curr in enumerate(tread_curr_set):
            tread_curr *= 100  # fraction to percent

            # Ignore wear difference while in pit
            if in_pits:
                wear_diff = 0.0
            else:
                wear_diff = tread_last[idx] - tread_curr
            tread_last[idx] = tread_curr
            if wear_diff > 0:
                tread_wear_curr[idx] += wear_diff

            # Delta wear
            if index_higher > 0:
                delta_wear = tread_wear_curr[idx] - calc.linear_interp(
                    pos_curr,
                    delta_array_last[index_higher - 1][0],
                    delta_array_last[index_higher - 1][idx + 1],
                    delta_array_last[index_higher][0],
                    delta_array_last[index_higher][idx + 1],
                )
            else:
                delta_wear = 0.0

            # Estimate wear
            if is_valid_delta:
                est_wear = tread_wear_valid[idx] + delta_wear
                est_valid_wear = tread_wear_valid[idx] if is_pit_lap else est_wear
            else:
                est_wear = calc.wear_weighted(
                    tread_wear_curr[idx],
                    tread_wear_valid[idx],
                    api.read.lap.progress(),
                )
                est_valid_wear = est_wear

            # Output
            output.currentTreadDepth[idx] = tread_curr
            output.currentLapTreadWear[idx] = tread_wear_curr[idx]
            output.estimatedTreadWear[idx] = est_wear
            output.estimatedValidTreadWear[idx] = est_valid_wear


@generator_init
def calc_brake_wear(output: WheelsInfo, min_delta_distance: float):
    """Calculate brake wear"""
    last_reset = None  # reset check

    last_lap_stime = 0.0  # last lap start time
    brake_last = list(WHEELS_ZERO)  # last moment remaining brake
    brake_wear_curr = list(WHEELS_ZERO)  # current lap brake wear
    brake_wear_valid = list(WHEELS_ZERO)  # valid last lap brake wear
    brake_max_thickness = list(WHEELS_ZERO)  # brake max thickness at start of stint
    failure_record = list(WHEELS_ZERO)  # recorded failure thickness

    is_pit_lap = 0  # whether pit in or pit out lap
    delta_recording = False
    delta_array_raw = [WHEELS_DELTA_DEFAULT]  # distance, wear diff
    delta_array_last = tuple(delta_array_raw)
    is_valid_delta = False
    pos_last = 0.0  # last checked vehicle position

    while True:
        reset = yield None

        # Reset
        if last_reset != reset:
            last_reset = reset
            brake_last[:] = WHEELS_ZERO
            brake_wear_curr[:] = WHEELS_ZERO
            brake_wear_valid[:] = WHEELS_ZERO
            brake_max_thickness[:] = WHEELS_ZERO
            delta_array_raw[:] = (WHEELS_DELTA_DEFAULT,)
            delta_array_last = (WHEELS_DELTA_DEFAULT,)
            is_valid_delta = False
            last_lap_stime = 0.0
            output.lastLapBrakeWear[:] = WHEELS_ZERO
            output.failureBrakeThickness[:] = brake_failure_thickness(
                api.read.vehicle.class_name(),
                api.read.vehicle.vehicle_name(),
            )

        brake_curr_set = api.read.brake.wear()
        if -1.0 in brake_curr_set:
            continue

        lap_stime = api.read.timing.start()
        laptime_curr = api.read.timing.current_laptime()
        pos_curr = api.read.lap.distance()
        in_pits = api.read.vehicle.in_pits()
        is_pit_lap |= in_pits

        if lap_stime != last_lap_stime:
            last_lap_stime = lap_stime  # reset time stamp counter
            output.lastLapBrakeWear[:] = brake_wear_curr
            # Update delta array for non-pit lap
            if len(delta_array_raw) > 1 and not is_pit_lap:
                delta_array_last = tuple(delta_array_raw)
                brake_wear_valid[:] = brake_wear_curr
            elif not is_valid_delta:  # save for first/out lap
                brake_wear_valid[:] = brake_wear_curr
            brake_wear_curr[:] = WHEELS_ZERO
            delta_array_raw[:] = (WHEELS_DELTA_DEFAULT,)
            delta_recording = laptime_curr < 1
            is_valid_delta = len(delta_array_last) > 1
            pos_last = pos_curr
            is_pit_lap = 0

        # Distance desync check at start of new lap, reset if higher than normal distance
        if 0 < laptime_curr < 1 and pos_curr > 300:
            pos_last = pos_curr = 0
        elif pos_last > pos_curr:
            pos_last = pos_curr

        # Update if position value is different & positive
        if delta_recording and pos_curr - pos_last >= min_delta_distance:
            delta_array_raw.append((pos_curr, *brake_wear_curr))
            pos_last = pos_curr

        # Find delta data index
        if is_valid_delta and laptime_curr > 0.3:
            index_higher = calc.binary_search_higher_column(
                delta_array_last, pos_curr, 0, len(delta_array_last) - 1)
        else:
            index_higher = 0

        # Calculate wear difference & accumulated wear
        for idx, brake_curr in enumerate(brake_curr_set):
            brake_curr *= 1000  # meter to millimeter

            # Log brake failure
            if brake_curr > 0:
                failure_record[idx] = brake_curr
            elif failure_record[idx] > 0:
                logger.info(
                    "%s brake failed at %s(mm)",
                    ("Front left", "Front right", "Rear left", "Rear right")[idx],
                    failure_record[idx],
                )
                save_brake_failure_thickness(
                    brake_name=set_predefined_brake_name(
                        api.read.vehicle.class_name(),
                        api.read.vehicle.vehicle_name(),
                        idx < 2,
                    ),
                    failure=round(failure_record[idx], 2),
                )
                output.failureBrakeThickness[:] = brake_failure_thickness(
                    api.read.vehicle.class_name(),
                    api.read.vehicle.vehicle_name(),
                )
                failure_record[idx] = 0

            # Calibrate max thickness
            if brake_max_thickness[idx] < brake_curr:
                brake_max_thickness[idx] = brake_curr
                output.maxBrakeThickness[idx] = brake_curr

            # Ignore wear difference while in pit
            if in_pits:
                wear_diff = 0.0
            else:
                wear_diff = brake_last[idx] - brake_curr
            brake_last[idx] = brake_curr
            if wear_diff > 0:
                brake_wear_curr[idx] += wear_diff

            # Delta wear
            if index_higher > 0:
                delta_wear = brake_wear_curr[idx] - calc.linear_interp(
                    pos_curr,
                    delta_array_last[index_higher - 1][0],
                    delta_array_last[index_higher - 1][idx + 1],
                    delta_array_last[index_higher][0],
                    delta_array_last[index_higher][idx + 1],
                )
            else:
                delta_wear = 0.0

            # Estimate wear
            if is_valid_delta:
                est_wear = brake_wear_valid[idx] + delta_wear
                est_valid_wear = brake_wear_valid[idx] if is_pit_lap else est_wear
            else:
                est_wear = max(brake_wear_curr[idx], brake_wear_valid[idx])
                est_valid_wear = est_wear

            # Output
            output.currentBrakeThickness[idx] = brake_curr
            output.currentlapBrakeWear[idx] = brake_wear_curr[idx]
            output.estimatedBrakeWear[idx] = est_wear
            output.estimatedValidBrakeWear[idx] = est_valid_wear


@generator_init
def calc_suspension_travel(output: WheelsInfo, average_samples: int, average_margin: float, wheel_liftoff: float, enable_offroad: bool):
    """Calculate suspension travel"""
    last_reset = None  # reset check
    last_offroad_time = 0.0

    min_susp_pos = [FLOAT_INF] * 4
    max_susp_pos = [-FLOAT_INF] * 4
    min_susp_pos_ema = list(WHEELS_ZERO)
    max_susp_pos_ema = list(WHEELS_ZERO)
    d_factor = calc.ema_factor(average_samples, 3)

    while True:
        reset = yield None

        # Reset
        if last_reset != reset:
            last_reset = reset
            min_susp_pos[:] = (FLOAT_INF, FLOAT_INF, FLOAT_INF, FLOAT_INF)
            max_susp_pos[:] = (-FLOAT_INF, -FLOAT_INF, -FLOAT_INF, -FLOAT_INF)
            min_susp_pos_ema[:] = WHEELS_ZERO
            max_susp_pos_ema[:] = WHEELS_ZERO

        susp_pos_set = api.read.wheel.suspension_deflection()
        output.currentSuspensionPosition[:] = susp_pos_set

        # Record static position
        if (
            api.read.engine.gear() == 0  # neutral gear
            and api.read.vehicle.in_paddock() != 1  # ignore while in pit (b/c car can be lifted), but not in garage
            and (enable_offroad or not api.read.wheel.offroad())  # offroad check
            and api.read.inputs.throttle_raw() < 0.01  # no throttle
            and api.read.vehicle.speed() < 0.01  # stationary
        ):
            output.staticSuspensionPosition[:] = susp_pos_set

        if last_reset:
            continue

        elapsed_time = api.read.timing.elapsed()

        # Offroad check
        if not enable_offroad and api.read.wheel.offroad():
            last_offroad_time = elapsed_time
        if last_offroad_time > elapsed_time:
            last_offroad_time = elapsed_time

        # Skip for incident in last 3 seconds
        if (elapsed_time - last_offroad_time < 3
            or elapsed_time - api.read.vehicle.impact_time() < 3):
            continue

        tyre_deflection_set = api.read.tyre.vertical_deflection()

        # Calculate only while not in pit
        for idx, susp_pos in enumerate(susp_pos_set):
            # Skip if wheel leaves ground (0 tyre deflection)
            if tyre_deflection_set[idx] < wheel_liftoff:
                continue

            # Min position (under extension)
            if min_susp_pos_ema[idx] == 0:
                min_susp_pos_ema[idx] = susp_pos

            min_susp_pos_ema[idx] = max(
                calc.exp_mov_avg(d_factor, min_susp_pos_ema[idx], susp_pos),
                min_susp_pos_ema[idx] - average_margin,
            )
            if min_susp_pos[idx] > min_susp_pos_ema[idx]:
                min_susp_pos[idx] = min_susp_pos_ema[idx]

            # Max position (under compression)
            if max_susp_pos_ema[idx] == 0:
                max_susp_pos_ema[idx] = susp_pos

            max_susp_pos_ema[idx] = min(
                calc.exp_mov_avg(d_factor, max_susp_pos_ema[idx], susp_pos),
                max_susp_pos_ema[idx] + average_margin,
            )

            if max_susp_pos[idx] < max_susp_pos_ema[idx]:
                max_susp_pos[idx] = max_susp_pos_ema[idx]

            # Output position data
            output.minSuspensionPosition[idx] = min_susp_pos[idx]
            output.maxSuspensionPosition[idx] = max_susp_pos[idx]


@generator_init
def calc_cornering_radius(output: WheelsInfo, sampling_interval: int):
    """Calculate cornering radius"""
    gps_last = POS_XY_ZERO
    min_coords = min(max(sampling_interval, 5), 100)
    coords_array = deque([POS_XY_ZERO] * min_coords * 2, min_coords * 2)

    while True:
        yield None

        gps_curr = (api.read.vehicle.position_longitudinal(), api.read.vehicle.position_lateral())

        # Calculate cornering radius based on tri-coordinates position
        if gps_last != gps_curr:
            gps_last = gps_curr
            coords_array.append(gps_curr)
            arc_center_pos = calc.tri_coords_circle_center(
                *coords_array[0], *coords_array[min_coords], *coords_array[-1])
            output.corneringRadius = calc.distance(coords_array[0], arc_center_pos)

```

# File: tinypedal/process/__init__.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Data process function
"""

```

# File: tinypedal/process/vehicle.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Vehicle function
"""

from __future__ import annotations

from itertools import islice
from typing import Mapping

from ..const_common import EMPTY_DICT, WHEELS_NA
from ..regex_pattern import rex_number_extract


def export_wheels(data: list) -> tuple[float, float, float, float]:
    """Export wheel data"""
    try:
        return data[0], data[1], data[2], data[3]
    except (IndexError, TypeError, ValueError):
        return WHEELS_NA


def expected_usage(value: str) -> float:
    """Extract expected fuel or energy usage from car setup"""
    try:
        match_obj = rex_number_extract.findall(value)
        assert match_obj is not None
        return float(match_obj[0]) / float(match_obj[1])
    except (ZeroDivisionError, AttributeError, IndexError, TypeError, ValueError):
        return 0.0


def steerlock_to_number(value: str) -> float:
    """Convert steerlock (degree) string to float value from car setup"""
    try:
        match_obj = rex_number_extract.search(value)
        assert match_obj is not None
        return float(match_obj.group())
    except (AttributeError, TypeError, ValueError):
        return 0.0


def absolute_refilling(dataset: list[dict]) -> float:
    """Get absolute refilling of fuel or virtual energy from next pit"""
    abs_refill = 0.0
    try:
        for data in dataset:
            # Get absolute refilling energy (percent) from raw value
            if data.get("name") == "VIRTUAL ENERGY:":
                abs_refill = float(data["currentSetting"])
                break
            # Get absolute refilling fuel (liter) from raw string
            if data.get("name") == "FUEL:":
                raw_value = data["settings"][data["currentSetting"]]["text"]
                abs_refill = float(rex_number_extract.search(raw_value).group())
                if "gal" in raw_value.lower():  # convert to liter
                    abs_refill *= 3.7854118
                break
    except (AttributeError, TypeError, IndexError, ValueError):
        pass
    return abs_refill


def stint_ve_usage(dataset: dict) -> Mapping[str, tuple[float, float, float, float, int]]:
    """Stint virtual energy usage"""
    if not isinstance(dataset, dict) or not dataset:
        return EMPTY_DICT
    output = {}
    for player_name, player_dataset in dataset.items():
        # Set default
        ve_remaining = -1.0  # fraction (0.0 to 1.0)
        ve_used = -1.0
        total_laps_done = -1.0
        stint_laps_est = 0.0
        stint_laps_done = 0
        # Calculate usage
        try:
            ve_prev = 0.0
            ve_curr = 0.0
            prev_diff = 0.0
            skip_pit = False
            for data in islice(reversed(player_dataset), 6):
                ve_curr = data["ve"]
                # Initial check
                if ve_remaining == -1.0:
                    if ve_curr == 0:  # ve unavailable
                        raise ValueError
                    ve_remaining = ve_curr
                    ve_prev = ve_curr
                    total_laps_done = data["lap"]
                    continue
                # Skip pit refill
                if skip_pit:
                    ve_prev = ve_curr
                    skip_pit = False
                    continue
                # Skip 0 ve
                if ve_curr == 0 or ve_prev == 0:
                    ve_prev = ve_curr
                    continue
                # Calculate usage
                diff = ve_curr - ve_prev
                # Skip pit refill or usage greater than 50% of total capacity
                if diff <= 0 or diff > 0.5:
                    ve_prev = ve_curr
                    skip_pit = True
                    continue
                ve_prev = ve_curr
                # Validate usage
                if 0 < prev_diff / diff < 2:  # ignore usage twice higher
                    ve_used = prev_diff
                    break
                ve_used = diff  # in case prev_diff is 0
                prev_diff = diff

            # Calculate completed stint laps
            ve_prev = 0.0
            ve_used_min = 1.0
            min_count = 0
            if ve_used > 0:
                ve_used_min = ve_used
            for data in reversed(player_dataset):
                ve_curr = data["ve"]
                if ve_prev == 0:
                    ve_prev = ve_curr
                    continue
                if ve_prev >= ve_curr:  # pit stop
                    break
                if min_count < 3:  # least usage of 3 most recent laps
                    diff = ve_curr - ve_prev
                    if ve_used_min > diff > 0:
                        ve_used_min = diff
                ve_prev = ve_curr
                stint_laps_done += 1
            if 0 < ve_used_min < 1:  # round up 0.9 or higher
                stint_laps_est = stint_laps_done + (ve_remaining / ve_used_min + 0.1)
        except (AttributeError, TypeError, IndexError, ValueError):
            pass
        output[player_name] = (ve_remaining, ve_used, total_laps_done, stint_laps_est, stint_laps_done)
    return output

```

# File: tinypedal/process/weather.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Weather forecast function
"""

from __future__ import annotations

from functools import lru_cache
from typing import NamedTuple

from ..const_common import ABS_ZERO_CELSIUS, MAX_SECONDS


class WeatherNode(NamedTuple):
    """Weather forecast node info"""

    start_percent: float = MAX_SECONDS
    sky_type: int = -1
    temperature: float = ABS_ZERO_CELSIUS
    rain_chance: float = -1.0


FORECAST_DEFAULT = (WeatherNode(),)
FORECAST_NODES_RF2 = ("START", "NODE_25", "NODE_50", "NODE_75", "FINISH")


def forecast_rf2(data: dict) -> tuple[WeatherNode, ...]:
    """Get value from weather forecast dictionary, output 5 api data"""
    try:
        output = tuple(
            WeatherNode(
                start_percent=round(index * 0.2, 1),
                sky_type=data[node]["WNV_SKY"]["currentValue"],
                temperature=round(data[node]["WNV_TEMPERATURE"]["currentValue"]),
                rain_chance=round(data[node]["WNV_RAIN_CHANCE"]["currentValue"]),
            )
            for index, node in enumerate(FORECAST_NODES_RF2)
        )
    except (KeyError, TypeError):
        output = FORECAST_DEFAULT
    return output


@lru_cache(maxsize=2)
def forecast_sky_type(sky_type: int, raininess: float) -> int:
    """Correct current sky type index based on current raininess

    Rain percent:
        1-10 drizzle, 11-20 light rain, 21-40 rain, 41-60 heavy rain, 61-100 storm

    Sky type:
        0 Clear
        1 Light Clouds
        2 Partially Cloudy
        3 Mostly Cloudy
        4 Overcast
        5 Cloudy & Drizzle
        6 Cloudy & Light Rain
        7 Overcast & Light Rain
        8 Overcast & Rain
        9 Overcast & Heavy Rain
        10 Overcast & Storm
    """
    if raininess <= 0:
        if sky_type > 4:
            return 4
        return 0
    if 0 < raininess <= 10:
        return 5
    if 10 < raininess <= 15:
        return 6
    if 15 < raininess <= 20:
        return 7
    if 20 < raininess <= 40:
        return 8
    if 40 < raininess <= 60:
        return 9
    if 60 < raininess:
        return 10
    return sky_type

```

# File: tinypedal/template/__init__.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Template files
"""

```

# File: tinypedal/template/setting_api.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default API setting template
"""

from ..const_api import API_LMU_CONFIG, API_RF2_CONFIG

API_DEFAULT = {
    API_LMU_CONFIG: {
        "access_mode": 0,
        "enable_active_state_override": False,
        "active_state": True,
        "enable_player_index_override": False,
        "player_index": -1,
        "character_encoding": "UTF-8",
        "enable_restapi_access": True,
        "restapi_update_interval": 200,
        "url_host": "localhost",
        "url_port": 6397,
        "connection_timeout": 1,
        "connection_retry": 3,
        "connection_retry_delay": 1,
        "enable_energy_remaining": True,
        "enable_garage_setup_info": True,
        "enable_session_info": True,
        "enable_vehicle_info": True,
        "enable_weather_info": True,
    },
    API_RF2_CONFIG: {
        "access_mode": 0,
        "process_id": "",
        "enable_active_state_override": False,
        "active_state": True,
        "enable_player_index_override": False,
        "player_index": -1,
        "character_encoding": "UTF-8",
        "enable_restapi_access": True,
        "restapi_update_interval": 200,
        "url_host": "localhost",
        "url_port": 5397,
        "connection_timeout": 1,
        "connection_retry": 3,
        "connection_retry_delay": 1,
        "enable_garage_setup_info": True,
        "enable_session_info": True,
        "enable_weather_info": True,
    },
}

```

# File: tinypedal/template/setting_brakes.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default brakes template
"""

from types import MappingProxyType

from .setting_heatmap import HEATMAP_DEFAULT_BRAKE

BRAKEINFO_DEFAULT = MappingProxyType({
    "failure_thickness": 0.0,
    "heatmap": HEATMAP_DEFAULT_BRAKE,
})

BRAKES_DEFAULT = {
    "Hyper - Front Brake": {
        "failure_thickness": 25.0,
        "heatmap": HEATMAP_DEFAULT_BRAKE,
    },
    "Hyper - Rear Brake": {
        "failure_thickness": 25.0,
        "heatmap": HEATMAP_DEFAULT_BRAKE,
    },
    "LMP2 - Front Brake": {
        "failure_thickness": 25.0,
        "heatmap": HEATMAP_DEFAULT_BRAKE,
    },
    "LMP2 - Rear Brake": {
        "failure_thickness": 25.0,
        "heatmap": HEATMAP_DEFAULT_BRAKE,
    },
    "GTE - Front Brake": {
        "failure_thickness": 30.0,
        "heatmap": HEATMAP_DEFAULT_BRAKE,
    },
    "GTE - Rear Brake": {
        "failure_thickness": 30.0,
        "heatmap": HEATMAP_DEFAULT_BRAKE,
    },
    "GT3 - Front Brake": {
        "failure_thickness": 30.0,
        "heatmap": HEATMAP_DEFAULT_BRAKE,
    },
    "GT3 - Rear Brake": {
        "failure_thickness": 30.0,
        "heatmap": HEATMAP_DEFAULT_BRAKE,
    },
}

```

# File: tinypedal/template/setting_classes.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default classes template
"""

from types import MappingProxyType

CLASSINFO_DEFAULT = MappingProxyType({
    "alias": "???",
    "color": "#0044AA",
    "preset": "",
})

CLASSES_DEFAULT = {
    "Hyper": {
        "alias": "HY",
        "color": "#FF4400",
        "preset": "",
    },
    "Hypercar": {
        "alias": "HY",
        "color": "#FF4400",
        "preset": "",
    },
    "LMP1": {
        "alias": "LMP1",
        "color": "#FF00AA",
        "preset": "",
    },
    "LMP2": {
        "alias": "LMP2",
        "color": "#0088FF",
        "preset": "",
    },
    "LMP2_ELMS": {
        "alias": "LMP2_ELMS",
        "color": "#0044AA",
        "preset": "",
    },
    "LMP3": {
        "alias": "LMP3",
        "color": "#880088",
        "preset": "",
    },
    "GTE": {
        "alias": "GTE",
        "color": "#00CC44",
        "preset": "",
    },
    "GT3": {
        "alias": "GT3",
        "color": "#229900",
        "preset": "",
    },
    "DPi": {
        "alias": "DPi",
        "color": "#0044AA",
        "preset": "",
    },
    "FR3.5_2014": {
        "alias": "FR35",
        "color": "#4488AA",
        "preset": "",
    },
    "Formula Pro": {
        "alias": "FPro",
        "color": "#FF3300",
        "preset": "",
    },
}

```

# File: tinypedal/template/setting_common.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default common setting template
"""

from ..const_api import API_LMU_NAME
from ..version import __version__

COMMON_DEFAULT = {
    "preset": {
        "api_name": API_LMU_NAME,
        "version": __version__,
    },
    "overlay": {
        "fixed_position": False,
        "auto_hide": True,
        "enable_grid_move": False,
        "vr_compatibility": False,
    },
    "units": {
        "distance_unit": "Meter",
        "fuel_unit": "Liter",
        "odometer_unit": "Kilometer",
        "power_unit": "Kilowatt",
        "speed_unit": "KPH",
        "temperature_unit": "Celsius",
        "turbo_pressure_unit": "bar",
        "tyre_pressure_unit": "kPa",
    },
    "pace_notes_playback": {
        "enable": False,
        "update_interval": 10,
        "enable_playback_while_in_pit": False,
        "enable_manual_file_selector": False,
        "pace_notes_file_name": "",
        "pace_notes_sound_path": "/",
        "pace_notes_sound_format": "wav",
        "pace_notes_sound_volume": 50,
        "pace_notes_sound_max_duration": 10,
        "pace_notes_sound_max_queue": 5,
        "pace_notes_global_offset": 0,
    },
}

```

# File: tinypedal/template/setting_compounds.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default compounds template
"""

from types import MappingProxyType

from .setting_heatmap import HEATMAP_DEFAULT_TYRE

COMPOUNDINFO_DEFAULT = MappingProxyType({
    "symbol": "?",
    "heatmap": HEATMAP_DEFAULT_TYRE,
})

COMPOUNDS_DEFAULT = {
    "Hyper - Soft": {
        "symbol": "S",
        "heatmap": "tyre_optimal_70",
    },
    "Hyper - Medium": {
        "symbol": "M",
        "heatmap": "tyre_optimal_80",
    },
    "Hyper - Hard": {
        "symbol": "H",
        "heatmap": "tyre_optimal_90",
    },
    "Hyper - Wet": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "LMP2 - Soft": {
        "symbol": "S",
        "heatmap": "tyre_optimal_70",
    },
    "LMP2 - Medium": {
        "symbol": "M",
        "heatmap": "tyre_optimal_80",
    },
    "LMP2 - Hard": {
        "symbol": "H",
        "heatmap": "tyre_optimal_90",
    },
    "LMP2 - Wet": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "GTE - Soft": {
        "symbol": "S",
        "heatmap": "tyre_optimal_80",
    },
    "GTE - Medium": {
        "symbol": "M",
        "heatmap": "tyre_optimal_90",
    },
    "GTE - Hard": {
        "symbol": "H",
        "heatmap": "tyre_optimal_100",
    },
    "GTE - Wet": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "GTE - P2M (Rain)": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "GT3 - Soft": {
        "symbol": "S",
        "heatmap": "tyre_optimal_80",
    },
    "GT3 - Medium": {
        "symbol": "M",
        "heatmap": "tyre_optimal_90",
    },
    "GT3 - Hard": {
        "symbol": "H",
        "heatmap": "tyre_optimal_100",
    },
    "GT3 - Wet": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "GT3 - P2M (Rain)": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "BTCC - Soft": {
        "symbol": "S",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "BTCC - Medium": {
        "symbol": "M",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "BTCC - Hard": {
        "symbol": "H",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "BTCC - Wet": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "Hypercar - Soft": {
        "symbol": "S",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "Hypercar - Medium": {
        "symbol": "M",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "Hypercar - Hard": {
        "symbol": "H",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "Hypercar - Wet": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "LMP2 - S7M (Soft)": {
        "symbol": "S",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "LMP2 - S8M (Medium)": {
        "symbol": "M",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "LMP2 - S9M (Hard)": {
        "symbol": "H",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "LMP2 - H5M (Inter)": {
        "symbol": "I",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "LMP2 - P2M (Rain)": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "LMP3 - S8M (Medium)": {
        "symbol": "M",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
    "LMP3 - P2M (Rain)": {
        "symbol": "W",
        "heatmap": HEATMAP_DEFAULT_TYRE,
    },
}

```

# File: tinypedal/template/setting_filelock.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default file lock template
"""

from types import MappingProxyType

FILELOCKINFO_DEFAULT = MappingProxyType({
    "version": "unknown",
})

FILELOCK_DEFAULT = {}

```

# File: tinypedal/template/setting_global.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default global (config) setting template
"""

from ..const_api import API_LMU_NAME
from ..const_app import APP_NAME, PLATFORM

GLOBAL_DEFAULT = {
    "application": {
        "show_at_startup": True,
        "check_for_updates_on_startup": True,
        "minimize_to_tray": True,
        "remember_position": True,
        "remember_size": True,
        "enable_high_dpi_scaling": True,
        "enable_auto_load_preset": False,
        "show_confirmation_for_batch_toggle": True,
        'snap_distance': 10,
        "snap_gap": 0,
        "grid_move_size": 8,
        "minimum_update_interval": 10,
        "maximum_saving_attempts": 10,
        "position_x": 0,
        "position_y": 0,
        "window_width": 0,
        "window_height": 0,
        "window_color_theme": "Dark",
    },
    "compatibility": {
        "enable_bypass_window_manager": False,
        "enable_translucent_background": True,
        "enable_window_position_correction": True,
        "enable_x11_platform_plugin_override": False,
        "global_bkg_color": "#000000",
        "multimedia_plugin_on_windows": "WMF",
    },
    "telemetry": {
        "api_name": API_LMU_NAME,
        "enable_api_selection_from_preset": True,
    },
    "user_path": {
        "settings_path": "settings/",
        "brand_logo_path": "brandlogo/",
        "delta_best_path": "deltabest/",
        "sector_best_path": "deltabest/",
        "energy_delta_path": "deltabest/",
        "fuel_delta_path": "deltabest/",
        "track_map_path": "trackmap/",
        "pace_notes_path": "pacenotes/",
        "track_notes_path": "tracknotes/",
    },
    "track_map_viewer": {
        "inner_margin": 6,
        "position_increment_step": 5,
        "font_color_light": "#CCCCCC",
        "font_color_dark": "#333333",
        "bkg_color_light": "#FFFFFF",
        "bkg_color_dark": "#333333",
        "map_color": "#FFFFFF",
        "map_width": 10,
        "map_outline_color": "#111111",
        "map_outline_width": 4,
        "start_line_color": "#FF4400",
        "start_line_width": 10,
        "start_line_length": 30,
        "sector_line_color": "#00AAFF",
        "sector_line_width": 8,
        "sector_line_length": 30,
        "marked_coordinates_color": "#808080",
        "marked_coordinates_size": 15,
        "highlighted_coordinates_color": "#22DD00",
        "highlighted_coordinates_width": 5,
        "highlighted_coordinates_size": 15,
        "center_mark_color": "#808080",
        "center_mark_width": 1,
        "center_mark_radius": 1000,
        "curve_section_color": "#FF4400",
        "curve_section_width": 5,
        "osculating_circle_color": "#00AAFF",
        "osculating_circle_width": 2,
        "distance_circle_color": "#808080",
        "distance_circle_width": 1,
        "distance_circle_0_radius": 50,
        "distance_circle_1_radius": 100,
        "distance_circle_2_radius": 200,
        "distance_circle_3_radius": 300,
        "distance_circle_4_radius": 400,
        "distance_circle_5_radius": 500,
        "distance_circle_6_radius": 1000,
        "distance_circle_7_radius": 0,
        "distance_circle_8_radius": 0,
        "distance_circle_9_radius": 0,
        "curve_grade_hairpin": 5,
        "curve_grade_1": 15,
        "curve_grade_2": 25,
        "curve_grade_3": 40,
        "curve_grade_4": 65,
        "curve_grade_5": 105,
        "curve_grade_6": 275,
        "curve_grade_7": -1,
        "curve_grade_8": -1,
        "curve_grade_straight": 3050,
        "length_grade_short": 0,
        "length_grade_normal": 50,
        "length_grade_long": 150,
        "length_grade_very_long": 250,
        "length_grade_extra_long": 350,
        "length_grade_extremely_long": 450,
        "slope_grade_flat": 0,
        "slope_grade_gentle": 0.03,
        "slope_grade_moderate": 0.1,
        "slope_grade_steep": 0.25,
        "slope_grade_extreme": 0.5,
        "slope_grade_cliff": 1,
    },
}


def _set_platform_default(global_def: dict):
    """Set platform default setting"""
    if PLATFORM != "Windows":
        # Global config
        global_def["application"]["show_at_startup"] = True
        global_def["application"]["minimize_to_tray"] = False
        global_def["compatibility"]["enable_bypass_window_manager"] = True
        global_def["compatibility"]["enable_x11_platform_plugin_override"] = True
        # Global path
        from xdg import BaseDirectory as BD

        config_paths = (
            "settings_path",
            "brand_logo_path",
            "pace_notes_path",
            "track_notes_path",
        )
        user_path = global_def["user_path"]
        for key, path in user_path.items():
            if key in config_paths:
                user_path[key] = BD.save_config_path(APP_NAME, path)
            else:
                user_path[key] = BD.save_data_path(APP_NAME, path)


_set_platform_default(GLOBAL_DEFAULT)

```

# File: tinypedal/template/setting_heatmap.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default heatmap template
"""

HEATMAP_DEFAULT_TYRE = "tyre_default"
HEATMAP_DEFAULT_BRAKE = "brake_default"

# key = temperature in Celsius
# value = HEX color code
HEATMAP_DEFAULT = {
    HEATMAP_DEFAULT_TYRE: {
        "-273": "#44F",
        "40": "#84F",
        "60": "#F4F",
        "80": "#F48",
        "100": "#F44",
        "120": "#F84",
        "140": "#FF4",
    },
    HEATMAP_DEFAULT_BRAKE: {
        "-273": "#44F",
        "100": "#48F",
        "200": "#4FF",
        "300": "#4F8",
        "400": "#4F4",
        "500": "#8F4",
        "600": "#FF4",
        "700": "#F84",
        "800": "#F44",
    },
    "tyre_optimal_70": {
        "-273": "#44F",
        "40": "#48F",
        "50": "#4FF",
        "60": "#4F8",
        "70": "#4F4",
        "80": "#8F4",
        "90": "#FF4",
        "100": "#F84",
        "110": "#F44",
    },
    "tyre_optimal_80": {
        "-273": "#44F",
        "50": "#48F",
        "60": "#4FF",
        "70": "#4F8",
        "80": "#4F4",
        "90": "#8F4",
        "100": "#FF4",
        "110": "#F84",
        "120": "#F44",
    },
    "tyre_optimal_90": {
        "-273": "#44F",
        "60": "#48F",
        "70": "#4FF",
        "80": "#4F8",
        "90": "#4F4",
        "100": "#8F4",
        "110": "#FF4",
        "120": "#F84",
        "130": "#F44",
    },
    "tyre_optimal_100": {
        "-273": "#44F",
        "70": "#48F",
        "80": "#4FF",
        "90": "#4F8",
        "100": "#4F4",
        "110": "#8F4",
        "120": "#FF4",
        "130": "#F84",
        "140": "#F44",
    },
    "brake_optimal_300": {
        "-273": "#44F",
        "75": "#48F",
        "150": "#4FF",
        "225": "#4F8",
        "300": "#4F4",
        "375": "#8F4",
        "450": "#FF4",
        "525": "#F84",
        "600": "#F44",
    },
}

```

# File: tinypedal/template/setting_module.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default module setting template
"""


MODULE_DEFAULT = {
    "module_delta": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
        "minimum_delta_distance": 5,
        "delta_smoothing_samples": 30,
        "laptime_pace_samples": 6,
        "laptime_pace_margin": 5,
    },
    "module_energy": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
        "minimum_delta_distance": 5,
    },
    "module_force": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
        "gravitational_acceleration": 9.80665,
        "max_g_force_reset_delay": 5,
        "max_average_g_force_samples": 10,
        "max_average_g_force_difference": 0.2,
        "max_average_g_force_reset_delay": 30,
        "max_braking_rate_reset_delay": 60,
    },
    "module_fuel": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
        "minimum_delta_distance": 5,
    },
    "module_hybrid": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
        "minimum_delta_distance": 5,
    },
    "module_mapping": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
    },
    "module_notes": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
    },
    "module_relative": {
        "enable": True,
        "update_interval": 100,
        "idle_update_interval": 400,
    },
    "module_sectors": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
        "enable_all_time_best_sectors": True,
    },
    "module_stats": {
        "enable": True,
        "update_interval": 200,
        "idle_update_interval": 400,
        "vehicle_classification": "Class - Brand",
        "enable_podium_by_class": True,
    },
    "module_vehicles": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
        "lap_difference_ahead_threshold": 0.9,
        "lap_difference_behind_threshold": 0.9,
    },
    "module_wheels": {
        "enable": True,
        "update_interval": 10,
        "idle_update_interval": 400,
        "minimum_axle_rotation": 4,
        "maximum_rotation_difference_front": 0.002,
        "maximum_rotation_difference_rear": 0.002,
        "minimum_delta_distance": 5,
        "enable_suspension_measurement_while_offroad": False,
        "average_suspension_position_samples": 20,
        "average_suspension_position_margin": 1,
        "wheel_lift_off_threshold": 1,
        "cornering_radius_sampling_interval": 10,
    },
}

```

# File: tinypedal/template/setting_tracks.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default tracks template
"""

from types import MappingProxyType

TRACKINFO_DEFAULT = MappingProxyType({
    "pit_entry": 0.0,
    "pit_exit": 0.0,
    "pit_speed": 0.0,
    "speed_trap": 0.0,
})

TRACKS_DEFAULT = {}

```

# File: tinypedal/template/setting_widget.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Default widget setting template
"""

from .setting_heatmap import HEATMAP_DEFAULT_BRAKE, HEATMAP_DEFAULT_TYRE

WIDGET_DEFAULT = {
    "battery": {
        "enable": True,
        "update_interval": 20,
        "position_x": 140,
        "position_y": 293,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_battery_charge": True,
        "font_color_battery_charge": "#FFFFFF",
        "bkg_color_battery_charge": "#2266CC",
        "high_battery_threshold": 95,
        "warning_color_high_battery": "#AA22AA",
        "low_battery_threshold": 10,
        "warning_color_low_battery": "#FF2200",
        "show_battery_charge_warning_flash": True,
        "number_of_warning_flashes": 10,
        "warning_flash_highlight_duration": 0.4,
        "warning_flash_interval": 0.2,
        "show_battery_drain": True,
        "font_color_battery_drain": "#FFFFFF",
        "bkg_color_battery_drain": "#222222",
        "show_battery_regen": True,
        "font_color_battery_regen": "#FFFFFF",
        "bkg_color_battery_regen": "#222222",
        "show_estimated_net_change": True,
        "font_color_estimated_net_change": "#FFFFFF",
        "bkg_color_estimated_net_change": "#222222",
        "show_activation_timer": True,
        "font_color_activation_timer": "#FFFFFF",
        "bkg_color_activation_timer": "#222222",
        "freeze_duration": 10,
        "column_index_battery_charge": 1,
        "column_index_battery_drain": 2,
        "column_index_battery_regen": 3,
        "column_index_estimated_net_change": 4,
        "column_index_activation_timer": 5,
    },
    "brake_bias": {
        "enable": True,
        "update_interval": 20,
        "position_x": 593,
        "position_y": 292,
        "opacity": 0.9,
        "layout": 1,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_front_and_rear": False,
        "show_percentage_sign": True,
        "font_color_brake_bias": "#FFFFFF",
        "bkg_color_brake_bias": "#222222",
        "show_baseline_bias_delta": True,
        "font_color_baseline_bias_delta": "#FFFFFF",
        "bkg_color_baseline_bias_delta": "#222222",
        "show_brake_migration": True,
        "font_color_brake_migration": "#FFFFFF",
        "bkg_color_brake_migration": "#222222",
        "electric_braking_allocation": -1,
        "decimal_places_baseline_bias_delta": 2,
        "decimal_places_brake_bias": 2,
        "decimal_places_brake_migration": 1,
        "prefix_brake_bias": "BB ",
        "prefix_baseline_bias_delta": "",
        "prefix_brake_migration": "BM ",
        "suffix_brake_migration": "F",
        "column_index_brake_bias": 1,
        "column_index_baseline_bias_delta": 2,
        "column_index_brake_migration": 3,
    },
    "brake_performance": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 753,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_transient_max_braking_rate": True,
        "font_color_transient_max_braking_rate": "#FFFFFF",
        "bkg_color_transient_max_braking_rate": "#222222",
        "show_max_braking_rate": True,
        "font_color_max_braking_rate": "#000000",
        "bkg_color_max_braking_rate": "#DDDDDD",
        "show_delta_braking_rate": True,
        "show_delta_braking_rate_in_percentage": True,
        "font_color_delta_braking_rate": "#FFFFFF",
        "bkg_color_delta_braking_rate": "#222222",
        "bkg_color_braking_rate_gain": "#008800",
        "bkg_color_braking_rate_loss": "#CC7700",
        "show_front_wheel_lock_duration": True,
        "font_color_front_wheel_lock_duration": "#FFFFFF",
        "bkg_color_front_wheel_lock_duration": "#222222",
        "show_rear_wheel_lock_duration": True,
        "font_color_rear_wheel_lock_duration": "#FFFFFF",
        "bkg_color_rear_wheel_lock_duration": "#222222",
        "wheel_lock_threshold": 0.3,
        "column_index_transient_max_braking_rate": 1,
        "column_index_max_braking_rate": 2,
        "column_index_delta_braking_rate": 3,
        "column_index_front_wheel_lock_duration": 4,
        "column_index_rear_wheel_lock_duration": 5,
    },
    "brake_pressure": {
        "enable": True,
        "update_interval": 20,
        "position_x": 253,
        "position_y": 476,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.4,
        "bar_padding_vertical": 0.3,
        "bar_width": 50,
        "bar_gap": 2,
        "horizontal_gap": 2,
        "vertical_gap": 2,
        "font_color": "#AAAAAA",
        "highlight_color": "#00AAFF",
        "bkg_color": "#222222",
        "show_brake_input": True,
        "brake_input_size": 3,
        "brake_input_color": "#00AAFF",
        "show_caption": False,
        "font_scale_caption": 0.8,
        "caption_text": "brake pres",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
    },
    "brake_temperature": {
        "enable": True,
        "update_interval": 20,
        "position_x": 460,
        "position_y": 525,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "inner_gap": 0,
        "enable_heatmap_auto_matching": True,
        "heatmap_name": HEATMAP_DEFAULT_BRAKE,
        "swap_style": False,
        "show_degree_sign": False,
        "leading_zero": 2,
        "font_color_temperature": "#000000",
        "bkg_color_temperature": "#222222",
        "show_average": True,
        "average_sampling_duration": 10,
        "off_brake_duration": 1,
        "font_color_average": "#AAAAAA",
        "bkg_color_average": "#222222",
        "column_index_temperature": 1,
        "column_index_average": 2,
    },
    "brake_wear": {
        "enable": True,
        "update_interval": 20,
        "position_x": 688,
        "position_y": 720,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_thickness": False,
        "show_remaining": True,
        "font_color_remaining": "#22CC22",
        "bkg_color_remaining": "#222222",
        "show_wear_difference": True,
        "font_color_wear_difference": "#CCCCCC",
        "bkg_color_wear_difference": "#222222",
        "show_live_wear_difference": False,
        "font_color_live_wear_difference": "#CCCCCC",
        "bkg_color_live_wear_difference": "#222222",
        "show_lifespan_laps": True,
        "font_color_lifespan_laps": "#CCCC22",
        "bkg_color_lifespan_laps": "#222222",
        "show_lifespan_minutes": True,
        "font_color_lifespan_minutes": "#66CCCC",
        "bkg_color_lifespan_minutes": "#222222",
        "warning_threshold_remaining": 30,
        "warning_threshold_wear": 1,
        "warning_threshold_laps": 5,
        "warning_threshold_minutes": 6,
        "font_color_warning": "#FF2200",
        "show_caption": True,
        "caption_text_remaining": "brake wear",
        "caption_text_wear_difference": "wear diff",
        "caption_text_live_wear_difference": "live wear",
        "caption_text_lifespan_laps": "est. laps",
        "caption_text_lifespan_minutes": "est. mins",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
        "column_index_remaining": 1,
        "column_index_wear_difference": 2,
        "column_index_live_wear_difference": 3,
        "column_index_lifespan_laps": 4,
        "column_index_lifespan_minutes": 5,
    },
    "cruise": {
        "enable": True,
        "update_interval": 100,
        "position_x": 57,
        "position_y": 98,
        "opacity": 0.9,
        "layout": 1,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_track_clock": True,
        "enable_track_clock_synchronization": True,
        "track_clock_time_scale": 1,
        "track_clock_format": "%H:%M%p",
        "font_color_track_clock": "#FFFFFF",
        "bkg_color_track_clock": "#222222",
        "show_time_scale": True,
        "font_color_time_scale": "#FFFFFF",
        "bkg_color_time_scale": "#222222",
        "show_compass": True,
        "font_color_compass": "#FFFFFF",
        "bkg_color_compass": "#222222",
        "show_elevation": True,
        "font_color_elevation": "#FFFFFF",
        "bkg_color_elevation": "#222222",
        "show_odometer": True,
        "odometer_maximum_digits": 8,
        "font_color_odometer": "#FFFFFF",
        "bkg_color_odometer": "#222222",
        "show_distance_into_lap": True,
        "font_color_distance_into_lap": "#FFFFFF",
        "bkg_color_distance_into_lap": "#222222",
        "show_cornering_radius": True,
        "font_color_cornering_radius": "#FFFFFF",
        "bkg_color_cornering_radius": "#222222",
        "column_index_track_clock": 1,
        "column_index_time_scale": 2,
        "column_index_compass": 3,
        "column_index_elevation": 4,
        "column_index_odometer": 5,
        "column_index_distance_into_lap": 6,
        "column_index_cornering_radius": 7,
    },
    "damage": {
        "enable": True,
        "update_interval": 100,
        "position_x": 658,
        "position_y": 515,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "display_margin": 4,
        "inner_gap": 3,
        "parts_width": 6,
        "parts_width_ratio": 0.5,
        "parts_max_width": 16,
        "parts_max_height": 22,
        "wheel_width": 10,
        "wheel_height": 16,
        "show_background": True,
        "bkg_color": "#88000000",
        "body_color": "#888888",
        "body_color_damage_light": "#FFFF00",
        "body_color_damage_heavy": "#FF0000",
        "body_color_detached": "#000000",
        "suspension_color": "#44CC00",
        "suspension_color_damage_light": "#FFFF00",
        "suspension_color_damage_medium": "#FF6600",
        "suspension_color_damage_heavy": "#FF00FF",
        "suspension_color_damage_totaled": "#0000FF",
        "wheel_color_detached": "#000000",
        "show_detached_warning_flash": True,
        "warning_color_detached": "#FF0000",
        "warning_flash_highlight_duration": 0.5,
        "warning_flash_interval": 0.5,
        "suspension_damage_light_threshold": 0.02,
        "suspension_damage_medium_threshold": 0.15,
        "suspension_damage_heavy_threshold": 0.4,
        "suspension_damage_totaled_threshold": 0.8,
        "show_last_impact_cone": True,
        "last_impact_cone_angle": 15,
        "last_impact_cone_duration": 15,
        "last_impact_cone_color": "#DDFF0000",
        "show_integrity_reading": True,
        "show_aero_integrity_if_available": True,
        "show_inverted_integrity": False,
        "font_color_integrity": "#FFFFFF",
    },
    "deltabest": {
        "enable": True,
        "update_interval": 20,
        "position_x": 317,
        "position_y": 69,
        "opacity": 0.9,
        "layout": 0,
        "swap_style": False,
        "font_name": "Consolas",
        "font_size": 17,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.5,
        "bar_padding_vertical": 0.4,
        "bar_gap": 2,
        "decimal_places": 3,
        "deltabest_source": "Best",
        "font_color_deltabest": "#000000",
        "bkg_color_deltabest": "#222222",
        "bkg_color_time_gain": "#44FF00",
        "bkg_color_time_loss": "#FF4400",
        "show_delta_bar": True,
        "bkg_color_deltabar": "#222222",
        "bar_length": 300,
        "bar_height": 16,
        "bar_display_range": 2,
        "delta_display_range": 99.999,
        "freeze_duration": 3,
        "show_animated_deltabest": True,
    },
    "deltabest_extended": {
        "enable": True,
        "update_interval": 20,
        "position_x": 320,
        "position_y": 123,
        "opacity": 0.9,
        "layout": 1,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "decimal_places": 3,
        "show_all_time_deltabest": True,
        "font_color_all_time_deltabest": "#000000",
        "bkg_color_all_time_deltabest": "#FFFFFF",
        "show_session_deltabest": True,
        "font_color_session_deltabest": "#22FFFF",
        "bkg_color_session_deltabest": "#222222",
        "show_stint_deltabest": True,
        "font_color_stint_deltabest": "#FFFF22",
        "bkg_color_stint_deltabest": "#222222",
        "show_deltalast": True,
        "font_color_deltalast": "#BBBBBB",
        "bkg_color_deltalast": "#222222",
        "delta_display_range": 99.999,
        "freeze_duration": 3,
        "prefix_all_time_deltabest": "B ",
        "prefix_session_deltabest": "S ",
        "prefix_stint_deltabest": "T ",
        "prefix_deltalast": "L ",
        "column_index_all_time_deltabest": 1,
        "column_index_session_deltabest": 2,
        "column_index_stint_deltabest": 3,
        "column_index_deltalast": 4,
    },
    "differential": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 860,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "decimal_places": 0,
        "show_inverted_locking": False,
        "show_power_locking_front": True,
        "font_color_power_locking_front": "#FFFFFF",
        "bkg_color_power_locking_front": "#222222",
        "show_coast_locking_front": True,
        "font_color_coast_locking_front": "#FFFFFF",
        "bkg_color_coast_locking_front": "#222222",
        "show_power_locking_rear": True,
        "font_color_power_locking_rear": "#000000",
        "bkg_color_power_locking_rear": "#FFFFFF",
        "show_coast_locking_rear": True,
        "font_color_coast_locking_rear": "#000000",
        "bkg_color_coast_locking_rear": "#FFFFFF",
        "off_throttle_threshold": 0.01,
        "on_throttle_threshold": 0.01,
        "power_locking_reset_cooldown": 5,
        "coast_locking_reset_cooldown": 5,
        "prefix_power_front": "P ",
        "prefix_coast_front": "C ",
        "prefix_power_rear": "P ",
        "prefix_coast_rear": "C ",
        "column_index_power_locking_front": 1,
        "column_index_coast_locking_front": 2,
        "column_index_power_locking_rear": 3,
        "column_index_coast_locking_rear": 4,
    },
    "drs": {
        "enable": True,
        "update_interval": 20,
        "position_x": 504,
        "position_y": 352,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 30,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.5,
        "bar_padding_vertical": 0.2,
        "drs_text": "DRS",
        "font_color_activated": "#000000",
        "bkg_color_activated": "#44FF00",
        "font_color_allowed": "#000000",
        "bkg_color_allowed": "#FF4400",
        "font_color_available": "#000000",
        "bkg_color_available": "#00CCFF",
        "font_color_not_available": "#888888",
        "bkg_color_not_available": "#222222",
    },
    "electric_motor": {
        "enable": True,
        "update_interval": 20,
        "position_x": 223,
        "position_y": 293,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_motor_temperature": True,
        "font_color_motor_temperature": "#FFFFFF",
        "bkg_color_motor_temperature": "#222222",
        "show_water_temperature": True,
        "font_color_water_temperature": "#FFFFFF",
        "bkg_color_water_temperature": "#222222",
        "show_rpm": True,
        "font_color_rpm": "#FFFFFF",
        "bkg_color_rpm": "#222222",
        "show_torque": True,
        "font_color_torque": "#FFFFFF",
        "bkg_color_torque": "#222222",
        "show_power": True,
        "font_color_power": "#FFFFFF",
        "bkg_color_power": "#222222",
        "overheat_threshold_motor": 80,
        "overheat_threshold_water": 80,
        "warning_color_overheat": "#FF2200",
        "column_index_motor_temperature": 1,
        "column_index_water_temperature": 2,
        "column_index_rpm": 3,
        "column_index_torque": 4,
        "column_index_power": 5,
    },
    "elevation": {
        "enable": True,
        "update_interval": 20,
        "position_x": 115,
        "position_y": 753,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "font_color": "#FFFFFF",
        "display_detail_level": 1,
        "display_width": 400,
        "display_height": 60,
        "display_margin_top": 10,
        "display_margin_bottom": 10,
        "show_elevation_reading": True,
        "elevation_reading_offset_x": 0.12,
        "elevation_reading_offset_y": 0.15,
        "elevation_reading_text_alignment": "Left",
        "show_elevation_scale": True,
        "elevation_scale_offset_x": 0.88,
        "elevation_scale_offset_y": 0.15,
        "elevation_scale_text_alignment": "Right",
        "show_background": True,
        "bkg_color": "#66222222",
        "show_elevation_background": True,
        "bkg_color_elevation": "#CC222222",
        "show_elevation_progress": True,
        "elevation_progress_color": "#66CCCCCC",
        "show_elevation_progress_line": True,
        "elevation_progress_line_color": "#FFFFFF",
        "elevation_progress_line_width": 2,
        "show_elevation_line": True,
        "elevation_line_color": "#AA888888",
        "elevation_line_width": 2,
        "show_zero_elevation_line": True,
        "zero_elevation_line_color": "#88FFFFFF",
        "zero_elevation_line_width": 1,
        "show_start_line": True,
        "start_line_color": "#88FFFFFF",
        "start_line_width": 4,
        "show_sector_line": True,
        "sector_line_color": "#88888888",
        "sector_line_width": 2,
        "show_position_mark": True,
        "position_mark_color": "#FF4422",
        "position_mark_width": 2,
    },
    "engine": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 293,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_oil_temperature": True,
        "font_color_oil": "#FFFFFF",
        "bkg_color_oil": "#222222",
        "show_water_temperature": True,
        "font_color_water": "#FFFFFF",
        "bkg_color_water": "#222222",
        "show_turbo_pressure": True,
        "font_color_turbo": "#FFFFFF",
        "bkg_color_turbo": "#222222",
        "show_rpm": True,
        "font_color_rpm": "#FFFFFF",
        "bkg_color_rpm": "#222222",
        "show_rpm_maximum": True,
        "font_color_rpm_maximum": "#FFFFFF",
        "bkg_color_rpm_maximum": "#222222",
        "show_torque": True,
        "font_color_torque": "#FFFFFF",
        "bkg_color_torque": "#222222",
        "show_power": True,
        "font_color_power": "#FFFFFF",
        "bkg_color_power": "#222222",
        "overheat_threshold_oil": 110,
        "overheat_threshold_water": 110,
        "warning_color_overheat": "#FF2200",
        "column_index_oil": 1,
        "column_index_water": 2,
        "column_index_turbo": 3,
        "column_index_rpm": 4,
        "column_index_rpm_maximum": 5,
        "column_index_torque": 6,
        "column_index_power": 7,
    },
    "flag": {
        "enable": True,
        "update_interval": 20,
        "position_x": 556,
        "position_y": 509,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 22,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_pit_timer": True,
        "pit_time_highlight_duration": 10,
        "font_color_pit_timer": "#000000",
        "bkg_color_pit_timer": "#22EE22",
        "font_color_pit_timer_stopped": "#000000",
        "bkg_color_pit_timer_stopped": "#DDDDDD",
        "pit_closed_text": "P CLOSE",
        "font_color_pit_closed": "#000000",
        "bkg_color_pit_closed": "#FF2200",
        "show_low_fuel": True,
        "show_low_fuel_for_race_only": False,
        "low_fuel_volume_threshold": 20,
        "low_fuel_lap_threshold": 2,
        "font_color_low_fuel": "#000000",
        "bkg_color_low_fuel": "#EE7700",
        "show_speed_limiter": True,
        "speed_limiter_text": "LIMITER",
        "font_color_speed_limiter": "#000000",
        "bkg_color_speed_limiter": "#FF2200",
        "show_yellow_flag": True,
        "show_yellow_flag_for_race_only": False,
        "yellow_flag_maximum_range_ahead": 500,
        "yellow_flag_maximum_range_behind": 50,
        "font_color_yellow_flag": "#000000",
        "bkg_color_yellow_flag": "#FFFF00",
        "show_blue_flag": True,
        "show_blue_flag_for_race_only": False,
        "font_color_blue_flag": "#000000",
        "bkg_color_blue_flag": "#00AAFF",
        "show_startlights": True,
        "green_flag_duration": 3,
        "red_lights_text": "READY",
        "green_flag_text": "GREEN",
        "font_color_startlights": "#000000",
        "bkg_color_red_lights": "#FF2200",
        "bkg_color_green_flag": "#00FF00",
        "show_traffic": True,
        "traffic_maximum_time_gap": 15,
        "traffic_pitout_duration": 10,
        "traffic_low_speed_threshold": 8,
        "font_color_traffic": "#FFFFFF",
        "bkg_color_traffic": "#4444FF",
        "show_pit_request": True,
        "pit_request_text": "PIT REQ",
        "font_color_pit_request": "#000000",
        "bkg_color_pit_request": "#44AA00",
        "show_finish_state": True,
        "finish_text": "FINISH",
        "disqualify_text": "DQ",
        "font_color_finish": "#000000",
        "bkg_color_finish": "#FFFFFF",
        "font_color_disqualify": "#FFFFFF",
        "bkg_color_disqualify": "#000000",
        "column_index_pit_timer": 1,
        "column_index_low_fuel": 2,
        "column_index_speed_limiter": 3,
        "column_index_yellow_flag": 4,
        "column_index_blue_flag": 5,
        "column_index_startlights": 6,
        "column_index_traffic": 7,
        "column_index_pit_request": 8,
        "column_index_finish_state": 9,
    },
    "force": {
        "enable": True,
        "update_interval": 20,
        "position_x": 453,
        "position_y": 395,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_g_force": True,
        "font_color_g_force": "#FFCC00",
        "bkg_color_g_force": "#222222",
        "show_downforce_ratio": True,
        "font_color_downforce_ratio": "#000000",
        "bkg_color_downforce_ratio": "#DDDDDD",
        "show_front_downforce": True,
        "font_color_front_downforce": "#FFFFFF",
        "bkg_color_front_downforce": "#222222",
        "show_rear_downforce": True,
        "font_color_rear_downforce": "#FFFFFF",
        "bkg_color_rear_downforce": "#222222",
        "warning_color_liftforce": "#FF2200",
        "column_index_long_gforce": 1,
        "column_index_lat_gforce": 2,
        "column_index_downforce_ratio": 3,
        "column_index_front_downforce": 4,
        "column_index_rear_downforce": 5,
    },
    "friction_circle": {
        "enable": True,
        "update_interval": 20,
        "position_x": 1000,
        "position_y": 266,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 13,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "display_size": 150,
        "display_radius_g": 3.2,
        "show_inverted_orientation": False,
        "show_readings": True,
        "font_color": "#FFFFFF",
        "font_color_highlight": "#FF8800",
        "show_background": False,
        "bkg_color": "#222222",
        "show_circle_background": False,
        "bkg_color_circle": "#66222222",
        "show_fade_out": True,
        "fade_in_radius": 0.5,
        "fade_out_radius": 0.98,
        "show_dot": True,
        "dot_size": 12,
        "dot_color": "#FFFFFF",
        "dot_outline_color": "#88000000",
        "dot_outline_width": 1,
        "show_trace": True,
        "trace_max_samples": 200,
        "trace_style": 0,
        "trace_width": 3,
        "trace_color": "#CCFF2200",
        "show_trace_fade_out": True,
        "trace_fade_out_step": 0.2,
        "show_max_average_lateral_g_circle": True,
        "max_average_lateral_g_circle_style": 1,
        "max_average_lateral_g_circle_width": 3,
        "max_average_lateral_g_circle_color": "#BBFFFFFF",
        "show_center_mark": True,
        "center_mark_radius_g": 6,
        "center_mark_style": 1,
        "center_mark_width": 1,
        "center_mark_color": "#88999999",
        "show_reference_circle": True,
        "reference_circle_1_radius_g": 1,
        "reference_circle_1_style": 1,
        "reference_circle_1_width": 1,
        "reference_circle_1_color": "#88999999",
        "reference_circle_2_radius_g": 2,
        "reference_circle_2_style": 1,
        "reference_circle_2_width": 1,
        "reference_circle_2_color": "#88999999",
        "reference_circle_3_radius_g": 3,
        "reference_circle_3_style": 1,
        "reference_circle_3_width": 1,
        "reference_circle_3_color": "#88999999",
        "reference_circle_4_radius_g": 4,
        "reference_circle_4_style": 1,
        "reference_circle_4_width": 1,
        "reference_circle_4_color": "#88999999",
        "reference_circle_5_radius_g": 5,
        "reference_circle_5_style": 1,
        "reference_circle_5_width": 1,
        "reference_circle_5_color": "#88999999",
    },
    "fuel": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 208,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_width": 5,
        "bar_gap": 0,
        "show_absolute_refueling": False,
        "font_color_remain": "#FFFFFF",
        "bkg_color_remain": "#009900",
        "font_color_refuel": "#FFFFFF",
        "bkg_color_refuel": "#009900",
        "font_color_laps": "#DDDDDD",
        "bkg_color_laps": "#333333",
        "font_color_minutes": "#DDDDDD",
        "bkg_color_minutes": "#333333",
        "font_color_used": "#555555",
        "bkg_color_used": "#FFFFFF",
        "font_color_save": "#DDDDDD",
        "bkg_color_save": "#666666",
        "show_estimated_pitstop_count": True,
        "font_color_pits": "#DDDDDD",
        "bkg_color_pits": "#666666",
        "font_color_early": "#DDDDDD",
        "bkg_color_early": "#666666",
        "show_delta_and_end_remaining": True,
        "font_color_delta": "#555555",
        "bkg_color_delta": "#FFFFFF",
        "font_color_end": "#DDDDDD",
        "bkg_color_end": "#666666",
        "low_fuel_lap_threshold": 2,
        "warning_color_low_fuel": "#FF2200",
        "show_low_fuel_warning_flash": True,
        "number_of_warning_flashes": 10,
        "warning_flash_highlight_duration": 0.4,
        "warning_flash_interval": 0.4,
        "show_fuel_level_bar": True,
        "fuel_level_bar_height": 10,
        "highlight_color_fuel_level": "#FFFFFF",
        "bkg_color_fuel_level": "#222222",
        "show_starting_fuel_level_mark": True,
        "starting_fuel_level_mark_width": 3,
        "starting_fuel_level_mark_color": "#FF4400",
        "show_refueling_level_mark": True,
        "refueling_level_mark_width": 3,
        "refueling_level_mark_color": "#44FF00",
        "decimal_places_remain": 2,
        "decimal_places_refuel": 2,
        "decimal_places_laps": 1,
        "decimal_places_minutes": 1,
        "decimal_places_used": 2,
        "decimal_places_save": 2,
        "decimal_places_pits": 2,
        "decimal_places_early": 2,
        "decimal_places_delta": 2,
        "decimal_places_end": 2,
        "show_caption": True,
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
        "caption_text_remain": "fuel",
        "caption_text_refuel": "refuel",
        "caption_text_absolute_refuel": "abfuel",
        "caption_text_laps": "laps",
        "caption_text_minutes": "mins",
        "caption_text_used": "used",
        "caption_text_save": "save",
        "caption_text_pits": "pits",
        "caption_text_early": "early",
        "caption_text_delta": "delta",
        "caption_text_end": "end",
        "swap_upper_caption": False,
        "swap_lower_caption": False,
        "column_index_upper": 1,
        "column_index_middle": 2,
        "column_index_lower": 3,
    },
    "fuel_energy_saver": {
        "enable": True,
        "update_interval": 100,
        "position_x": 115,
        "position_y": 912,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_width": 5,
        "bar_gap": 0,
        "font_color_target_laps": "#EEEEEE",
        "bkg_color_target_laps": "#777777",
        "font_color_current_laps": "#EEEEEE",
        "bkg_color_current_laps": "#333333",
        "font_color_target_consumption": "#EEEEEE",
        "bkg_color_target_consumption": "#333333",
        "font_color_delta_consumption": "#333333",
        "bkg_color_delta_consumption": "#DDDDDD",
        "font_color_lap_gain": "#448800",
        "font_color_lap_loss": "#DD5500",
        "decimal_places_consumption": 3,
        "decimal_places_delta": 3,
        "minimum_reserve": 0.2,
        "number_of_more_laps": 3,
        "number_of_less_laps": 0,
        "enable_pit_entry_bias": False,
        "remaining_pitstop_threshold": 0.1,
    },
    "gear": {
        "enable": True,
        "update_interval": 20,
        "position_x": 306,
        "position_y": 293,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 44,
        "font_weight_gear": "bold",
        "font_weight_speed": "normal",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.5,
        "bar_padding_vertical": 0.2,
        "bar_gap": 0,
        "inner_gap": 0,
        "font_color": "#FFFFFF",
        "bkg_color": "#222222",
        "show_speed": True,
        "show_speed_below_gear": False,
        "font_scale_speed": 0.5,
        "show_speed_limiter": True,
        "speed_limiter_text": "LIMIT",
        "speed_limiter_padding_horizontal": 0.3,
        "font_color_speed_limiter": "#111111",
        "bkg_color_speed_limiter": "#FF2200",
        "show_battery_bar": True,
        "show_inverted_battery": False,
        "battery_bar_height": 4,
        "battery_bar_color": "#00CCFF",
        "battery_bar_color_regen": "#44FF00",
        "battery_bar_bkg_color": "#88222222",
        "high_battery_threshold": 95,
        "warning_color_high_battery": "#FF44FF",
        "low_battery_threshold": 10,
        "warning_color_low_battery": "#FF2200",
        "show_battery_reading": False,
        "battery_decimal_places": 1,
        "font_size_battery": 16,
        "font_weight_battery": "bold",
        "font_color_battery": "#FFFFFF",
        "battery_reading_offset_x": 0.5,
        "battery_reading_text_alignment": "Center",
        "show_rpm_bar": True,
        "show_inverted_rpm": False,
        "rpm_bar_height": 14,
        "rpm_bar_color": "#FFFFFF",
        "rpm_bar_bkg_color": "#00222222",
        "show_rpm_reading": False,
        "rpm_decimal_places": 0,
        "font_size_rpm": 20,
        "font_weight_rpm": "bold",
        "font_color_rpm": "#888888",
        "rpm_reading_offset_x": 0.5,
        "rpm_reading_text_alignment": "Center",
        "rpm_multiplier_safe": 0.91,
        "rpm_multiplier_redline": 0.95,
        "rpm_multiplier_critical": 0.97,
        "show_rpm_flickering_above_critical": True,
        "rpm_color_safe": "#FF2200",
        "rpm_color_redline": "#00FFFF",
        "rpm_color_over_rev": "#FF00FF",
        "neutral_warning_speed_threshold": 28,
        "neutral_warning_time_threshold": 0.3,
        "column_index_gauge": 1,
        "column_index_battery": 2,
        "column_index_rpm": 3,
    },
    "heading": {
        "enable": True,
        "update_interval": 20,
        "position_x": 1015,
        "position_y": 455,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "display_size": 150,
        "show_yaw_angle_reading": True,
        "yaw_angle_offset_x": 0.5,
        "yaw_angle_offset_y": 0.7,
        "font_color_yaw_angle": "#FFFFFF",
        "show_slip_angle_reading": False,
        "slip_angle_offset_x": 0.5,
        "slip_angle_offset_y": 0.8,
        "font_color_slip_angle": "#FFFFFF",
        "show_degree_sign": True,
        "decimal_places": 0,
        "show_background": False,
        "bkg_color": "#222222",
        "show_circle_background": True,
        "bkg_color_circle": "#66222222",
        "show_yaw_line": True,
        "yaw_line_head_scale": 0.9,
        "yaw_line_tail_scale": 0.2,
        "yaw_line_width": 3,
        "yaw_line_color": "#CC22FF00",
        "show_direction_line": True,
        "direction_line_head_scale": 0.9,
        "direction_line_tail_scale": 0.2,
        "direction_line_width": 3,
        "direction_line_color": "#CCFF2200",
        "show_slip_angle_line": True,
        "slip_angle_line_head_scale": 0.7,
        "slip_angle_line_tail_scale": 0.2,
        "slip_angle_line_width": 3,
        "slip_angle_line_color": "#CCFFFF00",
        "show_dot": True,
        "dot_size": 8,
        "dot_color": "#FFFFFF",
        "dot_outline_color": "#88000000",
        "dot_outline_width": 1,
        "show_center_mark": True,
        "center_mark_length_scale": 1,
        "center_mark_style": 1,
        "center_mark_width": 1,
        "center_mark_color": "#88999999",
    },
    "instrument": {
        "enable": True,
        "update_interval": 20,
        "position_x": 306,
        "position_y": 339,
        "opacity": 0.9,
        "icon_size": 32,
        "bar_gap": 2,
        "layout": 1,
        "bkg_color": "#222222",
        "show_headlights": True,
        "show_ignition": True,
        "warning_color_stalling": "#00CC00",
        "stalling_rpm_threshold": 100,
        "show_clutch": True,
        "warning_color_clutch": "#00BBDD",
        "show_wheel_lock": True,
        "warning_color_wheel_lock": "#EE0000",
        "show_wheel_slip": True,
        "warning_color_wheel_slip": "#FFAA00",
        "wheel_lock_threshold": 0.3,
        "wheel_slip_threshold": 0.1,
        "column_index_headlights": 1,
        "column_index_ignition": 2,
        "column_index_clutch": 3,
        "column_index_wheel_lock": 4,
        "column_index_wheel_slip": 5,
    },
    "laps_and_position": {
        "enable": True,
        "update_interval": 100,
        "position_x": 57,
        "position_y": 42,
        "opacity": 0.9,
        "layout": 1,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_lap_number": True,
        "prefix_lap_number": "L",
        "font_color_lap_number": "#000000",
        "bkg_color_lap_number": "#FFFFFF",
        "bkg_color_maxlap_warn": "#FF0000",
        "show_position_overall": True,
        "prefix_position_overall": "P",
        "font_color_position_overall": "#FFFFFF",
        "bkg_color_position_overall": "#222222",
        "show_position_in_class": True,
        "prefix_position_in_class": "C",
        "font_color_position_in_class": "#FFFFFF",
        "bkg_color_position_in_class": "#666666",
        "column_index_lap_number": 1,
        "column_index_position_overall": 2,
        "column_index_position_in_class": 3,
    },
    "lap_time_history": {
        "enable": True,
        "update_interval": 20,
        "position_x": 523,
        "position_y": 393,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 1,
        "lap_time_history_count": 10,
        "show_empty_history": False,
        "show_virtual_energy_if_available": True,
        "font_color_laps": "#222222",
        "font_color_time": "#222222",
        "font_color_fuel": "#222222",
        "font_color_wear": "#222222",
        "bkg_color_laps": "#CCCCCC",
        "bkg_color_time": "#EEEEEE",
        "bkg_color_fuel": "#CCCCCC",
        "bkg_color_wear": "#EEEEEE",
        "font_color_last_laps": "#AAAAAA",
        "font_color_last_time": "#AAAAAA",
        "font_color_last_fuel": "#AAAAAA",
        "font_color_last_wear": "#AAAAAA",
        "bkg_color_last_laps": "#88444444",
        "bkg_color_last_time": "#88333333",
        "bkg_color_last_fuel": "#88444444",
        "bkg_color_last_wear": "#88333333",
        "font_color_invalid_laptime": "#FF6600",
        "column_index_laps": 1,
        "column_index_time": 2,
        "column_index_fuel": 3,
        "column_index_wear": 4,
    },
    "navigation": {
        "enable": True,
        "update_interval": 20,
        "position_x": 1040,
        "position_y": 70,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "font_color": "#000000",
        "display_size": 300,
        "view_radius": 500,
        "show_background": False,
        "bkg_color": "#222222",
        "show_circle_background": True,
        "bkg_color_circle": "#66222222",
        "circle_outline_color": "#CCFFFFFF",
        "circle_outline_width": 0,
        "show_fade_out": True,
        "fade_in_radius": 0.8,
        "fade_out_radius": 0.98,
        "map_color": "#FFFFFF",
        "map_width": 8,
        "map_outline_color": "#88000000",
        "map_outline_width": 2,
        "show_start_line": True,
        "start_line_color": "#FF4422",
        "start_line_width": 6,
        "start_line_length": 12,
        "show_sector_line": True,
        "sector_line_color": "#00AAFF",
        "sector_line_width": 5,
        "sector_line_length": 12,
        "show_vehicle_standings": False,
        "show_circle_vehicle_shape": False,
        "vehicle_size": 20,
        "vehicle_offset": 0.8,
        "vehicle_color_player": "#FF4422",
        "vehicle_color_leader": "#88FF00",
        "vehicle_color_same_lap": "#FFFFFF",
        "vehicle_color_laps_ahead": "#FF44CC",
        "vehicle_color_laps_behind": "#00AAFF",
        "vehicle_color_in_pit": "#888888",
        "vehicle_color_yellow": "#FFFF00",
        "vehicle_outline_color": "#88000000",
        "vehicle_outline_width": 1,
    },
    "p2p": {
        "enable": True,
        "update_interval": 20,
        "position_x": 556,
        "position_y": 457,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 30,
        "font_weight": "bold",
        "bar_padding": 0.3,
        "bar_gap": 0,
        "show_battery_charge": True,
        "font_color_battery_charge": "#FFFFFF",
        "bkg_color_battery_charge": "#0055ff",
        "bkg_color_battery_drain": "#FF6600",
        "bkg_color_battery_regen": "#22AA00",
        "font_color_battery_cooldown": "#AAAAAA",
        "bkg_color_battery_cooldown": "#222222",
        "show_activation_timer": True,
        "font_color_activation_timer": "#222222",
        "bkg_color_activation_timer": "#EEEEEE",
        "font_color_activation_cooldown": "#999999",
        "bkg_color_activation_cooldown": "#EEEEEE",
        "activation_threshold_gear": 3,
        "activation_threshold_speed": 120,
        "activation_threshold_throttle": 0.6,
        "minimum_activation_time_delay": 5,
        "maximum_activation_time_per_lap": 15,
        "column_index_battery_charge": 1,
        "column_index_activation_timer": 2,
    },
    "pace_notes": {
        "enable": True,
        "update_interval": 20,
        "position_x": 739,
        "position_y": 251,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_background": True,
        "show_pit_notes_while_in_pit": True,
        "pit_notes_text": "Pit Lane",
        "pit_comments_text": "",
        "show_pace_notes": True,
        "pace_notes_width": 30,
        "pace_notes_text_alignment": "Center",
        "font_color_pace_notes": "#FFFFFF",
        "bkg_color_pace_notes": "#66111111",
        "show_comments": False,
        "enable_comments_line_break": True,
        "comments_width": 30,
        "comments_text_alignment": "Center",
        "font_color_comments": "#FFFFFF",
        "bkg_color_comments": "#66111111",
        "show_debugging": False,
        "debugging_width": 30,
        "debugging_text_alignment": "Center",
        "font_color_debugging": "#FFFFFF",
        "bkg_color_debugging": "#66111111",
        "auto_hide_if_not_available": True,
        "maximum_display_duration": -1,
        "column_index_pace_notes": 1,
        "column_index_comments": 2,
        "column_index_debugging": 3,
    },
    "pedal": {
        "enable": True,
        "update_interval": 20,
        "position_x": 374,
        "position_y": 401,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 13,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "enable_horizontal_style": False,
        "show_readings": False,
        "readings_offset": 0.5,
        "font_color_throttle": "#FFFFFF",
        "font_color_brake": "#FFFFFF",
        "font_color_clutch": "#FFFFFF",
        "font_color_ffb": "#FFFFFF",
        "bar_length": 100,
        "bar_width_unfiltered": 5,
        "bar_width_filtered": 10,
        "bar_gap": 2,
        "inner_gap": 2,
        "max_indicator_height": 5,
        "bkg_color": "#222222",
        "show_throttle": True,
        "show_throttle_filtered": True,
        "throttle_color": "#77FF00",
        "show_brake": True,
        "show_brake_filtered": True,
        "show_brake_pressure": True,
        "brake_color": "#FF2200",
        "show_clutch": True,
        "show_clutch_filtered": True,
        "clutch_color": "#00C2F2",
        "show_ffb_meter": True,
        "ffb_color": "#888888",
        "ffb_clipping_color": "#FFAA00",
        "column_index_ffb": 1,
        "column_index_clutch": 2,
        "column_index_brake": 3,
        "column_index_throttle": 4,
    },
    "pit_stop_estimate": {
        "enable": True,
        "update_interval": 50,
        "position_x": 360,
        "position_y": 934,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_width": 5,
        "bar_gap": 0,
        "stop_go_penalty_time": 10,
        "additional_pitstop_time": 2,
        "font_color_pass_duration": "#555555",
        "bkg_color_pass_duration": "#FFFFFF",
        "font_color_pit_timer": "#DDDDDD",
        "bkg_color_pit_timer": "#666666",
        "font_color_stop_duration": "#FFFFFF",
        "bkg_color_stop_duration": "#0099FF",
        "font_color_minimum_total_duration": "#DDDDDD",
        "bkg_color_minimum_total_duration": "#333333",
        "show_relative_refilling": True,
        "font_color_actual_relative_refill": "#555555",
        "bkg_color_actual_relative_refill": "#FFFFFF",
        "font_color_total_relative_refill": "#DDDDDD",
        "bkg_color_total_relative_refill": "#666666",
        "show_pit_occupancy": True,
        "font_color_pit_occupancy": "#555555",
        "bkg_color_pit_occupancy": "#FFFFFF",
        "font_color_pit_requests": "#DDDDDD",
        "bkg_color_pit_requests": "#666666",
        "lengthy_stop_duration_threshold": 60,
        "warning_color_lengthy_stop": "#FF2200",
        "decimal_places_pass_duration": 2,
        "decimal_places_pit_timer": 2,
        "decimal_places_stop_duration": 2,
        "decimal_places_minimum_total_duration": 2,
        "decimal_places_actual_relative_refill": 2,
        "decimal_places_total_relative_refill": 2,
        "show_caption": True,
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
        "caption_text_pass_duration": "pass",
        "caption_text_pit_timer": "timer",
        "caption_text_stop_duration": "stop",
        "caption_text_minimum_total_duration": "min",
        "caption_text_actual_relative_refill": "refill",
        "caption_text_total_relative_refill": "total",
        "caption_text_pit_occupancy": "p/in",
        "caption_text_pit_requests": "r/out",
        "swap_upper_caption": False,
        "swap_lower_caption": False,
        "column_index_upper": 1,
        "column_index_lower": 3,
    },
    "radar": {
        "enable": True,
        "update_interval": 20,
        "position_x": 689,
        "position_y": 353,
        "opacity": 0.9,
        "global_scale": 6,
        "radar_radius": 30,
        "show_vehicle_orientation": True,
        "vehicle_length": 4.6,
        "vehicle_width": 2.2,
        "vehicle_border_radius": 2,
        "vehicle_color_player": "#FF4422",
        "vehicle_color_leader": "#88FF00",
        "vehicle_color_same_lap": "#FFFFFF",
        "vehicle_color_laps_ahead": "#FF44CC",
        "vehicle_color_laps_behind": "#00AAFF",
        "vehicle_color_in_pit": "#888888",
        "vehicle_color_yellow": "#FFFF00",
        "vehicle_outline_color": "#88000000",
        "vehicle_outline_width": 1,
        "enable_radar_fade": True,
        "radar_fade_in_radius": 0.8,
        "radar_fade_out_radius": 0.98,
        "show_background": False,
        "bkg_color": "#222222",
        "show_circle_background": False,
        "bkg_color_circle": "#66222222",
        "show_edge_fade_out": True,
        "edge_fade_in_radius": 0.6,
        "edge_fade_out_radius": 0.98,
        "show_overlap_indicator": True,
        "show_overlap_indicator_in_cone_style": False,
        "overlap_cone_angle": 120,
        "overlap_nearby_range_multiplier": 5,
        "overlap_critical_range_multiplier": 1,
        "indicator_size_multiplier": 8,
        "indicator_color_nearby": "#FFFF00",
        "indicator_color_critical": "#FF6600",
        "show_center_mark": True,
        "center_mark_style": 0,
        "center_mark_radius": 30,
        "center_mark_width": 1,
        "center_mark_color": "#888888",
        "show_angle_mark": True,
        "angle_mark_style": 0,
        "angle_mark_radius": 30,
        "angle_mark_width": 1,
        "angle_mark_color": "#888888",
        "show_distance_circle": True,
        "distance_circle_1_radius": 10,
        "distance_circle_1_style": 0,
        "distance_circle_1_width": 1,
        "distance_circle_1_color": "#888888",
        "distance_circle_2_radius": 20,
        "distance_circle_2_style": 0,
        "distance_circle_2_width": 1,
        "distance_circle_2_color": "#888888",
        "distance_circle_3_radius": 30,
        "distance_circle_3_style": 0,
        "distance_circle_3_width": 1,
        "distance_circle_3_color": "#888888",
        "distance_circle_4_radius": 40,
        "distance_circle_4_style": 0,
        "distance_circle_4_width": 1,
        "distance_circle_4_color": "#888888",
        "distance_circle_5_radius": 50,
        "distance_circle_5_style": 0,
        "distance_circle_5_width": 1,
        "distance_circle_5_color": "#888888",
        "auto_hide": True,
        "auto_hide_in_private_qualifying": True,
        "auto_hide_time_threshold": 1,
        "auto_hide_minimum_distance_ahead": -1,
        "auto_hide_minimum_distance_behind": -1,
        "auto_hide_minimum_distance_side": -1,
        "vehicle_maximum_visible_distance_ahead": -1,
        "vehicle_maximum_visible_distance_behind": -1,
        "vehicle_maximum_visible_distance_side": -1,
    },
    "rake_angle": {
        "enable": True,
        "update_interval": 20,
        "position_x": 593,
        "position_y": 315,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "show_degree_sign": True,
        "show_ride_height_difference": True,
        "wheelbase": 2800,
        "rake_angle_smoothing_samples": 10,
        "decimal_places": 2,
        "font_color_rake_angle": "#FFFFFF",
        "bkg_color_rake_angle": "#222222",
        "warning_color_negative_rake": "#00AAFF",
        "prefix_rake_angle": "RA ",
    },
    "relative": {
        "enable": True,
        "update_interval": 100,
        "position_x": 320,
        "position_y": 148,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 1,
        "show_vehicle_in_garage": False,
        "show_player_highlighted": True,
        "show_lap_difference": True,
        "font_color_same_lap": "#FFFFFF",
        "font_color_laps_ahead": "#FF44CC",
        "font_color_laps_behind": "#00CCFF",
        "show_position": True,
        "font_color_position": "#FFFFFF",
        "bkg_color_position": "#333333",
        "font_color_player_position": "#000000",
        "bkg_color_player_position": "#DDDDDD",
        "show_position_change": True,
        "show_position_change_in_class": True,
        "font_color_position_same": "#AAAAAA",
        "bkg_color_position_same": "#333333",
        "font_color_position_gain": "#66EE00",
        "bkg_color_position_gain": "#333333",
        "font_color_position_loss": "#EE6600",
        "bkg_color_position_loss": "#333333",
        "font_color_player_position_change": "#000000",
        "bkg_color_player_position_change": "#DDDDDD",
        "show_driver_name": True,
        "driver_name_shorten": False,
        "driver_name_uppercase": False,
        "driver_name_width": 10,
        "driver_name_align_center": False,
        "font_color_driver_name": "#FFFFFF",
        "bkg_color_driver_name": "#222222",
        "font_color_player_driver_name": "#000000",
        "bkg_color_player_driver_name": "#CCCCCC",
        "show_vehicle_name": False,
        "show_vehicle_brand_as_name": True,
        "vehicle_name_uppercase": False,
        "vehicle_name_width": 10,
        "vehicle_name_align_center": False,
        "font_color_vehicle_name": "#FFFFFF",
        "bkg_color_vehicle_name": "#222222",
        "font_color_player_vehicle_name": "#000000",
        "bkg_color_player_vehicle_name": "#CCCCCC",
        "show_brand_logo": False,
        "brand_logo_width": 20,
        "bkg_color_brand_logo": "#222222",
        "bkg_color_player_brand_logo": "#CCCCCC",
        "show_time_gap": True,
        "show_time_gap_sign": False,
        "time_gap_decimal_places": 1,
        "time_gap_width": 4,
        "time_gap_align_center": False,
        "font_color_time_gap": "#FFFFFF",
        "bkg_color_time_gap": "#222222",
        "font_color_player_time_gap": "#000000",
        "bkg_color_player_time_gap": "#CCCCCC",
        "show_highlighted_nearest_time_gap": True,
        "nearest_time_gap_threshold_front": 1,
        "nearest_time_gap_threshold_behind": 2,
        "font_color_nearest_time_gap": "#FFFFFF",
        "bkg_color_nearest_time_gap": "#AA22AA",
        "show_laptime": True,
        "font_color_laptime": "#AAAAAA",
        "bkg_color_laptime": "#2A2A2A",
        "font_color_player_laptime": "#000000",
        "bkg_color_player_laptime": "#BBBBBB",
        "show_highlighted_fastest_last_laptime": True,
        "font_color_fastest_last_laptime": "#FF44FF",
        "bkg_color_fastest_last_laptime": "#2A2A2A",
        "font_color_player_fastest_last_laptime": "#AA00AA",
        "bkg_color_player_fastest_last_laptime": "#BBBBBB",
        "show_pitstop_duration_while_requested_pitstop": True,
        "show_best_laptime": False,
        "show_best_laptime_from_recent_laps_in_race": False,
        "font_color_best_laptime": "#AAAAAA",
        "bkg_color_best_laptime": "#2A2A2A",
        "font_color_player_best_laptime": "#000000",
        "bkg_color_player_best_laptime": "#BBBBBB",
        "show_position_in_class": True,
        "show_class_style_for_position_in_class": False,
        "font_color_position_in_class": "#CCCCCC",
        "bkg_color_position_in_class": "#444444",
        "font_color_player_position_in_class": "#000000",
        "bkg_color_player_position_in_class": "#DDDDDD",
        "show_class": True,
        "class_width": 4,
        "font_color_class": "#FFFFFF",
        "bkg_color_class": "#333333",
        "show_pit_status": True,
        "pit_status_text": "P",
        "font_color_pit": "#000000",
        "bkg_color_pit": "#00CCEE",
        "garage_status_text": "G",
        "font_color_garage": "#000000",
        "bkg_color_garage": "#888888",
        "yellow_flag_status_text": "Y",
        "font_color_yellow_flag": "#000000",
        "bkg_color_yellow_flag": "#FFFF00",
        "show_tyre_compound": True,
        "font_color_tyre_compound": "#AAAAAA",
        "bkg_color_tyre_compound": "#2A2A2A",
        "font_color_player_tyre_compound": "#000000",
        "bkg_color_player_tyre_compound": "#CCCCCC",
        "show_pitstop_count": True,
        "font_color_pitstop_count": "#AAAAAA",
        "bkg_color_pitstop_count": "#333333",
        "font_color_player_pitstop_count": "#000000",
        "bkg_color_player_pitstop_count": "#BBBBBB",
        "font_color_penalty_count": "#000000",
        "bkg_color_penalty_count": "#CC22CC",
        "show_pit_request": True,
        "font_color_pit_request": "#000000",
        "bkg_color_pit_request": "#22AA00",
        "show_energy_remaining": True,
        "font_color_energy_remaining_unavailable": "#AAAAAA",
        "font_color_energy_remaining_high": "#88FF00",
        "font_color_energy_remaining_low": "#FFAA00",
        "font_color_energy_remaining_critical": "#FF2200",
        "bkg_color_energy_remaining": "#2A2A2A",
        "font_color_player_energy_remaining": "#000000",
        "bkg_color_player_energy_remaining": "#BBBBBB",
        "show_vehicle_integrity": True,
        "font_color_vehicle_integrity_full": "#AAAAAA",
        "font_color_vehicle_integrity_high": "#00CCFF",
        "font_color_vehicle_integrity_low": "#FF2200",
        "bkg_color_vehicle_integrity": "#2A2A2A",
        "font_color_player_vehicle_integrity": "#000000",
        "bkg_color_player_vehicle_integrity": "#BBBBBB",
        "show_stint_laps": True,
        "font_color_stint_laps": "#AAAAAA",
        "bkg_color_stint_laps": "#333333",
        "font_color_player_stint_laps": "#000000",
        "bkg_color_player_stint_laps": "#BBBBBB",
        "show_speed_trap": True,
        "font_color_speed_trap": "#AAAAAA",
        "bkg_color_speed_trap": "#2A2A2A",
        "font_color_player_speed_trap": "#000000",
        "bkg_color_player_speed_trap": "#BBBBBB",
        "column_index_position": 1,
        "column_index_driver": 2,
        "column_index_vehicle": 6,
        "column_index_brand_logo": 8,
        "column_index_laptime": 3,
        "column_index_best_laptime": 11,
        "column_index_position_in_class": 4,
        "column_index_class": 5,
        "column_index_tyre_compound": 7,
        "column_index_pitstop_count": 10,
        "column_index_position_change": 12,
        "column_index_timegap": 15,
        "column_index_stint_laps": 16,
        "column_index_vehicle_integrity": 17,
        "column_index_speed_trap": 19,
        "column_index_energy_remaining": 20,
        "column_index_pitstatus": 22,
        "additional_players_front": 0,
        "additional_players_behind": 0,
    },
    "relative_finish_order": {
        "enable": True,
        "update_interval": 100,
        "position_x": 360,
        "position_y": 824,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_width": 5,
        "bar_gap": 0,
        "show_absolute_refilling": False,
        "font_color_pit_time": "#EEEEEE",
        "bkg_color_pit_time": "#777777",
        "font_color_leader": "#333333",
        "bkg_color_leader": "#EEEEEE",
        "font_color_player": "#333333",
        "bkg_color_player": "#DDDDDD",
        "font_color_refill": "#DDDDDD",
        "bkg_color_refill": "#333333",
        "near_start_range": 20,
        "font_color_near_start": "#448800",
        "near_finish_range": 20,
        "font_color_near_finish": "#DD5500",
        "decimal_places_laps": 2,
        "decimal_places_refill": 1,
        "leader_laptime_pace_samples": 6,
        "leader_laptime_pace_margin": 5,
        "show_extra_refilling": True,
        "number_of_extra_laps": 1,
        "number_of_prediction": 4,
        "prediction_1_leader_pit_time": 30,
        "prediction_1_player_pit_time": 30,
        "prediction_2_leader_pit_time": 40,
        "prediction_2_player_pit_time": 40,
        "prediction_3_leader_pit_time": 50,
        "prediction_3_player_pit_time": 50,
        "prediction_4_leader_pit_time": 60,
        "prediction_4_player_pit_time": 60,
        "prediction_5_leader_pit_time": 70,
        "prediction_5_player_pit_time": 70,
        "prediction_6_leader_pit_time": 80,
        "prediction_6_player_pit_time": 80,
        "prediction_7_leader_pit_time": 90,
        "prediction_7_player_pit_time": 90,
        "prediction_8_leader_pit_time": 100,
        "prediction_8_player_pit_time": 100,
        "prediction_9_leader_pit_time": 110,
        "prediction_9_player_pit_time": 110,
        "prediction_10_leader_pit_time": 120,
        "prediction_10_player_pit_time": 120,
    },
    "ride_height": {
        "enable": True,
        "update_interval": 20,
        "position_x": 253,
        "position_y": 384,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.4,
        "bar_padding_vertical": 0.3,
        "bar_width": 50,
        "bar_gap": 2,
        "horizontal_gap": 2,
        "vertical_gap": 2,
        "font_color": "#AAAAAA",
        "highlight_color": "#44CC00",
        "bkg_color": "#222222",
        "ride_height_max_range": 150,
        "ride_height_offset_front_left": 0,
        "ride_height_offset_front_right": 0,
        "ride_height_offset_rear_left": 0,
        "ride_height_offset_rear_right": 0,
        "warning_color_bottoming": "#FF2200",
        "show_caption": False,
        "font_scale_caption": 0.8,
        "caption_text": "ride height",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
    },
    "rivals": {
        "enable": True,
        "update_interval": 50,
        "position_x": 433,
        "position_y": 688,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 1,
        "show_position": True,
        "font_color_position": "#FFFFFF",
        "bkg_color_position": "#333333",
        "show_position_change": True,
        "show_position_change_in_class": True,
        "font_color_position_same": "#AAAAAA",
        "bkg_color_position_same": "#333333",
        "font_color_position_gain": "#66EE00",
        "bkg_color_position_gain": "#333333",
        "font_color_position_loss": "#EE6600",
        "bkg_color_position_loss": "#333333",
        "show_driver_name": True,
        "driver_name_shorten": False,
        "driver_name_uppercase": False,
        "driver_name_width": 10,
        "driver_name_align_center": False,
        "font_color_driver_name": "#FFFFFF",
        "bkg_color_driver_name": "#222222",
        "show_vehicle_name": False,
        "show_vehicle_brand_as_name": True,
        "vehicle_name_uppercase": False,
        "vehicle_name_width": 10,
        "vehicle_name_align_center": False,
        "font_color_vehicle_name": "#FFFFFF",
        "bkg_color_vehicle_name": "#222222",
        "show_brand_logo": False,
        "brand_logo_width": 20,
        "bkg_color_brand_logo": "#222222",
        "show_time_interval": True,
        "time_interval_decimal_places": 3,
        "time_interval_width": 7,
        "time_interval_align_center": False,
        "font_color_time_interval_ahead": "#66FF00",
        "bkg_color_time_interval_ahead": "#222222",
        "font_color_time_interval_behind": "#FF6600",
        "bkg_color_time_interval_behind": "#222222",
        "show_laptime": True,
        "font_color_laptime": "#AAAAAA",
        "bkg_color_laptime": "#2A2A2A",
        "show_pitstop_duration_while_requested_pitstop": True,
        "show_best_laptime": False,
        "show_best_laptime_from_recent_laps_in_race": False,
        "font_color_best_laptime": "#AAAAAA",
        "bkg_color_best_laptime": "#2A2A2A",
        "show_delta_laptime": False,
        "show_inverted_delta_laptime_layout": False,
        "number_of_delta_laptime": 3,
        "font_color_delta_laptime_gain": "#66EE00",
        "font_color_delta_laptime_loss": "#EE6600",
        "font_color_delta_laptime": "#AAAAAA",
        "bkg_color_delta_laptime": "#222222",
        "show_position_in_class": True,
        "show_class_style_for_position_in_class": False,
        "font_color_position_in_class": "#CCCCCC",
        "bkg_color_position_in_class": "#444444",
        "show_class": True,
        "class_width": 4,
        "font_color_class": "#FFFFFF",
        "bkg_color_class": "#333333",
        "show_pit_status": True,
        "pit_status_text": "P",
        "font_color_pit": "#000000",
        "bkg_color_pit": "#00CCEE",
        "garage_status_text": "G",
        "font_color_garage": "#000000",
        "bkg_color_garage": "#888888",
        "yellow_flag_status_text": "Y",
        "font_color_yellow_flag": "#000000",
        "bkg_color_yellow_flag": "#FFFF00",
        "show_tyre_compound": True,
        "font_color_tyre_compound": "#AAAAAA",
        "bkg_color_tyre_compound": "#2A2A2A",
        "show_pitstop_count": True,
        "font_color_pitstop_count": "#AAAAAA",
        "bkg_color_pitstop_count": "#333333",
        "font_color_penalty_count": "#000000",
        "bkg_color_penalty_count": "#CC22CC",
        "show_pit_request": True,
        "font_color_pit_request": "#000000",
        "bkg_color_pit_request": "#22AA00",
        "show_energy_remaining": True,
        "font_color_energy_remaining_unavailable": "#AAAAAA",
        "font_color_energy_remaining_high": "#88FF00",
        "font_color_energy_remaining_low": "#FFAA00",
        "font_color_energy_remaining_critical": "#FF2200",
        "bkg_color_energy_remaining": "#2A2A2A",
        "show_vehicle_integrity": True,
        "font_color_vehicle_integrity_full": "#AAAAAA",
        "font_color_vehicle_integrity_high": "#00CCFF",
        "font_color_vehicle_integrity_low": "#FF2200",
        "bkg_color_vehicle_integrity": "#2A2A2A",
        "show_stint_laps": True,
        "font_color_stint_laps": "#AAAAAA",
        "bkg_color_stint_laps": "#333333",
        "show_speed_trap": True,
        "font_color_speed_trap": "#AAAAAA",
        "bkg_color_speed_trap": "#2A2A2A",
        "column_index_position": 1,
        "column_index_driver": 2,
        "column_index_vehicle": 6,
        "column_index_brand_logo": 8,
        "column_index_laptime": 3,
        "column_index_best_laptime": 11,
        "column_index_position_in_class": 4,
        "column_index_class": 5,
        "column_index_tyre_compound": 7,
        "column_index_pitstop_count": 10,
        "column_index_position_change": 12,
        "column_index_timeinterval": 13,
        "column_index_stint_laps": 16,
        "column_index_vehicle_integrity": 17,
        "column_index_delta_laptime": 18,
        "column_index_speed_trap": 19,
        "column_index_energy_remaining": 20,
        "column_index_pitstatus": 22,
    },
    "roll_angle": {
        "enable": True,
        "update_interval": 20,
        "position_x": 770,
        "position_y": 720,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_degree_and_percentage_sign": True,
        "wheel_track_front": 2000,
        "wheel_track_rear": 2000,
        "roll_angle_smoothing_samples": 10,
        "roll_angle_ratio_smoothing_samples": 50,
        "decimal_places": 2,
        "font_color_roll_angle_front": "#FFFFFF",
        "bkg_color_roll_angle_front": "#222222",
        "font_color_roll_angle_rear": "#FFFFFF",
        "bkg_color_roll_angle_rear": "#222222",
        "show_roll_angle_difference": True,
        "font_color_roll_angle_difference": "#FFFFFF",
        "bkg_color_roll_angle_difference": "#0066CC",
        "show_roll_angle_ratio": True,
        "font_color_roll_angle_ratio": "#000000",
        "bkg_color_roll_angle_ratio": "#DDDDDD",
        "prefix_roll_angle_front": "",
        "prefix_roll_angle_rear": "",
        "prefix_roll_angle_difference": "",
        "prefix_roll_angle_ratio": "",
        "column_index_roll_angle_front": 1,
        "column_index_roll_angle_rear": 2,
        "column_index_roll_angle_difference": 3,
        "column_index_roll_angle_ratio": 4,
    },
    "rpm_led": {
        "enable": True,
        "update_interval": 20,
        "position_x": 766,
        "position_y": 804,
        "opacity": 0.9,
        "display_margin": 4,
        "inner_gap": 3,
        "show_background": False,
        "bkg_color": "#88000000",
        "number_of_led": 10,
        "enable_double_side_led": False,
        "led_width": 40,
        "led_height": 20,
        "led_radius": 2,
        "led_outline_color": "#88888888",
        "led_outline_width": 2,
        "rpm_multiplier_low": 0.84,
        "rpm_multiplier_safe": 0.88,
        "rpm_multiplier_redline": 0.92,
        "rpm_multiplier_critical": 0.96,
        "rpm_multiplier_over_rev": 0.9999,
        "show_rpm_flickering_above_critical": True,
        "rpm_color_off": "#111111",
        "rpm_color_low": "#00FF00",
        "rpm_color_safe": "#FFFF00",
        "rpm_color_redline": "#FF0000",
        "rpm_color_critical": "#00FFFF",
        "rpm_color_over_rev": "#FF00FF",
        "show_speed_limiter_flash": True,
        "speed_limiter_flash_interval": 0.25,
        "speed_limiter_flash_color": "#00FF00",
    },
    "sectors": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 157,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "target_laptime": "Theoretical",
        "freeze_duration": 5,
        "font_color_target_time": "#AAAAAA",
        "bkg_color_target_time": "#222222",
        "font_color_current_time": "#FFFFFF",
        "bkg_color_current_time": "#222222",
        "font_color_sector": "#AAAAAA",
        "bkg_color_sector": "#222222",
        "font_color_sector_highlighted": "#FFFFFF",
        "font_color_time_gain": "#22CC22",
        "font_color_time_loss": "#BBAA00",
        "bkg_color_time_gain": "#008800",
        "bkg_color_time_loss": "#887700",
    },
    "session": {
        "enable": True,
        "update_interval": 100,
        "position_x": 57,
        "position_y": 127,
        "opacity": 0.9,
        "layout": 1,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_session_name": True,
        "font_color_session_name": "#FFFFFF",
        "bkg_color_session_name": "#222222",
        "session_text_testday": "TEST",
        "session_text_practice": "PRAC",
        "session_text_qualify": "QUAL",
        "session_text_warmup": "WARM",
        "session_text_race": "RACE",
        "show_system_clock": True,
        "system_clock_format": "%H:%M%p",
        "font_color_system_clock": "#FFFFFF",
        "bkg_color_system_clock": "#222222",
        "show_session_time": True,
        "font_color_session_time": "#FFFFFF",
        "bkg_color_session_time": "#880088",
        "show_estimated_laps": True,
        "prefix_estimated_laps": "L ",
        "font_color_estimated_laps": "#FFFFFF",
        "bkg_color_estimated_laps": "#008888",
        "column_index_session_name": 0,
        "column_index_system_clock": 1,
        "column_index_session_time": 2,
        "column_index_estimated_laps": 3,
    },
    "slip_ratio": {
        "enable": True,
        "update_interval": 20,
        "position_x": 280,
        "position_y": 712,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.4,
        "bar_padding_vertical": 0.3,
        "bar_width": 50,
        "bar_gap": 2,
        "horizontal_gap": 2,
        "vertical_gap": 2,
        "font_color": "#AAAAAA",
        "optimal_slip_ratio_color": "#FFFFFF",
        "critical_slip_ratio_color": "#FF00FF",
        "bkg_color": "#222222",
        "slip_ratio_optimal_range": 30,
        "slip_ratio_max_range": 50,
        "show_caption": False,
        "font_scale_caption": 0.8,
        "caption_text": "slip ratio",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
    },
    "speedometer": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 640,
        "opacity": 0.9,
        "layout": 1,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "leading_zero": 1,
        "decimal_places": 1,
        "show_speed": True,
        "font_color_speed": "#FFFFFF",
        "bkg_color_speed": "#222222",
        "show_speed_minimum": True,
        "font_color_speed_minimum": "#FFAA00",
        "bkg_color_speed_minimum": "#222222",
        "show_speed_maximum": True,
        "font_color_speed_maximum": "#44FF00",
        "bkg_color_speed_maximum": "#222222",
        "show_speed_fastest": True,
        "font_color_speed_fastest": "#000000",
        "bkg_color_speed_fastest": "#FFFFFF",
        "off_throttle_threshold": 0.5,
        "on_throttle_threshold": 0.01,
        "speed_minimum_reset_cooldown": 5,
        "speed_maximum_reset_cooldown": 10,
        "column_index_speed": 1,
        "column_index_speed_minimum": 2,
        "column_index_speed_maximum": 3,
        "column_index_speed_fastest": 4,
    },
    "standings": {
        "enable": True,
        "update_interval": 100,
        "position_x": 57,
        "position_y": 610,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 1,
        "enable_single_class_exclusive_mode": False,
        "enable_multi_class_split_mode": True,
        "min_top_vehicles": 3,
        "max_vehicles_exclusive_mode": 12,
        "max_vehicles_combined_mode": 12,
        "max_vehicles_split_mode": 50,
        "max_vehicles_per_split_player": 7,
        "max_vehicles_per_split_others": 3,
        "split_gap": 5,
        "show_player_highlighted": True,
        "show_position": True,
        "font_color_position": "#FFFFFF",
        "bkg_color_position": "#333333",
        "font_color_player_position": "#000000",
        "bkg_color_player_position": "#DDDDDD",
        "show_position_change": True,
        "show_position_change_in_class": True,
        "font_color_position_same": "#AAAAAA",
        "bkg_color_position_same": "#333333",
        "font_color_position_gain": "#66EE00",
        "bkg_color_position_gain": "#333333",
        "font_color_position_loss": "#EE6600",
        "bkg_color_position_loss": "#333333",
        "font_color_player_position_change": "#000000",
        "bkg_color_player_position_change": "#DDDDDD",
        "show_driver_name": True,
        "driver_name_shorten": False,
        "driver_name_uppercase": False,
        "driver_name_width": 10,
        "driver_name_align_center": False,
        "font_color_driver_name": "#FFFFFF",
        "bkg_color_driver_name": "#222222",
        "font_color_player_driver_name": "#000000",
        "bkg_color_player_driver_name": "#CCCCCC",
        "show_vehicle_name": False,
        "show_vehicle_brand_as_name": True,
        "vehicle_name_uppercase": False,
        "vehicle_name_width": 10,
        "vehicle_name_align_center": False,
        "font_color_vehicle_name": "#FFFFFF",
        "bkg_color_vehicle_name": "#222222",
        "font_color_player_vehicle_name": "#000000",
        "bkg_color_player_vehicle_name": "#CCCCCC",
        "show_brand_logo": False,
        "brand_logo_width": 20,
        "bkg_color_brand_logo": "#222222",
        "bkg_color_player_brand_logo": "#CCCCCC",
        "show_time_gap": True,
        "show_time_gap_from_same_class": True,
        "time_gap_leader_text": "LDR",
        "time_gap_decimal_places": 1,
        "time_gap_width": 4,
        "font_color_time_gap": "#FFFFFF",
        "bkg_color_time_gap": "#333333",
        "font_color_player_time_gap": "#000000",
        "bkg_color_player_time_gap": "#DDDDDD",
        "show_time_interval": True,
        "show_time_interval_from_same_class": True,
        "time_interval_leader_text": "INT",
        "time_interval_decimal_places": 1,
        "time_interval_width": 4,
        "font_color_time_interval": "#FFFFFF",
        "bkg_color_time_interval": "#222222",
        "font_color_player_time_interval": "#000000",
        "bkg_color_player_time_interval": "#CCCCCC",
        "show_laptime": True,
        "font_color_laptime": "#AAAAAA",
        "bkg_color_laptime": "#2A2A2A",
        "font_color_player_laptime": "#000000",
        "bkg_color_player_laptime": "#BBBBBB",
        "show_pitstop_duration_while_requested_pitstop": True,
        "show_highlighted_fastest_last_laptime": True,
        "font_color_fastest_last_laptime": "#FF44FF",
        "bkg_color_fastest_last_laptime": "#2A2A2A",
        "font_color_player_fastest_last_laptime": "#AA00AA",
        "bkg_color_player_fastest_last_laptime": "#BBBBBB",
        "show_best_laptime": False,
        "show_best_laptime_from_recent_laps_in_race": False,
        "font_color_best_laptime": "#AAAAAA",
        "bkg_color_best_laptime": "#2A2A2A",
        "font_color_player_best_laptime": "#000000",
        "bkg_color_player_best_laptime": "#BBBBBB",
        "show_delta_laptime": True,
        "show_inverted_delta_laptime_layout": False,
        "number_of_delta_laptime": 3,
        "font_color_delta_laptime_gain": "#66EE00",
        "font_color_delta_laptime_loss": "#EE6600",
        "font_color_delta_laptime": "#AAAAAA",
        "bkg_color_delta_laptime": "#222222",
        "font_color_player_delta_laptime": "#000000",
        "bkg_color_player_delta_laptime": "#BBBBBB",
        "show_position_in_class": True,
        "show_class_style_for_position_in_class": False,
        "font_color_position_in_class": "#CCCCCC",
        "bkg_color_position_in_class": "#444444",
        "font_color_player_position_in_class": "#000000",
        "bkg_color_player_position_in_class": "#DDDDDD",
        "show_class": True,
        "class_width": 4,
        "font_color_class": "#FFFFFF",
        "bkg_color_class": "#333333",
        "show_pit_status": True,
        "pit_status_text": "P",
        "font_color_pit": "#000000",
        "bkg_color_pit": "#00CCEE",
        "garage_status_text": "G",
        "font_color_garage": "#000000",
        "bkg_color_garage": "#888888",
        "yellow_flag_status_text": "Y",
        "font_color_yellow_flag": "#000000",
        "bkg_color_yellow_flag": "#FFFF00",
        "show_tyre_compound": True,
        "font_color_tyre_compound": "#AAAAAA",
        "bkg_color_tyre_compound": "#2A2A2A",
        "font_color_player_tyre_compound": "#000000",
        "bkg_color_player_tyre_compound": "#CCCCCC",
        "show_pitstop_count": True,
        "font_color_pitstop_count": "#AAAAAA",
        "bkg_color_pitstop_count": "#333333",
        "font_color_player_pitstop_count": "#000000",
        "bkg_color_player_pitstop_count": "#BBBBBB",
        "font_color_penalty_count": "#000000",
        "bkg_color_penalty_count": "#CC22CC",
        "show_pit_request": True,
        "font_color_pit_request": "#000000",
        "bkg_color_pit_request": "#22AA00",
        "show_energy_remaining": True,
        "font_color_energy_remaining_unavailable": "#AAAAAA",
        "font_color_energy_remaining_high": "#88FF00",
        "font_color_energy_remaining_low": "#FFAA00",
        "font_color_energy_remaining_critical": "#FF2200",
        "bkg_color_energy_remaining": "#2A2A2A",
        "font_color_player_energy_remaining": "#000000",
        "bkg_color_player_energy_remaining": "#BBBBBB",
        "show_vehicle_integrity": True,
        "font_color_vehicle_integrity_full": "#AAAAAA",
        "font_color_vehicle_integrity_high": "#00CCFF",
        "font_color_vehicle_integrity_low": "#FF2200",
        "bkg_color_vehicle_integrity": "#2A2A2A",
        "font_color_player_vehicle_integrity": "#000000",
        "bkg_color_player_vehicle_integrity": "#BBBBBB",
        "show_stint_laps": True,
        "font_color_stint_laps": "#AAAAAA",
        "bkg_color_stint_laps": "#333333",
        "font_color_player_stint_laps": "#000000",
        "bkg_color_player_stint_laps": "#BBBBBB",
        "show_speed_trap": True,
        "font_color_speed_trap": "#AAAAAA",
        "bkg_color_speed_trap": "#2A2A2A",
        "font_color_player_speed_trap": "#000000",
        "bkg_color_player_speed_trap": "#BBBBBB",
        "column_index_position": 1,
        "column_index_driver": 2,
        "column_index_vehicle": 6,
        "column_index_brand_logo": 8,
        "column_index_laptime": 3,
        "column_index_best_laptime": 11,
        "column_index_position_in_class": 4,
        "column_index_class": 5,
        "column_index_tyre_compound": 7,
        "column_index_pitstop_count": 10,
        "column_index_position_change": 12,
        "column_index_timeinterval": 13,
        "column_index_timegap": 15,
        "column_index_stint_laps": 16,
        "column_index_vehicle_integrity": 17,
        "column_index_delta_laptime": 18,
        "column_index_speed_trap": 19,
        "column_index_energy_remaining": 20,
        "column_index_pitstatus": 22,
    },
    "steering": {
        "enable": True,
        "update_interval": 20,
        "position_x": 585,
        "position_y": 358,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.4,
        "bar_padding_vertical": 0.3,
        "bar_width": 50,
        "bar_height": 15,
        "bar_edge_width": 2,
        "steering_color": "#FFAA00",
        "bkg_color": "#222222",
        "bar_edge_color": "#FFAA00",
        "manual_steering_range": 0,
        "show_steering_angle": True,
        "font_color": "#AAAAAA",
        "show_scale_mark": True,
        "scale_mark_degree": 90,
        "scale_mark_color": "#555555",
    },
    "steering_wheel": {
        "enable": True,
        "update_interval": 20,
        "position_x": 1050,
        "position_y": 620,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "show_custom_steering_wheel": False,
        "custom_steering_wheel_image_file": "",
        "display_size": 80,
        "display_margin": 4,
        "show_background": False,
        "bkg_color": "#88111111",
        "show_circle_background": True,
        "bkg_color_circle": "#88111111",
        "show_steering_angle": False,
        "steering_angle_offset_x": 0.5,
        "steering_angle_offset_y": 0.5,
        "font_color_steering_angle": "#FFFFFF",
        "show_degree_sign": True,
        "decimal_places": 0,
        "manual_steering_range": 0,
        "show_rotation_line": True,
        "show_rotation_line_while_stationary_only": True,
        "rotation_line_color": "#DD2200",
        "rotation_line_width": 3,
        "rotation_line_margin": 2,
    },
    "stint_history": {
        "enable": True,
        "update_interval": 20,
        "position_x": 523,
        "position_y": 423,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 1,
        "stint_history_count": 2,
        "show_empty_history": False,
        "show_virtual_energy_if_available": True,
        "minimum_stint_threshold_minutes": 10,
        "font_color_laps": "#222222",
        "font_color_time": "#222222",
        "font_color_fuel": "#222222",
        "font_color_tyre": "#222222",
        "font_color_wear": "#222222",
        "bkg_color_laps": "#CCCCCC",
        "bkg_color_time": "#EEEEEE",
        "bkg_color_fuel": "#CCCCCC",
        "bkg_color_tyre": "#EEEEEE",
        "bkg_color_wear": "#CCCCCC",
        "font_color_last_stint_laps": "#AAAAAA",
        "font_color_last_stint_time": "#AAAAAA",
        "font_color_last_stint_fuel": "#AAAAAA",
        "font_color_last_stint_tyre": "#AAAAAA",
        "font_color_last_stint_wear": "#AAAAAA",
        "bkg_color_last_stint_laps": "#88444444",
        "bkg_color_last_stint_time": "#88333333",
        "bkg_color_last_stint_fuel": "#88444444",
        "bkg_color_last_stint_tyre": "#88333333",
        "bkg_color_last_stint_wear": "#88444444",
        "column_index_laps": 1,
        "column_index_time": 2,
        "column_index_fuel": 3,
        "column_index_tyre": 4,
        "column_index_wear": 5,
    },
    "suspension_force": {
        "enable": True,
        "update_interval": 20,
        "position_x": 391,
        "position_y": 713,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.4,
        "bar_padding_vertical": 0.3,
        "bar_width": 50,
        "bar_gap": 2,
        "horizontal_gap": 2,
        "vertical_gap": 2,
        "font_color": "#AAAAAA",
        "highlight_color": "#CC00CC",
        "bkg_color": "#222222",
        "show_force_ratio": True,
        "show_caption": False,
        "font_scale_caption": 0.8,
        "caption_text": "susp force",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
    },
    "suspension_position": {
        "enable": True,
        "update_interval": 20,
        "position_x": 145,
        "position_y": 670,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.4,
        "bar_padding_vertical": 0.3,
        "bar_width": 50,
        "bar_gap": 2,
        "horizontal_gap": 2,
        "vertical_gap": 2,
        "font_color": "#AAAAAA",
        "positive_position_color": "#FFAA00",
        "negative_position_color": "#00AAFF",
        "bkg_color": "#222222",
        "position_max_range": 100,
        "show_third_spring_position_mark": True,
        "third_spring_position_mark_width": 2,
        "third_spring_position_mark_color": "#FFFFFF",
        "show_maximum_position_range": True,
        "maximum_position_range_size": 3,
        "maximum_position_range_color": "#FF2222",
        "show_caption": False,
        "font_scale_caption": 0.8,
        "caption_text": "susp pos",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
    },
    "suspension_travel": {
        "enable": True,
        "update_interval": 20,
        "position_x": 728,
        "position_y": 390,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_total_travel": True,
        "font_color_total_travel": "#FFFFFF",
        "bkg_color_total_travel": "#222222",
        "show_bump_travel": True,
        "font_color_bump_travel": "#FFFFFF",
        "bkg_color_bump_travel": "#222222",
        "show_rebound_travel": True,
        "font_color_rebound_travel": "#FFFFFF",
        "bkg_color_rebound_travel": "#222222",
        "show_travel_ratio": True,
        "font_color_travel_ratio": "#CCCC22",
        "bkg_color_travel_ratio": "#222222",
        "show_minimum_position": True,
        "font_color_minimum_position": "#66CCFF",
        "bkg_color_minimum_position": "#222222",
        "show_maximum_position": True,
        "font_color_maximum_position": "#FF6600",
        "bkg_color_maximum_position": "#222222",
        "show_live_position": True,
        "show_live_position_relative_to_static_position": True,
        "font_color_live_position": "#22CC22",
        "bkg_color_live_position": "#222222",
        "show_caption": True,
        "caption_text_total_travel": "total",
        "caption_text_bump_travel": "bump",
        "caption_text_rebound_travel": "rebound",
        "caption_text_travel_ratio": "t.ratio",
        "caption_text_minimum_position": "min pos",
        "caption_text_maximum_position": "max pos",
        "caption_text_live_position": "live pos",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
        "column_index_total_travel": 1,
        "column_index_bump_travel": 2,
        "column_index_rebound_travel": 3,
        "column_index_travel_ratio": 4,
        "column_index_minimum_position": 5,
        "column_index_maximum_position": 6,
        "column_index_live_position": 7,
    },
    "system_performance": {
        "enable": True,
        "update_interval": 500,
        "position_x": 145,
        "position_y": 710,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_system_performance": True,
        "font_color_system": "#FFFFFF",
        "bkg_color_system": "#222222",
        "show_tinypedal_performance": True,
        "font_color_tinypedal": "#FFFFFF",
        "bkg_color_tinypedal": "#222222",
        "average_samples": 40,
        "prefix_system": "OS ",
        "prefix_tinypedal": "TP ",
        "column_index_system": 1,
        "column_index_tinypedal": 2,
    },
    "timing": {
        "enable": True,
        "update_interval": 20,
        "position_x": 147,
        "position_y": 500,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_session_best": True,
        "show_session_best_from_same_class_only": True,
        "font_color_session_best": "#44DDFF",
        "bkg_color_session_best": "#222222",
        "show_best": True,
        "font_color_best": "#000000",
        "bkg_color_best": "#FFFFFF",
        "show_last": True,
        "font_color_last": "#FFFFFF",
        "font_color_invalid_laptime": "#FF6600",
        "bkg_color_last": "#222222",
        "show_current": True,
        "font_color_current": "#88FF88",
        "bkg_color_current": "#222222",
        "show_estimated": True,
        "font_color_estimated": "#FFFF88",
        "bkg_color_estimated": "#222222",
        "show_session_personal_best": True,
        "font_color_session_personal_best": "#EE77FF",
        "bkg_color_session_personal_best": "#222222",
        "show_stint_best": True,
        "font_color_stint_best": "#CCCCCC",
        "bkg_color_stint_best": "#222222",
        "show_average_pace": True,
        "font_color_average_pace": "#AADD88",
        "bkg_color_average_pace": "#222222",
        "prefix_session_best": "S ",
        "prefix_best": "B ",
        "prefix_last": "L ",
        "prefix_current": "C ",
        "prefix_estimated": "E ",
        "prefix_session_personal_best": "P ",
        "prefix_stint_best": "T ",
        "prefix_average_pace": "A ",
        "column_index_session_best": 1,
        "column_index_best": 2,
        "column_index_last": 3,
        "column_index_current": 4,
        "column_index_estimated": 5,
        "column_index_session_personal_best": 10,
        "column_index_stint_best": 15,
        "column_index_average_pace": 20,
    },
    "track_map": {
        "enable": True,
        "update_interval": 20,
        "position_x": 663,
        "position_y": 25,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding": 0.5,
        "vehicle_scale": 1,
        "vehicle_scale_player": 1,
        "display_orientation": 0,
        "display_detail_level": 1,
        "area_size": 400,
        "area_margin": 40,
        "show_background": False,
        "bkg_color": "#222222",
        "show_map_background": False,
        "bkg_color_map": "#88000000",
        "map_color": "#FFFFFF",
        "map_width": 5,
        "map_outline_color": "#88000000",
        "map_outline_width": 2,
        "show_start_line": True,
        "start_line_color": "#FF4422",
        "start_line_width": 4,
        "start_line_length": 8,
        "show_sector_line": True,
        "sector_line_color": "#00AAFF",
        "sector_line_width": 3,
        "sector_line_length": 7,
        "show_proximity_circle": True,
        "proximity_circle_radius": 150,
        "proximity_circle_width": 3,
        "proximity_circle_color": "#88888888",
        "show_vehicle_standings": True,
        "enable_multi_class_styling": True,
        "show_custom_player_color_in_multi_class": False,
        "show_position_in_class": True,
        "font_color_player": "#FFFFFF",
        "vehicle_color_player": "#FF4422",
        "vehicle_outline_player_width": 2,
        "vehicle_outline_player_color": "#AAFFFFFF",
        "font_color": "#000000",
        "vehicle_color_leader": "#88FF00",
        "vehicle_color_same_lap": "#FFFFFF",
        "vehicle_color_laps_ahead": "#FF44CC",
        "vehicle_color_laps_behind": "#00AAFF",
        "vehicle_color_in_pit": "#888888",
        "vehicle_color_yellow": "#FFFF00",
        "vehicle_outline_width": 1,
        "vehicle_outline_color": "#88000000",
        "show_lap_difference_outline": False,
        "vehicle_outline_width_laps_ahead": 2,
        "vehicle_outline_color_laps_ahead": "#FF44CC",
        "vehicle_outline_width_laps_behind": 2,
        "vehicle_outline_color_laps_behind": "#00AAFF",
        "show_pitout_prediction": True,
        "show_pitout_prediction_while_requested_pitstop": True,
        "prediction_outline_width": 3,
        "prediction_outline_color": "#BBFF0000",
        "number_of_prediction": 6,
        "pitout_time_offset": 3,
        "pitout_duration_minimum": 15,
        "pitout_duration_increment": 10,
        "enabled_fixed_pitout_prediction": False,
        "fixed_pitstop_duration_1": 0,
        "fixed_pitstop_duration_2": 10,
        "fixed_pitstop_duration_3": 25,
        "fixed_pitstop_duration_4": 40,
        "fixed_pitstop_duration_5": 45,
        "fixed_pitstop_duration_6": 52,
        "fixed_pitstop_duration_7": 100,
        "fixed_pitstop_duration_8": 120,
        "fixed_pitstop_duration_9": 180,
        "fixed_pitstop_duration_10": -1,
        "show_pitstop_duration": True,
        "font_color_pitstop_duration": "#FFFFFF",
        "bkg_color_pitstop_duration": "#AA000000",
    },
    "track_notes": {
        "enable": True,
        "update_interval": 20,
        "position_x": 739,
        "position_y": 182,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_background": True,
        "show_pit_notes_while_in_pit": True,
        "pit_notes_text": "Pit Lane",
        "pit_comments_text": "",
        "show_track_notes": True,
        "track_notes_uppercase": False,
        "track_notes_width": 30,
        "track_notes_text_alignment": "Center",
        "font_color_track_notes": "#FFFFFF",
        "bkg_color_track_notes": "#66111111",
        "show_comments": False,
        "enable_comments_line_break": True,
        "comments_width": 30,
        "comments_text_alignment": "Center",
        "font_color_comments": "#FFFFFF",
        "bkg_color_comments": "#66111111",
        "show_debugging": False,
        "debugging_width": 30,
        "debugging_text_alignment": "Center",
        "font_color_debugging": "#FFFFFF",
        "bkg_color_debugging": "#66111111",
        "auto_hide_if_not_available": True,
        "maximum_display_duration": -1,
        "column_index_track_notes": 1,
        "column_index_comments": 2,
        "column_index_debugging": 3,
    },
    "trailing": {
        "enable": True,
        "update_interval": 20,
        "position_x": 433,
        "position_y": 610,
        "opacity": 0.9,
        "bkg_color": "#CC222222",
        "display_width": 300,
        "display_height": 60,
        "display_margin": 2,
        "display_scale": 2,
        "show_inverted_pedal": False,
        "show_inverted_trailing": True,
        "show_throttle": True,
        "show_raw_throttle": False,
        "throttle_color": "#77FF00",
        "throttle_line_width": 2,
        "throttle_line_style": 0,
        "show_brake": True,
        "show_raw_brake": False,
        "brake_color": "#FF2200",
        "brake_line_width": 2,
        "brake_line_style": 0,
        "show_clutch": True,
        "show_raw_clutch": False,
        "clutch_color": "#00C2F2",
        "clutch_line_width": 2,
        "clutch_line_style": 0,
        "show_ffb": True,
        "show_absolute_ffb": True,
        "ffb_color": "#888888",
        "ffb_line_width": 2,
        "ffb_line_style": 0,
        "show_steering": False,
        "show_inverted_steering": False,
        "steering_color": "#FFFFFF",
        "steering_line_width": 2,
        "steering_line_style": 0,
        "show_wheel_lock": True,
        "wheel_lock_color": "#FFFF00",
        "wheel_lock_line_width": 6,
        "wheel_lock_line_style": 1,
        "wheel_lock_threshold": 0.3,
        "show_wheel_slip": True,
        "wheel_slip_color": "#FF00FF",
        "wheel_slip_line_width": 6,
        "wheel_slip_line_style": 1,
        "wheel_slip_threshold": 0.1,
        "show_reference_line": True,
        "reference_line_1_style": 0,
        "reference_line_1_offset": 0.25,
        "reference_line_1_width": 1,
        "reference_line_1_color": "#666666",
        "reference_line_2_style": 0,
        "reference_line_2_offset": 0.5,
        "reference_line_2_width": 1,
        "reference_line_2_color": "#666666",
        "reference_line_3_style": 0,
        "reference_line_3_offset": 0.75,
        "reference_line_3_width": 1,
        "reference_line_3_color": "#666666",
        "reference_line_4_style": 0,
        "reference_line_4_offset": 0,
        "reference_line_4_width": 0,
        "reference_line_4_color": "#666666",
        "reference_line_5_style": 0,
        "reference_line_5_offset": 0,
        "reference_line_5_width": 0,
        "reference_line_5_color": "#666666",
        "draw_order_index_throttle": 2,
        "draw_order_index_brake": 1,
        "draw_order_index_clutch": 5,
        "draw_order_index_ffb": 6,
        "draw_order_index_steering": 7,
        "draw_order_index_wheel_lock": 4,
        "draw_order_index_wheel_slip": 3,
    },
    "tyre_carcass": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 670,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "inner_gap": 0,
        "enable_heatmap_auto_matching": True,
        "heatmap_name": HEATMAP_DEFAULT_TYRE,
        "swap_style": False,
        "show_degree_sign": False,
        "leading_zero": 2,
        "font_color_carcass": "#000000",
        "bkg_color_carcass": "#222222",
        "show_rate_of_change": True,
        "rate_of_change_interval": 5,
        "rate_of_change_smoothing_samples": 20,
        "font_color_rate_of_change": "#000000",
        "bkg_color_rate_of_change": "#222222",
        "font_color_rate_gain": "#FF6600",
        "font_color_rate_loss": "#66CCFF",
        "show_tyre_compound": True,
        "font_color_tyre_compound": "#666666",
        "bkg_color_tyre_compound": "#222222",
        "column_index_carcass": 1,
        "column_index_rate_of_change": 2,
    },
    "tyre_inner_layer": {
        "enable": True,
        "update_interval": 20,
        "position_x": 249,
        "position_y": 563,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "horizontal_gap": 0,
        "vertical_gap": 0,
        "inner_gap": 0,
        "enable_heatmap_auto_matching": True,
        "heatmap_name": HEATMAP_DEFAULT_TYRE,
        "swap_style": False,
        "show_inner_center_outer": True,
        "show_degree_sign": False,
        "leading_zero": 2,
        "font_color_inner_layer": "#000000",
        "bkg_color_inner_layer": "#222222",
        "show_tyre_compound": True,
        "font_color_tyre_compound": "#666666",
        "bkg_color_tyre_compound": "#222222",
    },
    "tyre_load": {
        "enable": True,
        "update_interval": 20,
        "position_x": 253,
        "position_y": 430,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "enable_auto_font_offset": True,
        "font_offset_vertical": 0,
        "bar_padding_horizontal": 0.4,
        "bar_padding_vertical": 0.3,
        "bar_width": 50,
        "bar_gap": 2,
        "horizontal_gap": 2,
        "vertical_gap": 2,
        "font_color": "#AAAAAA",
        "highlight_color": "#FFFFFF",
        "bkg_color": "#222222",
        "show_tyre_load_ratio": True,
        "show_caption": False,
        "font_scale_caption": 0.8,
        "caption_text": "tyre load",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
    },
    "tyre_pressure": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 383,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "inner_gap": 0,
        "swap_style": False,
        "hot_pressure_temperature_threshold": 65,
        "font_color_pressure_cold": "#66CCFF",
        "font_color_pressure_hot": "#FF6600",
        "bkg_color_pressure": "#222222",
        "show_pressure_deviation": True,
        "average_sampling_duration": 10,
        "font_color_pressure_deviation": "#AAAAAA",
        "bkg_color_pressure_deviation": "#222222",
        "show_tyre_compound": True,
        "font_color_tyre_compound": "#666666",
        "bkg_color_tyre_compound": "#222222",
        "column_index_pressure": 1,
        "column_index_pressure_deviation": 2,
    },
    "tyre_temperature": {
        "enable": True,
        "update_interval": 20,
        "position_x": 249,
        "position_y": 525,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "horizontal_gap": 0,
        "vertical_gap": 0,
        "inner_gap": 0,
        "enable_heatmap_auto_matching": True,
        "heatmap_name": HEATMAP_DEFAULT_TYRE,
        "swap_style": False,
        "show_inner_center_outer": True,
        "show_degree_sign": False,
        "leading_zero": 2,
        "font_color_surface": "#000000",
        "bkg_color_surface": "#222222",
        "show_tyre_compound": True,
        "font_color_tyre_compound": "#666666",
        "bkg_color_tyre_compound": "#222222",
    },
    "tyre_wear": {
        "enable": True,
        "update_interval": 20,
        "position_x": 57,
        "position_y": 444,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_remaining": True,
        "font_color_remaining": "#22CC22",
        "bkg_color_remaining": "#222222",
        "show_wear_difference": True,
        "font_color_wear_difference": "#CCCCCC",
        "bkg_color_wear_difference": "#222222",
        "show_live_wear_difference": False,
        "font_color_live_wear_difference": "#CCCCCC",
        "bkg_color_live_wear_difference": "#222222",
        "show_lifespan_laps": True,
        "font_color_lifespan_laps": "#CCCC22",
        "bkg_color_lifespan_laps": "#222222",
        "show_lifespan_minutes": True,
        "font_color_lifespan_minutes": "#66CCCC",
        "bkg_color_lifespan_minutes": "#222222",
        "show_end_stint_remaining": True,
        "font_color_end_stint_remaining": "#CCCCCC",
        "bkg_color_end_stint_remaining": "#222222",
        "warning_threshold_remaining": 30,
        "warning_threshold_wear": 3,
        "warning_threshold_laps": 5,
        "warning_threshold_minutes": 6,
        "font_color_warning": "#FF2200",
        "show_caption": True,
        "caption_text_remaining": "tyre wear",
        "caption_text_wear_difference": "wear diff",
        "caption_text_live_wear_difference": "live wear",
        "caption_text_lifespan_laps": "est. laps",
        "caption_text_lifespan_minutes": "est. mins",
        "caption_text_end_stint_remaining": "end tread",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
        "column_index_remaining": 1,
        "column_index_wear_difference": 2,
        "column_index_live_wear_difference": 3,
        "column_index_lifespan_laps": 4,
        "column_index_lifespan_minutes": 5,
        "column_index_end_stint_remaining": 6,
    },
    "virtual_energy": {
        "enable": True,
        "update_interval": 20,
        "position_x": 115,
        "position_y": 824,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_width": 5,
        "bar_gap": 0,
        "show_absolute_refilling": False,
        "font_color_remain": "#FFFFFF",
        "bkg_color_remain": "#0088FF",
        "font_color_refill": "#FFFFFF",
        "bkg_color_refill": "#0088FF",
        "font_color_laps": "#DDDDDD",
        "bkg_color_laps": "#333333",
        "font_color_minutes": "#DDDDDD",
        "bkg_color_minutes": "#333333",
        "font_color_used": "#555555",
        "bkg_color_used": "#FFFFFF",
        "font_color_save": "#DDDDDD",
        "bkg_color_save": "#666666",
        "show_estimated_pitstop_count": True,
        "font_color_pits": "#DDDDDD",
        "bkg_color_pits": "#666666",
        "font_color_early": "#DDDDDD",
        "bkg_color_early": "#666666",
        "show_delta_and_end_remaining": True,
        "font_color_delta": "#555555",
        "bkg_color_delta": "#FFFFFF",
        "font_color_end": "#DDDDDD",
        "bkg_color_end": "#666666",
        "show_fuel_ratio_and_bias": True,
        "font_color_ratio": "#555555",
        "bkg_color_ratio": "#FFFFFF",
        "font_color_bias": "#DDDDDD",
        "bkg_color_bias": "#666666",
        "low_energy_lap_threshold": 2,
        "warning_color_low_energy": "#FF22FF",
        "show_low_energy_warning_flash": True,
        "number_of_warning_flashes": 10,
        "warning_flash_highlight_duration": 0.4,
        "warning_flash_interval": 0.4,
        "show_energy_level_bar": True,
        "energy_level_bar_height": 10,
        "highlight_color_energy_level": "#FFFFFF",
        "bkg_color_energy_level": "#222222",
        "show_starting_energy_level_mark": True,
        "starting_energy_level_mark_width": 3,
        "starting_energy_level_mark_color": "#FF4400",
        "show_refilling_level_mark": True,
        "refilling_level_mark_width": 3,
        "refilling_level_mark_color": "#44FF00",
        "decimal_places_remain": 2,
        "decimal_places_refill": 2,
        "decimal_places_laps": 1,
        "decimal_places_minutes": 1,
        "decimal_places_used": 2,
        "decimal_places_save": 2,
        "decimal_places_pits": 2,
        "decimal_places_early": 2,
        "decimal_places_delta": 2,
        "decimal_places_end": 2,
        "decimal_places_ratio": 3,
        "decimal_places_bias": 2,
        "show_caption": True,
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
        "caption_text_remain": "energy",
        "caption_text_refill": "refill",
        "caption_text_absolute_refill": "abfill",
        "caption_text_laps": "laps",
        "caption_text_minutes": "mins",
        "caption_text_used": "used",
        "caption_text_save": "save",
        "caption_text_pits": "pits",
        "caption_text_early": "early",
        "caption_text_delta": "delta",
        "caption_text_end": "end",
        "caption_text_ratio": "ratio",
        "caption_text_bias": "bias",
        "swap_upper_caption": False,
        "swap_lower_caption": False,
        "column_index_upper": 1,
        "column_index_middle": 2,
        "column_index_lower": 3,
    },
    "weather": {
        "enable": True,
        "update_interval": 100,
        "position_x": 57,
        "position_y": 70,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_temperature": True,
        "font_color_temperature": "#FFFFFF",
        "bkg_color_temperature": "#222222",
        "show_rain": True,
        "prefix_rain": "Rain",
        "font_color_rain": "#FFFFFF",
        "bkg_color_rain": "#222222",
        "show_wetness": True,
        "prefix_dry": "Dry",
        "prefix_wet": "Wet",
        "font_color_wetness": "#FFFFFF",
        "bkg_color_wetness": "#222222",
        "show_rubber_coverage_while_dry": True,
        "rubber_median_laps": 2000,
        "rubber_time_scale_practice": 1,
        "rubber_time_scale_qualifying": 1,
        "rubber_time_scale_race": 1,
        "starting_rubber_practice": 0.25,
        "starting_rubber_qualifying": 0.5,
        "starting_rubber_race": 0.5,
        "temperature_trend_interval": 60,
        "raininess_trend_interval": 60,
        "wetness_trend_interval": 60,
        "font_color_trend_constant": "#AAAAAA",
        "font_color_trend_decreasing": "#44FF00",
        "font_color_trend_increasing": "#FF4400",
        "decimal_places_temperature": 1,
        "column_index_temperature": 1,
        "column_index_rain": 2,
        "column_index_wetness": 3,
    },
    "weather_forecast": {
        "enable": True,
        "update_interval": 100,
        "position_x": 256,
        "position_y": 640,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 11,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "icon_size": 32,
        "bkg_color": "#222222",
        "show_estimated_time": True,
        "font_color_estimated_time": "#000000",
        "bkg_color_estimated_time": "#FFFFFF",
        "show_ambient_temperature": True,
        "font_color_ambient_temperature": "#000000",
        "bkg_color_ambient_temperature": "#FFFFFF",
        "show_rain_chance_bar": True,
        "rain_chance_bar_height": 5,
        "rain_chance_bar_color": "#FF00FF",
        "rain_chance_bar_bkg_color": "#88222222",
        "number_of_forecasts": 4,
        "show_unavailable_data": False,
        "column_index_estimated_time": 1,
        "column_index_weather_icon": 2,
        "column_index_ambient_temperature": 3,
        "column_index_rain_chance_bar": 4,
    },
    "weight_distribution": {
        "enable": True,
        "update_interval": 20,
        "position_x": 830,
        "position_y": 720,
        "opacity": 0.9,
        "layout": 0,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 2,
        "show_percentage_sign": True,
        "smoothing_samples": 10,
        "decimal_places": 1,
        "show_front_to_rear_distribution": True,
        "font_color_front_to_rear_distribution": "#FFFFFF",
        "bkg_color_front_to_rear_distribution": "#222222",
        "show_left_to_right_distribution": True,
        "font_color_left_to_right_distribution": "#FFFFFF",
        "bkg_color_left_to_right_distribution": "#222222",
        "show_cross_weight": True,
        "font_color_cross_weight": "#FFFFFF",
        "bkg_color_cross_weight": "#8800CC",
        "prefix_front_to_rear_distribution": "F ",
        "prefix_left_to_right_distribution": "L ",
        "prefix_cross_weight": "C ",
        "column_index_front_to_rear_distribution": 1,
        "column_index_left_to_right_distribution": 2,
        "column_index_cross_weight": 3,
    },
    "wheel_camber": {
        "enable": True,
        "update_interval": 20,
        "position_x": 140,
        "position_y": 395,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 0,
        "horizontal_gap": 0,
        "vertical_gap": 0,
        "camber_smoothing_samples": 10,
        "font_color_camber": "#FFFFFF",
        "bkg_color_camber": "#222222",
        "show_camber_difference": True,
        "camber_difference_smoothing_samples": 20,
        "font_color_camber_difference": "#AAAAAA",
        "bkg_color_camber_difference": "#222222",
        "decimal_places_camber": 2,
        "decimal_places_camber_difference": 1,
        "show_caption": True,
        "caption_text": "camber",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
    },
    "wheel_toe": {
        "enable": True,
        "update_interval": 20,
        "position_x": 140,
        "position_y": 447,
        "opacity": 0.9,
        "font_name": "Consolas",
        "font_size": 15,
        "font_weight": "bold",
        "bar_padding": 0.2,
        "bar_gap": 0,
        "horizontal_gap": 0,
        "vertical_gap": 0,
        "toe_in_smoothing_samples": 10,
        "font_color_toe_in": "#FFFFFF",
        "bkg_color_toe_in": "#222222",
        "show_total_toe_angle": True,
        "total_toe_angle_smoothing_samples": 20,
        "font_color_total_toe_angle": "#AAAAAA",
        "bkg_color_total_toe_angle": "#222222",
        "decimal_places_toe_in": 2,
        "decimal_places_total_toe_angle": 2,
        "show_caption": True,
        "caption_text": "toe in",
        "font_color_caption": "#CCCCCC",
        "bkg_color_caption": "#777777",
    },
}

```

# File: tinypedal/ui/__init__.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Application UI, style
"""

from PySide2.QtGui import QGuiApplication, QPalette
from PySide2.QtWidgets import QApplication


def set_style_palette(color_theme: str):
    """Set style palette"""
    if color_theme == "Dark":
        palette_theme = palette_dark()
    else:
        palette_theme = palette_light()

    palette = QGuiApplication.palette()
    group_active = QPalette.Active
    group_inactive = QPalette.Inactive
    group_disabled = QPalette.Disabled
    for color_active, color_inactive, color_disabled, color_role in palette_theme:
        palette.setColor(group_active, color_role, color_active)
        palette.setColor(group_inactive, color_role, color_inactive)
        palette.setColor(group_disabled, color_role, color_disabled)
    QApplication.setPalette(palette)


def palette_light():
    """Set palette light"""
    return (
        #   Active   Inactive   Disabled  Role
        ("#F0F0F0", "#F0F0F0", "#E8E8E8", QPalette.Window),
        ("#050505", "#050505", "#808080", QPalette.WindowText),
        ("#FFFFFF", "#FFFFFF", "#EEEEEE", QPalette.Base),
        ("#EBEBEB", "#EBEBEB", "#DBDBDB", QPalette.AlternateBase),
        ("#FFFFFF", "#FFFFFF", "#FFFFFF", QPalette.ToolTipBase),
        ("#050505", "#050505", "#050505", QPalette.ToolTipText),
        ("#050505", "#050505", "#050505", QPalette.PlaceholderText),
        ("#050505", "#050505", "#808080", QPalette.Text),
        ("#F0F0F0", "#F0F0F0", "#F0F0F0", QPalette.Button),
        ("#050505", "#050505", "#808080", QPalette.ButtonText),
        ("#FFFFFF", "#FFFFFF", "#FFFFFF", QPalette.BrightText),
        ("#FFFFFF", "#FFFFFF", "#FFFFFF", QPalette.Light),
        ("#E3E3E3", "#E3E3E3", "#F7F7F7", QPalette.Midlight),
        ("#A0A0A0", "#A0A0A0", "#A0A0A0", QPalette.Dark),
        ("#CCCCCC", "#CCCCCC", "#CCCCCC", QPalette.Mid),
        ("#111111", "#111111", "#050505", QPalette.Shadow),
        ("#0088DD", "#555555", "#CCCCCC", QPalette.Highlight),
        ("#FFFFFF", "#F0F0F0", "#555555", QPalette.HighlightedText),
        ("#0088DD", "#0088DD", "#808080", QPalette.Link),
        ("#FF00FF", "#FF00FF", "#808080", QPalette.LinkVisited),
    )


def palette_dark():
    """Set palette dark"""
    return (
        #   Active   Inactive   Disabled  Role
        ("#333333", "#333333", "#2A2A2A", QPalette.Window),
        ("#FAFAFA", "#FAFAFA", "#808080", QPalette.WindowText),
        ("#222222", "#222222", "#333333", QPalette.Base),
        ("#2A2A2A", "#2A2A2A", "#3A3A3A", QPalette.AlternateBase),
        ("#333333", "#333333", "#333333", QPalette.ToolTipBase),
        ("#FAFAFA", "#FAFAFA", "#FAFAFA", QPalette.ToolTipText),
        ("#FAFAFA", "#FAFAFA", "#FAFAFA", QPalette.PlaceholderText),
        ("#FAFAFA", "#FAFAFA", "#808080", QPalette.Text),
        ("#333333", "#333333", "#303030", QPalette.Button),
        ("#FAFAFA", "#FAFAFA", "#888888", QPalette.ButtonText),
        ("#FFFFFF", "#FFFFFF", "#FFFFFF", QPalette.BrightText),
        ("#AAAAAA", "#AAAAAA", "#484848", QPalette.Light),
        ("#999999", "#999999", "#383838", QPalette.Midlight),
        ("#555555", "#555555", "#181818", QPalette.Dark),
        ("#444444", "#444444", "#222222", QPalette.Mid),
        ("#222222", "#222222", "#0E0E0E", QPalette.Shadow),
        ("#0088DD", "#CCCCCC", "#444444", QPalette.Highlight),
        ("#FAFAFA", "#181818", "#999999", QPalette.HighlightedText),
        ("#22AAFF", "#22AAFF", "#808080", QPalette.Link),
        ("#FF22FF", "#FF22FF", "#808080", QPalette.LinkVisited),
    )


def set_style_window(base_font_pt: int) -> str:
    """Set style window (not affecting overlay)"""
    # Scale font (point size)
    font_pt_item_name = 1.2 * base_font_pt
    font_pt_item_button = 1.05 * base_font_pt
    font_pt_item_toggle = 1.0 * base_font_pt
    font_pt_text_browser = 0.9 * base_font_pt
    font_pt_app_name = 1.4 * base_font_pt

    # Size
    border_radius_button = 0.1  # em

    # Color
    palette = QApplication.palette()
    palette.setCurrentColorGroup(QPalette.Active)
    color_active_window_text = palette.windowText().color().name()
    color_active_window = palette.window().color().name()
    color_active_base = palette.base().color().name()
    color_active_highlighted_text = palette.highlightedText().color().name()
    color_active_highlight = palette.highlight().color().name()

    palette.setCurrentColorGroup(QPalette.Inactive)
    color_inactive_highlighted_text = palette.highlightedText().color().name()
    color_inactive_highlight = palette.highlight().color().name()

    palette.setCurrentColorGroup(QPalette.Disabled)
    color_disabled_window_text = palette.windowText().color().name()
    color_disabled_highlighted_text = palette.highlightedText().color().name()
    color_disabled_highlight = palette.highlight().color().name()

    style = f"""
        /* Misc */
        QSizeGrip {{
            image: none;
            width: 4px;
        }}
        QToolTip {{
            color: {color_active_window_text};
            background: {color_active_window};
            border: 1px solid {color_disabled_window_text};
        }}

        /* Main status bar */
        AppWindow QStatusBar > QPushButton {{
            font-size: {font_pt_text_browser}pt;
            border: none;
            padding: 0.1em 0.2em;
        }}
        AppWindow QStatusBar > QPushButton::hover {{
            color: {color_active_highlighted_text};
            background: {color_active_highlight};
        }}
        AppWindow QStatusBar > QPushButton::menu-indicator {{
            image: none;
            width: 0;
        }}

        /* Notify bar */
        NotifyBar QPushButton {{
            font-weight: bold;
            padding: 0.2em;
            border: none;
            color: {color_active_highlighted_text};
        }}
        NotifyBar #notifySpectate {{
            background: #08C;
        }}
        NotifyBar #notifyPacenotes {{
            background: #290;
        }}
        NotifyBar #notifyPresetLocked {{
            background: #777;
        }}
        NotifyBar #notifyUpdates {{
            background: #A4A;
        }}
        NotifyBar #notifyUpdates::menu-indicator {{
            image: none;
            width: 0;
        }}

        /* Module list (tab) */
        ModuleList QListView {{
            font-size: {font_pt_item_name}pt;
            outline: none;
        }}
        ModuleList QListView::item {{
            border: none;
            min-height: 1.75em;
            color: {color_active_window_text};
        }}
        ModuleList QListView::item:selected {{
            background: transparent;
        }}
        ModuleList QListView::item:hover {{
            background: {color_disabled_highlight};
        }}
        ModuleControlItem QPushButton {{
            border-radius: {border_radius_button}em;
            height: none;
            margin: 0.25em 0.25em 0.25em 0;
        }}
        ModuleControlItem #buttonConfig {{
            font-size: {font_pt_item_button}pt;
            color: {color_disabled_window_text};
            padding: 0 0.2em;
        }}
        ModuleControlItem #buttonToggle {{
            font-size: {font_pt_item_toggle}pt;
            font-weight: bold;
            color: {color_disabled_highlighted_text};
            background: {color_disabled_highlight};
            min-width: 2em;
        }}
        ModuleControlItem #buttonToggle::checked,
        ModuleControlItem #buttonConfig::checked {{
            color: {color_inactive_highlighted_text};
            background: {color_inactive_highlight};
        }}
        ModuleControlItem #buttonToggle::hover,
        ModuleControlItem #buttonConfig::hover,
        ModuleControlItem #buttonToggle::checked:hover,
        ModuleControlItem #buttonConfig::checked:hover {{
            color: {color_active_highlighted_text};
            background: {color_active_highlight};
        }}

        /* Preset list (tab) */
        PresetList QListView {{
            font-size: {font_pt_item_name}pt;
            outline: none;
        }}
        PresetList QListView::item {{
            border: none;
            min-height: 1.75em;
        }}
        PresetList QListView::item:selected {{
            selection-color: {color_active_highlighted_text};
            background: {color_active_highlight};
        }}
        PresetTagItem QLabel {{
            font-size: {font_pt_item_button}pt;
            color: {color_active_highlighted_text};
            margin: 0.25em 0.25em 0.25em 0;
            border-radius: {border_radius_button}em;
        }}

        /* Preset transfer (dialog) */
        PresetTransfer QListView {{
            outline: none;
            background: {color_active_window};
        }}
        PresetTransfer QListView::item {{
            border: none;
            min-height: 1.75em;
        }}
        PresetTransfer QListView::item:selected {{
            selection-color: {color_active_highlighted_text};
            background: {color_disabled_highlight};
        }}
        PresetTransfer QListView QCheckBox {{
            font-size: {font_pt_item_name}pt;
            margin: 0.25em 0.25em 0.25em 0.25em;
            border-radius: {border_radius_button}em;
        }}
        PresetTransfer ListHeader {{
            background: {color_active_base};
        }}
        PresetTransfer ListHeader QLabel {{
            font-size: {font_pt_item_name}pt;
            color: {color_disabled_highlighted_text};
            padding: 0 0.1em;
        }}
        PresetTransfer ListHeader CompactButton {{
            border: none;
            font-size: {font_pt_item_button}pt;
            padding: 0.2em;
        }}
        PresetTransfer ListHeader CompactButton::checked {{
            color: {color_inactive_highlighted_text};
            background: {color_inactive_highlight};
        }}
        PresetTransfer ListHeader CompactButton::hover,
        PresetTransfer ListHeader CompactButton::checked:hover {{
            color: {color_active_highlighted_text};
            background: {color_active_highlight};
        }}

        /* Spectate list (tab) */
        SpectateList QListView {{
            font-size: {font_pt_item_button}pt;
            outline: none;
        }}
        SpectateList QListView::item {{
            min-height: 1.75em;
            border: none;
        }}
        SpectateList QListView::item:selected {{
            selection-color: {color_active_highlighted_text};
            background: {color_active_highlight};
        }}

        /* Base dialog */
        BaseDialog QStatusBar {{
            font-weight:bold;
        }}
        BaseDialog QTextBrowser {{
            font-size: {font_pt_text_browser}pt;
        }}
        BaseEditor QTableWidget DoubleClickEdit {{
            border: none;
        }}
        FuelCalculator QLineEdit[readOnly="true"]{{
            background: {color_active_window};
        }}
        FuelCalculator QLabel {{
            font-size: {font_pt_text_browser}pt;
        }}
        FuelCalculator PitStopPreview {{
            font-size: {font_pt_text_browser}pt;
            font-weight:bold;
        }}
        FuelCalculator PitStopPreview QLabel {{
            color: {color_inactive_highlighted_text};
            background: {color_inactive_highlight};
            font-weight:bold;
        }}
        About QLabel {{
            font-size: {font_pt_text_browser}pt;
        }}
        About QTextBrowser {{
            border: none;
        }}
        About #labelAppName {{
            font-size: {font_pt_app_name}pt;
        }}
    """
    return style

```

# File: tinypedal/ui/_common.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Common
"""

import os
import re
from collections import deque
from typing import Callable

from PySide2.QtCore import QRegularExpression, Qt
from PySide2.QtGui import (
    QColor,
    QDoubleValidator,
    QIntValidator,
    QRegularExpressionValidator,
    qGray,
)
from PySide2.QtWidgets import (
    QApplication,
    QCheckBox,
    QColorDialog,
    QComboBox,
    QCompleter,
    QDialog,
    QDialogButtonBox,
    QDoubleSpinBox,
    QFileDialog,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from ..const_app import APP_NAME
from ..const_file import FileFilter
from ..module_control import mctrl, wctrl
from ..userfile import set_relative_path
from ..validator import image_exists, is_hex_color, is_string_number

# Validator
QVAL_INTEGER = QIntValidator(-999999, 999999)
QVAL_FLOAT = QDoubleValidator(-999999.9999, 999999.9999, 6)
QVAL_COLOR = QRegularExpressionValidator(QRegularExpression('^#[0-9a-fA-F]*'))
QVAL_HEATMAP = QRegularExpressionValidator(QRegularExpression('[0-9a-zA-Z_]*'))
QVAL_FILENAME = QRegularExpressionValidator(QRegularExpression('[^\\\\/:*?"<>|]*'))

# Misc
color_pick_history = deque(
    ["#FFF"] * QColorDialog.customCount(),
    maxlen=QColorDialog.customCount()
)


class UIScaler:
    """UI font & size scaler"""
    # Global base font size in point (not counting dpi scale)
    FONT_BASE_POINT = QApplication.font().pointSize()
    # Global base font size in pixel (dpi scaled)
    # dpi scale = font dpi / 96
    # px = (pt * dpi scale) * 96 / 72
    # px = pt * font dpi / 72
    FONT_DPI_SCALE = QApplication.fontMetrics().fontDpi() / 96
    FONT_BASE_PIXEL_SCALED = QApplication.font().pointSize() * QApplication.fontMetrics().fontDpi() / 72

    @staticmethod
    def font(scale: float) -> float:
        """Scale UI font size (points) by base font size (not counting dpi scale)"""
        return UIScaler.FONT_BASE_POINT * scale

    @staticmethod
    def size(scale: float) -> int:
        """Scale UI size (pixels) by base font size (scaled with dpi)"""
        return round(UIScaler.FONT_BASE_PIXEL_SCALED * scale)

    @staticmethod
    def pixel(pixel: int):
        """Scale pixel size by base font DPI scale"""
        return round(UIScaler.FONT_DPI_SCALE * pixel)


class CompactButton(QPushButton):
    """Compact button style"""

    def __init__(self, text, parent=None, has_menu=False):
        super().__init__(text, parent)
        self.setFixedWidth(
            self.fontMetrics().boundingRect(text).width()
            + UIScaler.FONT_BASE_PIXEL_SCALED * (1 + has_menu)
        )


# Class
class BaseDialog(QDialog):
    """Base dialog class"""
    MARGIN = UIScaler.pixel(6)

    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
        self.setAttribute(Qt.WA_DeleteOnClose, True)

    def set_config_title(self, option_name: str, preset_name: str):
        """Set config dialog title"""
        self.setWindowTitle(f"{option_name} - {preset_name}")

    def set_utility_title(self, name: str):
        """Set utility dialog title"""
        self.setWindowTitle(f"{name} - {APP_NAME}")

    def confirm_operation(self, title: str = "Confirm", message: str = "") -> bool:
        """Confirm operation"""
        confirm = QMessageBox.question(
            self, title, message,
            buttons=QMessageBox.Yes | QMessageBox.No,
            defaultButton=QMessageBox.No,
        )
        return confirm == QMessageBox.Yes


class BaseEditor(BaseDialog):
    """Base editor class"""

    def __init__(self, parent):
        super().__init__(parent)
        self._is_modified = False
        self._is_rejected = False

    def confirm_discard(self) -> bool:
        """Confirm save or discard changes"""
        if not self._is_modified:
            return True

        confirm = QMessageBox.question(
            self, "Confirm", "<b>Save changes before continue?</b>",
            buttons=QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel)

        if confirm == QMessageBox.Save:
            self.saving()
            return self.confirm_discard()

        return confirm == QMessageBox.Discard

    def is_modified(self) -> bool:
        """Is modified"""
        return self._is_modified

    def set_modified(self):
        """Set modified state"""
        if not self._is_modified:
            self._is_modified = True

    def set_unmodified(self):
        """Set unmodified state"""
        if self._is_modified:
            self._is_modified = False

    def saving(self):
        """Save changes"""

    def reject(self):
        """Reject(ESC) confirm"""
        if self.confirm_discard():
            self._is_rejected = True
            self.close()

    def closeEvent(self, event):
        """Close editor"""
        if self._is_rejected:
            return
        if not self.confirm_discard():
            event.ignore()

    @staticmethod
    def new_name_increment(name: str, table: QTableWidget, column: int = 0) -> str:
        """New name with number increment add at the end"""
        new_index = 1
        new_name = f"{name} {new_index}"
        exist = True
        while exist:  # check existing name
            items = table.findItems(new_name, Qt.MatchExactly)
            for item in items:
                if item.column() == column:  # match column
                    new_index += 1
                    new_name = f"{name} {new_index}"
                    break
            else:
                exist = False
        return new_name

    @staticmethod
    def is_value_in_table(target: str, table: QTableWidget, column: int = 0) -> bool:
        """Is there any matching value in table"""
        items = table.findItems(target, Qt.MatchExactly)
        for item in items:
            if item.column() == column:
                return True
        return False

    @staticmethod
    def reloading(reload_module: bool = True, reload_widget: bool = True) -> None:
        """Reloading"""
        if reload_module:
            mctrl.reload()
        if reload_widget:
            wctrl.reload()


class BatchOffset(BaseDialog):
    """Batch offset"""

    def __init__(self, parent, offset_func: Callable):
        super().__init__(parent)
        self.setWindowTitle("Batch Offset")
        self.decimals = 0
        self.value_range = 0, 1
        self.offset_func = offset_func
        self.edit_offset = QDoubleSpinBox()
        self.last_offset = QLabel("0")
        self.last_label = QLabel("Last Offset:")
        self.checkbox_scale = QCheckBox("Scale Mode")

    def config(self, decimals: int, step: float, min_range: int, max_range: int):
        """Config offset"""
        self.decimals = decimals
        self.value_range = min_range, max_range

        # Label
        layout_label = QHBoxLayout()
        layout_label.addWidget(self.last_label)
        layout_label.addStretch(1)
        layout_label.addWidget(self.last_offset)

        # Edit offset
        self.edit_offset.setDecimals(self.decimals)
        self.edit_offset.setRange(*self.value_range)
        self.edit_offset.setSingleStep(step)
        self.edit_offset.setAlignment(Qt.AlignRight)

        # Scale mode
        self.checkbox_scale.setChecked(False)
        self.checkbox_scale.toggled.connect(self.toggle_mode)

        # Button
        button_apply = QDialogButtonBox(QDialogButtonBox.Apply)
        button_apply.clicked.connect(self.applying)

        button_close = QDialogButtonBox(QDialogButtonBox.Close)
        button_close.rejected.connect(self.reject)

        layout_button = QHBoxLayout()
        layout_button.addWidget(button_apply)
        layout_button.addStretch(1)
        layout_button.addWidget(button_close)

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addLayout(layout_label)
        layout_main.addWidget(self.edit_offset)
        layout_main.addWidget(self.checkbox_scale)
        layout_main.addLayout(layout_button)
        self.setLayout(layout_main)
        self.setFixedSize(UIScaler.size(12), self.sizeHint().height())

    def toggle_mode(self, checked: bool):
        """Toggle mode"""
        self.last_offset.setText("0")
        if checked:
            self.edit_offset.setRange(0, 100)
            self.edit_offset.setDecimals(6)
            self.last_label.setText("Last Scale:")
        else:
            self.edit_offset.setRange(*self.value_range)
            self.edit_offset.setDecimals(self.decimals)
            self.last_label.setText("Last Offset:")

    def applying(self):
        """Apply offset"""
        value = self.edit_offset.value()
        if value != 0:
            self.offset_func(value, self.checkbox_scale.isChecked())
            offset_text = f"{value:.{self.edit_offset.decimals()}f}"
            self.last_offset.setText(offset_text.rstrip("0").rstrip("."))
            self.edit_offset.setValue(0)


class TableBatchReplace(BaseDialog):
    """Table batch replace"""

    def __init__(
        self, parent, table_selector: dict, table_data: QTableWidget):
        """
        Args:
            table_selector: table selector dictionary. key=column name, value=column index.
        """
        super().__init__(parent)
        self.table_selector = table_selector
        self.table_data = table_data
        self.setWindowTitle("Batch Replace")

        # Label & combobox
        self.search_selector = QComboBox()
        self.search_selector.setEditable(True)
        self.search_selector.setCompleter(QCompleter())  # disable auto-complete

        self.column_selector = QComboBox()
        self.column_selector.addItems(self.table_selector.keys())
        self.column_selector.currentIndexChanged.connect(self.update_selector)
        self.update_selector(self.table_selector[self.column_selector.currentText()])

        self.replace_entry = QLineEdit()

        self.checkbox_casematch = QCheckBox("Match Case")
        self.checkbox_casematch.setChecked(False)
        self.checkbox_exactmatch = QCheckBox("Match Whole Word")
        self.checkbox_exactmatch.setChecked(False)

        layout_option = QGridLayout()
        layout_option.setAlignment(Qt.AlignTop)
        layout_option.addWidget(QLabel("Column:"), 0, 0)
        layout_option.addWidget(QLabel("Find:"), 1, 0)
        layout_option.addWidget(QLabel("Replace:"), 2, 0)
        layout_option.addWidget(self.column_selector, 0, 1)
        layout_option.addWidget(self.search_selector, 1, 1)
        layout_option.addWidget(self.replace_entry, 2, 1)
        layout_option.addWidget(self.checkbox_exactmatch, 3, 1)
        layout_option.addWidget(self.checkbox_casematch, 4, 1)

        # Button
        button_replace = QPushButton("Replace")
        button_replace.clicked.connect(self.replacing)

        button_close = QDialogButtonBox(QDialogButtonBox.Close)
        button_close.rejected.connect(self.reject)

        layout_button = QHBoxLayout()
        layout_button.addWidget(button_replace)
        layout_button.addStretch(1)
        layout_button.addWidget(button_close)

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addLayout(layout_option)
        layout_main.addLayout(layout_button)
        self.setLayout(layout_main)
        self.setMinimumWidth(UIScaler.size(22))
        self.setFixedHeight(self.sizeHint().height())

    def update_selector(self, column_index: int, last_search: str = ""):
        """Update selector list"""
        column_index = self.table_selector[self.column_selector.currentText()]
        self.search_selector.clear()
        selector_list = set(
            self.table_data.item(row_index, column_index).text()
            for row_index in range(self.table_data.rowCount())
        )
        self.search_selector.addItems(sorted(selector_list))
        self.search_selector.setCurrentText(last_search)

    def replacing(self):
        """Replace"""
        if not self.search_selector.currentText():
            QMessageBox.warning(self, "Error", "Invalid name.")
            return

        column_index = self.table_selector[self.column_selector.currentText()]
        search = self.search_selector.currentText()
        replace = self.replace_entry.text()

        pattern = re.escape(search)  # escape special chars
        if self.checkbox_exactmatch.isChecked():
            pattern = f"^{pattern}$"

        if self.checkbox_casematch.isChecked():
            match_flag = 0
        else:
            match_flag = re.IGNORECASE

        for row_index in range(self.table_data.rowCount()):
            item = self.table_data.item(row_index, column_index)
            item.setText(re.sub(pattern, replace, item.text(), flags=match_flag))

        self.update_selector(column_index, search)


class DoubleClickEdit(QLineEdit):
    """Line edit with double click dialog trigger"""

    def __init__(self, parent, mode: str, init: str):
        """Set dialog mode and initial value

        Args:
            mode: "color", "path", "image".
            init: initial value.
        """
        super().__init__(parent)
        self.open_mode = mode
        self.init_value = init

    def mouseDoubleClickEvent(self, event):
        """Double click to open dialog"""
        if event.buttons() == Qt.LeftButton:
            if self.open_mode == "color":
                self.open_dialog_color()
            elif self.open_mode == "path":
                self.open_dialog_path()
            elif self.open_mode == "image":
                self.open_dialog_image()

    def open_dialog_color(self):
        """Open color dialog"""
        color_dialog = QColorDialog()
        # Load color history to custom color slot
        for index, old_color in enumerate(color_pick_history):
            color_dialog.setCustomColor(index, QColor(old_color))
        # Open color selector dialog
        color_get = color_dialog.getColor(
            initial=QColor(self.init_value),
            options=QColorDialog.ShowAlphaChannel
        )
        if color_get.isValid():
            # Add new color to color history
            if color_pick_history[0] != color_get:
                color_pick_history.appendleft(color_get)
            # Set output format
            if color_get.alpha() == 255:  # without alpha value
                color = color_get.name(QColor.HexRgb).upper()
            else:  # with alpha value
                color = color_get.name(QColor.HexArgb).upper()
            # Update edit box and init value
            self.setText(color)
            self.init_value = color

    def open_dialog_path(self):
        """Open file path dialog"""
        path_selected = QFileDialog.getExistingDirectory(self, dir=self.init_value)
        if os.path.exists(path_selected):
            # Convert to relative path if in APP root folder
            path_valid = set_relative_path(path_selected)
            # Update edit box and init value
            self.setText(path_valid)
            self.init_value = path_valid

    def open_dialog_image(self):
        """Open image file name dialog"""
        path_selected = QFileDialog.getOpenFileName(self, dir=self.init_value, filter=FileFilter.PNG)[0]
        if image_exists(path_selected):
            self.setText(path_selected)
            self.init_value = path_selected

    def preview_color(self):
        """Update edit preview color"""
        color_str = self.text()
        if is_hex_color(color_str):
            # Set foreground color based on background color lightness
            qcolor = QColor(color_str)
            if qcolor.alpha() > 128 > qGray(qcolor.rgb()):
                fg_color = "#FFF"
            else:
                fg_color = "#000"
            # Apply style
            self.setStyleSheet(f"QLineEdit {{color:{fg_color};background:{color_str};}}")


class FloatTableItem(QTableWidgetItem):
    """QTable item - float type with validation"""

    def __init__(self, value: float):
        """Convert & set float value to string"""
        super().__init__()
        self._value = 0.0
        self.setValue(value)

    def setValue(self, value: float):
        """Set value"""
        self._value = value
        self.setText(str(value))

    def value(self) -> float:
        """Get value"""
        return self._value

    def validate(self):
        """Validate value, replace invalid value with old value if invalid"""
        value = self.text()
        if is_string_number(value):
            self._value = float(value)
        else:
            self.setText(str(self._value))

    def __lt__(self, other):
        """Sort by value"""
        return self.value() < other.value()


class NumericTableItem(QTableWidgetItem):
    """QTable item - sortable numeric text"""

    def __init__(self, value: float, text: str):
        """Set numeric value & string text"""
        super().__init__()
        self.value = value
        self.setText(text)

    def __lt__(self, other):
        """Sort by value"""
        return self.value < other.value

```

# File: tinypedal/ui/about.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
About window
"""

import logging

from PySide2.QtCore import Qt
from PySide2.QtGui import QPixmap
from PySide2.QtWidgets import (
    QDialogButtonBox,
    QHBoxLayout,
    QLabel,
    QTabWidget,
    QTextBrowser,
    QVBoxLayout,
    QWidget,
)

from ..const_app import APP_NAME, COPYRIGHT, DESCRIPTION, LICENSE, URL_WEBSITE, VERSION
from ..const_file import ImageFile
from ._common import BaseDialog, UIScaler

logger = logging.getLogger(__name__)


class About(BaseDialog):
    """Create about window

    Hide window at startup.
    """

    def __init__(self, parent):
        super().__init__(parent)
        self.setWindowTitle(f"About {APP_NAME}")

        # Tab
        main_tab = self.add_tabs()

        # Button
        button_close = QDialogButtonBox(QDialogButtonBox.Close)
        button_close.rejected.connect(self.reject)

        # Layout
        layout_button = QHBoxLayout()
        layout_button.addWidget(button_close)

        layout_main = QVBoxLayout()
        layout_main.addWidget(main_tab)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)
        self.setFixedSize(self.sizeHint().width(), self.sizeHint().height())

    def add_tabs(self):
        """Add tabs"""
        info_tab = self.new_about_tab()
        ctrb_tab = self.new_text_tab(self.load_text_files("docs/contributors.md"))
        lics_tab = self.new_text_tab(self.load_text_files("LICENSE.txt"))
        tpan_tab = self.new_text_tab(self.load_text_files("docs/licenses/THIRDPARTYNOTICES.txt"))
        main_tab = QTabWidget(self)
        main_tab.addTab(info_tab, "About")
        main_tab.addTab(ctrb_tab, "Contributors")
        main_tab.addTab(lics_tab, "License")
        main_tab.addTab(tpan_tab, "Third-Party Notices")
        return main_tab

    @staticmethod
    def load_text_files(filepath: str):
        """Load text file"""
        try:
            with open(filepath, "r", encoding="utf-8") as text_file:
                return text_file.read()
        except FileNotFoundError:
            logger.error("MISSING: %s file not found", filepath)
            error_text = "Error: file not found."
            link_text = f"See link: {URL_WEBSITE}/blob/master/"
            return f"{error_text} \n{link_text}{filepath}"

    def new_text_tab(self, text: str):
        """New text tab"""
        new_tab = QTextBrowser(self)
        new_tab.setText(text)
        new_tab.setMinimumSize(UIScaler.size(30), UIScaler.size(22))
        return new_tab

    def new_about_tab(self):
        """New about tab"""
        new_tab = QWidget(self)

        # Logo
        logo_image = QPixmap(ImageFile.APP_ICON)
        logo_image = logo_image.scaledToHeight(UIScaler.size(9), mode=Qt.SmoothTransformation)

        label_logo = QLabel()
        label_logo.setPixmap(logo_image)
        label_logo.setAlignment(Qt.AlignCenter)

        # Description
        label_name = QLabel(APP_NAME)
        label_name.setObjectName("labelAppName")
        label_name.setAlignment(Qt.AlignCenter)

        label_version = QLabel(f"Version {VERSION}")
        label_version.setAlignment(Qt.AlignCenter)

        label_desc = QLabel(
            f"<p>{COPYRIGHT}</p><p>{DESCRIPTION}</p><p>{LICENSE}</p>"
            f"<p><a href={URL_WEBSITE}>{URL_WEBSITE}</a></p>"
        )
        label_desc.setAlignment(Qt.AlignCenter)
        label_desc.setOpenExternalLinks(True)

        # Layout
        layout_about = QVBoxLayout()
        layout_about.addSpacing(UIScaler.size(1))
        layout_about.addWidget(label_logo)
        layout_about.addSpacing(UIScaler.size(1))
        layout_about.addWidget(label_name)
        layout_about.addWidget(label_version)
        layout_about.addSpacing(UIScaler.size(1))
        layout_about.addWidget(label_desc)
        layout_about.addSpacing(UIScaler.size(1))
        layout_about.setAlignment(Qt.AlignHCenter | Qt.AlignTop)
        new_tab.setLayout(layout_about)
        return new_tab

```

# File: tinypedal/ui/app.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Main application window
"""

import logging
import time

from PySide2.QtCore import Qt, Slot
from PySide2.QtWidgets import (
    QApplication,
    QMainWindow,
    QMessageBox,
    QPushButton,
    QStatusBar,
    QSystemTrayIcon,
    QTabWidget,
    QVBoxLayout,
    QWidget,
)

from .. import loader, overlay_signal
from ..api_control import api
from ..const_api import API_MAP_ALIAS
from ..const_app import APP_NAME, VERSION
from ..const_file import ConfigType
from ..module_control import mctrl, wctrl
from ..setting import cfg
from . import set_style_palette, set_style_window
from ._common import UIScaler
from .menu import APIMenu, ConfigMenu, HelpMenu, OverlayMenu, ToolsMenu, WindowMenu
from .module_view import ModuleList
from .notification import NotifyBar
from .pace_notes_view import PaceNotesControl
from .preset_view import PresetList
from .spectate_view import SpectateList

logger = logging.getLogger(__name__)


class TabView(QWidget):
    """Tab view"""

    def __init__(self, parent):
        super().__init__(parent)
        # Notify bar
        notify_bar = NotifyBar(self)

        # Tabs
        widget_tab = ModuleList(self, wctrl)
        module_tab = ModuleList(self, mctrl)
        preset_tab = PresetList(self, parent.reload_preset, notify_bar.presetlocked.setVisible)
        spectate_tab = SpectateList(self, notify_bar.spectate.setVisible)
        pacenotes_tab = PaceNotesControl(self, notify_bar.pacenotes.setVisible)

        self._tabs = QTabWidget(self)
        self._tabs.addTab(widget_tab, "Widget")  # 0
        self._tabs.addTab(module_tab, "Module")  # 1
        self._tabs.addTab(preset_tab, "Preset")  # 2
        self._tabs.addTab(spectate_tab, "Spectate")  # 3
        self._tabs.addTab(pacenotes_tab, "Pace Notes")  # 4

        # Main view
        layout_main = QVBoxLayout()
        layout_main.setContentsMargins(0, 0, 0, 0)
        layout_main.setSpacing(0)
        layout_main.addWidget(self._tabs)
        layout_main.addWidget(notify_bar)
        self.setLayout(layout_main)

    def refresh_tab(self, index: int = -1):
        """Refresh tab

        Args:
            index: -1 All tabs, 0 Widget, 1 Module, 2 Preset, 3 Spectate, 4 Pace Notes
        """
        if index < 0:
            for tab_index in range(self._tabs.count()):
                self._tabs.widget(tab_index).refresh()
        else:
            self._tabs.widget(index).refresh()

    def select_tab(self, index: int):
        """Select tab"""
        self._tabs.setCurrentIndex(index)


class StatusButtonBar(QStatusBar):
    """Status button bar"""

    def __init__(self, parent):
        super().__init__(parent)
        self._parent = parent

        self.button_api = QPushButton("")
        self.button_api.clicked.connect(self.refresh)
        self.button_api.setToolTip("Config Telemetry API")

        self.button_style = QPushButton("Light")
        self.button_style.clicked.connect(self.toggle_color_theme)
        self.button_style.setToolTip("Toggle Window Color Theme")

        self.button_dpiscale = QPushButton("Scale: Auto")
        self.button_dpiscale.clicked.connect(self.toggle_dpi_scaling)
        self.button_dpiscale.setToolTip("Toggle High DPI Scaling")
        self._last_dpi_scaling = cfg.application["enable_high_dpi_scaling"]

        self.addPermanentWidget(self.button_api)
        self.addWidget(self.button_style)
        self.addWidget(self.button_dpiscale)
        self.refresh()

    def refresh(self):
        """Refresh status bar"""
        if cfg.api["enable_active_state_override"]:
            text_api_status = "overriding"
        else:
            text_api_status = api.read.state.version()
        self.button_api.setText(f"API: {API_MAP_ALIAS[api.name]} ({text_api_status})")

        self.button_style.setText(f"UI: {cfg.application['window_color_theme']}")

        if cfg.application["enable_high_dpi_scaling"]:
            text_dpi = "Auto"
        else:
            text_dpi = "Off"
        if self._last_dpi_scaling != cfg.application["enable_high_dpi_scaling"]:
            text_need_restart = "*"
        else:
            text_need_restart = ""
        self.button_dpiscale.setText(f"Scale: {text_dpi}{text_need_restart}")

    def toggle_dpi_scaling(self):
        """Toggle DPI scaling"""
        if cfg.application["enable_high_dpi_scaling"]:
            state = "Disable"
            desc = "not be scaled under high DPI screen resolution."
        else:
            state = "Enable"
            desc = "be auto-scaled according to system DPI scaling setting."
        msg_text = (
            f"{state} <b>High DPI Scaling</b> and restart <b>TinyPedal</b>?<br><br>"
            f"<b>Window</b> and <b>Overlay</b> size and position will {desc}"
        )
        restart_msg = QMessageBox.question(
            self, "High DPI Scaling", msg_text,
            buttons=QMessageBox.Yes | QMessageBox.No,
            defaultButton=QMessageBox.No,
        )
        if restart_msg != QMessageBox.Yes:
            return

        cfg.application["enable_high_dpi_scaling"] = not cfg.application["enable_high_dpi_scaling"]
        cfg.save(0, cfg_type=ConfigType.CONFIG)
        # Wait saving finish
        while cfg.is_saving:
            time.sleep(0.01)
        loader.restart()

    def toggle_color_theme(self):
        """Toggle color theme"""
        if cfg.application["window_color_theme"] == "Dark":
            cfg.application["window_color_theme"] = "Light"
        else:
            cfg.application["window_color_theme"] = "Dark"
        cfg.save(cfg_type=ConfigType.CONFIG)
        self._parent.load_window_style()


class AppWindow(QMainWindow):
    """Main application window"""

    def __init__(self):
        super().__init__()
        self.setWindowTitle(f"{APP_NAME} v{VERSION}")
        self.setAttribute(Qt.WA_DeleteOnClose, True)

        # Status bar
        self.setStatusBar(StatusButtonBar(self))

        # Menu bar
        self.set_menu_bar()

        # Tab view
        self.tab_view = TabView(self)
        self.setCentralWidget(self.tab_view)

        # Tray icon
        self.set_tray_icon()

        # Apply color style
        self.last_style = None
        self.load_window_style()

        # Window state
        self.set_window_state()
        self.__connect_signal()

    def set_menu_bar(self):
        """Set menu bar"""
        logger.info("GUI: loading window menu")
        menu = self.menuBar()
        # Overlay menu
        menu_overlay = OverlayMenu("Overlay", self)
        menu.addMenu(menu_overlay)
        # API menu
        menu_api = APIMenu("API", self)
        menu.addMenu(menu_api)
        self.statusBar().button_api.setMenu(menu_api)
        # Config menu
        menu_config = ConfigMenu("Config", self)
        menu.addMenu(menu_config)
        # Tools menu
        menu_tools = ToolsMenu("Tools", self)
        menu.addMenu(menu_tools)
        # Window menu
        menu_window = WindowMenu("Window", self)
        menu.addMenu(menu_window)
        # Help menu
        menu_help = HelpMenu("Help", self)
        menu.addMenu(menu_help)

    def set_tray_icon(self):
        """Set tray icon"""
        logger.info("GUI: loading tray icon")
        tray_icon = QSystemTrayIcon(self)
        # Config tray icon
        tray_icon.setIcon(self.windowIcon())
        tray_icon.setToolTip(self.windowTitle())
        tray_icon.activated.connect(self.tray_doubleclick)
        # Add tray menu
        tray_menu = OverlayMenu("Overlay", self, True)
        tray_icon.setContextMenu(tray_menu)
        tray_icon.show()

    def tray_doubleclick(self, active_reason: QSystemTrayIcon.ActivationReason):
        """Tray doubleclick"""
        if active_reason == QSystemTrayIcon.ActivationReason.DoubleClick:
            self.show_app()

    def set_window_state(self):
        """Set initial window state"""
        self.setMinimumSize(UIScaler.size(23), UIScaler.size(36))
        self.setWindowFlag(Qt.WindowMaximizeButtonHint, False)  # disable maximize

        if cfg.application["remember_size"]:
            self.resize(
                cfg.application["window_width"],
                cfg.application["window_height"],
            )

        if cfg.application["remember_position"]:
            self.load_window_position()

        if cfg.compatibility["enable_window_position_correction"]:
            self.verify_window_position()

        if cfg.application["show_at_startup"]:
            self.showNormal()
        elif not cfg.application["minimize_to_tray"]:
            self.showMinimized()

    def load_window_position(self):
        """Load window position"""
        logger.info("GUI: loading window setting")
        app_pos_x = cfg.application["position_x"]
        app_pos_y = cfg.application["position_y"]
        # Save new x,y position if preset value at 0,0
        if 0 == app_pos_x == app_pos_y:
            self.save_window_state()
        else:
            self.move(app_pos_x, app_pos_y)

    def verify_window_position(self):
        """Verify window position"""
        # Get screen size from the screen where app window located
        screen_geo = self.screen().geometry()
        # Limiting position value if out of screen range
        app_pos_x = min(
            max(self.x(), screen_geo.left()),
            screen_geo.right() - self.minimumWidth(),
        )
        app_pos_y = min(
            max(self.y(), screen_geo.top()),
            screen_geo.bottom() - self.minimumHeight(),
        )
        # Re-adjust position only if mismatched
        if self.x() != app_pos_x or self.y() != app_pos_y:
            self.move(app_pos_x, app_pos_y)
            logger.info("GUI: window position corrected")

    def save_window_state(self):
        """Save window state"""
        save_changes = False

        if cfg.application["remember_position"]:
            last_pos = cfg.application["position_x"], cfg.application["position_y"]
            new_pos = self.x(), self.y()
            if last_pos != new_pos:
                cfg.application["position_x"] = new_pos[0]
                cfg.application["position_y"] = new_pos[1]
                save_changes = True

        if cfg.application["remember_size"]:
            last_size = cfg.application["window_width"], cfg.application["window_height"]
            new_size = self.width(), self.height()
            if last_size != new_size:
                cfg.application["window_width"] = new_size[0]
                cfg.application["window_height"] = new_size[1]
                save_changes = True

        if save_changes:
            cfg.save(0, cfg_type=ConfigType.CONFIG)

    def load_window_style(self):
        """Load window style"""
        style = cfg.application["window_color_theme"]
        logger.info("GUI: loading window color theme: %s", style)
        if self.last_style != style:
            self.last_style = style
            set_style_palette(self.last_style)
            self.setStyleSheet(set_style_window(QApplication.font().pointSize()))
        self.statusBar().refresh()

    def show_app(self):
        """Show app window"""
        self.showNormal()
        self.activateWindow()

    def quit_app(self):
        """Quit manager"""
        loader.close()  # must close this first
        self.save_window_state()
        self.__break_signal()
        self.findChild(QSystemTrayIcon).hide()  # workaround tray icon not removed after exited
        QApplication.quit()

    def closeEvent(self, event):
        """Minimize to tray"""
        if cfg.application["minimize_to_tray"]:
            event.ignore()
            self.hide()
        else:
            self.quit_app()

    def restart_api(self):
        """Restart telemetry API"""
        api.restart()
        self.statusBar().refresh()
        self.tab_view.refresh_tab(3)

    @Slot(bool)  # type: ignore[operator]
    def reload_preset(self):
        """Reload current preset"""
        loader.reload(reload_preset=True)
        self.load_window_style()
        self.refresh_states()

    def reload_only(self):
        """Reload only api, module, widget"""
        loader.reload(reload_preset=False)
        self.refresh_states()

    def refresh_states(self):
        """Refresh state"""
        self.statusBar().refresh()
        self.tab_view.refresh_tab()

    def __connect_signal(self):
        """Connect signal"""
        overlay_signal.reload.connect(self.reload_preset)
        logger.info("GUI: connect signals")

    def __break_signal(self):
        """Disconnect signal"""
        overlay_signal.reload.disconnect(self.reload_preset)
        logger.info("GUI: disconnect signals")

```

# File: tinypedal/ui/brake_editor.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Brake editor
"""

import logging
import time

from PySide2.QtWidgets import (
    QComboBox,
    QHBoxLayout,
    QHeaderView,
    QMessageBox,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from ..api_control import api
from ..const_file import ConfigType
from ..setting import cfg, copy_setting
from ..userfile.heatmap import HEATMAP_DEFAULT_BRAKE, set_predefined_brake_name
from ._common import (
    BaseEditor,
    CompactButton,
    FloatTableItem,
    UIScaler,
    #TableBatchReplace,
)

HEADER_BRAKES = "Brake name","Failure (mm)","Heatmap name"

logger = logging.getLogger(__name__)


class BrakeEditor(BaseEditor):
    """Brake editor"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Brake Editor")
        self.setMinimumSize(UIScaler.size(45), UIScaler.size(38))

        self.brakes_temp = copy_setting(cfg.user.brakes)

        # Set table
        self.table_brakes = QTableWidget(self)
        self.table_brakes.setColumnCount(len(HEADER_BRAKES))
        self.table_brakes.setHorizontalHeaderLabels(HEADER_BRAKES)
        self.table_brakes.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.table_brakes.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table_brakes.horizontalHeader().setSectionResizeMode(1, QHeaderView.Fixed)
        self.table_brakes.horizontalHeader().setSectionResizeMode(2, QHeaderView.Fixed)
        self.table_brakes.setColumnWidth(1, UIScaler.size(8))
        self.table_brakes.setColumnWidth(2, UIScaler.size(12))
        self.table_brakes.cellChanged.connect(self.verify_input)
        self.refresh_table()
        self.set_unmodified()

        # Set button
        layout_button = self.set_layout_button()

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.table_brakes)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def set_layout_button(self):
        """Set button layout"""
        button_add = CompactButton("Add")
        button_add.clicked.connect(self.add_brake)

        button_sort = CompactButton("Sort")
        button_sort.clicked.connect(self.sort_brake)

        button_delete = CompactButton("Delete")
        button_delete.clicked.connect(self.delete_brake)

        #button_replace = CompactButton("Replace")
        #button_replace.clicked.connect(self.open_replace_dialog)

        button_reset = CompactButton("Reset")
        button_reset.clicked.connect(self.reset_setting)

        button_apply = CompactButton("Apply")
        button_apply.clicked.connect(self.applying)

        button_save = CompactButton("Save")
        button_save.clicked.connect(self.saving)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        # Set layout
        layout_button = QHBoxLayout()
        layout_button.addWidget(button_add)
        layout_button.addWidget(button_sort)
        layout_button.addWidget(button_delete)
        #layout_button.addWidget(button_replace)
        layout_button.addWidget(button_reset)
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_save)
        layout_button.addWidget(button_close)
        return layout_button

    def refresh_table(self):
        """Refresh brakes list"""
        self.table_brakes.setRowCount(0)
        row_index = 0
        for class_name, brake_data in self.brakes_temp.items():
            self.add_brake_entry(
                row_index,
                class_name,
                brake_data["failure_thickness"],
                brake_data["heatmap"],
            )
            row_index += 1

    def __add_option_combolist(self, key):
        """Combo droplist string"""
        combo_edit = QComboBox()
        combo_edit.addItems(cfg.user.heatmap.keys())
        combo_edit.setCurrentText(key)
        combo_edit.currentTextChanged.connect(self.set_modified)
        return combo_edit

    #def open_replace_dialog(self):
    #    """Open replace dialog"""
    #    selector = {HEADER_BRAKES[0]: 0}
    #    _dialog = TableBatchReplace(self, selector, self.table_brakes)
    #    _dialog.open()

    def add_brake(self):
        """Add new brake"""
        start_index = row_index = self.table_brakes.rowCount()
        # Add all missing vehicle name from active session
        veh_total = api.read.vehicle.total_vehicles()
        for index in range(veh_total):
            class_name = api.read.vehicle.class_name(index)
            vehicle_name = api.read.vehicle.vehicle_name(index)
            brake_names = (
                set_predefined_brake_name(class_name, vehicle_name, True),
                set_predefined_brake_name(class_name, vehicle_name, False),
            )
            for brake in brake_names:
                if not self.is_value_in_table(brake, self.table_brakes):
                    self.add_brake_entry(row_index, brake, 0)
                    self.table_brakes.setCurrentCell(row_index, 0)
                    row_index += 1
        # Add new name entry
        if start_index == row_index:
            new_class_name = self.new_name_increment("New Brake Name", self.table_brakes)
            self.add_brake_entry(row_index, new_class_name, 0)
            self.table_brakes.setCurrentCell(row_index, 0)

    def add_brake_entry(
        self, row_index: int, class_name: str, failure_thickness: float,
        heatmap_name: str = HEATMAP_DEFAULT_BRAKE):
        """Add new brake entry to table"""
        self.table_brakes.insertRow(row_index)
        self.table_brakes.setItem(row_index, 0, QTableWidgetItem(class_name))
        self.table_brakes.setItem(row_index, 1, FloatTableItem(failure_thickness))
        self.table_brakes.setCellWidget(row_index, 2, self.__add_option_combolist(heatmap_name))

    def sort_brake(self):
        """Sort brakes in ascending order"""
        if self.table_brakes.rowCount() > 1:
            self.table_brakes.sortItems(0)
            self.set_modified()

    def delete_brake(self):
        """Delete brake entry"""
        selected_rows = set(data.row() for data in self.table_brakes.selectedIndexes())
        if not selected_rows:
            QMessageBox.warning(self, "Error", "No data selected.")
            return

        if not self.confirm_operation(message="<b>Delete selected rows?</b>"):
            return

        for row_index in sorted(selected_rows, reverse=True):
            self.table_brakes.removeRow(row_index)
        self.set_modified()

    def reset_setting(self):
        """Reset setting"""
        msg_text = (
            "Reset <b>brakes preset</b> to default?<br><br>"
            "Changes are only saved after clicking Apply or Save Button."
        )
        if self.confirm_operation(message=msg_text):
            self.brakes_temp = copy_setting(cfg.default.brakes)
            self.set_modified()
            self.refresh_table()

    def applying(self):
        """Save & apply"""
        self.save_setting()

    def saving(self):
        """Save & close"""
        self.save_setting()
        self.accept()  # close

    def verify_input(self, row_index: int, column_index: int):
        """Verify input value"""
        self.set_modified()
        item = self.table_brakes.item(row_index, column_index)
        if column_index == 1:  # failure thickness column
            item.validate()

    def update_brakes_temp(self):
        """Update temporary changes to brakes temp first"""
        self.brakes_temp.clear()
        for index in range(self.table_brakes.rowCount()):
            class_name = self.table_brakes.item(index, 0).text()
            failure_thickness = self.table_brakes.item(index, 1).value()
            heatmap_name = self.table_brakes.cellWidget(index, 2).currentText()
            self.brakes_temp[class_name] = {
                "failure_thickness": failure_thickness,
                "heatmap": heatmap_name,
            }

    def save_setting(self):
        """Save setting"""
        self.update_brakes_temp()
        cfg.user.brakes = copy_setting(self.brakes_temp)
        cfg.save(0, cfg_type=ConfigType.BRAKES)
        while cfg.is_saving:  # wait saving finish
            time.sleep(0.01)
        self.reloading()
        self.set_unmodified()

```

# File: tinypedal/ui/fuel_calculator.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Fuel calculator
"""

from __future__ import annotations

import os
from collections import deque
from math import ceil, floor

from PySide2.QtCore import Qt
from PySide2.QtGui import QColor, QPainter
from PySide2.QtWidgets import (
    QDoubleSpinBox,
    QFileDialog,
    QFrame,
    QGridLayout,
    QHBoxLayout,
    QHeaderView,
    QLabel,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QStatusBar,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
)

from .. import calculation as calc
from ..api_control import api
from ..const_file import FileFilter
from ..formatter import laptime_string_to_seconds
from ..module_info import ConsumptionDataSet, minfo
from ..setting import cfg
from ..units import set_symbol_fuel, set_unit_fuel
from ..userfile.consumption_history import load_consumption_history_file
from ._common import BaseDialog, UIScaler


def set_grid_layout(spacing: int = 2, margin: int = 4):
    """Set grid layout"""
    spacing = UIScaler.pixel(spacing)
    margin = UIScaler.pixel(margin)
    layout = QGridLayout()
    layout.setSpacing(spacing)
    layout.setContentsMargins(margin, margin, margin, margin)
    return layout


def highlight_invalid(line_edit: QLineEdit, invalid=False):
    """Highlight invalid"""
    line_edit.setStyleSheet("background: #F40;" if invalid else "")


class PitStopPreview(QWidget):
    """Pit stop preview"""

    def __init__(self, parent):
        super().__init__(parent)
        self.setFixedWidth(UIScaler.size(2.2))
        self.floor_total_laps = 0
        self.floor_stint_runlaps = 0
        self.floor_start_runlaps = 0

        frame = QFrame(self)
        frame.setFrameShape(QFrame.StyledPanel)

        self.label_laps = QLabel("-")
        self.label_laps.setAlignment(Qt.AlignCenter)

        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        layout.addWidget(frame, stretch=1)
        layout.addWidget(self.label_laps)
        self.setLayout(layout)

    def update_input(self, total_laps: float, stint_runlaps: float, start_runlaps: float):
        """Update input value"""
        self.floor_total_laps = floor(total_laps)
        self.floor_stint_runlaps = floor(stint_runlaps)
        self.floor_start_runlaps = floor(start_runlaps) if start_runlaps > 0 else self.floor_stint_runlaps
        self.label_laps.setText(str(self.floor_total_laps) if self.floor_total_laps else "-")
        self.update()

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        length = self.height()
        width = self.width()
        palette = self.palette()

        # Background
        painter.fillRect(0, 0, width, length, palette.base().color())

        # Marks
        floor_total_laps = self.floor_total_laps
        floor_stint_runlaps = self.floor_stint_runlaps
        floor_start_runlaps = self.floor_start_runlaps
        if floor_total_laps > 0 < floor_stint_runlaps:

            length -= self.label_laps.height()

            # Lap mark
            laps = 1
            lap_color = palette.mid().color()
            while laps < floor_total_laps:
                lap_mark_y = laps / floor_total_laps * length
                if lap_mark_y < 5:
                    break
                painter.fillRect(0, lap_mark_y, width, 1, lap_color)
                laps += 1

            # Pit mark
            pit_count = 1
            pit_text_height = self.fontMetrics().height() * 2
            pit_color = palette.highlight().color()
            laps = floor_start_runlaps
            while laps < floor_total_laps:
                pit_mark_y = laps / floor_total_laps * length - 3
                painter.fillRect(0, pit_mark_y, width, 6, pit_color)
                painter.drawText(
                    0, pit_mark_y - pit_text_height, width, pit_text_height,
                    Qt.AlignHCenter | Qt.AlignBottom,
                    f"{laps}",
                )
                pit_count += 1
                laps = floor_start_runlaps + floor_stint_runlaps * (pit_count - 1)


class FuelCalculator(BaseDialog):
    """Fuel calculator"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Fuel Calculator")

        # Set (freeze) fuel unit
        self.is_gallon = cfg.units["fuel_unit"] == "Gallon"
        self.unit_fuel = set_unit_fuel(cfg.units["fuel_unit"])
        self.symbol_fuel = set_symbol_fuel(cfg.units["fuel_unit"])

        # Set status bar
        self.status_bar = QStatusBar(self)

        # Set preview
        self.pit_preview = PitStopPreview(self)

        # Set view
        self.panel_calculator = QWidget(self)
        self.set_panel_calculator(self.panel_calculator)

        # Panel table
        self.panel_table = QWidget(self)
        self.set_panel_table(self.panel_table)

        # Load data
        self.load_live_data()

        # Layout
        layout_panel = QHBoxLayout()
        layout_panel.addWidget(self.panel_calculator)
        layout_panel.addWidget(self.panel_table)
        layout_main = QVBoxLayout()
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, 0)
        layout_main.addLayout(layout_panel, stretch=1)
        layout_main.addWidget(self.status_bar)
        self.setLayout(layout_main)
        self.setFixedWidth(self.sizeHint().width())

    def toggle_history_panel(self):
        """Toggle history data panel"""
        if self.panel_table.isHidden():
            self.panel_table.show()
            self.setFixedWidth(self.sizeHint().width())
            self.button_toggle.setText("Hide History")
        else:
            self.panel_table.hide()
            margin = self.layout().contentsMargins()
            self.setFixedWidth(self.panel_calculator.sizeHint().width() + margin.left() + margin.right())
            self.button_toggle.setText("Show History")

    def add_selected_data(self):
        """Add selected history data"""
        selected_data = self.table_history.selectedItems()
        if not selected_data:
            QMessageBox.warning(
                self, "Error",
                "No data selected.")
            return

        data_laptime = [data for data in selected_data if data.column() == 1]
        data_fuel = [data for data in selected_data if data.column() == 2]
        data_energy = [data for data in selected_data if data.column() == 3]
        data_tyrewear = [data for data in selected_data if data.column() == 6]
        data_capacity = [data for data in selected_data if data.column() == 7]

        # Send data to calculator
        if data_laptime:
            dataset = [laptime_string_to_seconds(data.text()) for data in data_laptime]
            output_value = calc.mean(dataset) if len(data_laptime) > 1 else dataset[0]
            self.input_laptime.minutes.setValue(output_value // 60)
            self.input_laptime.seconds.setValue(output_value % 60)
            self.input_laptime.mseconds.setValue(output_value % 1 * 1000)
        if data_fuel:
            dataset = [float(data.text()) for data in data_fuel]
            output_value = calc.mean(dataset) if len(data_fuel) > 1 else dataset[0]
            self.input_fuel.fuel_used.setValue(output_value)
        if data_energy:
            dataset = [float(data.text()) for data in data_energy]
            output_value = calc.mean(dataset) if len(data_energy) > 1 else dataset[0]
            self.input_fuel.energy_used.setValue(output_value)
        if data_tyrewear:
            dataset = [float(data.text()) for data in data_tyrewear]
            output_value = calc.mean(dataset) if len(data_tyrewear) > 1 else dataset[0]
            self.input_tyre.wear_lap.setValue(output_value)
        if data_capacity:
            output_value = float(data_capacity[0].text())
            self.input_fuel.capacity.setValue(output_value)

    def load_file(self):
        """Load history data from file"""
        filename_full = QFileDialog.getOpenFileName(
            self,
            dir=cfg.path.fuel_delta,
            filter=";;".join((FileFilter.CONSUMPTION, FileFilter.CSV))
        )[0]
        if not filename_full:
            return

        filepath = os.path.dirname(filename_full) + "/"
        filename = os.path.splitext(os.path.basename(filename_full))[0]
        history_data = load_consumption_history_file(
            filepath=filepath,
            filename=filename,
        )
        self.refresh_table(history_data)
        self.fill_in_data(history_data)
        self.status_bar.showMessage(f"File Source: {filename}")

    def load_live_data(self):
        """Load history data from live session"""
        self.refresh_table(minfo.history.consumptionDataSet)
        self.fill_in_data(minfo.history.consumptionDataSet)
        self.status_bar.showMessage(f"Live Source: {api.read.session.combo_name()}")

    def fill_in_data(self, dataset: deque[ConsumptionDataSet]):
        """Fill in history data to edit"""
        latest_history = dataset[0]
        # Load laptime from last valid lap
        laptime = latest_history.lapTimeLast
        if laptime > 0 and latest_history.isValidLap:
            self.input_laptime.minutes.setValue(laptime // 60)
            self.input_laptime.seconds.setValue(laptime % 60)
            self.input_laptime.mseconds.setValue(laptime % 1 * 1000)
        # Load tank capacity
        capacity = max(api.read.vehicle.tank_capacity(), latest_history.capacityFuel)
        if capacity:
            self.input_fuel.capacity.setValue(self.unit_fuel(capacity))
        # Load consumption from last valid lap
        if latest_history.isValidLap:
            fuel_used = latest_history.lastLapUsedFuel
            self.input_fuel.fuel_used.setValue(self.unit_fuel(fuel_used))
            energy_used = latest_history.lastLapUsedEnergy
            self.input_fuel.energy_used.setValue(energy_used)
            tyre_wear = latest_history.tyreAvgWearLast
            self.input_tyre.wear_lap.setValue(tyre_wear)

    def refresh_table(self, dataset: deque[ConsumptionDataSet]):
        """Refresh history data table"""
        self.table_history.setRowCount(0)
        invalid_color = QColor("#F40")
        flag_selectable = Qt.ItemIsSelectable | Qt.ItemIsEnabled
        flag_unselectable = Qt.NoItemFlags

        for row_index, lap_data in enumerate(dataset):
            lapnumber = self.__add_table_item(f"{lap_data.lapNumber}", flag_unselectable)
            laptime = self.__add_table_item(calc.sec2laptime_full(lap_data.lapTimeLast), flag_selectable)
            used_fuel = self.__add_table_item(f"{self.unit_fuel(lap_data.lastLapUsedFuel):.3f}", flag_selectable)
            used_energy = self.__add_table_item(f"{lap_data.lastLapUsedEnergy:.3f}", flag_selectable)
            battery_drain = self.__add_table_item(f"{lap_data.batteryDrainLast:.3f}", flag_unselectable)
            battery_regen = self.__add_table_item(f"{lap_data.batteryRegenLast:.3f}", flag_unselectable)
            tyre_wear = self.__add_table_item(f"{lap_data.tyreAvgWearLast:.3f}", flag_selectable)
            capacity_fuel = self.__add_table_item(f"{self.unit_fuel(lap_data.capacityFuel):.3f}", flag_selectable)

            if not lap_data.isValidLap:  # set invalid lap text color
                laptime.setForeground(invalid_color)
                used_fuel.setForeground(invalid_color)
                used_energy.setForeground(invalid_color)

            self.table_history.insertRow(row_index)
            self.table_history.setItem(row_index, 0, lapnumber)
            self.table_history.setItem(row_index, 1, laptime)
            self.table_history.setItem(row_index, 2, used_fuel)
            self.table_history.setItem(row_index, 3, used_energy)
            self.table_history.setItem(row_index, 4, battery_drain)
            self.table_history.setItem(row_index, 5, battery_regen)
            self.table_history.setItem(row_index, 6, tyre_wear)
            self.table_history.setItem(row_index, 7, capacity_fuel)

    def __add_table_item(self, text: str, flags: Qt.ItemFlags):
        """Add table item"""
        item = QTableWidgetItem()
        item.setText(text)
        item.setTextAlignment(Qt.AlignCenter)
        item.setFlags(flags)
        return item

    def set_panel_calculator(self, panel):
        """Set panel calculator"""
        frame_laptime = QFrame(self)
        frame_laptime.setFrameShape(QFrame.StyledPanel)

        frame_fuel = QFrame(self)
        frame_fuel.setFrameShape(QFrame.StyledPanel)

        frame_race = QFrame(self)
        frame_race.setFrameShape(QFrame.StyledPanel)

        frame_output_fuel = QFrame(self)
        frame_output_fuel.setFrameShape(QFrame.StyledPanel)

        frame_output_energy = QFrame(self)
        frame_output_energy.setFrameShape(QFrame.StyledPanel)

        frame_output_start_fuel = QFrame(self)
        frame_output_start_fuel.setFrameShape(QFrame.StyledPanel)

        frame_output_start_energy = QFrame(self)
        frame_output_start_energy.setFrameShape(QFrame.StyledPanel)

        frame_output_tyre_wear = QFrame(self)
        frame_output_tyre_wear.setFrameShape(QFrame.StyledPanel)

        self.input_laptime = InputLapTime(self, frame_laptime)
        self.input_fuel = InputFuel(self, frame_fuel)
        self.input_race = InputRace(self, frame_race)

        self.usage_fuel = OutputUsage(self, frame_output_fuel, "Fuel")
        self.usage_energy = OutputUsage(self, frame_output_energy, "Energy")

        self.refill_fuel = InputRefill(self, frame_output_start_fuel, "Fuel")
        self.refill_energy = InputRefill(self, frame_output_start_energy, "Energy")

        self.input_tyre = InputTyreWear(self, frame_output_tyre_wear)

        button_loadlive = QPushButton("Load Live")
        button_loadlive.clicked.connect(self.load_live_data)
        button_loadlive.setFocusPolicy(Qt.NoFocus)

        button_loadfile = QPushButton("Load File")
        button_loadfile.clicked.connect(self.load_file)
        button_loadfile.setFocusPolicy(Qt.NoFocus)

        self.button_toggle = QPushButton("Hide History")
        self.button_toggle.clicked.connect(self.toggle_history_panel)
        self.button_toggle.setFocusPolicy(Qt.NoFocus)

        layout_usage = QHBoxLayout()
        layout_usage.addWidget(frame_output_fuel)
        layout_usage.addWidget(frame_output_energy)

        layout_refill = QHBoxLayout()
        layout_refill.addWidget(frame_output_start_fuel)
        layout_refill.addWidget(frame_output_start_energy)

        layout_calculator = QVBoxLayout()
        layout_calculator.setAlignment(Qt.AlignTop)
        layout_calculator.addWidget(frame_laptime)
        layout_calculator.addWidget(frame_fuel)
        layout_calculator.addWidget(frame_race)
        layout_calculator.addLayout(layout_usage)
        layout_calculator.addLayout(layout_refill)
        layout_calculator.addWidget(frame_output_tyre_wear)

        layout_data = QHBoxLayout()
        layout_data.addWidget(self.pit_preview)
        layout_data.addLayout(layout_calculator)

        layout_button = QHBoxLayout()
        layout_button.addWidget(button_loadlive, stretch=1)
        layout_button.addWidget(button_loadfile, stretch=1)
        layout_button.addStretch(1)
        layout_button.addWidget(self.button_toggle, stretch=2)

        layout_panel = QVBoxLayout()
        layout_panel.setContentsMargins(0, 0, 0, 0)
        layout_panel.addLayout(layout_data)
        layout_panel.addLayout(layout_button)
        panel.setLayout(layout_panel)

    def set_panel_table(self, panel):
        """Set panel table"""
        columns_stretch = 7
        self.table_history = QTableWidget(self)
        self.table_history.setColumnCount(1 + columns_stretch)
        self.table_history.verticalHeader().setVisible(False)
        self.table_history.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table_history.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.table_history.setColumnWidth(0, UIScaler.size(3))
        self.table_history.setFixedWidth(UIScaler.size(3 + 5 * columns_stretch))
        self.table_history.setHorizontalHeaderLabels((
            "Lap",
            "Time",
            f"Fuel({self.symbol_fuel})",
            "Energy(%)",
            "Drain(%)",
            "Regen(%)",
            "Tyre(%)",
            f"Tank({self.symbol_fuel})",
        ))

        button_adddata = QPushButton("Add Selected Data")
        button_adddata.clicked.connect(self.add_selected_data)
        button_adddata.setFocusPolicy(Qt.NoFocus)

        layout_panel = QVBoxLayout()
        layout_panel.setContentsMargins(0, 0, 0, 0)
        layout_panel.addWidget(self.table_history)
        layout_panel.addWidget(button_adddata)
        panel.setLayout(layout_panel)

    def update_input(self):
        """Calculate and output results"""
        # Get lap time setup
        self.input_laptime.carry_over()
        laptime = self.input_laptime.to_seconds()

        # Get race setup
        total_race_seconds = self.input_race.minutes.value() * 60
        absolute_race_laps = self.input_race.laps.value()
        total_formation_laps = self.input_race.formation.value()
        average_pit_seconds = self.input_race.pit_seconds.value()

        # Get fuel setup
        tank_capacity = self.input_fuel.capacity.value()
        fuel_used = self.input_fuel.fuel_used.value()
        fuel_start = self.refill_fuel.amount_start.value(
            ) if self.refill_fuel.amount_start.value() else tank_capacity
        energy_used = self.input_fuel.energy_used.value()
        energy_start = self.refill_energy.amount_start.value(
            ) if self.refill_energy.amount_start.value() else 100

        # Calc fuel ratio
        if self.is_gallon:
            fuel_ratio = calc.fuel_to_energy_ratio(fuel_used * 3.785411784, energy_used)
        else:
            fuel_ratio = calc.fuel_to_energy_ratio(fuel_used, energy_used)
        self.input_fuel.fuel_ratio.setText(f"{fuel_ratio:.3f}")

        # Calc fuel
        fuel_total_runlaps, fuel_stint_runlaps, fuel_start_runlaps = self.calc_consumption(
            "fuel", tank_capacity, fuel_used, fuel_start, total_race_seconds,
            absolute_race_laps, total_formation_laps, average_pit_seconds, laptime)

        # Calc energy
        energy_total_runlaps, energy_stint_runlaps, energy_start_runlaps = self.calc_consumption(
            "energy", 100, energy_used, energy_start, total_race_seconds,
            absolute_race_laps, total_formation_laps, average_pit_seconds, laptime)

        # Calc tyre
        self.calc_tyre_consumption(fuel_stint_runlaps, energy_stint_runlaps, laptime)

        # Update pit preview
        if energy_used > 0:
            self.pit_preview.update_input(energy_total_runlaps, energy_stint_runlaps, energy_start_runlaps)
        else:
            self.pit_preview.update_input(fuel_total_runlaps, fuel_stint_runlaps, fuel_start_runlaps)

    def calc_consumption(self, output_type, tank_capacity, consumption, fuel_start,
        total_race_seconds, absolute_race_laps, total_formation_laps, average_pit_seconds, laptime):
        """Calculate and output results"""
        estimate_pit_counts = 0
        minimum_pit_counts = 0  # minimum pit stop required to finish race
        loop_counts = 10  # max loop limit

        start_runlaps = calc.end_stint_laps(fuel_start, consumption)

        # Total pit seconds depends on estimated pit counts
        # Recalculate and find nearest minimum pit counts on previous loop
        while loop_counts:
            minimum_pit_counts = ceil(estimate_pit_counts)
            if total_race_seconds:  # time-type race
                total_pit_seconds = minimum_pit_counts * average_pit_seconds
                total_race_laps = total_formation_laps + calc.time_type_full_laps_remain(
                    laptime, total_race_seconds - total_pit_seconds)
            else:  # lap-type race
                total_race_laps = total_formation_laps + absolute_race_laps

            total_need_frac = calc.total_fuel_needed(total_race_laps, consumption, 0)

            # Keep 1 decimal place for Gallon
            if self.is_gallon and output_type == "fuel":
                total_need_full = ceil(total_need_frac * 10) / 10
            else:
                total_need_full = ceil(total_need_frac)

            # amount_refuel = total_need_full - tank_capacity
            amount_refuel = total_need_full - fuel_start

            amount_curr = min(total_need_full, tank_capacity)

            end_stint_fuel = calc.end_stint_fuel(amount_curr, 0, consumption)

            estimate_pit_counts = calc.end_stint_pit_counts(
                amount_refuel, tank_capacity - end_stint_fuel)

            loop_counts -= 1
            # Set one last loop to revert back to last minimum pit counts
            # If new rounded up minimum pit counts is not enough to finish race
            if (minimum_pit_counts < estimate_pit_counts and
                minimum_pit_counts == floor(estimate_pit_counts)):
                loop_counts = 1

            if minimum_pit_counts == ceil(estimate_pit_counts):
                break

        total_runlaps = calc.end_stint_laps(total_need_full, consumption)

        total_runmins = calc.end_stint_minutes(total_runlaps, laptime)

        used_one_less = calc.one_less_pit_stop_consumption(
            estimate_pit_counts, tank_capacity, amount_curr, total_race_laps)

        if minimum_pit_counts:
            average_refuel = (
                total_need_full - fuel_start + minimum_pit_counts * end_stint_fuel
                ) / minimum_pit_counts
        elif fuel_start < total_need_full <= tank_capacity:
            average_refuel = total_need_full - fuel_start
        else:
            average_refuel = 0

        if total_need_full > tank_capacity:
            stint_runlaps = calc.end_stint_laps(tank_capacity, consumption)
            stint_runmins = calc.end_stint_minutes(stint_runlaps, laptime)
        else:
            stint_runlaps = total_runlaps
            stint_runmins = total_runmins

        # Output
        if output_type == "fuel":
            output_usage = self.usage_fuel
            output_refill = self.refill_fuel
        else:
            output_usage = self.usage_energy
            output_refill = self.refill_energy

        output_usage.total_needed.setText(
            f"{total_need_frac:.3f} â‰ˆ {total_need_full}")
        output_usage.end_stint.setText(
            f"{end_stint_fuel:.3f}")
        output_usage.pit_stops.setText(
            f"{max(estimate_pit_counts, 0):.3f} â‰ˆ {max(ceil(minimum_pit_counts), 0)}")
        output_usage.one_less_stint.setText(
            f"{max(used_one_less, 0):.3f}")
        output_usage.total_laps.setText(
            f"{total_runlaps:.3f}")
        output_usage.total_minutes.setText(
            f"{total_runmins:.3f}")
        output_usage.stint_laps.setText(
            f"{stint_runlaps:.3f}")
        output_usage.stint_minutes.setText(
            f"{stint_runmins:.3f}")

        output_refill.average_refill.setText(
            f"{average_refuel:.3f}")
        # Set warning color if exceeded tank capacity
        highlight_invalid(output_refill.average_refill, average_refuel > tank_capacity)
        return total_runlaps, stint_runlaps, start_runlaps

    def calc_tyre_consumption(self, fuel_stint_runlaps, energy_stint_runlaps, laptime):
        """Calculate tyre consumption"""
        # Pick the least runnable laps if both energy & fuel available
        if energy_stint_runlaps > 0 < fuel_stint_runlaps:
            stint_runlaps = min(fuel_stint_runlaps, energy_stint_runlaps)
        else:
            stint_runlaps = fuel_stint_runlaps

        tyre_start_tread = self.input_tyre.start_tread.value()
        tyre_wear_lap = self.input_tyre.wear_lap.value()
        tyre_wear_stint = tyre_wear_lap * stint_runlaps

        tyre_lifespan_laps = calc.wear_lifespan_in_laps(tyre_start_tread, tyre_wear_lap)
        tyre_lifespan_mins = calc.wear_lifespan_in_mins(tyre_start_tread, tyre_wear_lap, laptime)
        tyre_lifespan_stints = tyre_lifespan_laps / stint_runlaps if stint_runlaps else 0

        self.input_tyre.lifespan_laps.setText(f"{tyre_lifespan_laps:.3f}")
        self.input_tyre.lifespan_minutes.setText(f"{tyre_lifespan_mins:.3f}")
        self.input_tyre.lifespan_stints.setText(f"{tyre_lifespan_stints:.3f}")

        self.input_tyre.wear_stint.setText(f"{tyre_wear_stint:.3f}")
        highlight_invalid(self.input_tyre.lifespan_stints, 0 < tyre_lifespan_stints < 1)
        highlight_invalid(self.input_tyre.wear_stint, tyre_wear_stint >= tyre_start_tread)

    def validate_starting_fuel(self):
        """Validate starting fuel"""
        if self.refill_fuel.amount_start.value() > self.input_fuel.capacity.value():
            self.refill_fuel.amount_start.setValue(self.input_fuel.capacity.value())


class InputLapTime():
    """Input lap time setup"""

    def __init__(self, parent, frame) -> None:
        """Set input lap time"""
        self.minutes = QSpinBox()
        self.minutes.setAlignment(Qt.AlignRight)
        self.minutes.setRange(0, 9999)
        self.minutes.valueChanged.connect(parent.update_input)

        self.seconds = QSpinBox()
        self.seconds.setAlignment(Qt.AlignRight)
        self.seconds.setRange(-1, 60)
        self.seconds.valueChanged.connect(parent.update_input)

        self.mseconds = QSpinBox()
        self.mseconds.setAlignment(Qt.AlignRight)
        self.mseconds.setRange(-1, 1000)
        self.mseconds.setSingleStep(100)
        self.mseconds.valueChanged.connect(parent.update_input)

        layout = set_grid_layout()

        layout.setColumnStretch(0, 1)
        layout.setColumnStretch(2, 1)
        layout.setColumnStretch(4, 1)

        layout.addWidget(QLabel("Lap Time:"), 0, 0, 1, 6)

        layout.addWidget(self.minutes, 1, 0)
        layout.addWidget(QLabel("m"), 1, 1)

        layout.addWidget(self.seconds, 1, 2)
        layout.addWidget(QLabel("s"), 1, 3)

        layout.addWidget(self.mseconds, 1, 4)
        layout.addWidget(QLabel("ms"), 1, 5)

        frame.setLayout(layout)

    def to_seconds(self):
        """Output lap time value to seconds"""
        return (
            self.minutes.value() * 60
            + self.seconds.value()
            + self.mseconds.value() * 0.001
        )

    def carry_over(self):
        """Carry over lap time value"""
        if self.seconds.value() > 59:
            self.seconds.setValue(0)
            self.minutes.setValue(self.minutes.value() + 1)
        elif self.seconds.value() < 0:
            if self.minutes.value() > 0:
                self.seconds.setValue(59)
                self.minutes.setValue(self.minutes.value() - 1)
            else:
                self.seconds.setValue(0)

        if self.mseconds.value() > 999:
            self.mseconds.setValue(0)
            self.seconds.setValue(self.seconds.value() + 1)
        elif self.mseconds.value() < 0:
            if self.seconds.value() > 0 or self.minutes.value() > 0:
                self.mseconds.setValue(900)
                self.seconds.setValue(self.seconds.value() - 1)
            else:
                self.mseconds.setValue(0)


class InputFuel():
    """Input fuel setup"""

    def __init__(self, parent, frame) -> None:
        """Set input fuel"""
        self.capacity = QDoubleSpinBox()
        self.capacity.setRange(0, 9999)
        self.capacity.setDecimals(2)
        self.capacity.setAlignment(Qt.AlignRight)
        self.capacity.valueChanged.connect(parent.update_input)

        self.fuel_ratio = QLineEdit("0.000")
        self.fuel_ratio.setAlignment(Qt.AlignRight)
        self.fuel_ratio.setReadOnly(True)

        self.fuel_used = QDoubleSpinBox()
        self.fuel_used.setRange(0, 9999)
        self.fuel_used.setDecimals(3)
        self.fuel_used.setSingleStep(0.1)
        self.fuel_used.setAlignment(Qt.AlignRight)
        self.fuel_used.valueChanged.connect(parent.update_input)

        self.energy_used = QDoubleSpinBox()
        self.energy_used.setRange(0, 100)
        self.energy_used.setDecimals(3)
        self.energy_used.setSingleStep(0.1)
        self.energy_used.setAlignment(Qt.AlignRight)
        self.energy_used.valueChanged.connect(parent.update_input)

        layout = set_grid_layout()

        layout.setColumnStretch(0, 1)
        layout.setColumnStretch(2, 1)

        layout.addWidget(QLabel("Tank Capacity:"), 0, 0, 1, 2)
        layout.addWidget(self.capacity, 1, 0)
        layout.addWidget(QLabel(parent.symbol_fuel), 1, 1)

        layout.addWidget(QLabel("Fuel Ratio:"), 2, 0, 1, 2)
        layout.addWidget(self.fuel_ratio, 3, 0)

        layout.addWidget(QLabel("Fuel Consumption:"), 0, 2, 1, 2)
        layout.addWidget(self.fuel_used, 1, 2)
        layout.addWidget(QLabel(parent.symbol_fuel), 1, 3)

        layout.addWidget(QLabel("Energy Consumption:"), 2, 2, 1, 2)
        layout.addWidget(self.energy_used, 3, 2)
        layout.addWidget(QLabel("%"), 3, 3)

        frame.setLayout(layout)


class InputRace():
    """Input race setup"""

    def __init__(self, parent, frame) -> None:
        """Set input race"""
        self.minutes = QSpinBox()
        self.minutes.setRange(0, 9999)
        self.minutes.setAlignment(Qt.AlignRight)
        self.minutes.valueChanged.connect(parent.update_input)
        self.minutes.valueChanged.connect(self.disable_race_lap)

        self.laps = QSpinBox()
        self.laps.setRange(0, 9999)
        self.laps.setAlignment(Qt.AlignRight)
        self.laps.valueChanged.connect(parent.update_input)
        self.laps.valueChanged.connect(self.disable_race_minute)

        self.formation = QDoubleSpinBox()
        self.formation.setRange(0, 9999)
        self.formation.setDecimals(2)
        self.formation.setSingleStep(0.1)
        self.formation.setAlignment(Qt.AlignRight)
        self.formation.valueChanged.connect(parent.update_input)

        self.pit_seconds = QDoubleSpinBox()
        self.pit_seconds.setRange(0, 9999)
        self.pit_seconds.setDecimals(1)
        self.pit_seconds.setAlignment(Qt.AlignRight)
        self.pit_seconds.valueChanged.connect(parent.update_input)

        layout = set_grid_layout()

        layout.setColumnStretch(0, 1)
        layout.setColumnStretch(2, 1)

        layout.addWidget(QLabel("Race Minutes:"), 0, 0, 1, 2)
        layout.addWidget(self.minutes, 1, 0)
        layout.addWidget(QLabel("min"), 1, 1)

        layout.addWidget(QLabel("Race Laps:"), 0, 2, 1, 2)
        layout.addWidget(self.laps, 1, 2)
        layout.addWidget(QLabel("lap"), 1, 3)

        layout.addWidget(QLabel("Formation/Rolling:"), 2, 0, 1, 2)
        layout.addWidget(self.formation, 3, 0)
        layout.addWidget(QLabel("lap"), 3, 1)

        layout.addWidget(QLabel("Average Pit Seconds:"), 2, 2, 1, 2)
        layout.addWidget(self.pit_seconds, 3, 2)
        layout.addWidget(QLabel("sec"), 3, 3)

        frame.setLayout(layout)

    def disable_race_lap(self):
        """Disable race laps if race minutes is set"""
        if self.minutes.value() > 0:
            if self.laps.isEnabled():
                self.laps.setValue(0)
                self.laps.setDisabled(True)
        else:
            self.laps.setDisabled(False)

    def disable_race_minute(self):
        """Disable race minutes if race laps is set"""
        if self.laps.value() > 0:
            if self.minutes.isEnabled():
                self.minutes.setValue(0)
                self.minutes.setDisabled(True)
        else:
            self.minutes.setDisabled(False)


class OutputUsage():
    """Output usage display"""

    def __init__(self, parent, frame, type_name) -> None:
        """Set output display"""
        if type_name == "Fuel":
            unit_text = parent.symbol_fuel
        else:
            unit_text = "%"

        self.total_needed = QLineEdit("0.000 â‰ˆ 0")
        self.total_needed.setAlignment(Qt.AlignRight)
        self.total_needed.setReadOnly(True)

        self.pit_stops = QLineEdit("0.000 â‰ˆ 0")
        self.pit_stops.setAlignment(Qt.AlignRight)
        self.pit_stops.setReadOnly(True)

        self.total_laps = QLineEdit("0.000")
        self.total_laps.setAlignment(Qt.AlignRight)
        self.total_laps.setReadOnly(True)

        self.total_minutes = QLineEdit("0.000")
        self.total_minutes.setAlignment(Qt.AlignRight)
        self.total_minutes.setReadOnly(True)

        self.stint_laps = QLineEdit("0.000")
        self.stint_laps.setAlignment(Qt.AlignRight)
        self.stint_laps.setReadOnly(True)

        self.stint_minutes = QLineEdit("0.000")
        self.stint_minutes.setAlignment(Qt.AlignRight)
        self.stint_minutes.setReadOnly(True)

        self.end_stint = QLineEdit("0.000")
        self.end_stint.setAlignment(Qt.AlignRight)
        self.end_stint.setReadOnly(True)

        self.one_less_stint = QLineEdit("0.000")
        self.one_less_stint.setAlignment(Qt.AlignRight)
        self.one_less_stint.setReadOnly(True)

        layout = set_grid_layout()

        layout.addWidget(QLabel(f"Total Race {type_name}:"), 0, 0, 1, 2)
        layout.addWidget(self.total_needed, 1, 0)
        layout.addWidget(QLabel(unit_text), 1, 1)

        layout.addWidget(QLabel("Total Pit Stops:"), 2, 0, 1, 2)
        layout.addWidget(self.pit_stops, 3, 0)
        layout.addWidget(QLabel("pit"), 3, 1)

        layout.addWidget(QLabel("Total Laps:"), 4, 0, 1, 2)
        layout.addWidget(self.total_laps, 5, 0)
        layout.addWidget(QLabel("lap"), 5, 1)

        layout.addWidget(QLabel("Total Minutes:"), 6, 0, 1, 2)
        layout.addWidget(self.total_minutes, 7, 0)
        layout.addWidget(QLabel("min"), 7, 1)

        layout.addWidget(QLabel("Max Stint Laps:"), 8, 0, 1, 2)
        layout.addWidget(self.stint_laps, 9, 0)
        layout.addWidget(QLabel("lap"), 9, 1)

        layout.addWidget(QLabel("Max Stint Minutes:"), 10, 0, 1, 2)
        layout.addWidget(self.stint_minutes, 11, 0)
        layout.addWidget(QLabel("min"), 11, 1)

        layout.addWidget(QLabel(f"End Stint {type_name}:"), 12, 0, 1, 2)
        layout.addWidget(self.end_stint, 13, 0)
        layout.addWidget(QLabel(unit_text), 13, 1)

        layout.addWidget(QLabel("One Less Pit Stop:"), 14, 0, 1, 2)
        layout.addWidget(self.one_less_stint, 15, 0)
        layout.addWidget(QLabel(unit_text), 15, 1)

        frame.setLayout(layout)


class InputRefill():
    """Input refill display"""

    def __init__(self, parent, frame, type_name) -> None:
        """Set output display"""
        self.amount_start = QDoubleSpinBox()
        self.amount_start.setDecimals(2)
        self.amount_start.setAlignment(Qt.AlignRight)

        if type_name == "Fuel":
            start_range = 9999
            unit_text = parent.symbol_fuel
            self.amount_start.valueChanged.connect(parent.validate_starting_fuel)
        else:
            start_range = 100
            unit_text = "%"
        self.amount_start.setRange(0, start_range)
        self.amount_start.valueChanged.connect(parent.update_input)

        self.average_refill = QLineEdit("0.000")
        self.average_refill.setAlignment(Qt.AlignRight)
        self.average_refill.setReadOnly(True)

        layout = set_grid_layout()

        layout.addWidget(QLabel(f"Starting {type_name}:"), 0, 0, 1, 2)
        layout.addWidget(self.amount_start, 1, 0)
        layout.addWidget(QLabel(unit_text), 1, 1)

        layout.addWidget(QLabel("Average Refilling:"), 2, 0, 1, 2)
        layout.addWidget(self.average_refill, 3, 0)
        layout.addWidget(QLabel(unit_text), 3, 1)

        frame.setLayout(layout)


class InputTyreWear():
    """Input tyre wear"""

    def __init__(self, parent, frame) -> None:
        """Set input race"""
        self.start_tread = QDoubleSpinBox()
        self.start_tread.setRange(0, 100)
        self.start_tread.setDecimals(3)
        self.start_tread.setSingleStep(0.01)
        self.start_tread.setAlignment(Qt.AlignRight)
        self.start_tread.setValue(100.0)
        self.start_tread.valueChanged.connect(parent.update_input)

        self.wear_lap = QDoubleSpinBox()
        self.wear_lap.setRange(0, 100)
        self.wear_lap.setDecimals(3)
        self.wear_lap.setSingleStep(0.01)
        self.wear_lap.setAlignment(Qt.AlignRight)
        self.wear_lap.valueChanged.connect(parent.update_input)

        self.wear_stint = QLineEdit("0.000")
        self.wear_stint.setAlignment(Qt.AlignRight)
        self.wear_stint.setReadOnly(True)

        self.lifespan_laps = QLineEdit("0.000")
        self.lifespan_laps.setAlignment(Qt.AlignRight)
        self.lifespan_laps.setReadOnly(True)

        self.lifespan_minutes = QLineEdit("0.000")
        self.lifespan_minutes.setAlignment(Qt.AlignRight)
        self.lifespan_minutes.setReadOnly(True)

        self.lifespan_stints = QLineEdit("0.000")
        self.lifespan_stints.setAlignment(Qt.AlignRight)
        self.lifespan_stints.setReadOnly(True)

        layout = set_grid_layout()

        layout.setColumnStretch(0, 1)
        layout.setColumnStretch(2, 1)

        layout.addWidget(QLabel("Starting Tyre Tread:"), 0, 0, 1, 2)
        layout.addWidget(self.start_tread, 1, 0)
        layout.addWidget(QLabel("%"), 1, 1)

        layout.addWidget(QLabel("Lifespan Laps:"), 0, 2, 1, 2)
        layout.addWidget(self.lifespan_laps, 1, 2)
        layout.addWidget(QLabel("lap"), 1, 3)

        layout.addWidget(QLabel("Tread Wear Per Lap:"), 2, 0, 1, 2)
        layout.addWidget(self.wear_lap, 3, 0)
        layout.addWidget(QLabel("%"), 3, 1)

        layout.addWidget(QLabel("Lifespan Minutes:"), 2, 2, 1, 2)
        layout.addWidget(self.lifespan_minutes, 3, 2)
        layout.addWidget(QLabel("min"), 3, 3)

        layout.addWidget(QLabel("Tread Wear Per Stint:"), 4, 0, 1, 2)
        layout.addWidget(self.wear_stint, 5, 0)
        layout.addWidget(QLabel("%"), 5, 1)

        layout.addWidget(QLabel("Lifespan Stints:"), 4, 2, 1, 2)
        layout.addWidget(self.lifespan_stints, 5, 2)
        layout.addWidget(QLabel("x"), 5, 3)

        frame.setLayout(layout)

```

# File: tinypedal/ui/heatmap_editor.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Heatmap editor
"""

import time

from PySide2.QtWidgets import (
    QComboBox,
    QDialogButtonBox,
    QHBoxLayout,
    QHeaderView,
    QLineEdit,
    QMessageBox,
    QTableWidget,
    QVBoxLayout,
)

from ..const_file import ConfigType
from ..setting import cfg, copy_setting
from ._common import (
    QVAL_COLOR,
    QVAL_HEATMAP,
    BaseDialog,
    BaseEditor,
    BatchOffset,
    CompactButton,
    DoubleClickEdit,
    FloatTableItem,
    UIScaler,
)

HEADER_HEATMAP = "Temperature (Celsius)","Color"


class HeatmapEditor(BaseEditor):
    """Heatmap editor"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Heatmap Editor")
        self.setMinimumHeight(UIScaler.size(30))

        self._verify_enabled = True
        self.heatmap_temp = copy_setting(cfg.user.heatmap)
        self.selected_heatmap_key = next(iter(self.heatmap_temp.keys()))
        self.selected_heatmap_dict = self.heatmap_temp[self.selected_heatmap_key]

        # Preset selector
        self.heatmap_list = QComboBox()
        self.heatmap_list.addItems(self.heatmap_temp.keys())
        self.heatmap_list.currentIndexChanged.connect(self.select_heatmap)

        # Heatmap list box
        self.table_heatmap = QTableWidget(self)
        self.table_heatmap.setColumnCount(len(HEADER_HEATMAP))
        self.table_heatmap.setHorizontalHeaderLabels(HEADER_HEATMAP)
        self.table_heatmap.verticalHeader().setVisible(False)
        self.table_heatmap.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.table_heatmap.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table_heatmap.horizontalHeader().setSectionResizeMode(1, QHeaderView.Fixed)
        self.table_heatmap.setColumnWidth(1, UIScaler.size(8))
        self.table_heatmap.cellChanged.connect(self.set_modified)
        self.table_heatmap.cellChanged.connect(self.verify_input)
        self.refresh_table()
        self.set_unmodified()

        # Button
        button_create = CompactButton("New")
        button_create.clicked.connect(self.open_create_dialog)

        button_copy = CompactButton("Copy")
        button_copy.clicked.connect(self.open_copy_dialog)

        button_delete = CompactButton("Delete")
        button_delete.clicked.connect(self.delete_heatmap)

        button_add = CompactButton("Add")
        button_add.clicked.connect(self.add_temperature)

        button_sort = CompactButton("Sort")
        button_sort.clicked.connect(self.sort_temperature)

        button_remove = CompactButton("Remove")
        button_remove.clicked.connect(self.delete_temperature)

        button_offset = CompactButton("Offset")
        button_offset.clicked.connect(self.open_offset_dialog)

        button_reset = CompactButton("Reset")
        button_reset.clicked.connect(self.reset_heatmap)

        button_apply = CompactButton("Apply")
        button_apply.clicked.connect(self.applying)

        button_save = CompactButton("Save")
        button_save.clicked.connect(self.saving)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        # Set layout
        layout_main = QVBoxLayout()
        layout_selector = QHBoxLayout()
        layout_button = QHBoxLayout()

        layout_selector.addWidget(self.heatmap_list, stretch=1)
        layout_selector.addWidget(button_create)
        layout_selector.addWidget(button_copy)
        layout_selector.addWidget(button_delete)

        layout_button.addWidget(button_add)
        layout_button.addWidget(button_sort)
        layout_button.addWidget(button_remove)
        layout_button.addWidget(button_offset)
        layout_button.addWidget(button_reset)
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_save)
        layout_button.addWidget(button_close)

        layout_main.addLayout(layout_selector)
        layout_main.addWidget(self.table_heatmap)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)
        self.setMinimumWidth(self.sizeHint().width() + UIScaler.size(2))

    def refresh_table(self):
        """Refresh temperature table"""
        self.table_heatmap.setRowCount(0)
        row_index = 0

        self._verify_enabled = False
        for temperature, color in self.selected_heatmap_dict.items():
            self.add_temperature_entry(row_index, float(temperature), color)
            row_index += 1
        self._verify_enabled = True

    def __add_option_color(self, key):
        """Color string"""
        color_edit = DoubleClickEdit(self, mode="color", init=key)
        color_edit.setMaxLength(9)
        color_edit.setValidator(QVAL_COLOR)
        color_edit.textChanged.connect(self.set_modified)
        color_edit.textChanged.connect(color_edit.preview_color)
        color_edit.setText(key)  # load selected option
        return color_edit

    def add_temperature_entry(self, row_index: int, temperature: float, color: str):
        """Add new temperature entry to table"""
        self.table_heatmap.insertRow(row_index)
        self.table_heatmap.setItem(row_index, 0, FloatTableItem(temperature))
        self.table_heatmap.setCellWidget(row_index, 1, self.__add_option_color(color))

    def open_create_dialog(self):
        """Create heatmap preset"""
        _dialog = CreateHeatmapPreset(self, "Create Heatmap Preset")
        _dialog.open()

    def open_copy_dialog(self):
        """Copy heatmap preset"""
        _dialog = CreateHeatmapPreset(self, "Duplicate Heatmap Preset", "duplicate")
        _dialog.open()

    def open_offset_dialog(self):
        """Open offset dialog"""
        if self.column_selection_count(0) == 0:
            msg_text = (
                "Select <b>one or more values</b> from <b>temperature</b> "
                "column to apply offset."
            )
            QMessageBox.warning(self, "Error", msg_text)
            return

        self.sort_temperature()
        _dialog = BatchOffset(self, self.apply_batch_offset)
        _dialog.config(1, 1, -99999, 99999)
        _dialog.open()

    def column_selection_count(self, column_index: int = 0) -> int:
        """Column selection count"""
        row_count = 0
        for data in self.table_heatmap.selectedIndexes():
            if data.column() == column_index:
                row_count += 1
            else:
                return 0
        return row_count

    def verify_input(self, row_index: int, column_index: int):
        """Verify input value"""
        if self._verify_enabled:
            self.set_modified()
            item = self.table_heatmap.item(row_index, column_index)
            if column_index == 0:
                item.validate()

    def apply_batch_offset(self, offset: int, is_scale_mode: bool):
        """Apply batch offset"""
        self._verify_enabled = False
        for item in self.table_heatmap.selectedItems():
            value = item.value()
            if is_scale_mode:
                value *= offset
            else:
                value += offset
            item.setValue(value)
        self._verify_enabled = True
        self.set_modified()

    def add_temperature(self):
        """Add new temperature"""
        self.sort_temperature()
        row_index = self.table_heatmap.rowCount()
        if row_index > 0:
            temperature = self.table_heatmap.item(row_index - 1, 0).value() + 10
            color = "#FFFFFF"
        else:
            temperature = -273.0
            color = "#4444FF"
        self.add_temperature_entry(row_index, temperature, color)
        self.table_heatmap.setCurrentCell(row_index, 0)

    def delete_temperature(self, row_index: int):
        """Delete temperature entry"""
        selected_rows = set(data.row() for data in self.table_heatmap.selectedIndexes())
        if not selected_rows:
            QMessageBox.warning(self, "Error", "No data selected.")
            return

        if not self.confirm_operation(message="<b>Delete selected temperature?</b>"):
            return

        for row_index in sorted(selected_rows, reverse=True):
            self.table_heatmap.removeRow(row_index)
        self.set_modified()

    def sort_temperature(self):
        """Sort temperature"""
        if self.table_heatmap.rowCount() > 1:
            self.table_heatmap.sortItems(0)
            self.set_modified()

    def select_heatmap(self):
        """Select heatmap list"""
        # Sort & apply previous preset first
        if self.selected_heatmap_dict:
            self.update_heatmap_temp()
        # Get newly selected preset name
        self.selected_heatmap_key = self.heatmap_list.currentText()
        self.selected_heatmap_dict = self.heatmap_temp[self.selected_heatmap_key]
        self.refresh_table()

    def delete_heatmap(self):
        """Delete heatmap"""
        if self.selected_heatmap_key in cfg.default.heatmap:
            QMessageBox.warning(self, "Error", "Cannot delete built-in heatmap preset.")
            return

        msg_text = (
            f"Delete <b>{self.selected_heatmap_key}</b> preset?<br><br>"
            "Changes are only saved after clicking Apply or Save Button."
        )
        if self.confirm_operation(message=msg_text):
            self.heatmap_temp.pop(self.selected_heatmap_key)  # remove from dict
            self.selected_heatmap_dict.clear()
            self.heatmap_list.removeItem(self.heatmap_list.currentIndex())
            self.set_modified()

    def reset_heatmap(self):
        """Reset heatmap"""
        if cfg.default.heatmap.get(self.selected_heatmap_key) is None:
            msg_text = (
                "Cannot reset selected heatmap preset.<br><br>"
                "Default preset does not exist."
            )
            QMessageBox.warning(self, "Error", msg_text)
            return

        msg_text = (
            f"Reset <b>{self.selected_heatmap_key}</b> preset to default?<br><br>"
            "Changes are only saved after clicking Apply or Save Button."
        )
        if self.confirm_operation(message=msg_text):
            self.selected_heatmap_dict = cfg.default.heatmap[self.selected_heatmap_key].copy()
            self.refresh_table()

    def applying(self):
        """Save & apply"""
        self.save_heatmap()

    def saving(self):
        """Save & close"""
        self.save_heatmap()
        self.accept()  # close

    def update_heatmap_temp(self):
        """Update temporary changes to selected heatmap first"""
        self.sort_temperature()
        self.selected_heatmap_dict.clear()
        for index in range(self.table_heatmap.rowCount()):
            temperature = f"{self.table_heatmap.item(index, 0).value():.1f}"
            color_string = self.table_heatmap.cellWidget(index, 1).text()
            self.selected_heatmap_dict[temperature] = color_string
        # Apply changes to heatmap preset dictionary
        self.heatmap_temp[self.selected_heatmap_key] = self.selected_heatmap_dict

    def save_heatmap(self):
        """Save heatmap"""
        self.update_heatmap_temp()
        cfg.user.heatmap = copy_setting(self.heatmap_temp)
        cfg.save(0, cfg_type=ConfigType.HEATMAP)
        while cfg.is_saving:  # wait saving finish
            time.sleep(0.01)
        self.reloading()
        self.set_unmodified()


class CreateHeatmapPreset(BaseDialog):
    """Create heatmap preset

    Args:
        title: Dialog title string.
        mode: Edit mode, either "duplicate" or "" for new preset.
    """

    def __init__(self, parent, title: str = "", mode: str = ""):
        super().__init__(parent)
        self._parent = parent
        self.edit_mode = mode
        self.setWindowTitle(title)
        self.setMinimumWidth(UIScaler.size(21))

        # Entry box
        self.preset_entry = QLineEdit()
        self.preset_entry.setMaxLength(40)
        self.preset_entry.setPlaceholderText("Enter a new preset name")
        self.preset_entry.setValidator(QVAL_HEATMAP)

        # Button
        button_create = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)
        button_create.accepted.connect(self.creating)
        button_create.rejected.connect(self.reject)

        # Layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.preset_entry)
        layout_main.addWidget(button_create)
        self.setLayout(layout_main)

    def creating(self):
        """Creating new preset"""
        entered_name = self.preset_entry.text()
        if not entered_name:
            QMessageBox.warning(self, "Error", "Invalid preset name.")
        elif entered_name in cfg.user.heatmap:
            QMessageBox.warning(self, "Error", "Preset already exists.")
        else:
            self.__saving(entered_name)

    def __saving(self, entered_name: str):
        """Saving new preset"""
        # Duplicate preset
        if self.edit_mode == "duplicate":
            self._parent.heatmap_temp[entered_name] = self._parent.selected_heatmap_dict.copy()
        # Create new preset
        else:
            self._parent.heatmap_temp[entered_name] = {"-273.0": "#4444FF"}
        self._parent.heatmap_list.addItem(entered_name)
        self._parent.heatmap_list.setCurrentText(entered_name)
        # Close window
        self.accept()

```

# File: tinypedal/ui/log_info.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Log window
"""

from PySide2.QtGui import QTextCursor, QTextOption
from PySide2.QtWidgets import (
    QFileDialog,
    QHBoxLayout,
    QMessageBox,
    QTextBrowser,
    QVBoxLayout,
)

from ..const_file import FileFilter
from ..main import log_stream
from ._common import BaseDialog, CompactButton, UIScaler


class LogInfo(BaseDialog):
    """Create log info dialog"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Log")

        # Text view
        self.log_view = QTextBrowser(self)
        self.log_view.setMinimumSize(UIScaler.size(42), UIScaler.size(22))
        self.log_view.setWordWrapMode(QTextOption.NoWrap)
        self.refresh_log()

        # Button
        button_refresh = CompactButton("Refresh")
        button_refresh.clicked.connect(self.refresh_log)

        button_save = CompactButton("Save")
        button_save.clicked.connect(self.save_log)

        button_copy = CompactButton("Copy")
        button_copy.clicked.connect(self.copy_log)

        button_clear = CompactButton("Clear")
        button_clear.clicked.connect(self.clear_log)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.reject)

        # Layout
        layout_button = QHBoxLayout()
        layout_button.addWidget(button_refresh)
        layout_button.addWidget(button_save)
        layout_button.addWidget(button_copy)
        layout_button.addWidget(button_clear)
        layout_button.addStretch(1)
        layout_button.addWidget(button_close)

        layout_main = QVBoxLayout()
        layout_main.addWidget(self.log_view)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def refresh_log(self):
        """Refresh log"""
        self.log_view.setText(log_stream.getvalue())
        self.log_view.moveCursor(QTextCursor.End)

    def clear_log(self):
        """Clear log"""
        if self.confirm_operation(message="Clear all log?"):
            log_stream.truncate(0)
            log_stream.seek(0)
            self.refresh_log()

    def copy_log(self):
        """Copy log"""
        self.log_view.selectAll()
        self.log_view.copy()
        QMessageBox.information(self, "Copy", "Copied all log to Clipboard.")

    def save_log(self):
        """Save log"""
        filename_full = QFileDialog.getSaveFileName(
            self,
            dir="log",
            filter=";;".join((FileFilter.TXT, FileFilter.LOG, FileFilter.ALL)),
        )[0]
        if not filename_full:
            return
        with open(filename_full, "w", newline="", encoding="utf-8") as log_file:
            log_stream.seek(0)
            log_file.writelines(log_stream)
        # Set back to end
        log_stream.seek(2)

```

# File: tinypedal/ui/menu.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Menu
"""

import os

from PySide2.QtGui import QDesktopServices
from PySide2.QtWidgets import QMenu, QMessageBox

from .. import loader
from ..api_control import API_PACK, api
from ..const_app import URL_FAQ, URL_USER_GUIDE
from ..const_file import ConfigType
from ..module_info import minfo
from ..overlay_control import octrl
from ..setting import cfg
from ..update import update_checker
from .about import About
from .brake_editor import BrakeEditor
from .config import FontConfig, UserConfig
from .driver_stats_viewer import DriverStatsViewer
from .fuel_calculator import FuelCalculator
from .heatmap_editor import HeatmapEditor
from .log_info import LogInfo
from .track_info_editor import TrackInfoEditor
from .track_map_viewer import TrackMapViewer
from .track_notes_editor import TrackNotesEditor
from .tyre_compound_editor import TyreCompoundEditor
from .vehicle_brand_editor import VehicleBrandEditor
from .vehicle_class_editor import VehicleClassEditor


class OverlayMenu(QMenu):
    """Overlay menu, shared between main & tray menu"""

    def __init__(self, title, parent, is_tray: bool = False):
        super().__init__(title, parent)
        if is_tray:
            self.loaded_preset = self.addAction("")
            self.loaded_preset.setDisabled(True)
            self.aboutToShow.connect(self.refresh_preset_name)
            self.addSeparator()

        # Lock overlay
        self.overlay_lock = self.addAction("Lock Overlay")
        self.overlay_lock.setCheckable(True)
        self.overlay_lock.triggered.connect(self.is_locked)

        # Auto hide
        self.overlay_hide = self.addAction("Auto Hide")
        self.overlay_hide.setCheckable(True)
        self.overlay_hide.triggered.connect(self.is_hidden)

        # Grid move
        self.overlay_grid = self.addAction("Grid Move")
        self.overlay_grid.setCheckable(True)
        self.overlay_grid.triggered.connect(self.has_grid)

        # VR Compatbiility
        self.overlay_vr = self.addAction("VR Compatibility")
        self.overlay_vr.setCheckable(True)
        self.overlay_vr.triggered.connect(self.vr_compatibility)

        # Reload preset
        reload_preset = self.addAction("Reload")
        reload_preset.triggered.connect(parent.reload_preset)
        self.addSeparator()

        # Reset submenu
        menu_reset_data = ResetDataMenu("Reset Data", parent)
        self.addMenu(menu_reset_data)
        self.addSeparator()

        # Config
        if is_tray:
            app_config = self.addAction("Config")
            app_config.triggered.connect(parent.show_app)
            self.addSeparator()

        # Quit
        app_quit = self.addAction("Quit")
        app_quit.triggered.connect(parent.quit_app)

        # Refresh menu
        self.aboutToShow.connect(self.refresh_menu)

    def refresh_menu(self):
        """Refresh menu"""
        self.overlay_lock.setChecked(cfg.overlay["fixed_position"])
        self.overlay_hide.setChecked(cfg.overlay["auto_hide"])
        self.overlay_grid.setChecked(cfg.overlay["enable_grid_move"])
        self.overlay_vr.setChecked(cfg.overlay["vr_compatibility"])

    def refresh_preset_name(self):
        """Refresh preset name"""
        loaded_preset = cfg.filename.setting[:-5]
        if len(loaded_preset) > 16:
            loaded_preset = f"{loaded_preset[:16]}..."
        self.loaded_preset.setText(loaded_preset)

    @staticmethod
    def is_locked():
        """Check lock state"""
        octrl.toggle.lock()

    @staticmethod
    def is_hidden():
        """Check hide state"""
        octrl.toggle.hide()

    @staticmethod
    def has_grid():
        """Check grid move state"""
        octrl.toggle.grid()

    @staticmethod
    def vr_compatibility():
        """Check VR compatibility state"""
        octrl.toggle.vr()


class ResetDataMenu(QMenu):
    """Reset user data menu"""

    def __init__(self, title, parent):
        super().__init__(title, parent)
        self._parent = parent

        reset_deltabest = self.addAction("Delta Best")
        reset_deltabest.triggered.connect(self.reset_deltabest)

        reset_energydelta = self.addAction("Energy Delta")
        reset_energydelta.triggered.connect(self.reset_energydelta)

        reset_fueldelta = self.addAction("Fuel Delta")
        reset_fueldelta.triggered.connect(self.reset_fueldelta)

        reset_consumption = self.addAction("Consumption History")
        reset_consumption.triggered.connect(self.reset_consumption)

        reset_sectorbest = self.addAction("Sector Best")
        reset_sectorbest.triggered.connect(self.reset_sectorbest)

        reset_trackmap = self.addAction("Track Map")
        reset_trackmap.triggered.connect(self.reset_trackmap)

    def reset_deltabest(self):
        """Reset deltabest data"""
        self.__confirmation(
            data_type="delta best",
            extension="csv",
            filepath=cfg.path.delta_best,
            filename=api.read.session.combo_name(),
        )

    def reset_energydelta(self):
        """Reset energy delta data"""
        self.__confirmation(
            data_type="energy delta",
            extension="energy",
            filepath=cfg.path.energy_delta,
            filename=api.read.session.combo_name(),
        )

    def reset_fueldelta(self):
        """Reset fuel delta data"""
        self.__confirmation(
            data_type="fuel delta",
            extension="fuel",
            filepath=cfg.path.fuel_delta,
            filename=api.read.session.combo_name(),
        )

    def reset_consumption(self):
        """Reset consumption history data"""
        if self.__confirmation(
            data_type="consumption history",
            extension="consumption",
            filepath=cfg.path.fuel_delta,
            filename=api.read.session.combo_name(),
        ):
            minfo.history.reset_consumption()

    def reset_sectorbest(self):
        """Reset sector best data"""
        self.__confirmation(
            data_type="sector best",
            extension="sector",
            filepath=cfg.path.sector_best,
            filename=api.read.session.combo_name(),
        )

    def reset_trackmap(self):
        """Reset trackmap data"""
        self.__confirmation(
            data_type="track map",
            extension="svg",
            filepath=cfg.path.track_map,
            filename=api.read.session.track_name(),
        )

    def __confirmation(self, data_type: str, extension: str, filepath: str, filename: str) -> bool:
        """Message confirmation, returns true if file deleted"""
        # Check if on track
        if api.read.state.active():
            QMessageBox.warning(
                self._parent,
                "Error",
                "Cannot reset data while on track.",
            )
            return False
        # Check if file exist
        filename_full = f"{filepath}{filename}.{extension}"
        if not os.path.exists(filename_full):
            QMessageBox.warning(
                self._parent,
                "Error",
                f"No {data_type} data found.<br><br>You can only reset data from active session.",
            )
            return False
        # Confirm reset
        msg_text = (
            f"Reset <b>{data_type}</b> data for<br>"
            f"<b>{filename}</b> ?<br><br>"
            "This cannot be undone!"
        )
        delete_msg = QMessageBox.question(
            self._parent, f"Reset {data_type.title()}", msg_text,
            buttons=QMessageBox.Yes | QMessageBox.No,
            defaultButton=QMessageBox.No,
        )
        if delete_msg != QMessageBox.Yes:
            return False
        # Delete file
        os.remove(filename_full)
        QMessageBox.information(
            self._parent,
            f"Reset {data_type.title()}",
            f"{data_type.capitalize()} data has been reset for<br><b>{filename}</b>",
        )
        return True


class ConfigMenu(QMenu):
    """Config menu"""

    def __init__(self, title, parent):
        super().__init__(title, parent)
        self._parent = parent

        config_app = self.addAction("Application")
        config_app.triggered.connect(self.open_config_application)

        config_compat = self.addAction("Compatibility")
        config_compat.triggered.connect(self.open_config_compatibility)

        config_userpath = self.addAction("User Path")
        config_userpath.triggered.connect(self.open_config_userpath)
        self.addSeparator()

        config_units = self.addAction("Units")
        config_units.triggered.connect(self.open_config_units)

        config_font = self.addAction("Global Font Override")
        config_font.triggered.connect(self.open_config_font)

    def open_config_application(self):
        """Config global application"""
        _dialog = UserConfig(
            parent=self._parent,
            key_name="application",
            cfg_type=ConfigType.CONFIG,
            user_setting=cfg.user.config,
            default_setting=cfg.default.config,
            reload_func=self._parent.reload_preset,
        )
        _dialog.open()

    def open_config_compatibility(self):
        """Config global compatibility"""
        _dialog = UserConfig(
            parent=self._parent,
            key_name="compatibility",
            cfg_type=ConfigType.CONFIG,
            user_setting=cfg.user.config,
            default_setting=cfg.default.config,
            reload_func=self._parent.reload_preset,
        )
        _dialog.open()

    def open_config_userpath(self):
        """Config global user path"""
        _dialog = UserConfig(
            parent=self._parent,
            key_name="user_path",
            cfg_type=ConfigType.CONFIG,
            user_setting=cfg.user.config,
            default_setting=cfg.default.config,
            reload_func=self._parent.reload_preset,
            option_width=22,
        )
        _dialog.open()

    def open_config_font(self):
        """Config global font"""
        _dialog = FontConfig(
            parent=self._parent,
            user_setting=cfg.user.setting,
            reload_func=self._parent.reload_only,
        )
        _dialog.open()

    def open_config_units(self):
        """Config display units"""
        _dialog = UserConfig(
            parent=self._parent,
            key_name="units",
            cfg_type=ConfigType.SETTING,
            user_setting=cfg.user.setting,
            default_setting=cfg.default.setting,
            reload_func=self._parent.reload_only,
        )
        _dialog.open()


class APIMenu(QMenu):
    """API menu"""

    def __init__(self, title, parent):
        super().__init__(title, parent)
        self._parent = parent

        # API selector
        self.actions_api = self.__api_selector()
        self.addSeparator()

        self.api_selection = self.addAction("Remember API Selection from Preset")
        self.api_selection.setCheckable(True)
        self.api_selection.triggered.connect(self.toggle_api_selection)

        config_api = self.addAction("Options")
        config_api.triggered.connect(self.open_config_api)
        self.addSeparator()

        restart_api = self.addAction("Restart API")
        restart_api.triggered.connect(parent.restart_api)

        self.aboutToShow.connect(self.refresh_menu)

    def refresh_menu(self):
        """Refresh menu"""
        selected_api_name = cfg.api_name
        for action in self.actions_api.actions():
            if selected_api_name == action.text():
                action.setChecked(True)
                break
        self.api_selection.setChecked(cfg.telemetry["enable_api_selection_from_preset"])

    def toggle_api_selection(self):
        """Toggle API selection mode"""
        enabled = cfg.telemetry["enable_api_selection_from_preset"]
        cfg.telemetry["enable_api_selection_from_preset"] = not enabled
        cfg.save(cfg_type=ConfigType.CONFIG)
        self._parent.reload_only()

    def open_config_api(self):
        """Config API"""
        _dialog = UserConfig(
            parent=self._parent,
            key_name=cfg.api_key,
            cfg_type=ConfigType.SETTING,
            user_setting=cfg.user.setting,
            default_setting=cfg.default.setting,
            reload_func=self._parent.restart_api,
        )
        _dialog.open()

    def __api_selector(self):
        """Generate API selector"""
        if os.getenv("PYSIDE_OVERRIDE") == "6":
            from PySide6.QtGui import QActionGroup
        else:
            from PySide2.QtWidgets import QActionGroup

        actions_api = QActionGroup(self)

        for _api in API_PACK:
            api_name = _api.NAME
            option = self.addAction(api_name)
            option.setCheckable(True)
            option.triggered.connect(lambda checked=True, name=api_name: self.__toggle_option(checked, name))
            actions_api.addAction(option)
        return actions_api

    def __toggle_option(self, checked: bool, api_name: str):
        """Toggle option"""
        if cfg.api_name == api_name:
            return
        cfg.api_name = api_name
        cfg.save(cfg_type=ConfigType.CONFIG)
        self._parent.reload_only()


class ToolsMenu(QMenu):
    """Tools menu"""

    def __init__(self, title, parent):
        super().__init__(title, parent)
        self._parent = parent

        utility_fuelcalc = self.addAction("Fuel Calculator")
        utility_fuelcalc.triggered.connect(self.open_utility_fuelcalc)

        utility_driverstats = self.addAction("Driver Stats Viewer")
        utility_driverstats.triggered.connect(self.open_utility_driverstats)

        utility_mapviewer = self.addAction("Track Map Viewer")
        utility_mapviewer.triggered.connect(self.open_utility_mapviewer)
        self.addSeparator()

        editor_heatmap = self.addAction("Heatmap Editor")
        editor_heatmap.triggered.connect(self.open_editor_heatmap)

        editor_brakes = self.addAction("Brake Editor")
        editor_brakes.triggered.connect(self.open_editor_brakes)

        editor_compounds = self.addAction("Tyre Compound Editor")
        editor_compounds.triggered.connect(self.open_editor_compounds)

        editor_brands = self.addAction("Vehicle Brand Editor")
        editor_brands.triggered.connect(self.open_editor_brands)

        editor_classes = self.addAction("Vehicle Class Editor")
        editor_classes.triggered.connect(self.open_editor_classes)

        editor_trackinfo = self.addAction("Track Info Editor")
        editor_trackinfo.triggered.connect(self.open_editor_trackinfo)

        editor_tracknotes = self.addAction("Track Notes Editor")
        editor_tracknotes.triggered.connect(self.open_editor_tracknotes)

    def open_utility_fuelcalc(self):
        """Fuel calculator"""
        _dialog = FuelCalculator(self._parent)
        _dialog.show()

    def open_utility_driverstats(self):
        """Track driver stats viewer"""
        _dialog = DriverStatsViewer(self._parent)
        _dialog.show()

    def open_utility_mapviewer(self):
        """Track map viewer"""
        _dialog = TrackMapViewer(self._parent)
        _dialog.show()

    def open_editor_heatmap(self):
        """Edit heatmap preset"""
        _dialog = HeatmapEditor(self._parent)
        _dialog.show()

    def open_editor_brakes(self):
        """Edit brakes preset"""
        _dialog = BrakeEditor(self._parent)
        _dialog.show()

    def open_editor_compounds(self):
        """Edit compounds preset"""
        _dialog = TyreCompoundEditor(self._parent)
        _dialog.show()

    def open_editor_brands(self):
        """Edit brands preset"""
        _dialog = VehicleBrandEditor(self._parent)
        _dialog.show()

    def open_editor_classes(self):
        """Edit classes preset"""
        _dialog = VehicleClassEditor(self._parent)
        _dialog.show()

    def open_editor_trackinfo(self):
        """Edit track info"""
        _dialog = TrackInfoEditor(self._parent)
        _dialog.show()

    def open_editor_tracknotes(self):
        """Edit track notes"""
        _dialog = TrackNotesEditor(self._parent)
        _dialog.show()


class WindowMenu(QMenu):
    """Window menu"""

    def __init__(self, title, parent):
        super().__init__(title, parent)
        self.show_at_startup = self.addAction("Show at Startup")
        self.show_at_startup.setCheckable(True)
        self.show_at_startup.triggered.connect(self.is_show_at_startup)

        self.minimize_to_tray = self.addAction("Minimize to Tray")
        self.minimize_to_tray.setCheckable(True)
        self.minimize_to_tray.triggered.connect(self.is_minimize_to_tray)

        self.remember_position = self.addAction("Remember Position")
        self.remember_position.setCheckable(True)
        self.remember_position.triggered.connect(self.is_remember_position)

        self.remember_size = self.addAction("Remember Size")
        self.remember_size.setCheckable(True)
        self.remember_size.triggered.connect(self.is_remember_size)
        self.addSeparator()

        restart_app = self.addAction("Restart TinyPedal")
        restart_app.triggered.connect(loader.restart)

        self.aboutToShow.connect(self.refresh_menu)

    def refresh_menu(self):
        """Refresh menu"""
        self.show_at_startup.setChecked(cfg.application["show_at_startup"])
        self.minimize_to_tray.setChecked(cfg.application["minimize_to_tray"])
        self.remember_position.setChecked(cfg.application["remember_position"])
        self.remember_size.setChecked(cfg.application["remember_size"])

    def is_show_at_startup(self):
        """Toggle config window startup state"""
        self.__toggle_option("show_at_startup")

    def is_minimize_to_tray(self):
        """Toggle minimize to tray state"""
        self.__toggle_option("minimize_to_tray")

    def is_remember_position(self):
        """Toggle config window remember position state"""
        self.__toggle_option("remember_position")

    def is_remember_size(self):
        """Toggle config window remember size state"""
        self.__toggle_option("remember_size")

    @staticmethod
    def __toggle_option(option_name: str):
        """Toggle option"""
        cfg.application[option_name] = not cfg.application[option_name]
        cfg.save(cfg_type=ConfigType.CONFIG)


class HelpMenu(QMenu):
    """Help menu"""

    def __init__(self, title, parent):
        super().__init__(title, parent)
        self._parent = parent

        app_guide = self.addAction("User Guide")
        app_guide.triggered.connect(self.open_user_guide)

        app_faq = self.addAction("FAQ")
        app_faq.triggered.connect(self.open_faq)

        app_log = self.addAction("Show Log")
        app_log.triggered.connect(self.show_log)
        self.addSeparator()

        app_update = self.addAction("Check for Updates")
        app_update.triggered.connect(self.show_update)
        self.addSeparator()

        app_about = self.addAction("About")
        app_about.triggered.connect(self.show_about)

    def show_about(self):
        """Show about"""
        _dialog = About(self._parent)
        _dialog.show()

    def show_log(self):
        """Show log"""
        _dialog = LogInfo(self._parent)
        _dialog.show()

    def show_update(self):
        """Show update"""
        update_checker.check(True)

    def open_user_guide(self):
        """Open user guide link"""
        QDesktopServices.openUrl(URL_USER_GUIDE)

    def open_faq(self):
        """Open FAQ link"""
        QDesktopServices.openUrl(URL_FAQ)

```

# File: tinypedal/ui/module_view.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Module & widget list view
"""

from PySide2.QtWidgets import (
    QHBoxLayout,
    QLabel,
    QListWidget,
    QListWidgetItem,
    QMessageBox,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from ..formatter import format_module_name
from ..module_control import ModuleControl
from ..setting import cfg
from ._common import UIScaler
from .config import UserConfig


class ModuleList(QWidget):
    """Module & widget list view"""

    def __init__(self, parent, module_control: ModuleControl):
        """Initialize module list setting

        Args:
            module_control: Module control (or widget) object.
        """
        super().__init__(parent)
        self.module_control = module_control

        # Label
        self.label_loaded = QLabel("")

        # List box
        self.listbox_module = QListWidget(self)
        self.listbox_module.setAlternatingRowColors(True)
        self.create_list()

        # Button
        button_enable = QPushButton("Enable All")
        button_enable.clicked.connect(self.module_button_enable_all)

        button_disable = QPushButton("Disable All")
        button_disable.clicked.connect(self.module_button_disable_all)

        layout_button = QHBoxLayout()
        layout_button.addWidget(button_enable)
        layout_button.addStretch(1)
        layout_button.addWidget(button_disable)

        # Layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.label_loaded)
        layout_main.addWidget(self.listbox_module)
        layout_main.addLayout(layout_button)
        margin = UIScaler.pixel(6)
        layout_main.setContentsMargins(margin, margin, margin, margin)
        self.setLayout(layout_main)

    def create_list(self):
        """Create module list"""
        for _name in self.module_control.names:
            module_item = ModuleControlItem(self, _name, self.module_control)
            item = QListWidgetItem()
            item.setText(format_module_name(_name))
            self.listbox_module.addItem(item)
            self.listbox_module.setItemWidget(item, module_item)
        self.listbox_module.setCurrentRow(0)

    def refresh(self):
        """Refresh module & button toggle state"""
        listbox_module = self.listbox_module
        for row_index in range(listbox_module.count()):
            item = listbox_module.item(row_index)
            listbox_module.itemWidget(item).update_state()

    def refresh_label(self):
        """Refresh label text"""
        self.label_loaded.setText(
            f"Enabled: <b>{self.module_control.number_active}/"
            f"{self.module_control.number_total}</b>"
        )

    def module_button_enable_all(self):
        """Enable all modules"""
        if self.module_control.number_active != self.module_control.number_total:
            if self.confirm_batch_toggle("Enable"):
                self.module_control.enable_all()
                self.refresh()

    def module_button_disable_all(self):
        """Disable all modules"""
        if self.module_control.number_active:
            if self.confirm_batch_toggle("Disable"):
                self.module_control.disable_all()
                self.refresh()

    def confirm_batch_toggle(self, confirm_type: str) -> bool:
        """Batch toggle confirmation"""
        if not cfg.application["show_confirmation_for_batch_toggle"]:
            return True
        msg_text = f"<b>{confirm_type}</b> all {self.module_control.type_id}s?"
        confirm_msg = QMessageBox.question(
            self, "Confirm", msg_text,
            buttons=QMessageBox.Yes | QMessageBox.No,
            defaultButton=QMessageBox.No,
        )
        return confirm_msg == QMessageBox.Yes


class ModuleControlItem(QWidget):
    """Module control item"""

    def __init__(self, parent, module_name: str, module_control: ModuleControl):
        """Initialize list box setting

        Args:
            module_name: Module (or widget) name string.
            module_control: Module control (or widget) object.
        """
        super().__init__(parent)
        self._parent = parent
        self.module_name = module_name
        self.module_control = module_control

        self.button_toggle = QPushButton("")
        self.button_toggle.setObjectName("buttonToggle")
        self.set_button_toggle()

        button_config = QPushButton("Config")
        button_config.setObjectName("buttonConfig")
        button_config.pressed.connect(self.open_config_dialog)

        layout_item = QHBoxLayout()
        layout_item.setContentsMargins(0, 0, 0, 0)
        layout_item.addStretch(1)
        layout_item.setSpacing(0)
        layout_item.addWidget(button_config)
        layout_item.addWidget(self.button_toggle)
        self.setLayout(layout_item)

    def is_enabled(self) -> bool:
        """Is module enabled"""
        return cfg.user.setting[self.module_name]["enable"]

    def set_button_toggle(self):
        """Set toggle button"""
        self.button_toggle.setCheckable(True)
        self.button_toggle.setChecked(self.is_enabled())
        # Use "clicked" to avoid trigger with "setChecked"
        self.button_toggle.clicked.connect(self.toggle_state)
        self.update_button_text()

    def toggle_state(self):
        """Toggle button state"""
        self.module_control.toggle(self.module_name)
        self.update_button_text()

    def update_state(self):
        """Update button toggle state"""
        self.button_toggle.setChecked(self.is_enabled())
        self.update_button_text()

    def update_button_text(self):
        """Update button text"""
        self.button_toggle.setText("ON" if self.is_enabled() else "OFF")
        self._parent.refresh_label()

    def open_config_dialog(self):
        """Config dialog"""
        _dialog = UserConfig(
            parent=self._parent,
            key_name=self.module_name,
            cfg_type=self.module_control.type_id,
            user_setting=cfg.user.setting,
            default_setting=cfg.default.setting,
            reload_func=self.reload_module,
        )
        _dialog.open()

    def reload_module(self):
        """Reload module & button state"""
        self.module_control.reload(self.module_name)
        self.update_state()

```

# File: tinypedal/ui/notification.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Notification
"""

from __future__ import annotations

from PySide2.QtCore import Slot
from PySide2.QtGui import QDesktopServices
from PySide2.QtWidgets import (
    QMenu,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from .. import overlay_signal
from ..const_app import URL_RELEASE
from ..update import update_checker


class NotifyBar(QWidget):
    """Notify bar"""

    def __init__(self, parent):
        super().__init__(parent)
        self.spectate = QPushButton("Spectate Mode Enabled")
        self.spectate.setObjectName("notifySpectate")
        self.spectate.setVisible(False)
        self.spectate.clicked.connect(lambda _: parent.select_tab(3))

        self.pacenotes = QPushButton("Pace Notes Playback Enabled")
        self.pacenotes.setObjectName("notifyPacenotes")
        self.pacenotes.setVisible(False)
        self.pacenotes.clicked.connect(lambda _: parent.select_tab(4))

        self.presetlocked = QPushButton("Preset Locked")
        self.presetlocked.setObjectName("notifyPresetLocked")
        self.presetlocked.setVisible(False)
        self.presetlocked.clicked.connect(lambda _: parent.select_tab(2))

        self.updates = UpdatesNotifyButton("")
        self.updates.setObjectName("notifyUpdates")
        self.updates.setVisible(False)
        overlay_signal.updates.connect(self.updates.checking)

        layout = QVBoxLayout()
        layout.addWidget(self.spectate)
        layout.addWidget(self.pacenotes)
        layout.addWidget(self.presetlocked)
        layout.addWidget(self.updates)
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)


class UpdatesNotifyButton(QPushButton):
    """Updates notify button"""

    def __init__(self, text, parent=None):
        super().__init__(text, parent)
        version_menu = QMenu(self)

        view_update = version_menu.addAction("View Updates On GitHub")
        view_update.triggered.connect(self.open_release)
        version_menu.addSeparator()

        dismiss_msg = version_menu.addAction("Dismiss")
        dismiss_msg.triggered.connect(self.hide)

        self.setMenu(version_menu)

    def open_release(self):
        """Open release link"""
        QDesktopServices.openUrl(URL_RELEASE)

    @Slot(bool)  # type: ignore[operator]
    def checking(self, checking: bool):
        """Checking updates"""
        if checking:
            # Show checking message only with manual checking
            self.setText("Checking For Updates...")
            self.setVisible(update_checker.is_manual())
        else:
            # Hide message if no unpdates and not manual checking
            self.setText(update_checker.message())
            self.setVisible(update_checker.is_manual() or update_checker.is_updates())

```

# File: tinypedal/ui/pace_notes_view.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Pace notes view & player
"""

from __future__ import annotations

import logging
import os
from typing import Callable

from PySide2.QtCore import QBasicTimer, Qt, QUrl
from PySide2.QtMultimedia import QMediaPlayer
from PySide2.QtWidgets import (
    QCheckBox,
    QComboBox,
    QDoubleSpinBox,
    QFileDialog,
    QFrame,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QSlider,
    QVBoxLayout,
    QWidget,
)

from .. import realtime_state
from ..api_control import api
from ..const_file import FileFilter
from ..module_control import mctrl
from ..module_info import minfo
from ..setting import cfg
from ..userfile import set_relative_path
from ..userfile.track_notes import COLUMN_PACENOTE
from ._common import CompactButton, UIScaler

logger = logging.getLogger(__name__)


class PaceNotesPlayer(QMediaPlayer):
    """Pace notes player"""

    def __init__(self, parent, config: dict):
        super().__init__(parent)
        self.mcfg = config
        self.is_pyside6 = os.getenv("PYSIDE_OVERRIDE") == "6"
        self.audio_device = self.set_audio_device()

        # Set update timer
        self._update_timer = QBasicTimer()

        # Last data
        self._checked = False
        self._last_notes_index = None
        self._play_queue: list[str] = []

    def set_audio_device(self):
        """Set audio device"""
        if self.is_pyside6:
            from PySide6.QtMultimedia import QAudioOutput

            audio_device = QAudioOutput()
            self.setAudioOutput(audio_device)  # qt6 only
            return audio_device
        return None  # qt5

    def set_playback(self, enabled: bool):
        """Set playback state"""
        self.reset_playback()
        if enabled:
            update_interval = max(
                self.mcfg["update_interval"],
                cfg.application["minimum_update_interval"],
            )
            self._update_timer.start(update_interval, self)
            logger.info("ENABLED: pace notes sounds playback")
        else:
            self._update_timer.stop()
            logger.info("DISABLED: pace notes sounds playback")

    def reset_playback(self):
        """Reset"""
        self._checked = False
        self._last_notes_index = None
        self._play_queue.clear()
        self.stop()
        self.set_volume(self.mcfg["pace_notes_sound_volume"])

    def timerEvent(self, event):
        """Update when vehicle on track"""
        if realtime_state.active:

            # Reset switch
            if not self._checked:
                self._checked = True

            # Playback
            notes_index = minfo.pacenotes.currentIndex
            if self._last_notes_index != notes_index:
                self._last_notes_index = notes_index
                if self.mcfg["enable_playback_while_in_pit"] or not api.read.vehicle.in_pits():
                    self.__update_queue(minfo.pacenotes.currentNote.get(COLUMN_PACENOTE))

            if self._play_queue:
                self.__play_next_in_queue()

        else:
            if self._checked:
                self.reset_playback()

    def set_source(self) -> None:
        """Set source (compatibility)"""
        # Get sound source url
        pace_note = self._play_queue[0]
        sound_path = self.mcfg["pace_notes_sound_path"]
        sound_format = self.mcfg["pace_notes_sound_format"].strip(".")
        source_url = QUrl(f"{sound_path}{pace_note}.{sound_format}")

        if self.is_pyside6:
            return self.setSource(source_url)  # qt6
        return self.setMedia(source_url)  # qt5

    def set_volume(self, value: int) -> None:
        """Set volume (compatibility)"""
        if self.is_pyside6 and self.audio_device:
            return self.audio_device.setVolume(value / 100)  # qt6 (0.0 - 1.0)
        return self.setVolume(value)  # qt5 (0 - 100)

    def is_playing(self) -> bool:
        """Is playing state (compatibility)"""
        if self.is_pyside6:
            return self.playbackState() == QMediaPlayer.PlayingState  # qt6
        return self.state() == QMediaPlayer.State.PlayingState  # qt5

    def __update_queue(self, pace_note: str | None):
        """Update playback queue"""
        if (pace_note is not None
            and len(self._play_queue) < self.mcfg["pace_notes_sound_max_queue"]):
            self._play_queue.append(pace_note)

    def __play_next_in_queue(self):
        """Play next sound in playback queue"""
        # Wait if is playing & not exceeded max duration
        if (self.is_playing() and
            self.position() < self.mcfg["pace_notes_sound_max_duration"] * 1000):
            return
        # Play next sound in queue
        self.set_source()
        self.play()
        self._play_queue.pop(0)  # remove playing notes from queue


class PaceNotesControl(QWidget):
    """Pace notes control"""

    def __init__(self, parent, notify_toggle: Callable):
        super().__init__(parent)
        self.notify_toggle = notify_toggle
        self.mcfg = cfg.user.setting["pace_notes_playback"]
        self.pace_notes_player = PaceNotesPlayer(self, self.mcfg)

        # Pace notes file selector
        self.checkbox_file = QCheckBox("Manually Select Pace Notes File")
        self.checkbox_file.toggled.connect(self.toggle_selector_state)

        self.file_selector = QLineEdit()
        self.file_selector.setReadOnly(True)
        self.button_openfile = CompactButton("Open")
        self.button_openfile.clicked.connect(self.set_notes_path)

        # Sound path selector
        label_path = QLabel("Sound File Path:")
        self.path_selector = QLineEdit()
        self.path_selector.setReadOnly(True)
        button_openpath = CompactButton("Open")
        button_openpath.clicked.connect(self.set_sound_path)

        # Sound file format
        label_format = QLabel("Sound Format:")
        self.combobox_format = QComboBox()
        self.combobox_format.setEditable(True)
        self.combobox_format.addItems(("wav", "mp3", "aac"))

        # Global Offset
        label_offset = QLabel("Global Offset:")
        self.spinbox_offset = QDoubleSpinBox()
        self.spinbox_offset.setRange(-9999, 9999)
        self.spinbox_offset.setSingleStep(1)
        self.spinbox_offset.setDecimals(2)
        self.spinbox_offset.setSuffix("m")

        # Max playback duration per sound
        label_max_duration = QLabel("Max Duration:")
        self.spinbox_max_duration = QDoubleSpinBox()
        self.spinbox_max_duration.setRange(0.2, 60)
        self.spinbox_max_duration.setSingleStep(1)
        self.spinbox_max_duration.setDecimals(3)
        self.spinbox_max_duration.setSuffix("s")

        # Max playback queue
        label_max_queue = QLabel("Max Queue:")
        self.spinbox_max_queue = QDoubleSpinBox()
        self.spinbox_max_queue.setRange(1, 50)
        self.spinbox_max_queue.setSingleStep(1)
        self.spinbox_max_queue.setDecimals(0)

        # Sound volumn slider
        self.label_volume = QLabel("Playback Volume: 0%")
        self.slider_volume = QSlider(Qt.Horizontal)
        self.slider_volume.setRange(0, 100)
        self.slider_volume.valueChanged.connect(self.set_sound_volume)

        # Playback option
        self.checkbox_playinpit = QCheckBox("Enable Playback While in Pit Lane")
        self.checkbox_playinpit.toggled.connect(self.toggle_playinpit_state)

        # Frame layout
        layout_file = QGridLayout()
        layout_file.setAlignment(Qt.AlignTop)
        layout_file.addWidget(self.checkbox_file, 0, 0, 1, 2)
        layout_file.addWidget(self.file_selector, 1, 0)
        layout_file.addWidget(self.button_openfile, 1, 1)

        layout_file.addWidget(label_path, 2, 0, 1, 2)
        layout_file.addWidget(self.path_selector, 3, 0)
        layout_file.addWidget(button_openpath, 3, 1)

        layout_inner = QGridLayout()
        layout_inner.addWidget(label_format, 0, 0)
        layout_inner.addWidget(self.combobox_format, 1, 0)

        layout_inner.addWidget(label_offset, 0, 1)
        layout_inner.addWidget(self.spinbox_offset, 1, 1)

        layout_inner.addWidget(label_max_duration, 2, 0)
        layout_inner.addWidget(self.spinbox_max_duration, 3, 0)

        layout_inner.addWidget(label_max_queue, 2, 1)
        layout_inner.addWidget(self.spinbox_max_queue, 3, 1)

        layout_setting = QVBoxLayout()
        margin = UIScaler.pixel(5)
        layout_setting.setContentsMargins(margin, margin, margin, margin)
        layout_setting.addLayout(layout_file)
        layout_setting.addLayout(layout_inner)
        layout_setting.addStretch(1)
        layout_setting.addWidget(self.label_volume)
        layout_setting.addWidget(self.slider_volume)
        layout_setting.addWidget(self.checkbox_playinpit)

        self.frame_control = QFrame(self)
        self.frame_control.setFrameShape(QFrame.StyledPanel)
        self.frame_control.setLayout(layout_setting)

        # Button
        self.button_apply = QPushButton("Apply")
        self.button_apply.clicked.connect(self.set_playback_setting)

        self.button_toggle = QPushButton("")
        self.button_toggle.setCheckable(True)
        self.button_toggle.clicked.connect(self.toggle_button_state)

        layout_button = QHBoxLayout()
        layout_button.addWidget(self.button_apply)
        layout_button.addStretch(1)
        layout_button.addWidget(self.button_toggle)

        # Layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.frame_control, stretch=1)
        layout_main.addLayout(layout_button)
        margin = UIScaler.pixel(6)
        layout_main.setContentsMargins(margin, margin, margin, margin)
        self.setLayout(layout_main)
        self.refresh()

    def refresh(self):
        """Refresh state"""
        self.mcfg = cfg.user.setting["pace_notes_playback"]
        self.pace_notes_player.mcfg = self.mcfg
        self.toggle_playinpit_state(self.mcfg["enable_playback_while_in_pit"])
        self.toggle_selector_state(self.mcfg["enable_manual_file_selector"])
        self.file_selector.setText(self.mcfg["pace_notes_file_name"])
        self.path_selector.setText(self.mcfg["pace_notes_sound_path"])
        self.combobox_format.setEditText(self.mcfg["pace_notes_sound_format"])
        self.spinbox_offset.setValue(self.mcfg["pace_notes_global_offset"])
        self.spinbox_max_duration.setValue(self.mcfg["pace_notes_sound_max_duration"])
        self.spinbox_max_queue.setValue(self.mcfg["pace_notes_sound_max_queue"])
        self.slider_volume.setValue(self.mcfg["pace_notes_sound_volume"])
        self.set_enable_state(self.mcfg["enable"])

    def set_notes_path(self):
        """Set pace notes file path"""
        filepath = self.mcfg["pace_notes_file_name"]
        filename_full = QFileDialog.getOpenFileName(self, dir=filepath, filter=FileFilter.TPPN)[0]
        if not filename_full:
            return
        self.file_selector.setText(filename_full)
        self.pace_notes_player.reset_playback()
        if self.update_config("pace_notes_file_name", filename_full):
            mctrl.reload("module_notes")  # reload path in module notes

    def set_sound_path(self):
        """Set sounds folder path"""
        filepath = self.mcfg["pace_notes_sound_path"]
        filename_full = QFileDialog.getExistingDirectory(self, dir=filepath)
        if not filename_full:
            return
        filename_full = set_relative_path(filename_full)
        self.path_selector.setText(filename_full)
        self.update_config("pace_notes_sound_path", filename_full)

    def set_playback_setting(self):
        """Set sound playback setting"""
        sound_format = self.combobox_format.currentText()
        self.update_config("pace_notes_sound_format", sound_format)

        global_offset = self.spinbox_offset.value()
        self.update_config("pace_notes_global_offset", global_offset)

        max_duration = self.spinbox_max_duration.value()
        self.update_config("pace_notes_sound_max_duration", max_duration)

        max_queue = int(self.spinbox_max_queue.value())
        self.update_config("pace_notes_sound_max_queue", max_queue)

    def set_sound_volume(self, volume: int):
        """Set sound volume"""
        self.label_volume.setText(f"Playback Volume: {volume}%")
        if self.update_config("pace_notes_sound_volume", volume):
            self.pace_notes_player.set_volume(volume)

    def toggle_selector_state(self, checked: bool):
        """Toggle file selector state"""
        self.checkbox_file.setChecked(checked)
        self.file_selector.setText(self.mcfg["pace_notes_file_name"])
        self.file_selector.setDisabled(not checked)
        self.button_openfile.setDisabled(not checked)

        if self.update_config("enable_manual_file_selector", checked):
            mctrl.reload("module_notes")  # reload file in module notes

    def toggle_playinpit_state(self, checked: bool):
        """Toggle playback in pit state"""
        self.checkbox_playinpit.setChecked(checked)
        self.update_config("enable_playback_while_in_pit", checked)

    def toggle_button_state(self, checked: bool):
        """Toggle button state"""
        self.set_enable_state(checked)
        self.update_config("enable", checked)

    def set_enable_state(self, enabled: bool):
        """Set pace notes enabled state"""
        self.button_toggle.setText("  Playback Enabled  " if enabled else "  Playback Disabled  ")
        self.button_toggle.setChecked(enabled)
        self.button_apply.setDisabled(not enabled)
        self.frame_control.setDisabled(not enabled)
        self.pace_notes_player.set_playback(enabled)
        self.notify_toggle(enabled)

    def update_config(self, key: str, value: int | float | str) -> bool:
        """Update pace note playback setting, save if changed"""
        if self.mcfg[key] == value:
            return False
        self.mcfg[key] = value
        cfg.save()
        return True

```

# File: tinypedal/ui/spectate_view.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Spectate list view
"""

import logging
from typing import Callable

from PySide2.QtWidgets import (
    QHBoxLayout,
    QLabel,
    QListWidget,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from ..api_control import api
from ..setting import cfg
from ._common import UIScaler

logger = logging.getLogger(__name__)


class SpectateList(QWidget):
    """Spectate list view"""

    def __init__(self, parent, notify_toggle: Callable):
        super().__init__(parent)
        self.notify_toggle = notify_toggle
        self.last_enabled = None

        # Label
        self.label_spectating = QLabel("")

        # List box
        self.listbox_spectate = QListWidget(self)
        self.listbox_spectate.setAlternatingRowColors(True)
        self.listbox_spectate.itemDoubleClicked.connect(self.spectate_selected)

        # Button
        self.button_spectate = QPushButton("Spectate")
        self.button_spectate.clicked.connect(self.spectate_selected)

        self.button_refresh = QPushButton("Refresh")
        self.button_refresh.clicked.connect(self.refresh)

        self.button_toggle = QPushButton("")
        self.button_toggle.setCheckable(True)
        self.button_toggle.toggled.connect(self.toggle_spectate)
        self.refresh()

        layout_button = QHBoxLayout()
        layout_button.addWidget(self.button_spectate)
        layout_button.addWidget(self.button_refresh)
        layout_button.addStretch(1)
        layout_button.addWidget(self.button_toggle)

        # Layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.label_spectating)
        layout_main.addWidget(self.listbox_spectate)
        layout_main.addLayout(layout_button)
        margin = UIScaler.pixel(6)
        layout_main.setContentsMargins(margin, margin, margin, margin)
        self.setLayout(layout_main)

    def set_button_state(self, enabled: bool):
        """Set button state"""
        self.button_toggle.setChecked(enabled)
        self.button_toggle.setText("Enabled" if enabled else "Disabled")
        self.listbox_spectate.setDisabled(not enabled)
        self.button_spectate.setDisabled(not enabled)
        self.button_refresh.setDisabled(not enabled)
        self.label_spectating.setDisabled(not enabled)
        self.notify_toggle(enabled)
        if enabled:
            logger.info("ENABLED: spectate mode")
        else:
            logger.info("DISABLED: spectate mode")

    def toggle_spectate(self, checked: bool):
        """Toggle spectate mode"""
        cfg.api["enable_player_index_override"] = checked
        cfg.save()
        api.setup()
        self.refresh()

    def refresh(self):
        """Refresh spectate list"""
        enabled = cfg.api["enable_player_index_override"]

        if enabled:
            self.update_drivers("Anonymous", cfg.api["player_index"], False)
        else:
            self.listbox_spectate.clear()
            self.label_spectating.setText("Spectating: <b>Disabled</b>")

        # Update button state only if changed
        if self.last_enabled != enabled:
            self.last_enabled = enabled
            self.set_button_state(enabled)

    def spectate_selected(self):
        """Spectate selected player"""
        self.update_drivers(self.selected_name(), -1, True)

    def update_drivers(self, selected_driver_name: str, selected_index: int, match_name: bool):
        """Update drivers list"""
        listbox = self.listbox_spectate
        driver_list = []

        for driver_index in range(api.read.vehicle.total_vehicles()):
            driver_name = api.read.vehicle.driver_name(driver_index)
            driver_list.append(driver_name)
            if match_name:
                if driver_name == selected_driver_name:
                    selected_index = driver_index
            else:  # match index
                if driver_index == selected_index:
                    selected_driver_name = driver_name

        driver_list.sort(key=str.lower)
        listbox.clear()
        listbox.addItem("Anonymous")
        listbox.addItems(driver_list)

        self.focus_on_selected(selected_driver_name)
        self.save_selected_index(selected_index)

    def focus_on_selected(self, driver_name: str):
        """Focus on selected driver row"""
        listbox = self.listbox_spectate
        for row_index in range(listbox.count()):
            if driver_name == listbox.item(row_index).text():
                break
        else:  # fallback to 0 if name not found
            row_index = 0
        listbox.setCurrentRow(row_index)
        # Make sure selected name valid
        self.label_spectating.setText(f"Spectating: <b>{self.selected_name()}</b>")

    def selected_name(self) -> str:
        """Selected driver name"""
        selected_item = self.listbox_spectate.currentItem()
        return "Anonymous" if selected_item is None else selected_item.text()

    @staticmethod
    def save_selected_index(index: int):
        """Save selected driver index"""
        if cfg.api["player_index"] != index:
            cfg.api["player_index"] = index
            api.setup()
            cfg.save()

```

# File: tinypedal/ui/track_info_editor.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Track info editor
"""

import logging
import time

from PySide2.QtCore import QPoint, Qt
from PySide2.QtWidgets import (
    QHBoxLayout,
    QHeaderView,
    QMenu,
    QMessageBox,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from ..api_control import api
from ..const_file import ConfigType
from ..setting import cfg, copy_setting
from ..template.setting_tracks import TRACKINFO_DEFAULT
from ._common import (
    BaseEditor,
    CompactButton,
    FloatTableItem,
    UIScaler,
)

HEADER_TRACKS = (
    "Track name",
    "Pit entry (m)",
    "Pit exit (m)",
    "Pit speed (m/s)",
    "Speed trap (m)",
)

logger = logging.getLogger(__name__)


class TrackInfoEditor(BaseEditor):
    """Track info editor"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Track Info Editor")
        self.setMinimumSize(UIScaler.size(60), UIScaler.size(38))

        self.tracks_temp = copy_setting(cfg.user.tracks)

        # Set table
        self.table_tracks = QTableWidget(self)
        self.table_tracks.setColumnCount(len(HEADER_TRACKS))
        self.table_tracks.setHorizontalHeaderLabels(HEADER_TRACKS)
        self.table_tracks.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.table_tracks.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        for idx in range(1, len(HEADER_TRACKS)):
            self.table_tracks.horizontalHeader().setSectionResizeMode(idx, QHeaderView.Fixed)
            self.table_tracks.setColumnWidth(idx, UIScaler.size(8))
        self.table_tracks.cellChanged.connect(self.verify_input)

        self.table_tracks.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table_tracks.customContextMenuRequested.connect(self.open_context_menu)

        self.refresh_table()
        self.set_unmodified()

        # Set button
        layout_button = self.set_layout_button()

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.table_tracks)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def set_layout_button(self):
        """Set button layout"""
        button_add = CompactButton("Add")
        button_add.clicked.connect(self.add_track)

        button_sort = CompactButton("Sort")
        button_sort.clicked.connect(self.sort_track)

        button_delete = CompactButton("Delete")
        button_delete.clicked.connect(self.delete_track)

        button_reset = CompactButton("Reset")
        button_reset.clicked.connect(self.reset_setting)

        button_apply = CompactButton("Apply")
        button_apply.clicked.connect(self.applying)

        button_save = CompactButton("Save")
        button_save.clicked.connect(self.saving)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        # Set layout
        layout_button = QHBoxLayout()
        layout_button.addWidget(button_add)
        layout_button.addWidget(button_sort)
        layout_button.addWidget(button_delete)
        layout_button.addWidget(button_reset)
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_save)
        layout_button.addWidget(button_close)
        return layout_button

    def refresh_table(self):
        """Refresh tracks list"""
        self.table_tracks.setRowCount(0)
        row_index = 0
        for track_name, track_data in self.tracks_temp.items():
            self.add_track_entry(row_index, track_name, track_data)
            row_index += 1

    def add_track(self):
        """Add new track"""
        start_index = row_index = self.table_tracks.rowCount()
        # Add missing track name from active session
        track_name = api.read.session.track_name()
        if track_name and not self.is_value_in_table(track_name, self.table_tracks):
            self.add_track_entry(row_index, track_name, TRACKINFO_DEFAULT)
            row_index += 1
        # Add new name entry
        if start_index == row_index:
            new_track_name = self.new_name_increment("New Track Name", self.table_tracks)
            self.add_track_entry(row_index, new_track_name, TRACKINFO_DEFAULT)
            self.table_tracks.setCurrentCell(row_index, 0)

    def add_track_entry(self, row_index: int, track_name: str, track_data: dict):
        """Add new track entry to table"""
        self.table_tracks.insertRow(row_index)
        self.table_tracks.setItem(row_index, 0, QTableWidgetItem(track_name))
        column_index = 1
        for key, value in TRACKINFO_DEFAULT.items():
            self.table_tracks.setItem(
                row_index,
                column_index,
                FloatTableItem(track_data.get(key, value)),
            )
            column_index += 1

    def sort_track(self):
        """Sort tracks in ascending order"""
        if self.table_tracks.rowCount() > 1:
            self.table_tracks.sortItems(0)
            self.set_modified()

    def delete_track(self):
        """Delete track entry"""
        selected_rows = set(data.row() for data in self.table_tracks.selectedIndexes())
        if not selected_rows:
            QMessageBox.warning(self, "Error", "No data selected.")
            return

        if not self.confirm_operation(message="<b>Delete selected rows?</b>"):
            return

        for row_index in sorted(selected_rows, reverse=True):
            self.table_tracks.removeRow(row_index)
        self.set_modified()

    def reset_setting(self):
        """Reset setting"""
        msg_text = (
            "Reset <b>tracks preset</b> to default?<br><br>"
            "Changes are only saved after clicking Apply or Save Button."
        )
        if self.confirm_operation(message=msg_text):
            self.tracks_temp = copy_setting(cfg.default.tracks)
            self.set_modified()
            self.refresh_table()

    def applying(self):
        """Save & apply"""
        self.save_setting()

    def saving(self):
        """Save & close"""
        self.save_setting()
        self.accept()  # close

    def verify_input(self, row_index: int, column_index: int):
        """Verify input value"""
        self.set_modified()
        item = self.table_tracks.item(row_index, column_index)
        if column_index >= 1:
            item.validate()

    def open_context_menu(self, position: QPoint):
        """Open context menu"""
        if not self.table_tracks.itemAt(position):
            return

        menu = QMenu()
        if self.table_tracks.currentColumn() == 4:
            menu.addAction("Set from Telemetry")
        else:
            return

        position += QPoint(  # position correction from header
            self.table_tracks.verticalHeader().width(),
            self.table_tracks.horizontalHeader().height(),
        )
        selected_action = menu.exec_(self.table_tracks.mapToGlobal(position))
        if not selected_action:
            return

        action = selected_action.text()
        if action == "Set from Telemetry":
            self.set_position_from_tele()

    def set_position_from_tele(self):
        """Set position from telemetry to selected cell"""
        if len(self.table_tracks.selectedIndexes()) != 1:  # limit to one selected cell
            msg_text = (
                "Select <b>one value</b> from <b>Speed trap</b> column to set position."
            )
            QMessageBox.warning(self, "Error", msg_text)
            return

        if api.read.vehicle.in_pits():
            msg_text = "Cannot set speed trap position while in pit lane."
            QMessageBox.warning(self, "Error", msg_text)
            return

        row_index = self.table_tracks.currentRow()
        track_name = self.table_tracks.item(row_index, 0).text()
        current_name = api.read.session.track_name()
        if track_name != current_name:
            msg_text = (
                f"Unable to set speed trap position for selected track:<br><b>{track_name}</b><br><br>"
                f"Only support to set speed trap position for current track:<br><b>{current_name}</b>"
            )
            QMessageBox.warning(self, "Error", msg_text)
            return

        position = round(api.read.lap.distance(), 4)
        if not self.confirm_operation(
            message=f"Set speed trap at position <b>{position}</b><br>for <b>{track_name}</b>?"):
            return

        self.table_tracks.item(row_index, 4).setValue(position)
        self.table_tracks.setCurrentCell(-1, -1)  # deselect to avoid mis-clicking

    def update_tracks_temp(self):
        """Update temporary changes to tracks temp first"""
        self.tracks_temp.clear()
        for row_index in range(self.table_tracks.rowCount()):
            track_name = self.table_tracks.item(row_index, 0).text()
            self.tracks_temp[track_name] = {
                key: self.table_tracks.item(row_index, column_index).value()
                for column_index, key in enumerate(TRACKINFO_DEFAULT, start=1)
            }

    def save_setting(self):
        """Save setting"""
        self.update_tracks_temp()
        cfg.user.tracks = copy_setting(self.tracks_temp)
        cfg.save(0, cfg_type=ConfigType.TRACKS)
        while cfg.is_saving:  # wait saving finish
            time.sleep(0.01)
        self.reloading()
        self.set_unmodified()

```

# File: tinypedal/ui/track_map_viewer.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Track map viewer
"""

import os

from PySide2.QtCore import QPoint, QPointF, QRect, Qt, Signal
from PySide2.QtGui import QPainter, QPainterPath, QPen
from PySide2.QtWidgets import (
    QAbstractSpinBox,
    QDoubleSpinBox,
    QFileDialog,
    QFrame,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QMenu,
    QMessageBox,
    QSlider,
    QSpinBox,
    QVBoxLayout,
    QWidget,
)

from .. import calculation as calc
from ..const_file import ConfigType, FileExt, FileFilter
from ..setting import cfg
from ..userfile.track_map import load_track_map_file
from ._common import BaseDialog, CompactButton, UIScaler
from .config import UserConfig


class TrackMapViewer(BaseDialog):
    """Track map viewer"""

    def __init__(self, parent, filepath: str = "", filename: str = ""):
        super().__init__(parent)
        self.set_utility_title("Track Map Viewer")

        # Set panel
        self.trackmap_panel = self.set_layout_trackmap()

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        layout_main.addWidget(self.trackmap_panel)
        self.setLayout(layout_main)

        # Pre-load track map if exists
        if filepath and filename:
            self.trackmap.load_trackmap(filepath, filename)

    def set_layout_trackmap(self):
        """Set track map panel"""
        self.trackmap = MapView(self)

        layout_map_wrap = QVBoxLayout()
        layout_map_wrap.addWidget(self.trackmap)
        layout_map_wrap.setContentsMargins(0, 0, 0, 0)

        frame_trackmap = QFrame(self)
        frame_trackmap.setLayout(layout_map_wrap)
        frame_trackmap.setFrameShape(QFrame.StyledPanel)

        layout_trackmap = QVBoxLayout()
        layout_trackmap.addLayout(self.trackmap.set_button_layout())
        layout_trackmap.addWidget(frame_trackmap)
        layout_trackmap.addLayout(self.trackmap.set_control_layout())
        layout_trackmap.setContentsMargins(0, 0, 0, 0)

        trackmap_panel = QFrame(self)
        trackmap_panel.setMinimumSize(UIScaler.size(38), UIScaler.size(38))
        trackmap_panel.setLayout(layout_trackmap)
        return trackmap_panel


class MapView(QWidget):
    """Map view"""

    reloaded = Signal(bool)

    def __init__(self, parent):
        super().__init__(parent)
        # Style
        self.load_config(False)
        self.pen = QPen()
        self.pen.setJoinStyle(Qt.RoundJoin)
        self.rect_info = QRect(0, 0, 1, 1)

        # Map data
        self.raw_coords = None
        self.raw_dists = None

        self.map_path = None
        self.sfinish_path = None
        self.sector1_path = None
        self.sector2_path = None

        self.map_filename = ""
        self.map_length = 0
        self.map_scale = 1
        self.map_seek_dist = 0
        self.map_seek_index = 0
        self.map_nodes = 0
        self.curve_nodes = 10
        self.center_x = 0
        self.center_y = 0
        self.marked_dists = set()
        self.marked_coords = []
        self.highlighted_coords = None

        # Toggle
        self.osd = {
            "map_info": True,
            "position_info": True,
            "curve_info": True,
            "slope_info": True,
            "separator1":"",
            "center_mark": True,
            "distance_circle": True,
            "osculating_circle": True,
            "curve_section": True,
            "marked_coordinates": True,
            "highlighted_coordinates": True,
            "separator2":"",
            "dark_background": cfg.application["window_color_theme"] == "Dark",
        }

        # Set layout
        self.set_controls()
        layout_inner_control = QHBoxLayout()
        layout_inner_control.setAlignment(Qt.AlignBottom)
        layout_inner_control.addWidget(self.slider_pos_dist)
        self.setLayout(layout_inner_control)

    def load_config(self, is_reload: bool = True):
        """Load config"""
        self.ecfg = cfg.user.config["track_map_viewer"]
        self.distance_circle_radius = [
            self.ecfg[f"distance_circle_{idx}_radius"] for idx in range(10)
        ]
        self.curve_grades = [
            (self.ecfg["curve_grade_hairpin"], "Hairpin"),
            *[(self.ecfg[f"curve_grade_{idx}"], str(idx))
            for idx in range(1, 9) if self.ecfg[f"curve_grade_{idx}"] >= 0],
            (self.ecfg["curve_grade_straight"], "Straight"),
        ]
        self.curve_grades.sort()
        self.length_grades = [
            (self.ecfg["length_grade_short"], "Short"),
            (self.ecfg["length_grade_normal"], "Normal"),
            (self.ecfg["length_grade_long"], "Long"),
            (self.ecfg["length_grade_very_long"], "Very Long"),
            (self.ecfg["length_grade_extra_long"], "Extra Long"),
            (self.ecfg["length_grade_extremely_long"], "Extremely Long"),
        ]
        self.length_grades.sort()
        self.slope_grades = [
            (self.ecfg["slope_grade_flat"], "Flat"),
            (self.ecfg["slope_grade_gentle"], "Gentle"),
            (self.ecfg["slope_grade_moderate"], "Moderate"),
            (self.ecfg["slope_grade_steep"], "Steep"),
            (self.ecfg["slope_grade_extreme"], "Extreme"),
            (self.ecfg["slope_grade_cliff"], "Cliff"),
        ]
        self.slope_grades.sort()
        if is_reload:
            self.spinbox_pos_dist.setSingleStep(self.ecfg["position_increment_step"])
            self.slider_pos_dist.setSingleStep(self.ecfg["position_increment_step"])
            self.update()

    def set_controls(self):
        """Set controls"""
        # Context menu
        self.map_context_menu = self.set_context_menu()
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.open_context_menu)

        # Outer controls
        self.edit_filename = QLineEdit()
        self.edit_filename.setReadOnly(True)
        self.edit_filename.setPlaceholderText("Track Map Name")

        self.spinbox_map_scale = QDoubleSpinBox()
        self.spinbox_map_scale.setRange(0.01, 10)
        self.spinbox_map_scale.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)
        self.spinbox_map_scale.setDecimals(2)
        self.spinbox_map_scale.setAlignment(Qt.AlignRight)
        self.spinbox_map_scale.setValue(1)
        self.spinbox_map_scale.valueChanged.connect(self.update_control)

        self.spinbox_nodes = QSpinBox()
        self.spinbox_nodes.setRange(3, 9999)
        self.spinbox_nodes.setSingleStep(1)
        self.spinbox_nodes.setAlignment(Qt.AlignRight)
        self.spinbox_nodes.setValue(self.curve_nodes)
        self.spinbox_nodes.valueChanged.connect(self.update_control)

        self.spinbox_pos_dist = QSpinBox()
        self.spinbox_pos_dist.setRange(0, 0)
        self.spinbox_pos_dist.setSingleStep(self.ecfg["position_increment_step"])
        self.spinbox_pos_dist.setWrapping(True)
        self.spinbox_pos_dist.setAccelerated(True)
        self.spinbox_pos_dist.setAlignment(Qt.AlignRight)
        self.spinbox_pos_dist.setValue(0)
        self.spinbox_pos_dist.valueChanged.connect(self.update_pos_spinbox)

        # Inner controls
        self.slider_pos_dist = QSlider(Qt.Horizontal)
        self.slider_pos_dist.setRange(0, 0)
        self.slider_pos_dist.setSingleStep(self.ecfg["position_increment_step"])
        self.slider_pos_dist.valueChanged.connect(self.update_pos_slider)

    def set_button_layout(self):
        """Set button layout"""
        button_load = CompactButton("Load Map")
        button_load.clicked.connect(self.open_trackmap)

        button_config = CompactButton("Config")
        button_config.clicked.connect(self.open_config_dialog)

        layout_button = QHBoxLayout()
        layout_button.addWidget(button_load)
        layout_button.addWidget(self.edit_filename)
        layout_button.addWidget(button_config)
        return layout_button

    def set_control_layout(self):
        """Set control layout"""
        layout_control = QHBoxLayout()
        layout_control.addWidget(QLabel("Zoom:"))
        layout_control.addWidget(self.spinbox_map_scale)
        layout_control.addStretch(1)
        layout_control.addWidget(QLabel("Position:"))
        layout_control.addWidget(self.spinbox_pos_dist)
        layout_control.addWidget(QLabel("Nodes:"))
        layout_control.addWidget(self.spinbox_nodes)
        return layout_control

    def update_pos_slider(self):
        """Update slider position"""
        self.map_seek_dist = self.slider_pos_dist.value()
        self.spinbox_pos_dist.setValue(self.map_seek_dist)
        self.update()

    def update_pos_spinbox(self):
        """Update spinbox position"""
        self.map_seek_dist = self.spinbox_pos_dist.value()
        self.slider_pos_dist.setValue(self.map_seek_dist)
        self.update()

    def update_control(self):
        """Update control"""
        self.map_scale = self.spinbox_map_scale.value()
        self.curve_nodes = self.spinbox_nodes.value()
        self.update()

    def reset_control(self):
        """Reset control"""
        self.spinbox_pos_dist.setValue(0)
        self.slider_pos_dist.setRange(0, self.map_length)
        self.spinbox_pos_dist.setRange(0, self.map_length)
        self.edit_filename.setText(self.map_filename)
        self.marked_dists.clear()
        self.marked_coords.clear()
        self.highlighted_coords = None

    def update_highlighted_coords(self):
        """Update highlighted coordinates"""
        if not self.raw_coords:
            return
        dist = self.spinbox_pos_dist.value()
        index = calc.binary_search_higher_column(
            self.raw_dists, dist, 0, self.map_nodes - 1)
        self.highlighted_coords = self.raw_coords[index]
        self.update()

    def update_marked_coords(self, temp_dists: set):
        """Update marked coordinates"""
        if not temp_dists or not self.raw_coords:
            return
        if temp_dists == self.marked_dists:
            return
        end_node = self.map_nodes - 1
        self.marked_coords.clear()
        for dist in temp_dists:
            if 0 <= dist <= self.map_length:
                index = calc.binary_search_higher_column(
                    self.raw_dists, dist, 0, end_node)
                self.marked_coords.append(QPointF(*self.raw_coords[index]))
        self.marked_dists = temp_dists
        self.update()

    def set_context_menu(self):
        """Set context menu"""
        menu = QMenu(self)
        for key, item in self.osd.items():
            if key.startswith("separator"):
                menu.addSeparator()
                continue
            option = menu.addAction(key.title().replace("_", " "))
            option.setCheckable(True)
            option.setChecked(item)
        return menu

    def open_context_menu(self, position: QPoint):
        """Open context menu"""
        action = self.map_context_menu.exec_(self.mapToGlobal(position))
        if not action:
            return
        name = action.text().replace(" ", "_").lower()
        self.osd[name] = not self.osd[name]
        self.update()

    def open_config_dialog(self):
        """Open config"""
        _dialog = UserConfig(
            parent=self,
            key_name="track_map_viewer",
            cfg_type=ConfigType.CONFIG,
            user_setting=cfg.user.config,
            default_setting=cfg.default.config,
            reload_func=self.load_config,
        )
        _dialog.open()

    def open_trackmap(self):
        """Open trackmap"""
        filename_full = QFileDialog.getOpenFileName(self, dir=cfg.path.track_map, filter=FileFilter.SVG)[0]
        if not filename_full:
            return

        filepath = os.path.dirname(filename_full) + "/"
        filename = os.path.splitext(os.path.basename(filename_full))[0]
        self.load_trackmap(filepath=filepath, filename=filename)

    def load_trackmap(self, filepath: str, filename: str):
        """Load trackmap"""
        if not os.path.exists(f"{filepath}{filename}{FileExt.SVG}"):
            msg_text = f"Cannot find track map for<br><b>{filename}</b><br>"
            QMessageBox.warning(self, "Error", msg_text)
            return

        self.raw_coords, self.raw_dists, sector_index = load_track_map_file(
            filepath=filepath,
            filename=filename,
        )

        if self.raw_coords and len(self.raw_coords) > 9:
            self.map_length = self.raw_dists[-1][0]
            self.map_nodes = len(self.raw_coords)
            self.map_filename = filename
            self.create_map_path(self.raw_coords, sector_index)
        else:
            self.map_length = 0
            self.map_nodes = 0
            self.map_filename = ""
            msg_text = (
                "Unable to load track map file from<br>"
                f"<b>{filepath}{filename}{FileExt.SVG}</b><br><br>"
                "Only support SVG file that generated with TinyPedal."
            )
            QMessageBox.warning(self, "Error", msg_text)

        self.reset_control()
        self.update()
        self.reloaded.emit(True)

    def create_map_path(self, raw_coords, sectors_index):
        """Create map path"""
        map_path = QPainterPath()
        sfinish_path = QPainterPath()
        sector1_path = QPainterPath()
        sector1_path = QPainterPath()

        for index, coords in enumerate(raw_coords):
            if index == 0:
                map_path.moveTo(*coords)
            else:
                map_path.lineTo(*coords)
        # Close map loop if start & end distance less than 500 meters
        if calc.distance(raw_coords[0], raw_coords[-1]) < 500:
            map_path.closeSubpath()
        # Create start/finish path
        sfinish_path = self.create_sector_path(
            sfinish_path, self.ecfg["start_line_length"], 0, 1)
        # Create sectors paths
        sector1_path = self.create_sector_path(
            sector1_path, self.ecfg["sector_line_length"],
            sectors_index[0], sectors_index[0] + 1)
        sector1_path = self.create_sector_path(
            sector1_path, self.ecfg["sector_line_length"],
            sectors_index[1], sectors_index[1] + 1)

        self.map_path = map_path
        self.sfinish_path = sfinish_path
        self.sector1_path = sector1_path
        self.sector2_path = sector1_path

    def create_sector_path(self, sector_path, length, node_idx1, node_idx2):
        """Create sector line"""
        pos_x1, pos_y1, pos_x2, pos_y2 = calc.line_intersect_coords(
            self.raw_coords[node_idx1],  # point a
            self.raw_coords[node_idx2],  # point b
            1.57079633,  # 90 degree rotation
            length
        )
        sector_path.moveTo(pos_x1, pos_y1)
        sector_path.lineTo(pos_x2, pos_y2)
        return sector_path

    def wheelEvent(self, event):
        """Mouse wheel control map scale"""
        scale = self.spinbox_map_scale.value()
        if event.angleDelta().y() > 0:
            if scale >= 0.1:
                zoom_step = 0.05
            else:
                zoom_step = 0.01
            scale += zoom_step
        else:
            if scale > 0.1:
                zoom_step = 0.05
            else:
                zoom_step = 0.01
            scale -= zoom_step
        self.spinbox_map_scale.setValue(scale)

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)

        if self.osd["dark_background"]:
            bkg_color = self.ecfg["bkg_color_dark"]
        else:
            bkg_color = self.ecfg["bkg_color_light"]
        painter.fillRect(0, 0, self.size().width(), self.size().height(), bkg_color)

        if not self.raw_coords:
            return

        # Locate position node index
        self.map_seek_index = calc.binary_search_higher_column(
            self.raw_dists, self.map_seek_dist, 0, self.map_nodes - 1)

        # Raw coordinates
        pos_x, pos_y = self.raw_coords[self.map_seek_index]
        pos_dist, pos_z = self.raw_dists[self.map_seek_index]

        # Transform coordinates
        self.center_x = self.size().width() / 2
        self.center_y = self.size().height() / 2
        center_offset_x = self.center_x - pos_x * self.map_scale
        center_offset_y = self.center_y - pos_y * self.map_scale

        # Calculation
        curve_section = list(gen_section_path(
            self.map_nodes, self.curve_nodes, self.map_seek_index, self.raw_coords))
        mid_index = int(len(curve_section)/2)
        point_one = curve_section[0].x(), curve_section[0].y()
        point_sec = curve_section[1].x(), curve_section[1].y()
        point_mid = curve_section[mid_index].x(), curve_section[mid_index].y()
        point_end = curve_section[-1].x(), curve_section[-1].y()
        arc_center_pos = calc.tri_coords_circle_center(*point_one, *point_mid, *point_end)
        arc_radius = calc.distance(point_one, arc_center_pos)
        arc_angle = calc.quad_coords_angle(
            arc_center_pos, point_one, point_mid, point_end)
        yaw_radians = calc.oriyaw2rad(
            point_sec[1] - point_one[1], point_sec[0] - point_one[0])
        turn_direct = calc.turning_direction(
            yaw_radians, *point_one, *point_end)

        curve_length = calc_section_length(
            self.map_length, self.map_nodes, self.curve_nodes,
            self.map_seek_index, self.raw_dists)
        length_desc = calc.select_grade(self.length_grades, curve_length)
        curve_desc = curve_description(arc_radius, turn_direct, self.curve_grades)

        slope_delta = calc_section_height_delta(
            self.map_nodes, self.curve_nodes, self.map_seek_index, self.raw_dists)
        slope_percent = calc.slope_percent(slope_delta, curve_length)
        slope_angle = calc.slope_angle(slope_delta, curve_length)
        slope_desc = calc.select_grade(self.slope_grades, abs(slope_percent))

        # Apply transform
        painter.translate(center_offset_x, center_offset_y)
        painter.scale(self.map_scale, self.map_scale)

        # Draw map
        self.draw_map_image(painter)
        self.draw_osculating_circle(
            painter, arc_center_pos, arc_radius, point_one, point_end)
        self.draw_curve(painter, curve_section)
        self.draw_marked_coords(painter)

        painter.resetTransform()

        self.draw_distance_circle(painter)
        self.draw_center_mark(painter, yaw_radians)

        # Draw info
        self.update_info_rect(painter)
        self.draw_map_info(painter)
        self.draw_curve_info(
            painter, curve_length, arc_radius, arc_angle, curve_desc, length_desc)
        self.draw_slope_info(
            painter, slope_percent, slope_angle, slope_delta, slope_desc)
        self.draw_position_info(painter, pos_x, pos_y, pos_z, pos_dist)

    def draw_map_image(self, painter):
        """Draw map image"""
        # Draw map outline
        if self.ecfg["map_outline_width"] > 0:
            self.pen.setWidth(self.ecfg["map_width"] + self.ecfg["map_outline_width"])
            self.pen.setColor(self.ecfg["map_outline_color"])
            painter.setPen(self.pen)
            painter.drawPath(self.map_path)

        # Draw map
        self.pen.setWidth(self.ecfg["map_width"])
        self.pen.setColor(self.ecfg["map_color"])
        painter.setPen(self.pen)
        painter.drawPath(self.map_path)

        # Draw start/finish line
        self.pen.setWidth(self.ecfg["start_line_width"])
        self.pen.setColor(self.ecfg["start_line_color"])
        painter.setPen(self.pen)
        painter.drawPath(self.sfinish_path)

        # Draw sectors line
        self.pen.setWidth(self.ecfg["sector_line_width"])
        self.pen.setColor(self.ecfg["sector_line_color"])
        painter.setPen(self.pen)
        painter.drawPath(self.sector1_path)
        painter.drawPath(self.sector2_path)

    def draw_osculating_circle(
        self, painter, arc_center_pos, arc_radius, point_one, point_end):
        """Draw osculating circle"""
        if self.osd["osculating_circle"]:
            self.pen.setWidth(self.ecfg["osculating_circle_width"])
            self.pen.setColor(self.ecfg["osculating_circle_color"])
            painter.setPen(self.pen)
            painter.drawLine(*arc_center_pos, *point_one)  # radius line
            painter.drawLine(*arc_center_pos, *point_end)  # radius line
            painter.drawEllipse(
                arc_center_pos[0] - arc_radius,
                arc_center_pos[1] - arc_radius,
                arc_radius * 2, arc_radius * 2)

    def draw_curve(self, painter, curve_section):
        """Draw curve"""
        if self.osd["curve_section"]:
            self.pen.setWidth(self.ecfg["curve_section_width"])
            self.pen.setColor(self.ecfg["curve_section_color"])
            painter.setPen(self.pen)
            painter.drawPolyline(curve_section)

    def draw_marked_coords(self, painter):
        """Draw marked coordinates"""
        if self.osd["marked_coordinates"] and self.marked_coords:
            self.pen.setWidth(self.ecfg["marked_coordinates_size"])
            self.pen.setColor(self.ecfg["marked_coordinates_color"])
            painter.setPen(self.pen)
            painter.drawPoints(self.marked_coords)

        if self.osd["highlighted_coordinates"] and self.highlighted_coords:
            self.pen.setWidth(self.ecfg["highlighted_coordinates_width"])
            self.pen.setColor(self.ecfg["highlighted_coordinates_color"])
            painter.setPen(self.pen)
            x, y = self.highlighted_coords
            highlighted_size = self.ecfg["highlighted_coordinates_size"]
            painter.drawRect(
                x - highlighted_size,
                y - highlighted_size,
                highlighted_size * 2,
                highlighted_size * 2
            )

    def draw_distance_circle(self, painter):
        """Draw distance circle"""
        if self.osd["distance_circle"]:
            self.pen.setWidth(self.ecfg["distance_circle_width"])
            self.pen.setColor(self.ecfg["distance_circle_color"])
            painter.setPen(self.pen)
            for circle_radius in self.distance_circle_radius:
                if circle_radius > 0:
                    circle_radius *= self.map_scale
                    painter.drawEllipse(
                        self.center_x - circle_radius,
                        self.center_y - circle_radius,
                        circle_radius * 2, circle_radius * 2)

    def draw_center_mark(self, painter, yaw_radians):
        """Draw center mark"""
        if self.osd["center_mark"]:
            self.pen.setWidth(self.ecfg["center_mark_width"])
            self.pen.setColor(self.ecfg["center_mark_color"])
            painter.setPen(self.pen)

            center_mark_radius = self.ecfg["center_mark_radius"]
            painter.translate(self.center_x, self.center_y)
            painter.rotate(calc.rad2deg(yaw_radians))
            painter.drawLine(-center_mark_radius, 0, center_mark_radius, 0)
            painter.drawLine(0, -center_mark_radius, 0, center_mark_radius)
            painter.resetTransform()

    def update_info_rect(self, painter):
        """Update info rect"""
        margin = self.ecfg["inner_margin"]
        self.rect_info.setRect(
            margin, margin, (self.center_x - margin) * 2,
            (self.center_y - margin - self.slider_pos_dist.height()) * 2
        )
        if self.osd["dark_background"]:
            font_color = self.ecfg["font_color_light"]
        else:
            font_color = self.ecfg["font_color_dark"]
        self.pen.setColor(font_color)
        painter.setPen(self.pen)

    def draw_map_info(self, painter):
        """Draw map info"""
        if self.osd["map_info"]:
            painter.drawText(
                self.rect_info, Qt.AlignRight,
                f"{self.map_length:.3f}m ({self.map_nodes} nodes)"
            )

    def draw_curve_info(
        self, painter, curve_length, arc_radius, arc_angle, curve_desc, length_desc):
        """Draw curve info"""
        if self.osd["curve_info"]:
            painter.drawText(
                self.rect_info, Qt.AlignLeft,
                (
                    f"Curve: {curve_length:.3f}m ({length_desc})\n"
                    f"Radius: {arc_radius:.3f}m ({curve_desc})\n"
                    f"Angle: {arc_angle:.3f}Â°"
                    #f"Curvature: {calc.curvature(arc_radius):.6f}"
                )
            )

    def draw_slope_info(self, painter, slope_percent, slope_angle, slope_delta, slope_desc):
        """Draw slope info"""
        if self.osd["slope_info"]:
            painter.drawText(
                self.rect_info, Qt.AlignLeft | Qt.AlignBottom,
                (
                    f"Slope: {slope_percent:.3%} ({slope_desc})\n"
                    f"Angle: {slope_angle:.3f}Â°\n"
                    f"Delta: {slope_delta:.3f}m"
                )
            )

    def draw_position_info(self, painter, pos_x, pos_y, pos_z, pos_dist):
        """Draw position info"""
        if self.osd["position_info"]:
            painter.drawText(
                self.rect_info, Qt.AlignRight | Qt.AlignBottom,
                (
                    f"{pos_dist:.3f}m (node {self.map_seek_index + 1})\n"
                    f"{pos_x:.3f}m, {pos_y:.3f}m, {pos_z:.3f}m"
                )
            )


def gen_section_path(
    total_nodes: int, section_nodes: int, seek_index: int, raw_coords: tuple):
    """Generate section path from selected nodes"""
    max_nodes = int(min(section_nodes, total_nodes - 2))
    for index in range(max_nodes):
        index += seek_index
        if index >= total_nodes:
            index -= total_nodes
        yield QPointF(*raw_coords[index])


def calc_section_length(
    map_length: float, total_nodes: int, section_nodes: int,
    seek_index: int, raw_dists: tuple) -> float:
    """Calculate section length from selected nodes"""
    max_nodes = int(min(section_nodes, total_nodes - 2))
    end_index = seek_index + max_nodes
    if end_index >= total_nodes:
        length = (
            map_length - raw_dists[seek_index][0]
            + raw_dists[end_index - total_nodes][0])
    else:
        length = raw_dists[end_index][0] - raw_dists[seek_index][0]
    return length


def calc_section_height_delta(
    total_nodes: int, section_nodes: int, seek_index: int, raw_dists: tuple) -> float:
    """Calculate section height delta from selected nodes"""
    max_nodes = int(min(section_nodes, total_nodes - 2))
    end_index = seek_index + max_nodes
    if end_index >= total_nodes:
        end_index -= total_nodes
    height_delta = raw_dists[end_index][1] - raw_dists[seek_index][1]
    return height_delta


def curve_description(arc_radius: float, turn_direct: int, curve_grade: tuple) -> str:
    """Curve description"""
    if arc_radius >= curve_grade[-1][0]:
        return curve_grade[-1][1]
    if turn_direct > 0:
        direct_desc = "Right"
    else:
        direct_desc = "Left"
    curve_desc = calc.select_grade(curve_grade, arc_radius)
    return f"{direct_desc} {curve_desc}"

```

# File: tinypedal/ui/track_notes_editor.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Track & pace notes editor
"""

import os

from PySide2.QtCore import QPoint, Qt
from PySide2.QtWidgets import (
    QFileDialog,
    QFrame,
    QGridLayout,
    QHBoxLayout,
    QHeaderView,
    QLabel,
    QLineEdit,
    QMenu,
    QMessageBox,
    QPushButton,
    QSplitter,
    QStatusBar,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from ..api_control import api
from ..formatter import strip_invalid_char
from ..setting import cfg
from ..userfile.track_notes import (
    NOTESTYPE_PACE,
    NOTESTYPE_TRACK,
    create_notes_metadata,
    load_notes_file,
    save_notes_file,
    set_notes_filter,
    set_notes_header,
    set_notes_parser,
    set_notes_writer,
)
from ._common import (
    QVAL_FILENAME,
    BaseDialog,
    BaseEditor,
    BatchOffset,
    CompactButton,
    FloatTableItem,
    TableBatchReplace,
    UIScaler,
)
from .track_map_viewer import MapView

DECIMALS = 2


def set_file_path(notes_type: str, filename: str = "") -> str:
    """Set file path"""
    if notes_type == NOTESTYPE_PACE:
        filepath = cfg.path.pace_notes
    else:
        filepath = cfg.path.track_notes
    return f"{filepath}{filename}"


class TrackNotesEditor(BaseEditor):
    """Track & pace notes editor"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Track Notes Editor")

        self.notes_type = None
        self.notes_header = None
        self.notes_metadata = create_notes_metadata()
        self.notes_temp = []
        self._verify_enabled = True

        # Set status bar
        self.status_bar = QStatusBar(self)

        # Set panels
        self.trackmap_panel = self.set_layout_trackmap()
        self.editor_panel = self.set_layout_editor()
        splitter = QSplitter(Qt.Horizontal, self)
        splitter.setHandleWidth(5)
        splitter.addWidget(self.trackmap_panel)
        splitter.addWidget(self.editor_panel)
        splitter.setCollapsible(0, False)
        splitter.setCollapsible(1, False)
        splitter.setStretchFactor(0,1)

        # Init setting & table
        self.create_pacenotes()

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, 0)
        layout_main.addWidget(splitter, stretch=1)
        layout_main.addWidget(self.status_bar)
        self.setLayout(layout_main)

    def toggle_trackmap_panel(self):
        """Toggle trackmap panel"""
        if self.trackmap_panel.isHidden():
            self.trackmap_panel.show()
            self.button_showmap.setText("Hide Map")
        else:
            self.trackmap_panel.hide()
            self.button_showmap.setText("Show Map")

    def set_layout_trackmap(self):
        """Set track map panel"""
        self.trackmap = MapView(self)
        self.trackmap.reloaded.connect(self.mark_positions_on_map)

        layout_map_wrap = QVBoxLayout()
        layout_map_wrap.addWidget(self.trackmap)
        layout_map_wrap.setContentsMargins(0, 0, 0, 0)

        frame_trackmap = QFrame(self)
        frame_trackmap.setLayout(layout_map_wrap)
        frame_trackmap.setFrameShape(QFrame.StyledPanel)

        layout_trackmap = QVBoxLayout()
        layout_trackmap.addLayout(self.trackmap.set_button_layout())
        layout_trackmap.addWidget(frame_trackmap)
        layout_trackmap.addLayout(self.trackmap.set_control_layout())
        layout_trackmap.setContentsMargins(0, 0, 0, 0)

        trackmap_panel = QFrame(self)
        trackmap_panel.setMinimumSize(UIScaler.size(38), UIScaler.size(38))
        trackmap_panel.setLayout(layout_trackmap)
        return trackmap_panel

    def set_layout_editor(self):
        """Set editor panel"""
        # Notes table
        self.table_notes = QTableWidget(self)
        self.table_notes.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table_notes.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.table_notes.cellChanged.connect(self.verify_input)

        self.table_context_menu = self.set_context_menu()
        self.table_notes.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table_notes.customContextMenuRequested.connect(self.open_context_menu)

        # Notes filename edit
        self.filename_entry = QLineEdit()
        self.filename_entry.setValidator(QVAL_FILENAME)

        # File menu
        file_menu = QMenu(self)

        open_pacenotes = file_menu.addAction("Open Pace Notes")
        open_pacenotes.triggered.connect(self.load_pacenotes_file)

        open_tracknotes = file_menu.addAction("Open Track Notes")
        open_tracknotes.triggered.connect(self.load_tracknotes_file)
        file_menu.addSeparator()

        create_pacenotes = file_menu.addAction("New Pace Notes")
        create_pacenotes.triggered.connect(self.create_pacenotes)

        create_tracknotes = file_menu.addAction("New Track Notes")
        create_tracknotes.triggered.connect(self.create_tracknotes)

        button_file = CompactButton("File", has_menu=True)
        button_file.setMenu(file_menu)

        # Set position menu
        setpos_menu = QMenu(self)

        setpos_frommap = setpos_menu.addAction("From Map")
        setpos_frommap.triggered.connect(self.set_position_from_map)

        setpos_fromtele = setpos_menu.addAction("From Telemetry")
        setpos_fromtele.triggered.connect(self.set_position_from_tele)

        button_setpos = CompactButton("Set Pos", has_menu=True)
        button_setpos.setMenu(setpos_menu)

        # Button
        self.button_showmap = CompactButton("Hide Map")
        self.button_showmap.clicked.connect(self.toggle_trackmap_panel)

        button_add = CompactButton("Add")
        button_add.clicked.connect(self.add_notes)

        button_insert = CompactButton("Insert")
        button_insert.clicked.connect(self.insert_notes)

        button_sort = CompactButton("Sort")
        button_sort.clicked.connect(self.sort_notes)

        button_delete = CompactButton("Delete")
        button_delete.clicked.connect(self.delete_notes)

        button_replace = CompactButton("Replace")
        button_replace.clicked.connect(self.open_replace_dialog)

        button_offset = CompactButton("Offset")
        button_offset.clicked.connect(self.open_offset_dialog)

        button_metadata = CompactButton("Info")
        button_metadata.clicked.connect(self.open_metadata_dialog)

        button_save = CompactButton("Save")
        button_save.clicked.connect(self.saving)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        layout_top = QHBoxLayout()
        layout_top.addWidget(self.button_showmap)
        layout_top.addWidget(button_file)
        layout_top.addWidget(self.filename_entry, stretch=1)
        layout_top.addWidget(button_metadata)
        layout_top.addWidget(button_save)

        layout_button = QHBoxLayout()
        layout_button.addWidget(button_setpos)
        layout_button.addWidget(button_add)
        layout_button.addWidget(button_insert)
        layout_button.addWidget(button_sort)
        layout_button.addWidget(button_delete)
        layout_button.addWidget(button_replace)
        layout_button.addWidget(button_offset)
        layout_button.addStretch(1)
        layout_button.addWidget(button_close)

        layout_editor = QVBoxLayout()
        layout_editor.addLayout(layout_top)
        layout_editor.addWidget(self.table_notes)
        layout_editor.addLayout(layout_button)
        layout_editor.setContentsMargins(0, 0, 0, 0)

        editor_panel = QFrame(self)
        editor_panel.setMinimumSize(UIScaler.size(38), UIScaler.size(38))
        editor_panel.setLayout(layout_editor)
        return editor_panel

    def set_notes_type(self, notes_type: str):
        """Set notes type"""
        self.notes_type = notes_type
        self.notes_header = set_notes_header(notes_type)
        self.status_bar.showMessage(f"Edit Mode: {notes_type}", 0)
        self.filename_entry.setPlaceholderText(f"{notes_type} Name")

    def create_pacenotes(self):
        """Create pace notes file"""
        self.create_new_file(NOTESTYPE_PACE)

    def create_tracknotes(self):
        """Load track notes file"""
        self.create_new_file(NOTESTYPE_TRACK)

    def create_new_file(self, notes_type: str):
        """Create new file"""
        if not self.confirm_discard():
            return

        self.set_notes_type(notes_type)
        self.filename_entry.setText(self.get_track_name())
        self.notes_temp.clear()
        self.notes_metadata.update(create_notes_metadata())
        self.refresh_table()
        self.add_notes()
        self.set_unmodified()

    def load_pacenotes_file(self):
        """Load pace notes file"""
        self.load_from_file(NOTESTYPE_PACE)

    def load_tracknotes_file(self):
        """Load track notes file"""
        self.load_from_file(NOTESTYPE_TRACK)

    def load_from_file(self, notes_type: str):
        """Load notes from file"""
        if not self.confirm_discard():
            return

        filename_full, file_filter = QFileDialog.getOpenFileName(
            self,
            dir=set_file_path(notes_type),
            filter=set_notes_filter(notes_type),
        )
        if not filename_full:
            return

        filepath = os.path.dirname(filename_full) + "/"
        filename = os.path.basename(filename_full)
        notes_header = set_notes_header(notes_type)
        notes_parsed = load_notes_file(
            filepath=filepath,
            filename=filename,
            table_header=notes_header,
            parser=set_notes_parser(file_filter),
        )

        if notes_parsed is None:
            msg_text = "Cannot open selected file.<br><br>Invalid notes file."
            QMessageBox.warning(self, "Error", msg_text)
            return

        notes_sorted, meta_info = notes_parsed
        self.set_notes_type(notes_type)
        self.notes_temp = notes_sorted
        self.notes_metadata.update(meta_info)
        self.filename_entry.setText(filename)
        self.refresh_table()
        self.set_unmodified()
        self.mark_positions_on_map()

    def refresh_table(self):
        """Refresh notes table"""
        self.table_notes.setRowCount(0)
        self.table_notes.setColumnCount(len(self.notes_header))
        self.table_notes.setHorizontalHeaderLabels(self.notes_header)
        self.table_notes.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.table_notes.setColumnWidth(0, UIScaler.size(6))

        self._verify_enabled = False
        for row_index, note_line in enumerate(self.notes_temp):
            self.table_notes.insertRow(row_index)
            for column_index, fieldname in enumerate(self.notes_header):
                value = note_line[fieldname]
                if column_index == 0:
                    item = FloatTableItem(round(value, DECIMALS))
                else:
                    item = QTableWidgetItem(value)
                self.table_notes.setItem(row_index, column_index, item)
        self._verify_enabled = True

    def open_replace_dialog(self):
        """Open replace dialog"""
        selector = {name:idx for idx, name in enumerate(self.notes_header) if idx > 0}
        _dialog = TableBatchReplace(self, selector, self.table_notes)
        _dialog.open()

    def open_metadata_dialog(self):
        """Open metadata dialog"""
        _dialog = MetaDataEditor(self, self.notes_metadata)
        _dialog.open()

    def open_offset_dialog(self):
        """Open offset dialog"""
        if self.column_selection_count(0) == 0:
            msg_text = (
                "Select <b>one or more values</b> from <b>distance</b> "
                "column to apply offset."
            )
            QMessageBox.warning(self, "Error", msg_text)
            return

        _dialog = BatchOffset(self, self.apply_batch_offset)
        _dialog.config(2, 0.1, -99999, 99999)
        _dialog.open()

    def apply_batch_offset(self, offset: float, is_scale_mode: bool):
        """Apply batch offset"""
        self._verify_enabled = False
        for item in self.table_notes.selectedItems():
            value = item.value()
            if is_scale_mode:
                value *= offset
            else:
                value += offset
            item.setValue(round(value, DECIMALS))
        self._verify_enabled = True
        self.set_modified()
        self.mark_positions_on_map()

    def set_position_from_map(self):
        """Set position from map"""
        self.set_position(float(self.trackmap.map_seek_dist), "from map")

    def set_position_from_tele(self):
        """Set position from telemetry"""
        self.set_position(api.read.lap.distance(), "from telemetry")

    def set_position(self, position: float, source: str):
        """Set position to selected cell"""
        if self.column_selection_count(0) != 1:  # limit to one selected cell
            msg_text = (
                "Select <b>one value</b> from <b>distance</b> column to set position."
            )
            QMessageBox.warning(self, "Error", msg_text)
            return

        if not self.confirm_operation(message=f"Set position at <b>{position}</b> {source}?"):
            return

        pos_curr = round(position, DECIMALS)
        row_index = self.table_notes.currentRow()
        self.table_notes.item(row_index, 0).setValue(pos_curr)
        self.mark_positions_on_map()
        self.highlight_position_on_map()
        self.table_notes.setCurrentCell(-1, -1)  # deselect to avoid mis-clicking

    def add_notes(self):
        """Add new notes entry"""
        self.add_table_row(
            self.table_notes.rowCount(),
            self.table_notes.columnCount()
        )

    def insert_notes(self, row_offset: int = 0):
        """Insert new notes entry"""
        self.add_table_row(
            self.table_notes.currentRow() + row_offset,
            self.table_notes.columnCount()
        )

    def sort_notes(self) -> bool:
        """Sort notes by distance in ascending order"""
        if self.table_notes.rowCount() > 1:
            self.table_notes.sortItems(0)
            self.set_modified()
        return True

    def delete_notes(self):
        """Delete notes entry"""
        selected_rows = set(data.row() for data in self.table_notes.selectedIndexes())
        if not selected_rows:
            QMessageBox.warning(self, "Error", "No data selected.")
            return

        if not self.confirm_operation(message="<b>Delete selected rows?</b>"):
            return

        for row_index in sorted(selected_rows, reverse=True):
            self.table_notes.removeRow(row_index)
        self.set_modified()
        self.mark_positions_on_map()

    def update_notes_temp(self, table_header):
        """Update temporary changes to notes temp"""
        temp = (
            {
                fieldname: self.parse_notes(
                    self.table_notes.item(row_index, column_index), column_index
                )
                for column_index, fieldname in enumerate(table_header)
            }
            for row_index in range(self.table_notes.rowCount())
        )
        self.notes_temp = list(temp)

    @staticmethod
    def parse_notes(item, index: int):
        """Parse notes"""
        if index == 0:
            return round(item.value(), DECIMALS)
        return item.text()

    def saving(self):
        """Save notes"""
        self.save_notes(self.notes_type)

    def save_notes(self, notes_type: str):
        """Save notes"""
        if not self.sort_notes():
            return

        self.update_notes_temp(self.notes_header)

        if not self.notes_temp:
            QMessageBox.warning(self, "Error", "Nothing to save.")
            return

        filename = self.filename_entry.text()
        if not filename:  # try find track name if file name was not set
            filename = self.get_track_name()

        filename_full, file_filter = QFileDialog.getSaveFileName(
            self,
            dir=set_file_path(notes_type, filename),
            filter=set_notes_filter(notes_type),
        )
        if not filename_full:  # save canceled
            return

        filepath = os.path.dirname(filename_full) + "/"
        filename = os.path.basename(filename_full)
        save_notes_file(
            filepath=filepath,
            filename=filename,
            table_header=self.notes_header,
            dataset=self.notes_temp,
            metadata=self.notes_metadata,
            writer=set_notes_writer(file_filter),
        )
        self.filename_entry.setText(filename)
        self.set_unmodified()
        msg_text = f"Notes saved at:<br><b>{filename_full}</b>"
        QMessageBox.information(self, "Saved", msg_text)

    def column_selection_count(self, column_index: int = 0) -> int:
        """Column selection count"""
        row_count = 0
        for data in self.table_notes.selectedIndexes():
            if data.column() == column_index:
                row_count += 1
            else:
                return 0
        return row_count

    def verify_input(self, row_index: int, column_index: int):
        """Verify input value"""
        if self._verify_enabled:
            self.set_modified()
            item = self.table_notes.item(row_index, column_index)
            if column_index == 0:
                item.validate()
                self.mark_positions_on_map()
            elif column_index == 1 and self.notes_type == NOTESTYPE_PACE:
                # Remove invalid char (filename) from pace note column
                item.setText(strip_invalid_char(item.text()))

    def set_context_menu(self):
        """Set context menu"""
        menu = QMenu(self)
        menu.addAction("Highlight on Map")
        menu.addSeparator()
        menu.addAction("Set from Map")
        menu.addAction("Set from Telemetry")
        menu.addSeparator()
        menu.addAction("Insert Row Above")
        menu.addAction("Insert Row Below")
        menu.addAction("Delete Rows")
        return menu

    def open_context_menu(self, position: QPoint):
        """Open context menu"""
        if not self.table_notes.itemAt(position):
            return

        position += QPoint(  # position correction from header
            self.table_notes.verticalHeader().width(),
            self.table_notes.horizontalHeader().height(),
        )
        selected_action = self.table_context_menu.exec_(
            self.table_notes.mapToGlobal(position))
        if not selected_action:
            return

        action = selected_action.text()
        if action == "Highlight on Map":
            self.mark_positions_on_map()
            self.highlight_position_on_map()
        elif action == "Set from Map":
            self.set_position_from_map()
        elif action == "Set from Telemetry":
            self.set_position_from_tele()
        elif action == "Insert Row Above":
            self.insert_notes(0)
        elif action == "Insert Row Below":
            self.insert_notes(1)
        elif action == "Delete Rows":
            self.delete_notes()

    def highlight_position_on_map(self):
        """Highlight selected position on map"""
        value = self.table_notes.item(self.table_notes.currentRow(), 0).value()
        self.trackmap.spinbox_pos_dist.setValue(value)
        self.trackmap.update_highlighted_coords()

    def mark_positions_on_map(self):
        """Mark all positions on map"""
        temp_coords = set(
            self.table_notes.item(row_index, 0).value()
            for row_index in range(self.table_notes.rowCount())
        )
        self.trackmap.update_marked_coords(temp_coords)

    def get_track_name(self) -> str:
        """Get track name"""
        track_name = api.read.session.track_name()
        if not track_name:
            return self.trackmap.map_filename
        return track_name

    def add_table_row(self, row_index: int, column_count: int):
        """Add new table row"""
        self.table_notes.insertRow(row_index)
        self.table_notes.setCurrentCell(row_index, 0)
        for column_index in range(column_count):
            if column_index == 0:
                item = FloatTableItem(0)
            else:
                item = QTableWidgetItem("")
            self.table_notes.setItem(row_index, column_index, item)


class MetaDataEditor(BaseDialog):
    """Metadata editor"""

    def __init__(self, parent, metadata: dict):
        super().__init__(parent)
        self.setWindowTitle("Metadata Info")

        self.metadata = metadata
        self.option_metadata = {}

        # Label & Edit
        layout_option = QGridLayout()
        layout_option.setAlignment(Qt.AlignTop)

        for idx, fieldname in enumerate(metadata):
            desc_label = QLabel(f"{fieldname.capitalize()}:")
            edit_entry = QLineEdit()
            edit_entry.setText(metadata[fieldname])
            layout_option.addWidget(desc_label, idx, 0)
            layout_option.addWidget(edit_entry, idx, 1)
            self.option_metadata[fieldname] = edit_entry

        # Button
        button_save = QPushButton("Ok")
        button_save.clicked.connect(self.saving)

        button_close = QPushButton("Close")
        button_close.clicked.connect(self.reject)

        layout_button = QHBoxLayout()
        layout_button.addStretch(1)
        layout_button.addWidget(button_save)
        layout_button.addWidget(button_close)

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addLayout(layout_option)
        layout_main.addLayout(layout_button)
        self.setLayout(layout_main)
        self.setMinimumWidth(UIScaler.size(38))
        self.setFixedHeight(self.sizeHint().height())

    def saving(self):
        """Save metadata"""
        self.metadata.update({key:edit.text() for key, edit in self.option_metadata.items()})
        self.accept()

```

# File: tinypedal/ui/tyre_compound_editor.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Tyre compound editor
"""

import logging
import time

from PySide2.QtWidgets import (
    QComboBox,
    QHBoxLayout,
    QHeaderView,
    QMessageBox,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from ..api_control import api
from ..const_file import ConfigType
from ..setting import cfg, copy_setting
from ..userfile.heatmap import HEATMAP_DEFAULT_TYRE, set_predefined_compound_symbol
from ._common import (
    BaseEditor,
    CompactButton,
    TableBatchReplace,
    UIScaler,
)

HEADER_COMPOUNDS = "Compound name","Symbol","Heatmap name"

logger = logging.getLogger(__name__)


class TyreCompoundEditor(BaseEditor):
    """Tyre compound editor"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Tyre Compound Editor")
        self.setMinimumSize(UIScaler.size(45), UIScaler.size(38))

        self.compounds_temp = copy_setting(cfg.user.compounds)

        # Set table
        self.table_compounds = QTableWidget(self)
        self.table_compounds.setColumnCount(len(HEADER_COMPOUNDS))
        self.table_compounds.setHorizontalHeaderLabels(HEADER_COMPOUNDS)
        self.table_compounds.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.table_compounds.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table_compounds.horizontalHeader().setSectionResizeMode(1, QHeaderView.Fixed)
        self.table_compounds.setColumnWidth(1, UIScaler.size(6))
        self.table_compounds.horizontalHeader().setSectionResizeMode(2, QHeaderView.Fixed)
        self.table_compounds.setColumnWidth(2, UIScaler.size(12))
        self.table_compounds.cellChanged.connect(self.verify_input)
        self.refresh_table()
        self.set_unmodified()

        # Set button
        layout_button = self.set_layout_button()

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.table_compounds)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def set_layout_button(self):
        """Set button layout"""
        button_add = CompactButton("Add")
        button_add.clicked.connect(self.add_compound)

        button_sort = CompactButton("Sort")
        button_sort.clicked.connect(self.sort_compound)

        button_delete = CompactButton("Delete")
        button_delete.clicked.connect(self.delete_compound)

        button_replace = CompactButton("Replace")
        button_replace.clicked.connect(self.open_replace_dialog)

        button_reset = CompactButton("Reset")
        button_reset.clicked.connect(self.reset_setting)

        button_apply = CompactButton("Apply")
        button_apply.clicked.connect(self.applying)

        button_save = CompactButton("Save")
        button_save.clicked.connect(self.saving)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        # Set layout
        layout_button = QHBoxLayout()
        layout_button.addWidget(button_add)
        layout_button.addWidget(button_sort)
        layout_button.addWidget(button_delete)
        layout_button.addWidget(button_replace)
        layout_button.addWidget(button_reset)
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_save)
        layout_button.addWidget(button_close)
        return layout_button

    def refresh_table(self):
        """Refresh compounds list"""
        self.table_compounds.setRowCount(0)
        row_index = 0
        for compound_name, compound_data in self.compounds_temp.items():
            self.add_compound_entry(
                row_index,
                compound_name,
                compound_data["symbol"],
                compound_data["heatmap"],
            )
            row_index += 1

    def __add_option_combolist(self, key):
        """Combo droplist string"""
        combo_edit = QComboBox()
        combo_edit.addItems(cfg.user.heatmap.keys())
        combo_edit.setCurrentText(key)
        combo_edit.currentTextChanged.connect(self.set_modified)
        return combo_edit

    def open_replace_dialog(self):
        """Open replace dialog"""
        selector = {HEADER_COMPOUNDS[1]: 1}
        _dialog = TableBatchReplace(self, selector, self.table_compounds)
        _dialog.open()

    def add_compound(self):
        """Add new compound"""
        start_index = row_index = self.table_compounds.rowCount()
        # Add all missing vehicle name from active session
        veh_total = api.read.vehicle.total_vehicles()
        for index in range(veh_total):
            class_name = api.read.vehicle.class_name(index)
            compound_names = set(
                (
                    f"{class_name} - {api.read.tyre.compound_name_front(index)}",
                    f"{class_name} - {api.read.tyre.compound_name_rear(index)}",
                )
            )
            for compound in compound_names:
                if not self.is_value_in_table(compound, self.table_compounds):
                    self.add_compound_entry(
                        row_index,
                        compound,
                        set_predefined_compound_symbol(compound),
                    )
                    self.table_compounds.setCurrentCell(row_index, 0)
                    row_index += 1
        # Add new name entry
        if start_index == row_index:
            new_compound_name = self.new_name_increment("New Compound Name", self.table_compounds)
            self.add_compound_entry(row_index, new_compound_name, "?")
            self.table_compounds.setCurrentCell(row_index, 0)

    def add_compound_entry(
        self, row_index: int, compound_name: str, symbol_name: str,
        heatmap_name: str = HEATMAP_DEFAULT_TYRE):
        """Add new compound entry to table"""
        self.table_compounds.insertRow(row_index)
        self.table_compounds.setItem(row_index, 0, QTableWidgetItem(compound_name))
        self.table_compounds.setItem(row_index, 1, QTableWidgetItem(symbol_name))
        self.table_compounds.setCellWidget(row_index, 2, self.__add_option_combolist(heatmap_name))

    def sort_compound(self):
        """Sort compounds in ascending order"""
        if self.table_compounds.rowCount() > 1:
            self.table_compounds.sortItems(0)
            self.set_modified()

    def delete_compound(self):
        """Delete compound entry"""
        selected_rows = set(data.row() for data in self.table_compounds.selectedIndexes())
        if not selected_rows:
            QMessageBox.warning(self, "Error", "No data selected.")
            return

        if not self.confirm_operation(message="<b>Delete selected rows?</b>"):
            return

        for row_index in sorted(selected_rows, reverse=True):
            self.table_compounds.removeRow(row_index)
        self.set_modified()

    def reset_setting(self):
        """Reset setting"""
        msg_text = (
            "Reset <b>compounds preset</b> to default?<br><br>"
            "Changes are only saved after clicking Apply or Save Button."
        )
        if self.confirm_operation(message=msg_text):
            self.compounds_temp = copy_setting(cfg.default.compounds)
            self.set_modified()
            self.refresh_table()

    def applying(self):
        """Save & apply"""
        self.save_setting()

    def saving(self):
        """Save & close"""
        self.save_setting()
        self.accept()  # close

    def verify_input(self, row_index: int, column_index: int):
        """Verify input value"""
        self.set_modified()
        item = self.table_compounds.item(row_index, column_index)
        if column_index == 1:  # symbol column
            text = item.text()
            if not text:
                item.setText("?")
            else:
                item.setText(text[:1])

    def update_compounds_temp(self):
        """Update temporary changes to compounds temp first"""
        self.compounds_temp.clear()
        for index in range(self.table_compounds.rowCount()):
            compound_name = self.table_compounds.item(index, 0).text()
            symbol_name = self.table_compounds.item(index, 1).text()
            heatmap_name = self.table_compounds.cellWidget(index, 2).currentText()
            self.compounds_temp[compound_name] = {
                "symbol": symbol_name,
                "heatmap": heatmap_name,
            }

    def save_setting(self):
        """Save setting"""
        self.update_compounds_temp()
        cfg.user.compounds = copy_setting(self.compounds_temp)
        cfg.save(0, cfg_type=ConfigType.COMPOUNDS)
        while cfg.is_saving:  # wait saving finish
            time.sleep(0.01)
        self.reloading()
        self.set_unmodified()

```

# File: tinypedal/ui/vehicle_brand_editor.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Vehicle brand editor
"""

from __future__ import annotations

import asyncio
import json
import logging
import os
import time

from PySide2.QtWidgets import (
    QFileDialog,
    QHBoxLayout,
    QHeaderView,
    QMenu,
    QMessageBox,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from ..api_control import api
from ..async_request import get_response, set_header_get
from ..const_api import API_LMU_ALIAS, API_LMU_CONFIG, API_RF2_ALIAS, API_RF2_CONFIG
from ..const_file import ConfigType, FileFilter
from ..setting import cfg, copy_setting
from ._common import (
    BaseEditor,
    CompactButton,
    TableBatchReplace,
    UIScaler,
)

HEADER_BRANDS = "Vehicle name","Brand name"

logger = logging.getLogger(__name__)


class VehicleBrandEditor(BaseEditor):
    """Vehicle brand editor"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Vehicle Brand Editor")
        self.setMinimumSize(UIScaler.size(45), UIScaler.size(38))

        self.brands_temp = copy_setting(cfg.user.brands)

        # Set table
        self.table_brands = QTableWidget(self)
        self.table_brands.setColumnCount(len(HEADER_BRANDS))
        self.table_brands.setHorizontalHeaderLabels(HEADER_BRANDS)
        self.table_brands.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table_brands.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.table_brands.cellChanged.connect(self.set_modified)
        self.refresh_table()
        self.set_unmodified()

        # Set button
        layout_button = self.set_layout_button()

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.table_brands)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def set_layout_button(self):
        """Set button layout"""
        # Menu
        import_menu = QMenu(self)

        import_rf2 = import_menu.addAction("RF2 Rest API")
        import_rf2.triggered.connect(self.import_from_rf2)

        import_lmu = import_menu.addAction("LMU Rest API (Primary)")
        import_lmu.triggered.connect(self.import_from_lmu)

        import_lmu_alt = import_menu.addAction("LMU Rest API (Alternative)")
        import_lmu_alt.triggered.connect(self.import_from_lmu_alt)

        import_json = import_menu.addAction("JSON file")
        import_json.triggered.connect(self.import_from_file)

        # Button
        button_import = CompactButton("Import from", has_menu=True)
        button_import.setMenu(import_menu)

        button_add = CompactButton("Add")
        button_add.clicked.connect(self.add_brand)

        button_sort = CompactButton("Sort")
        button_sort.clicked.connect(self.sort_brand)

        button_delete = CompactButton("Delete")
        button_delete.clicked.connect(self.delete_brand)

        button_replace = CompactButton("Replace")
        button_replace.clicked.connect(self.open_replace_dialog)

        button_reset = CompactButton("Reset")
        button_reset.clicked.connect(self.reset_setting)

        button_apply = CompactButton("Apply")
        button_apply.clicked.connect(self.applying)

        button_save = CompactButton("Save")
        button_save.clicked.connect(self.saving)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        # Set layout
        layout_button = QHBoxLayout()
        layout_button.addWidget(button_import)
        layout_button.addWidget(button_add)
        layout_button.addWidget(button_sort)
        layout_button.addWidget(button_delete)
        layout_button.addWidget(button_replace)
        layout_button.addWidget(button_reset)
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_save)
        layout_button.addWidget(button_close)
        return layout_button

    def refresh_table(self):
        """Refresh brands list"""
        self.table_brands.setRowCount(0)
        row_index = 0
        for veh_name, brand_name in self.brands_temp.items():
            self.add_vehicle_entry(row_index, veh_name, brand_name)
            row_index += 1

    def import_from_rf2(self):
        """Import brand from RF2"""
        setting_api = cfg.user.setting[API_RF2_CONFIG]
        self.import_from_restapi(
            API_RF2_ALIAS,
            setting_api["url_host"],
            setting_api["url_port"],
            "/rest/race/car",
        )

    def import_from_lmu(self):
        """Import brand from LMU (primary source)"""
        setting_api = cfg.user.setting[API_LMU_CONFIG]
        self.import_from_restapi(
            API_LMU_ALIAS,
            setting_api["url_host"],
            setting_api["url_port"],
            "/rest/race/car",
        )

    def import_from_lmu_alt(self):
        """Import brand from LMU (alternative source)"""
        setting_api = cfg.user.setting[API_LMU_CONFIG]
        self.import_from_restapi(
            API_LMU_ALIAS,
            setting_api["url_host"],
            setting_api["url_port"],
            "/rest/sessions/getAllVehicles",
        )

    def import_from_restapi(self, sim_name: str, url_host: str, url_port: int, resource_name: str):
        """Import brand from Rest API"""
        request_header = set_header_get(resource_name, url_host)
        time_out = 3

        try:
            raw_veh_data = asyncio.run(get_response(request_header, url_host, url_port, time_out))
            self.parse_brand_data(json.loads(raw_veh_data))
        except (AttributeError, TypeError, IndexError, KeyError, ValueError,
                OSError, TimeoutError, BaseException):
            logger.error("Failed importing vehicle data from %s Rest API", sim_name)
            msg_text = (
                f"Unable to import vehicle data from {sim_name} Rest API.<br><br>"
                "Make sure game is running and try again."
            )
            QMessageBox.warning(self, "Error", msg_text)

    def import_from_file(self):
        """Import brand from file"""
        filename_full = QFileDialog.getOpenFileName(self, filter=FileFilter.JSON)[0]
        if not filename_full:
            return

        try:
            # Limit import file size under 5120kb
            if os.path.getsize(filename_full) > 5120000:
                raise TypeError
            # Load JSON
            with open(filename_full, "r", encoding="utf-8") as jsonfile:
                dict_vehicles = json.load(jsonfile)
                self.parse_brand_data(dict_vehicles)
        except (AttributeError, IndexError, KeyError, TypeError,
                FileNotFoundError, ValueError, OSError):
            logger.error("Failed importing %s", filename_full)
            msg_text = "Cannot import selected file.<br><br>Invalid vehicle data file."
            QMessageBox.warning(self, "Error", msg_text)

    def parse_brand_data(self, vehicles: dict):
        """Parse brand data"""
        if vehicles[0].get("desc"):
            # Match LMU data format
            brands_db = {
                veh["desc"]: veh["manufacturer"]
                for veh in vehicles
            }
        elif vehicles[0].get("name"):
            # Match RF2 data format
            brands_db = {
                parse_vehicle_name(veh): veh["manufacturer"]
                for veh in vehicles
            }
        else:
            raise KeyError

        self.update_brands_temp()
        brands_db.update(self.brands_temp)
        self.brands_temp = brands_db
        self.refresh_table()
        QMessageBox.information(self, "Data Imported", "Vehicle brand data imported.")

    def open_replace_dialog(self):
        """Open replace dialog"""
        selector = {HEADER_BRANDS[1]: 1}
        _dialog = TableBatchReplace(self, selector, self.table_brands)
        _dialog.open()

    def add_brand(self):
        """Add new brand"""
        start_index = row_index = self.table_brands.rowCount()
        # Add all missing vehicle name from active session
        veh_total = api.read.vehicle.total_vehicles()
        for index in range(veh_total):
            veh_name = api.read.vehicle.vehicle_name(index)
            if not self.is_value_in_table(veh_name, self.table_brands):
                self.add_vehicle_entry(row_index, veh_name, "Unknown")
                row_index += 1
        # Add new name entry
        if start_index == row_index:
            new_brand_name = self.new_name_increment("New Vehicle Name", self.table_brands)
            self.add_vehicle_entry(row_index, new_brand_name, "Unknown")
            self.table_brands.setCurrentCell(row_index, 0)

    def add_vehicle_entry(self, row_index: int, veh_name: str, brand_name: str):
        """Add new brand entry to table"""
        self.table_brands.insertRow(row_index)
        self.table_brands.setItem(row_index, 0, QTableWidgetItem(veh_name))
        self.table_brands.setItem(row_index, 1, QTableWidgetItem(brand_name))

    def sort_brand(self):
        """Sort brands in ascending order"""
        if self.table_brands.rowCount() > 1:
            self.table_brands.sortItems(1)
            self.set_modified()

    def delete_brand(self):
        """Delete brand entry"""
        selected_rows = set(data.row() for data in self.table_brands.selectedIndexes())
        if not selected_rows:
            QMessageBox.warning(self, "Error", "No data selected.")
            return

        if not self.confirm_operation(message="<b>Delete selected rows?</b>"):
            return

        for row_index in sorted(selected_rows, reverse=True):
            self.table_brands.removeRow(row_index)
        self.set_modified()

    def reset_setting(self):
        """Reset setting"""
        msg_text = (
            "Reset <b>brands preset</b> to default?<br><br>"
            "Changes are only saved after clicking Apply or Save Button."
        )
        if self.confirm_operation(message=msg_text):
            self.brands_temp = copy_setting(cfg.default.brands)
            self.set_modified()
            self.refresh_table()

    def applying(self):
        """Save & apply"""
        self.save_setting()

    def saving(self):
        """Save & close"""
        self.save_setting()
        self.accept()  # close

    def update_brands_temp(self):
        """Update temporary changes to brands temp first"""
        self.brands_temp.clear()
        for index in range(self.table_brands.rowCount()):
            key_name = self.table_brands.item(index, 0).text()
            item_name = self.table_brands.item(index, 1).text()
            self.brands_temp[key_name] = item_name

    def save_setting(self):
        """Save setting"""
        self.update_brands_temp()
        cfg.user.brands = copy_setting(self.brands_temp)
        cfg.save(0, cfg_type=ConfigType.BRANDS)
        while cfg.is_saving:  # wait saving finish
            time.sleep(0.01)
        self.reloading()
        self.set_unmodified()


def parse_vehicle_name(vehicle):
    """Parse vehicle name"""
    # Example path string: "D:\\RF2\\Installed\\Vehicles\\SOMECAR\\1.50\\CAR_24.VEH"
    path_split = vehicle["vehFile"].split("\\")
    if len(path_split) < 2:
        # If VEH path does not contain version number, split name by space directly
        # Example name: "#24 Some Car 1.50"
        version_length = len(vehicle["name"].split(" ")[-1]) + 1
    else:
        # Get version number from last second split of path_split
        version_length = len(path_split[-2]) + 1
    return vehicle["name"][:-version_length]

```

# File: tinypedal/ui/vehicle_class_editor.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Vehicle class editor
"""

import random
import time

from PySide2.QtWidgets import (
    QHBoxLayout,
    QHeaderView,
    QMessageBox,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from ..api_control import api
from ..const_common import EMPTY_DICT
from ..const_file import ConfigType
from ..formatter import random_color_class
from ..setting import cfg, copy_setting
from ._common import (
    QVAL_COLOR,
    BaseEditor,
    CompactButton,
    DoubleClickEdit,
    UIScaler,
)

HEADER_CLASSES = "Class name","Alias name","Color"


class VehicleClassEditor(BaseEditor):
    """Vehicle class editor"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Vehicle Class Editor")
        self.setMinimumSize(UIScaler.size(30), UIScaler.size(30))

        self.classes_temp = copy_setting(cfg.user.classes)

        # Set table
        self.table_classes = QTableWidget(self)
        self.table_classes.setColumnCount(len(HEADER_CLASSES))
        self.table_classes.setHorizontalHeaderLabels(HEADER_CLASSES)
        self.table_classes.verticalHeader().setVisible(False)
        self.table_classes.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.table_classes.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table_classes.horizontalHeader().setSectionResizeMode(2, QHeaderView.Fixed)
        self.table_classes.setColumnWidth(2, UIScaler.size(7))
        self.table_classes.cellChanged.connect(self.set_modified)
        self.refresh_table()
        self.set_unmodified()

        # Set button
        layout_button = self.set_layout_button()

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.table_classes)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def set_layout_button(self):
        """Set button layout"""
        button_add = CompactButton("Add")
        button_add.clicked.connect(self.add_class)

        button_sort = CompactButton("Sort")
        button_sort.clicked.connect(self.sort_class)

        button_delete = CompactButton("Delete")
        button_delete.clicked.connect(self.delete_class)

        button_reset = CompactButton("Reset")
        button_reset.clicked.connect(self.reset_setting)

        button_apply = CompactButton("Apply")
        button_apply.clicked.connect(self.applying)

        button_save = CompactButton("Save")
        button_save.clicked.connect(self.saving)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        layout_button = QHBoxLayout()
        layout_button.addWidget(button_add)
        layout_button.addWidget(button_sort)
        layout_button.addWidget(button_delete)
        layout_button.addWidget(button_reset)
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_save)
        layout_button.addWidget(button_close)
        return layout_button

    def refresh_table(self):
        """Refresh class list"""
        self.table_classes.setRowCount(0)
        row_index = 0
        for class_name, class_data in self.classes_temp.items():
            self.add_vehicle_entry(
                row_index, class_name, class_data["alias"], class_data["color"])
            row_index += 1

    def __add_option_color(self, key):
        """Color string"""
        color_edit = DoubleClickEdit(self, mode="color", init=key)
        color_edit.setMaxLength(9)
        color_edit.setValidator(QVAL_COLOR)
        color_edit.textChanged.connect(self.set_modified)
        color_edit.textChanged.connect(color_edit.preview_color)
        color_edit.setText(key)  # load selected option
        return color_edit

    def add_class(self):
        """Add new class entry"""
        start_index = row_index = self.table_classes.rowCount()
        # Add all missing vehicle class from active session
        veh_total = api.read.vehicle.total_vehicles()
        for index in range(veh_total):
            class_name = api.read.vehicle.class_name(index)
            if not self.is_value_in_table(class_name, self.table_classes):
                self.add_vehicle_entry(
                    row_index, class_name, class_name, random_color_class(class_name))
                row_index += 1
        # Add new class entry
        if start_index == row_index:
            new_class_name = self.new_name_increment("New Class Name", self.table_classes)
            self.add_vehicle_entry(
                row_index, new_class_name, "NAME", random_color_class(str(random.random())))
            self.table_classes.setCurrentCell(row_index, 0)

    def add_vehicle_entry(self, row_index: int, class_name: str, alias_name: str, color: str):
        """Add new class entry to table"""
        self.table_classes.insertRow(row_index)
        self.table_classes.setItem(row_index, 0, QTableWidgetItem(class_name))
        self.table_classes.setItem(row_index, 1, QTableWidgetItem(alias_name))
        self.table_classes.setCellWidget(row_index, 2, self.__add_option_color(color))

    def sort_class(self):
        """Sort class in ascending order"""
        if self.table_classes.rowCount() > 1:
            self.table_classes.sortItems(0)
            self.set_modified()

    def delete_class(self):
        """Delete class entry"""
        selected_rows = set(data.row() for data in self.table_classes.selectedIndexes())
        if not selected_rows:
            QMessageBox.warning(self, "Error", "No data selected.")
            return

        if not self.confirm_operation(message="<b>Delete selected rows?</b>"):
            return

        for row_index in sorted(selected_rows, reverse=True):
            self.table_classes.removeRow(row_index)
        self.set_modified()

    def reset_setting(self):
        """Reset setting"""
        msg_text = (
            "Reset <b>classes preset</b> to default?<br><br>"
            "Changes are only saved after clicking Apply or Save Button."
        )
        if self.confirm_operation(message=msg_text):
            self.classes_temp = copy_setting(cfg.default.classes)
            self.set_modified()
            self.refresh_table()

    def applying(self):
        """Save & apply"""
        self.save_setting()

    def saving(self):
        """Save & close"""
        self.save_setting()
        self.accept()  # close

    def update_classes_temp(self):
        """Update temporary changes to class temp first"""
        loaded = self.classes_temp.copy()
        self.classes_temp.clear()
        for index in range(self.table_classes.rowCount()):
            class_name = self.table_classes.item(index, 0).text()
            abbr_name = self.table_classes.item(index, 1).text()
            color_string = self.table_classes.cellWidget(index, 2).text()
            self.classes_temp[class_name] = {
                "alias": abbr_name,
                "color": color_string,
                "preset": loaded.get(class_name, EMPTY_DICT).get("preset", ""),
            }

    def save_setting(self):
        """Save setting"""
        self.update_classes_temp()
        cfg.user.classes = copy_setting(self.classes_temp)
        cfg.save(0, cfg_type=ConfigType.CLASSES)
        while cfg.is_saving:  # wait saving finish
            time.sleep(0.01)
        self.reloading()
        self.set_unmodified()

```

# File: tinypedal/ui/config.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Config dialog
"""

from __future__ import annotations

import os
import re
import time
from typing import Callable

from PySide2.QtCore import QPoint, Qt
from PySide2.QtGui import QFontDatabase
from PySide2.QtWidgets import (
    QCheckBox,
    QComboBox,
    QDialogButtonBox,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QMenu,
    QMessageBox,
    QScrollArea,
    QSpinBox,
    QVBoxLayout,
    QWidget,
)

from .. import regex_pattern as rxp
from ..const_file import ConfigType
from ..formatter import format_option_name
from ..setting import cfg
from ..userfile import set_relative_path, set_user_data_path
from ..validator import is_clock_format, is_hex_color, is_string_number
from ._common import (
    QVAL_COLOR,
    QVAL_FLOAT,
    QVAL_INTEGER,
    BaseDialog,
    DoubleClickEdit,
    UIScaler,
)

COLUMN_LABEL = 0  # grid layout column index
COLUMN_OPTION = 1


def get_font_list() -> list[str]:
    """Get all available font families list"""
    if os.getenv("PYSIDE_OVERRIDE") == "6":  # no instance in qt6
        return QFontDatabase.families()  # type: ignore[call-arg]
    return QFontDatabase().families()


class FontConfig(BaseDialog):
    """Config global font setting"""

    def __init__(self, parent, user_setting: dict, reload_func: Callable):
        super().__init__(parent)
        self.set_config_title("Global Font Override", cfg.filename.setting)

        self.reloading = reload_func
        self.user_setting = user_setting

        # Combobox
        self.edit_fontname = QComboBox(self)
        self.edit_fontname.addItem("no change")
        self.edit_fontname.addItems(get_font_list())
        self.edit_fontname.setFixedWidth(UIScaler.size(9))

        self.edit_fontsize = QSpinBox(self)
        self.edit_fontsize.setRange(-999,999)
        self.edit_fontsize.setFixedWidth(UIScaler.size(9))

        self.edit_fontweight = QComboBox(self)
        self.edit_fontweight.addItem("no change")
        self.edit_fontweight.addItems(rxp.CHOICE_COMMON[rxp.CFG_FONT_WEIGHT])
        self.edit_fontweight.setFixedWidth(UIScaler.size(9))

        layout_option = QGridLayout()
        layout_option.setAlignment(Qt.AlignTop)
        layout_option.addWidget(QLabel("Font Name"), 0, 0)
        layout_option.addWidget(self.edit_fontname, 0, 1)
        layout_option.addWidget(QLabel("Font Size Addend"), 1, 0)
        layout_option.addWidget(self.edit_fontsize, 1, 1)
        layout_option.addWidget(QLabel("Font Weight"), 2, 0)
        layout_option.addWidget(self.edit_fontweight, 2, 1)

        # Button
        button_apply = QDialogButtonBox(QDialogButtonBox.Apply)
        button_apply.clicked.connect(self.applying)

        button_save = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        button_save.accepted.connect(self.saving)
        button_save.rejected.connect(self.reject)

        layout_button = QHBoxLayout()
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_save)

        # Set layout
        layout_main = QVBoxLayout()
        layout_main.addLayout(layout_option)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def applying(self):
        """Save & apply"""
        self.save_setting(self.user_setting)

    def saving(self):
        """Save & close"""
        self.applying()
        self.accept()  # close

    def save_setting(self, dict_user: dict[str, dict]):
        """Save setting"""
        for setting in dict_user.values():
            for key in setting:
                if re.search(rxp.CFG_FONT_NAME, key):
                    font_name = self.edit_fontname.currentText()
                    if font_name != "no change":
                        setting[key] = font_name
                    continue
                if re.search(rxp.CFG_FONT_WEIGHT, key):
                    font_weight = self.edit_fontweight.currentText()
                    if font_weight != "no change":
                        setting[key] = font_weight
                    continue
                if re.search("font_size", key):
                    font_size = self.edit_fontsize.value()
                    if font_size != 0:
                        setting[key] = max(setting[key] + font_size, 1)
                    continue
        self.edit_fontsize.setValue(0)
        cfg.save(0)
        while cfg.is_saving:  # wait saving finish
            time.sleep(0.01)
        self.reloading()


class UserConfig(BaseDialog):
    """User configuration"""

    def __init__(
        self, parent, key_name: str, cfg_type: str, user_setting: dict,
        default_setting: dict, reload_func: Callable, option_width: int = 9):
        """
        Args:
            key_name: config key name.
            cfg_type: config type name from "ConfigType".
            user_setting: user setting dictionary, ex. cfg.user.setting.
            default_setting: default setting dictionary, ex. cfg.default.setting.
            reload_func: config reload (callback) function.
            option_width: option column width in pixels.
        """
        super().__init__(parent)
        self.set_config_title(format_option_name(key_name), set_preset_name(cfg_type))

        self.reloading = reload_func
        self.key_name = key_name
        self.cfg_type = cfg_type
        self.user_setting = user_setting
        self.default_setting = default_setting
        self.option_width = UIScaler.size(option_width)

        # Option dict (key: option editor)
        self.option_bool: dict = {}
        self.option_color: dict = {}
        self.option_path: dict = {}
        self.option_image: dict = {}
        #self.option_fontname: dict = {}
        self.option_droplist: dict = {}
        self.option_string: dict = {}
        self.option_integer: dict = {}
        self.option_float: dict = {}

        # Button
        button_reset = QDialogButtonBox(QDialogButtonBox.Reset)
        button_reset.clicked.connect(self.reset_setting)

        button_apply = QDialogButtonBox(QDialogButtonBox.Apply)
        button_apply.clicked.connect(self.applying)

        button_save = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        button_save.accepted.connect(self.saving)
        button_save.rejected.connect(self.reject)

        # Create options
        layout_option = QGridLayout()
        layout_option.setAlignment(Qt.AlignTop)
        self.create_options(layout_option)
        option_box = QWidget(self)
        option_box.setLayout(layout_option)

        # Create scroll box
        scroll_box = QScrollArea(self)
        scroll_box.setWidget(option_box)
        scroll_box.setWidgetResizable(True)

        # Set layout
        layout_main = QVBoxLayout()
        layout_button = QHBoxLayout()

        layout_main.addWidget(scroll_box)
        layout_button.addWidget(button_reset)
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_save)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)
        self.setMinimumWidth(self.sizeHint().width() + UIScaler.size(2))

    def applying(self):
        """Save & apply"""
        self.save_setting(is_apply=True)

    def saving(self):
        """Save & close"""
        self.save_setting(is_apply=False)

    def reset_setting(self):
        """Reset setting"""
        msg_text = (
            f"Reset all <b>{format_option_name(self.key_name)}</b> options to default?<br><br>"
            "Changes are only saved after clicking Apply or Save Button."
        )
        if self.confirm_operation(title="Reset Options", message=msg_text):
            for editor in self.option_bool.values():
                editor.setChecked(editor.defaults)

            for editor in self.option_color.values():
                editor.setText(editor.defaults)

            for editor in self.option_path.values():
                editor.setText(editor.defaults)

            for editor in self.option_image.values():
                editor.setText(editor.defaults)

            #for editor in self.option_fontname.values():
            #    editor.setCurrentFont(editor.defaults)

            for editor in self.option_droplist.values():
                editor.setCurrentText(str(editor.defaults))

            for editor in self.option_string.values():
                editor.setText(editor.defaults)

            for editor in self.option_integer.values():
                editor.setText(str(editor.defaults))

            for editor in self.option_float.values():
                editor.setText(str(editor.defaults))

    def save_setting(self, is_apply: bool):
        """Save setting"""
        user_setting = self.user_setting[self.key_name]
        error_found = False
        for key, editor in self.option_bool.items():
            user_setting[key] = editor.isChecked()

        for key, editor in self.option_color.items():
            value = editor.text()
            if is_hex_color(value):
                user_setting[key] = value
            else:
                self.value_error_message("color", key)
                error_found = True

        for key, editor in self.option_path.items():
            # Try convert to relative path again, in case user manually sets path
            value = set_relative_path(editor.text())
            if set_user_data_path(value):
                user_setting[key] = value
                editor.setText(value)  # update reformatted path
            else:
                self.value_error_message("path", key)
                error_found = True

        for key, editor in self.option_image.items():
            user_setting[key] = editor.text()

        #for key, editor in self.option_fontname.items():
        #    user_setting[key] = editor.currentFont().family()

        for key, editor in self.option_droplist.items():
            user_setting[key] = editor.currentText()

        for key, editor in self.option_string.items():
            value = editor.text()
            if re.search(rxp.CFG_CLOCK_FORMAT, key) and not is_clock_format(value):
                self.value_error_message("clock format", key)
                error_found = True
                continue
            user_setting[key] = value

        for key, editor in self.option_integer.items():
            value = editor.text()
            if is_string_number(value):
                user_setting[key] = int(value)
            else:
                self.value_error_message("number", key)
                error_found = True

        for key, editor in self.option_float.items():
            value = editor.text()
            if is_string_number(value):
                value = float(value)
                if value % 1 == 0:  # remove unnecessary decimal points
                    value = int(value)
                user_setting[key] = value
            else:
                self.value_error_message("number", key)
                error_found = True

        # Abort saving if error found
        if error_found:
            return
        # Save global settings
        if self.cfg_type == ConfigType.CONFIG:
            cfg.update_path()
            cfg.save(0, cfg_type=ConfigType.CONFIG)
        # Save user preset settings
        else:
            cfg.save(0)
        # Wait saving finish
        while cfg.is_saving:
            time.sleep(0.01)
        # Reload
        self.reloading()
        # Close
        if not is_apply:
            self.accept()

    def value_error_message(self, value_type: str, option_name: str):
        """Value error message"""
        msg_text = (
            f"Invalid {value_type} for <b>{format_option_name(option_name)}</b> option."
            "<br><br>Changes are not saved."
        )
        QMessageBox.warning(self, "Error", msg_text)

    def create_options(self, layout):
        """Create options"""
        for idx, key in enumerate(self.user_setting[self.key_name]):
            self.__add_option_label(idx, key, layout)
            # Bool
            if re.search(rxp.CFG_BOOL, key):
                self.__add_option_bool(idx, key, layout)
                continue
            # Units choice list string
            if self.__choice_match(rxp.CHOICE_UNITS, idx, key, layout):
                continue
            # Common choice list string
            if self.__choice_match(rxp.CHOICE_COMMON, idx, key, layout):
                continue
            # Color string
            if re.search(rxp.CFG_COLOR, key):
                self.__add_option_color(idx, key, layout)
                continue
            # User path string
            if re.search(rxp.CFG_USER_PATH, key):
                self.__add_option_path(idx, key, layout)
                continue
            # User image file path string
            if re.search(rxp.CFG_USER_IMAGE, key):
                self.__add_option_image(idx, key, layout)
                continue
            # Font name string
            if re.search(rxp.CFG_FONT_NAME, key):
                self.__add_option_combolist(idx, key, layout, get_font_list())
                continue
            # Heatmap string
            if re.search(rxp.CFG_HEATMAP, key):
                self.__add_option_combolist(idx, key, layout, cfg.user.heatmap.keys())
                continue
            # Clock format string
            if re.search(rxp.CFG_CLOCK_FORMAT, key):
                self.__add_option_string(idx, key, layout)
                continue
            # String
            if re.search(rxp.CFG_STRING, key):
                self.__add_option_string(idx, key, layout)
                continue
            # Int
            if re.search(rxp.CFG_INTEGER, key):
                self.__add_option_integer(idx, key, layout)
                continue
            # Float or int
            self.__add_option_float(idx, key, layout)

    def __choice_match(self, choice_dict, idx, key, layout):
        """Choice match"""
        for ref_key, choice_list in choice_dict.items():
            if re.search(ref_key, key):
                self.__add_option_combolist(
                    idx, key, layout, choice_list)
                return True
        return False

    def __add_option_label(self, idx, key, layout):
        """Option label"""
        label = QLabel(format_option_name(key))
        layout.addWidget(label, idx, COLUMN_LABEL)

    def __add_option_bool(self, idx, key, layout):
        """Bool"""
        editor = QCheckBox(self)
        editor.setFixedWidth(self.option_width)
        editor.setChecked(self.user_setting[self.key_name][key])
        # Context menu
        editor.defaults = self.default_setting[self.key_name][key]
        add_context_menu(editor)
        # Add layout
        layout.addWidget(editor, idx, COLUMN_OPTION)
        self.option_bool[key] = editor

    def __add_option_color(self, idx, key, layout):
        """Color string"""
        editor = DoubleClickEdit(
            self, mode="color", init=self.user_setting[self.key_name][key])
        editor.setFixedWidth(self.option_width)
        editor.setMaxLength(9)
        editor.setValidator(QVAL_COLOR)
        editor.textChanged.connect(editor.preview_color)
        # Load selected option
        editor.setText(self.user_setting[self.key_name][key])
        # Context menu
        editor.defaults = self.default_setting[self.key_name][key]
        add_context_menu(editor)
        # Add layout
        layout.addWidget(editor, idx, COLUMN_OPTION)
        self.option_color[key] = editor

    def __add_option_path(self, idx, key, layout):
        """Path string"""
        editor = DoubleClickEdit(
            self, mode="path", init=self.user_setting[self.key_name][key])
        editor.setFixedWidth(self.option_width)
        # Load selected option
        editor.setText(self.user_setting[self.key_name][key])
        # Context menu
        editor.defaults = self.default_setting[self.key_name][key]
        add_context_menu(editor)
        # Add layout
        layout.addWidget(editor, idx, COLUMN_OPTION)
        self.option_path[key] = editor

    def __add_option_image(self, idx, key, layout):
        """Image file path string"""
        editor = DoubleClickEdit(
            self, mode="image", init=self.user_setting[self.key_name][key])
        editor.setFixedWidth(self.option_width)
        # Load selected option
        editor.setText(self.user_setting[self.key_name][key])
        # Context menu
        editor.defaults = self.default_setting[self.key_name][key]
        add_context_menu(editor)
        # Add layout
        layout.addWidget(editor, idx, COLUMN_OPTION)
        self.option_image[key] = editor

    #def __add_option_fontname(self, idx, key, layout):
    #    """Font name string"""
    #    editor = QFontComboBox(self)
    #    editor.setFixedWidth(self.option_width)
    #    # Load selected option
    #    editor.setCurrentFont(self.user_setting[self.key_name][key])
    #    # Context menu
    #    editor.defaults = self.default_setting[self.key_name][key]
    #    add_context_menu(editor)
    #    # Add layout
    #    layout.addWidget(editor, idx, COLUMN_OPTION)
    #    self.option_fontname[key] = editor

    def __add_option_combolist(self, idx, key, layout, item_list):
        """Combo droplist string"""
        editor = QComboBox(self)
        editor.setFixedWidth(self.option_width)
        editor.addItems(item_list)
        # Load selected option
        editor.setCurrentText(str(self.user_setting[self.key_name][key]))
        # Context menu
        editor.defaults = self.default_setting[self.key_name][key]
        add_context_menu(editor)
        # Add layout
        layout.addWidget(editor, idx, COLUMN_OPTION)
        self.option_droplist[key] = editor

    def __add_option_string(self, idx, key, layout):
        """String"""
        editor = QLineEdit(self)
        editor.setFixedWidth(self.option_width)
        # Load selected option
        editor.setText(self.user_setting[self.key_name][key])
        # Context menu
        editor.defaults = self.default_setting[self.key_name][key]
        add_context_menu(editor)
        # Add layout
        layout.addWidget(editor, idx, COLUMN_OPTION)
        self.option_string[key] = editor

    def __add_option_integer(self, idx, key, layout):
        """Integer"""
        editor = QLineEdit(self)
        editor.setFixedWidth(self.option_width)
        editor.setValidator(QVAL_INTEGER)
        # Load selected option
        editor.setText(str(self.user_setting[self.key_name][key]))
        # Context menu
        editor.defaults = self.default_setting[self.key_name][key]
        add_context_menu(editor)
        # Add layout
        layout.addWidget(editor, idx, COLUMN_OPTION)
        self.option_integer[key] = editor

    def __add_option_float(self, idx, key, layout):
        """Float"""
        editor = QLineEdit(self)
        editor.setFixedWidth(self.option_width)
        editor.setValidator(QVAL_FLOAT)
        # Load selected option
        editor.setText(str(self.user_setting[self.key_name][key]))
        # Context menu
        editor.defaults = self.default_setting[self.key_name][key]
        add_context_menu(editor)
        # Add layout
        layout.addWidget(editor, idx, COLUMN_OPTION)
        self.option_float[key] = editor


def set_preset_name(cfg_type: str):
    """Set preset name"""
    if cfg_type == ConfigType.CONFIG:
        return f"{cfg.filename.config} (global)"
    return cfg.filename.setting


def add_context_menu(parent: QWidget):
    """Add context menu"""
    parent.setContextMenuPolicy(Qt.CustomContextMenu)
    parent.customContextMenuRequested.connect(
        lambda position, parent=parent: context_menu_reset_option(position, parent)
    )


def context_menu_reset_option(position: QPoint, parent: QWidget):
    """Context menu reset option"""
    menu = QMenu()  # no parent for temp menu
    option_reset = menu.addAction("Reset to Default")
    action = menu.exec_(parent.mapToGlobal(position))
    if action == option_reset:
        if isinstance(parent, QCheckBox):
            parent.setChecked(parent.defaults)
            return
        if isinstance(parent, QLineEdit):
            parent.setText(str(parent.defaults))
            return
        if isinstance(parent, QComboBox):
            parent.setCurrentText(str(parent.defaults))
            return
```

# File: tinypedal/ui/driver_stats_viewer.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Driver stats viewer
"""

from __future__ import annotations

from PySide2.QtCore import QPoint, Qt
from PySide2.QtWidgets import (
    QAbstractItemView,
    QComboBox,
    QHBoxLayout,
    QHeaderView,
    QMenu,
    QMessageBox,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
)

from .. import calculation as calc
from ..api_control import api
from ..const_common import MAX_SECONDS, TEXT_NOLAPTIME
from ..formatter import strip_invalid_char
from ..setting import cfg
from ..units import liter_to_gallon, meter_to_kilometer, meter_to_mile
from ..userfile.driver_stats import (
    DriverStats,
    load_stats_json_file,
    save_stats_json_file,
    validate_stats_file,
)
from ._common import (
    BaseEditor,
    CompactButton,
    NumericTableItem,
    UIScaler,
)
from .track_map_viewer import TrackMapViewer


def parse_display_value(key: str, value: int | float) -> str | int | float:
    """Parse stats display value"""
    if DriverStats.is_lap_time(key):
        if 0 < value < MAX_SECONDS:
            return calc.sec2laptime_full(value)
        return TEXT_NOLAPTIME
    if key == "meters":
        if cfg.units["odometer_unit"] == "Kilometer":
            return round(meter_to_kilometer(value), 1)
        if cfg.units["odometer_unit"] == "Mile":
            return round(meter_to_mile(value), 1)
        return int(value)
    if key == "seconds":
        return round(value / 60 / 60, 2)
    if key == "liters":
        if cfg.units["fuel_unit"] == "Gallon":
            value = liter_to_gallon(value)
        return round(value, 2)
    return value


def format_header_key(key: str):
    """Format header key"""
    if key == "pb":
        return "PB"
    if key == "qb":
        return "Qualifying"
    if key == "rb":
        return "Race"
    if key == "meters":
        if cfg.units["odometer_unit"] == "Kilometer":
            return "Km"
        if cfg.units["odometer_unit"] == "Mile":
            return "Miles"
        return "Meters"
    if key == "seconds":
        return "Hours"
    if key == "liters":
        if cfg.units["fuel_unit"] == "Gallon":
            return "Gallons"
        return "Liters"
    if key == "races":
        return "Finishes"
    return key.title()


class DriverStatsViewer(BaseEditor):
    """Driver stats viewer"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Driver Stats Viewer")
        self.setMinimumSize(UIScaler.size(80), UIScaler.size(30))
        self.resize(UIScaler.size(80), UIScaler.size(50))

        self.stats_temp = {}
        self.selected_stats_key = ""  # get active session key
        self.selected_stats_dict = {}

        # Preset selector
        self.stats_list = QComboBox()
        self.stats_list.currentIndexChanged.connect(self.select_stats)

        # Set table
        self.table_header_key = ["vehicle", *DriverStats.keys()]
        self.table_stats = QTableWidget(self)
        self.table_stats.setColumnCount(len(self.table_header_key))
        self.table_stats.setSelectionMode(QAbstractItemView.SingleSelection)
        self.table_stats.setHorizontalHeaderLabels([format_header_key(key) for key in self.table_header_key])
        self.table_stats.verticalHeader().setVisible(False)
        self.table_stats.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)
        self.table_stats.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        for idx in range(1, len(self.table_header_key)):
            self.table_stats.horizontalHeader().setSectionResizeMode(idx, QHeaderView.Fixed)
            self.table_stats.setColumnWidth(idx, UIScaler.size(5 + (idx <= 6)))

        self.table_stats.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table_stats.customContextMenuRequested.connect(self.open_context_menu)

        self.reload_stats()
        self.refresh_table()

        # Button
        button_delete = CompactButton("Delete")
        button_delete.clicked.connect(self.delete_stats_key)

        button_reload = CompactButton("Reload")
        button_reload.clicked.connect(self.reload_stats)

        button_viewmap = CompactButton("View Map")
        button_viewmap.clicked.connect(self.open_trackmap)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        # Set layout
        layout_main = QVBoxLayout()
        layout_selector = QHBoxLayout()
        layout_button = QHBoxLayout()

        layout_selector.addWidget(button_viewmap)
        layout_selector.addWidget(self.stats_list, stretch=2)
        layout_selector.addWidget(button_delete)

        layout_button.addWidget(button_reload)
        layout_button.addStretch(1)
        layout_button.addWidget(button_close)

        layout_main.addLayout(layout_selector)
        layout_main.addWidget(self.table_stats)
        layout_main.addLayout(layout_button)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def reload_stats(self):
        """Reload stats data"""
        stats_user = load_stats_json_file(
            filepath=cfg.path.config,
        )
        if stats_user is None:
            return

        self.stats_temp = validate_stats_file(stats_user)

        if self.selected_stats_key:
            last_selected_stats_key = self.selected_stats_key
        else:  # initial load current track name
            last_selected_stats_key = api.read.session.track_name()

        self.stats_list.clear()
        if self.stats_temp:
            self.stats_list.addItems(sorted(self.stats_temp, key=sort_stats_key))
        self.stats_list.setCurrentText(last_selected_stats_key)

    def refresh_table(self):
        """Refresh stats table"""
        self.table_stats.setSortingEnabled(False)  # must disable before refresh
        self.table_stats.setRowCount(0)

        row_index = 0
        for veh_name, veh_data in self.selected_stats_dict.items():
            self.add_stats_vehicle(row_index, veh_name, veh_data)
            row_index += 1

        self.table_stats.setSortingEnabled(True)
        self.table_stats.sortByColumn(1, Qt.AscendingOrder)  # sort by laptime

    def add_stats_vehicle(self, row_index: int, veh_name: str, veh_data: dict):
        """Add stats vehicle to table"""
        self.table_stats.insertRow(row_index)
        flag_selectable = Qt.ItemIsSelectable | Qt.ItemIsEnabled

        for column_index, header_key in enumerate(self.table_header_key):
            # Vehicle name
            if column_index == 0:
                item = QTableWidgetItem(str(veh_name))
                item.setFlags(flag_selectable)
                self.table_stats.setItem(row_index, column_index, item)
                continue
            # Vehicle stats
            value_raw = veh_data.get(header_key, 0)
            if DriverStats.is_lap_time(header_key) and value_raw <= 0:
                value_raw = MAX_SECONDS  # correct invalid lap time
            item = NumericTableItem(value_raw, str(parse_display_value(header_key, value_raw)))
            item.setFlags(flag_selectable)
            item.setTextAlignment(Qt.AlignCenter)
            self.table_stats.setItem(row_index, column_index, item)

    def select_stats(self):
        """Select stats key"""
        self.selected_stats_key = self.stats_list.currentText()
        if self.selected_stats_key:
            self.selected_stats_dict = self.stats_temp[self.selected_stats_key]
            self.refresh_table()
        else:
            self.table_stats.setRowCount(0)  # clear table if no track data found

    def delete_stats_key(self):
        """Delete stats key"""
        if not self.selected_stats_key:
            QMessageBox.warning(self, "Error", "No data found.")
            return

        msg_text = (
            "Delete all stats from<br>"
            f"<b>{self.selected_stats_key}</b> ?<br><br>"
            "This cannot be undone!"
        )
        if self.confirm_operation(message=msg_text):
            self.stats_temp.pop(self.selected_stats_key, None)  # remove from dict
            save_stats_json_file(
                stats_user=self.stats_temp,
                filepath=cfg.path.config,
            )
            self.reload_stats()

    def remove_vehicle(self):
        """Remove vehicle and stats"""
        selected_rows = list(data.row() for data in self.table_stats.selectedIndexes())
        if not selected_rows:
            QMessageBox.warning(self, "Error", "No data selected.")
            return

        track_stats = self.stats_temp.get(self.selected_stats_key, None)
        if not isinstance(track_stats, dict):
            QMessageBox.warning(self, "Error", "No data found.")
            return

        selected_vehicle = self.table_stats.item(selected_rows[0], 0).text()
        msg_text = (
            f"Remove all stats from <b>{selected_vehicle}</b>?<br><br>"
            "This cannot be undone!"
        )
        if self.confirm_operation(message=msg_text):
            track_stats.pop(selected_vehicle, None)  # remove from dict
            save_stats_json_file(
                stats_user=self.stats_temp,
                filepath=cfg.path.config,
            )
            self.reload_stats()

    def reset_stat(self, row: int, column: int):
        """Reset stat"""
        selected_vehicle = self.table_stats.item(row, 0).text()
        selected_column = self.table_header_key[column]
        best_laptime = self.table_stats.item(row, column).text()
        if best_laptime == TEXT_NOLAPTIME:
            QMessageBox.warning(self, "Error", "No lap time found.")
            return
        msg_text = (
            f"Reset <b>{best_laptime}</b> lap time for <b>{selected_vehicle}</b>?<br><br>"
            "This cannot be undone!"
        )
        if self.confirm_operation(message=msg_text):
            default_value = DriverStats.__dict__[selected_column]
            self.stats_temp[self.selected_stats_key][selected_vehicle][selected_column] = default_value
            save_stats_json_file(
                stats_user=self.stats_temp,
                filepath=cfg.path.config,
            )
            self.reload_stats()

    def open_context_menu(self, position: QPoint):
        """Open context menu"""
        if not self.table_stats.itemAt(position):
            return

        item_row = self.table_stats.currentRow()
        item_column = self.table_stats.currentColumn()

        menu = QMenu()  # no parent for temp menu
        if item_column == 0:
            menu.addAction("Remove Vehicle")
        elif DriverStats.is_lap_time(self.table_header_key[item_column]):
            menu.addAction("Reset Lap Time")
        else:
            return

        position += QPoint(  # position correction from header
            self.table_stats.verticalHeader().width(),
            self.table_stats.horizontalHeader().height(),
        )
        selected_action = menu.exec_(self.table_stats.mapToGlobal(position))
        if not selected_action:
            return

        action = selected_action.text()
        if action == "Remove Vehicle":
            self.remove_vehicle()
        elif action == "Reset Lap Time":
            self.reset_stat(item_row, item_column)

    def open_trackmap(self):
        """Open trackmap, make sure to strip off invalid char from key name"""
        _dialog = TrackMapViewer(
            self,
            filepath=cfg.path.track_map,
            filename=strip_invalid_char(self.selected_stats_key),
        )
        _dialog.show()


def sort_stats_key(key: str):
    """Sort stats key in lower case"""
    return key.lower()

```

# File: tinypedal/ui/preset_transfer.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Preset transfer
"""

from __future__ import annotations

import logging
import re
from types import MappingProxyType

from PySide2.QtWidgets import (
    QCheckBox,
    QComboBox,
    QFrame,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QListWidget,
    QListWidgetItem,
    QMessageBox,
)

from .. import regex_pattern as rxp
from ..formatter import format_option_name
from ..setting import cfg, load_setting_json_file, save_and_verify_json_file
from ._common import (
    BaseEditor,
    CompactButton,
    UIScaler,
)

logger = logging.getLogger(__name__)


class PresetTransfer(BaseEditor):
    """Preset Transfer"""

    def __init__(self, parent):
        super().__init__(parent)
        self.set_utility_title("Preset Transfer")
        self.setMinimumSize(UIScaler.size(40), UIScaler.size(38))

        # Label
        self.loaded_preset = cfg.filename.setting[:-5]
        label_loaded = QLabel(f"From: <b>{self.loaded_preset}</b>")

        # Setting list
        self.listbox_setting = QListWidget(self)
        self.set_setting_list(self.listbox_setting, cfg.user.setting)

        # Preset selector
        self.dest_selector = QComboBox()
        self.dest_selector.addItems(self.set_selector_list())

        # Option type list
        self.listbox_options = QListWidget(self)
        option_types = (
            "enable_state",
            "feature_toggle",
            "update_interval",
            "position",
            "opacity",
            "layout",
            "color",
            "font",
            "prefix_and_suffix",
            "caption_text",
            "column_index",
            "decimal_places",
            "other_options",
        )
        self.set_setting_list(self.listbox_options, option_types)
        layout_dest = QHBoxLayout()
        layout_dest.addWidget(QLabel("To:"))
        layout_dest.addWidget(self.dest_selector, stretch=1)

        # Button transfer
        button_apply = CompactButton("Transfer")
        button_apply.clicked.connect(self.transfer)

        button_close = CompactButton("Close")
        button_close.clicked.connect(self.close)

        layout_button = QHBoxLayout()
        layout_button.addStretch(1)
        layout_button.addWidget(button_apply)
        layout_button.addWidget(button_close)

        # List header
        header_setting = ListHeader(self, "Setting", self.listbox_setting)
        header_options = ListHeader(self, "Option Type", self.listbox_options)

        # Set layout
        layout_main = QGridLayout()
        layout_main.addWidget(label_loaded, 0, 0)
        layout_main.addWidget(header_setting, 1, 0)
        layout_main.addWidget(self.listbox_setting, 2, 0)
        layout_main.addLayout(layout_dest, 0, 1)
        layout_main.addWidget(header_options, 1, 1)
        layout_main.addWidget(self.listbox_options, 2, 1)
        layout_main.addLayout(layout_button, 3, 1)
        layout_main.setContentsMargins(self.MARGIN, self.MARGIN, self.MARGIN, self.MARGIN)
        self.setLayout(layout_main)

    def set_selector_list(self) -> list:
        """Set preset selector list"""
        preset_list = cfg.preset_files()
        # Remove loaded preset
        if self.loaded_preset in preset_list:
            preset_list.remove(self.loaded_preset)
        # Remove locked preset
        for name in reversed(preset_list):
            full_name = f"{name}.json"
            if full_name in cfg.user.filelock:
                preset_list.remove(name)
        return preset_list

    def set_setting_list(self, listbox: QListWidget, settings: tuple | dict):
        """Set setting list"""
        for setting_name in settings:
            item = QListWidgetItem()
            listbox.addItem(item)
            checkbox_item = QCheckBox(self)
            checkbox_item.setText(format_option_name(setting_name))
            checkbox_item.key_name = setting_name
            listbox.setItemWidget(item, checkbox_item)

    def get_setting_selection(self, listbox: QListWidget):
        """Get setting selection"""
        for row_index in range(listbox.count()):
            item = listbox.item(row_index)
            checkbox = listbox.itemWidget(item)
            if checkbox.isChecked():
                yield checkbox.key_name

    def transfer(self):
        """Transfer setting"""
        if not self.dest_selector.currentText():
            msg_text = "No destination preset selected or found."
            QMessageBox.warning(self, "Error", msg_text)
            return
        loaded_preset_name = f"{self.loaded_preset}.json"
        dest_preset_name = f"{self.dest_selector.currentText()}.json"
        setting_selection = tuple(self.get_setting_selection(self.listbox_setting))
        if not setting_selection:
            msg_text = "No preset setting selected.<br><br>Select at least one setting and try again."
            QMessageBox.warning(self, "Error", msg_text)
            return
        options_selection = tuple(self.get_setting_selection(self.listbox_options))
        if not options_selection:
            msg_text = "No option type selected.<br><br>Select at least one option type and try again."
            QMessageBox.warning(self, "Error", msg_text)
            return
        msg_text = (
            f"Transfer selected settings from <b>{loaded_preset_name}</b>"
            f" to <b>{dest_preset_name}</b>?<br><br>"
            "This cannot be undone!"
        )
        if not self.confirm_operation(message=msg_text):
            return
        # Load preset dict
        dest_dict = load_setting_json_file(
            filename=dest_preset_name,
            filepath=cfg.path.settings,
            dict_def=cfg.default.setting,
        )
        # Copy setting
        self.copy_setting(dest_dict, setting_selection, options_selection)
        # Save setting
        save_and_verify_json_file(
            dict_user=dest_dict,
            filename=dest_preset_name,
            filepath=cfg.path.settings,
            max_attempts=cfg.max_saving_attempts,
        )
        msg_text = (
            f"Settings are transferred from <b>{loaded_preset_name}</b>"
            f" to <b>{dest_preset_name}</b>."
        )
        QMessageBox.information(self, "Transfer Completed", msg_text)

    def copy_setting(self, dest_dict: dict, setting_selection: tuple[str, ...], options_selection: tuple[str, ...]):
        """Copy setting"""
        source_dict = MappingProxyType(cfg.user.setting)
        for setting_name, source_setting_dict in source_dict.items():
            if setting_name not in setting_selection:
                continue
            dest_setting_dict = dest_dict[setting_name]
            for option_name, option_value in source_setting_dict.items():
                if "enable" == option_name:
                    if "enable_state" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search(rxp.CFG_BOOL, option_name):
                    if "feature_toggle" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search("update_interval", option_name):
                    if "update_interval" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search("^position_x$|^position_y$", option_name):
                    if "position" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if "opacity" == option_name:
                    if "opacity" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if "layout" == option_name:
                    if "layout" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search(rxp.CFG_COLOR, option_name):
                    if "color" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search("font_name|font_weight|font_size", option_name):
                    if "font" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search("prefix|suffix", option_name):
                    if "prefix_and_suffix" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search("caption_text", option_name):
                    if "caption_text" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search("column_index", option_name):
                    if "column_index" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if re.search("decimal_places", option_name):
                    if "decimal_places" in options_selection:
                        dest_setting_dict[option_name] = option_value
                    continue
                if "other_options" in options_selection:
                    dest_setting_dict[option_name] = option_value
                    continue


class ListHeader(QFrame):
    """List header"""

    def __init__(self, parent, title: str, listbox: QListWidget):
        super().__init__(parent)
        self._parent = parent
        self._listbox = listbox
        self._title = title

        button_selectall = CompactButton(" All ")
        button_selectall.clicked.connect(self.button_select_all)

        button_deselectall = CompactButton("None")
        button_deselectall.clicked.connect(self.button_deselect_all)

        layout = QHBoxLayout()
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(QLabel(f"Select {title}"))
        layout.addWidget(button_selectall)
        layout.addWidget(button_deselectall)
        self.setLayout(layout)
        self.setFrameShape(QFrame.StyledPanel)

    def button_select_all(self):
        """Select all check box"""
        msg_text = f"Select all {self._title}s from list?"
        if self._parent.confirm_operation(message=msg_text):
            self.set_selection(self._listbox, True)

    def button_deselect_all(self):
        """Deselect all check box"""
        msg_text = f"Deselect all {self._title}s from list?"
        if self._parent.confirm_operation(message=msg_text):
            self.set_selection(self._listbox, False)

    def set_selection(self, listbox: QListWidget, checked: bool):
        """Set check box"""
        for row_index in range(listbox.count()):
            item = listbox.item(row_index)
            listbox.itemWidget(item).setChecked(checked)

```

# File: tinypedal/ui/preset_view.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Preset list view
"""

import os
import shutil
from typing import Callable

from PySide2.QtCore import QPoint, Qt
from PySide2.QtWidgets import (
    QCheckBox,
    QDialogButtonBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMenu,
    QMessageBox,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from ..const_app import VERSION
from ..const_file import ConfigType, FileExt
from ..formatter import strip_filename_extension
from ..setting import cfg
from ..validator import is_allowed_filename
from ._common import QVAL_FILENAME, BaseDialog, UIScaler
from .preset_transfer import PresetTransfer


class PresetList(QWidget):
    """Preset list view"""

    def __init__(self, parent, reload_func: Callable, notify_toggle: Callable):
        super().__init__(parent)
        self.reload_preset = reload_func
        self.notify_toggle = notify_toggle

        # Label
        self.label_loaded = QLabel("")

        # Button
        button_refresh = QPushButton("Refresh")
        button_refresh.clicked.connect(self.refresh)

        button_transfer = QPushButton("Transfer")
        button_transfer.clicked.connect(self.open_preset_transfer)

        button_create = QPushButton("New Preset")
        button_create.clicked.connect(self.open_create_preset)

        # Check box
        self.checkbox_autoload = QCheckBox("Auto Load Primary Preset")
        self.checkbox_autoload.setChecked(cfg.application["enable_auto_load_preset"])
        self.checkbox_autoload.toggled.connect(self.toggle_autoload)

        # List box
        self.listbox_preset = QListWidget(self)
        self.listbox_preset.setAlternatingRowColors(True)
        self.listbox_preset.itemDoubleClicked.connect(self.load_preset)
        self.listbox_preset.setContextMenuPolicy(Qt.CustomContextMenu)
        self.listbox_preset.customContextMenuRequested.connect(self.open_context_menu)
        self.refresh()

        layout_button = QHBoxLayout()
        layout_button.addWidget(button_refresh)
        layout_button.addWidget(button_transfer)
        layout_button.addStretch(1)
        layout_button.addWidget(button_create)

        # Layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.label_loaded)
        layout_main.addWidget(self.listbox_preset)
        layout_main.addWidget(self.checkbox_autoload)
        layout_main.addLayout(layout_button)
        margin = UIScaler.pixel(6)
        layout_main.setContentsMargins(margin, margin, margin, margin)
        self.setLayout(layout_main)

    def refresh(self):
        """Refresh preset list"""
        preset_list = cfg.preset_files()
        self.listbox_preset.clear()

        for preset_name in preset_list:
            # Add preset name
            item = QListWidgetItem()
            item.setText(preset_name)
            self.listbox_preset.addItem(item)
            # Add primary preset tag
            label_item = PresetTagItem(None, preset_name)
            self.listbox_preset.setItemWidget(item, label_item)

        loaded_preset = cfg.filename.setting
        is_locked = loaded_preset in cfg.user.filelock
        locked_tag = " (locked)" if is_locked else ""
        self.label_loaded.setText(f"Loaded: <b>{loaded_preset[:-5]}{locked_tag}</b>")
        self.checkbox_autoload.setChecked(cfg.application["enable_auto_load_preset"])
        self.notify_toggle(is_locked)

    def load_preset(self):
        """Load selected preset"""
        selected_index = self.listbox_preset.currentRow()
        if selected_index >= 0:
            selected_preset_name = self.listbox_preset.item(selected_index).text()
            cfg.set_next_to_load(f"{selected_preset_name}{FileExt.JSON}")
            self.reload_preset()
        else:
            QMessageBox.warning(
                self, "Error",
                "No preset selected.\nPlease select a preset to continue.")

    def open_create_preset(self):
        """Create new preset"""
        _dialog = CreatePreset(self, title="Create new default preset")
        _dialog.open()

    def open_preset_transfer(self):
        """Transfer preset"""
        _dialog = PresetTransfer(self)
        _dialog.open()

    @staticmethod
    def toggle_autoload(checked: bool):
        """Toggle auto load preset"""
        cfg.application["enable_auto_load_preset"] = checked
        cfg.save(cfg_type=ConfigType.CONFIG)

    def open_context_menu(self, position: QPoint):
        """Open context menu"""
        if not self.listbox_preset.itemAt(position):
            return

        selected_index = self.listbox_preset.currentRow()
        selected_preset_name = self.listbox_preset.item(selected_index).text()
        selected_filename = f"{selected_preset_name}{FileExt.JSON}"
        is_locked = (selected_filename in cfg.user.filelock)

        # Create context menu
        menu = QMenu()  # no parent for temp menu
        menu.addAction("Unlock Preset" if is_locked else "Lock Preset")
        menu.addSeparator()

        menu_class = QMenu()
        menu_class.setTitle("Set Primary for Class")
        for class_name in cfg.user.classes:
            menu_class.addAction(class_name)
        menu.addMenu(menu_class)

        menu.addAction("Clear Primary Tag")
        menu.addSeparator()
        menu.addAction("Duplicate")
        if not is_locked:
            menu.addAction("Rename")
            menu.addAction("Delete")

        selected_action = menu.exec_(self.listbox_preset.mapToGlobal(position))
        if not selected_action:
            return
        action = selected_action.text()

        # Set primary preset Class
        if action in cfg.user.classes:
            cfg.user.classes[action]["preset"] = selected_preset_name
            cfg.save(cfg_type=ConfigType.CLASSES)
            self.refresh()
        # Clear primary preset tag
        elif action == "Clear Primary Tag":
            for class_name, class_data in cfg.user.classes.items():
                if selected_preset_name == class_data["preset"]:
                    class_data["preset"] = ""
                    cfg.save(cfg_type=ConfigType.CLASSES)
                self.refresh()
        # Lock/unlock preset
        elif action == "Lock Preset":
            msg_text = (
                f"Lock <b>{selected_filename}</b> preset?<br><br>"
                "Changes to locked preset will not be saved."
            )
            if self.confirm_operation(title="Lock Preset", message=msg_text):
                cfg.user.filelock[selected_filename] = {"version": VERSION}
                cfg.save(cfg_type=ConfigType.FILELOCK)
                self.refresh()
        elif action == "Unlock Preset":
            msg_text = f"Unlock <b>{selected_filename}</b> preset?"
            if self.confirm_operation(title="Unlock Preset", message=msg_text):
                if cfg.user.filelock.pop(selected_filename, None):
                    cfg.save(cfg_type=ConfigType.FILELOCK)
                self.refresh()
        # Duplicate preset
        elif action == "Duplicate":
            _dialog = CreatePreset(
                self,
                title="Duplicate Preset",
                mode="duplicate",
                source_filename=selected_filename
            )
            _dialog.open()
        # Rename preset
        elif action == "Rename":
            _dialog = CreatePreset(
                self,
                title="Rename Preset",
                mode="rename",
                source_filename=selected_filename
            )
            _dialog.open()
        # Delete preset
        elif action == "Delete":
            msg_text = (
                f"Delete <b>{selected_filename}</b> preset permanently?<br><br>"
                "This cannot be undone!"
            )
            if self.confirm_operation(title="Delete Preset", message=msg_text):
                if os.path.exists(f"{cfg.path.settings}{selected_filename}"):
                    os.remove(f"{cfg.path.settings}{selected_filename}")
                self.refresh()

    def confirm_operation(self, title: str = "Confirm", message: str = "") -> bool:
        """Confirm operation"""
        confirm = QMessageBox.question(
            self, title, message,
            buttons=QMessageBox.Yes | QMessageBox.No,
            defaultButton=QMessageBox.No,
        )
        return confirm == QMessageBox.Yes


class CreatePreset(BaseDialog):
    """Create preset"""

    def __init__(self, parent, title: str = "", mode: str = "", source_filename: str = ""):
        """Initialize create preset dialog setting

        Args:
            title: Dialog title string.
            mode: Edit mode, either "duplicate", "rename", or "" for new preset.
            source_filename: Source setting filename.
        """
        super().__init__(parent)
        self._parent = parent
        self.edit_mode = mode
        self.source_filename = source_filename

        self.setWindowTitle(title)

        # Entry box
        self.preset_entry = QLineEdit()
        self.preset_entry.setMaxLength(40)
        self.preset_entry.setPlaceholderText("Enter a new preset name")
        self.preset_entry.setValidator(QVAL_FILENAME)

        # Button
        button_create = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)
        button_create.accepted.connect(self.creating)
        button_create.rejected.connect(self.reject)

        # Layout
        layout_main = QVBoxLayout()
        layout_main.addWidget(self.preset_entry)
        layout_main.addWidget(button_create)
        self.setLayout(layout_main)
        self.setMinimumWidth(UIScaler.size(21))
        self.setFixedHeight(self.sizeHint().height())

    def creating(self):
        """Creating new preset"""
        entered_filename = strip_filename_extension(self.preset_entry.text(), FileExt.JSON)

        if is_allowed_filename(entered_filename):
            self.__saving(cfg.path.settings, entered_filename, self.source_filename)
        else:
            QMessageBox.warning(self, "Error", "Invalid preset name.")

    def __saving(self, filepath: str, entered_filename: str, source_filename: str):
        """Saving new preset"""
        # Check existing preset
        temp_list = cfg.preset_files()
        for preset in temp_list:
            if entered_filename.lower() == preset.lower():
                QMessageBox.warning(self, "Error", "Preset already exists.")
                return
        # Duplicate preset
        if self.edit_mode == "duplicate":
            shutil.copy(
                f"{filepath}{source_filename}",
                f"{filepath}{entered_filename}{FileExt.JSON}"
            )
            self._parent.refresh()
        # Rename preset
        elif self.edit_mode == "rename":
            os.rename(
                f"{filepath}{source_filename}",
                f"{filepath}{entered_filename}{FileExt.JSON}"
            )
            # Reload if renamed file was loaded
            if cfg.is_loaded(source_filename):
                cfg.set_next_to_load(f"{entered_filename}{FileExt.JSON}")
                self._parent.reload_preset()
            else:
                self._parent.refresh()
        # Create new preset
        else:
            cfg.create(f"{entered_filename}{FileExt.JSON}")
            self._parent.refresh()
        # Close window
        self.accept()


class PresetTagItem(QWidget):
    """Preset tag item"""

    def __init__(self, parent, preset_name: str):
        super().__init__(parent)
        layout_item = QHBoxLayout()
        layout_item.setContentsMargins(0, 0, 0, 0)
        layout_item.setSpacing(0)
        layout_item.addStretch(1)

        # Class name tag
        for class_name, class_data in cfg.user.classes.items():
            if preset_name == class_data["preset"]:
                label_class_name = QLabel(class_name)
                label_class_name.setStyleSheet(f"background: {class_data['color']};")
                layout_item.addWidget(label_class_name)

        # File lock tag
        preset_filename = f"{preset_name}{FileExt.JSON}"
        if preset_filename in cfg.user.filelock:
            label_locked = QLabel(f"{cfg.user.filelock[preset_filename]['version']}")
            label_locked.setStyleSheet("background: #777;")
            layout_item.addWidget(label_locked)

        self.setLayout(layout_item)

```

# File: tinypedal/userfile/__init__.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
User file access function
"""

import logging
import os

logger = logging.getLogger(__name__)


def set_user_data_path(filepath: str) -> str:
    """Set user data path, create if not exist"""
    if not os.path.exists(filepath):
        logger.info("%s folder does not exist, attemp to create", filepath)
        try:
            os.mkdir(filepath)
        except (PermissionError, FileExistsError, FileNotFoundError):
            logger.error("failed to create %s folder", filepath)
            return ""
    return filepath


def set_global_user_path(filepath: str, platform: str) -> str:
    """Set global user data path, create if not exist"""
    if platform == "Windows":
        path = set_user_data_path(f"{os.getenv('APPDATA', '.')}\\{filepath}\\")
    else:
        from xdg import BaseDirectory as BD

        path = BD.save_config_path(filepath) + "/"
    return path


def set_relative_path(filepath: str) -> str:
    """Convert absolute path to relative if path is inside APP root folder"""
    try:
        rel_path = os.path.relpath(filepath)
        if rel_path.startswith(".."):
            output_path = filepath
        else:
            output_path = rel_path
    except ValueError:
        output_path = filepath
    # Convert backslash to slash
    output_path = output_path.replace("\\", "/")
    # Make sure path end with "/"
    if not output_path.endswith("/"):
        output_path += "/"
    return output_path

```

# File: tinypedal/userfile/brand_logo.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Brand logo file function
"""

import os

from PySide2.QtCore import Qt
from PySide2.QtGui import QPixmap

from ..const_file import FileExt


def exceeded_max_logo_width(
    org_width: int, org_height: int, max_width: int, max_height: int
) -> bool:
    """Whether exceeded max logo width"""
    return org_width * max_height / max(org_height, 1) > max_width


def load_brand_logo_file(
    filepath:str, filename: str, max_width: int, max_height: int, extension: str = FileExt.PNG
) -> QPixmap:
    """Load brand logo file (*.png)"""
    filename_full = f"{filepath}{filename}{extension}"
    # Check existing file and size < 1mb
    if not os.path.exists(filename_full) or os.path.getsize(filename_full) > 1024000:
        return QPixmap()
    # Load and scale logo
    logo = QPixmap(filename_full)
    if exceeded_max_logo_width(logo.width(), logo.height(), max_width, max_height):
        logo_scaled = logo.scaledToWidth(max_width, mode=Qt.SmoothTransformation)
    else:
        logo_scaled = logo.scaledToHeight(max_height, mode=Qt.SmoothTransformation)
    return logo_scaled

```

# File: tinypedal/userfile/consumption_history.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Consumption history file function
"""

from __future__ import annotations

import csv
import logging

from ..const_file import FileExt
from ..module_info import ConsumptionDataSet
from ..validator import dict_value_type, invalid_save_name

logger = logging.getLogger(__name__)


def load_consumption_history_file(
    filepath: str, filename: str, extension: str = FileExt.CONSUMPTION
) -> tuple[ConsumptionDataSet, ...]:
    """Load fuel/energy consumption history file (*.consumption)"""
    try:
        with open(f"{filepath}{filename}{extension}", newline="", encoding="utf-8") as csvfile:
            data_reader = csv.DictReader(csvfile, restval="", restkey="unknown")
            default_data = ConsumptionDataSet._field_defaults
            dataset = tuple(
                ConsumptionDataSet(**dict_value_type(data, default_data))
                for data in data_reader
            )
            if not dataset:
                raise ValueError
        return dataset
    except FileNotFoundError:
        logger.info("MISSING: consumption history (%s) data", extension)
    except (IndexError, KeyError, ValueError, TypeError):
        logger.info("MISSING: invalid consumption history (%s) data", extension)
    return (ConsumptionDataSet(),)


def save_consumption_history_file(
    dataset: tuple, filepath: str, filename: str, extension: str = FileExt.CONSUMPTION
) -> None:
    """Save fuel/energy consumption history file (*.consumption)"""
    if len(dataset) < 2 or invalid_save_name(filename):
        return
    with open(f"{filepath}{filename}{extension}", "w", newline="", encoding="utf-8") as csvfile:
        data_writer = csv.writer(csvfile, quoting=csv.QUOTE_NONNUMERIC)
        data_writer.writerow(ConsumptionDataSet._fields)  # write field name as column header
        data_writer.writerows(dataset)
        logger.info("USERDATA: %s%s saved", filename, extension)

```

# File: tinypedal/userfile/delta_best.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Delta best file function
"""

from __future__ import annotations

import csv
import logging

from ..const_file import FileExt
from ..validator import invalid_save_name, valid_delta_set

logger = logging.getLogger(__name__)


def load_delta_best_file(
    filepath: str, filename: str, defaults: tuple, extension: str = FileExt.CSV
) -> tuple[tuple, float]:
    """Load delta best file (*.csv)"""
    try:
        with open(f"{filepath}{filename}{extension}", newline="", encoding="utf-8") as csvfile:
            data_reader = csv.reader(csvfile, quoting=csv.QUOTE_NONNUMERIC)
            temp_list = tuple(tuple(data) for data in data_reader)
        # Validate data
        bestlist = valid_delta_set(temp_list)
        laptime_best = bestlist[-1][1]
        return bestlist, laptime_best
    except FileNotFoundError:
        logger.info("MISSING: delta best (%s) data", extension)
    except (IndexError, ValueError, TypeError):
        logger.info("MISSING: invalid delta best (%s) data", extension)
    return defaults


def save_delta_best_file(
    filepath: str, filename: str, dataset: tuple, extension: str = FileExt.CSV
) -> None:
    """Save delta best file (*.csv)"""
    if len(dataset) < 10 or invalid_save_name(filename):
        return
    with open(f"{filepath}{filename}{extension}", "w", newline="", encoding="utf-8") as csvfile:
        data_writer = csv.writer(csvfile)
        data_writer.writerows(dataset)
        logger.info("USERDATA: %s%s saved", filename, extension)

```

# File: tinypedal/userfile/driver_stats.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Driver stats file function
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass
from time import sleep
from typing import KeysView, get_type_hints

from ..const_common import MAX_SECONDS
from ..const_file import FileExt, StatsFile
from ..validator import convert_value_type, purge_data_key
from .json_setting import (
    create_backup_file,
    save_and_verify_json_file,
    save_json_file,
    set_backup_timestamp,
)

logger = logging.getLogger(__name__)


@dataclass
class DriverStats:
    """Driver stats data

    Attributes:
        pb: personal best lap time.
        qb: qualifying best lap time.
        rb: race best lap time.
        meters: meters driven.
        seconds: seconds spent driving.
        liters: liters of fuel consumed.
        valid: valid laps.
        invalid: invalid laps.
        penalties: penalties recieved in race.
        races: number of races completed.
        wins: number of wins.
        podiums: number of podiums.
    """

    pb: float = MAX_SECONDS
    qb: float = MAX_SECONDS
    rb: float = MAX_SECONDS
    meters: float = 0.0
    seconds: float = 0.0
    liters: float = 0.0
    valid: int = 0
    invalid: int = 0
    penalties: int = 0
    races: int = 0
    wins: int = 0
    podiums: int = 0

    @classmethod
    def keys(cls) -> KeysView[str]:
        """Get key name list"""
        return cls.__annotations__.keys()

    @staticmethod
    def is_lap_time(key: str) -> bool:
        """Is lap time"""
        return key in ("pb", "qb", "rb")


def validate_stats_file(stats_user: dict) -> dict:
    """Validate stats file

    Full validation for every primary key (track name) and secondary key (vehicle name),
    Only required for loading file in Driver Stats Viewer.
    """
    for key in stats_user:
        if not isinstance(stats_user[key], dict):
            stats_user[key] = {}
        sub_value = stats_user[key]
        for sub_key in sub_value:
            if not isinstance(sub_value[sub_key], dict):
                sub_value[sub_key] = {}
    return stats_user


def get_sub_dict(source: dict, key_name: str) -> dict:
    """Get sub dict, create new if not exist"""
    sub_dict = source.get(key_name)
    if not isinstance(sub_dict, dict):
        source[key_name] = {}
        sub_dict = source[key_name]
    return sub_dict


def load_driver_stats(
    key_list: tuple[str, str], filepath: str, filename: str = StatsFile.DRIVER
) -> DriverStats:
    """Load driver stats"""
    stats_user = load_stats_json_file(
        filepath=filepath,
        filename=filename,
    )
    if stats_user is None:
        return DriverStats()
    # Get data from matching key
    loaded_dict = stats_user
    for key in key_list:
        temp_dict = loaded_dict.get(key)
        if not isinstance(temp_dict, dict):  # not exist, set to default
            return DriverStats()
        loaded_dict = temp_dict
    # Add data to DriverStats
    try:
        return DriverStats(**purge_data_key(loaded_dict, DriverStats.keys()))
    except (AttributeError, TypeError, KeyError, ValueError):
        return DriverStats()


def save_driver_stats(
    key_list: tuple[str, str], stats_update: DriverStats, filepath: str, filename: str = StatsFile.DRIVER
) -> None:
    """Save driver stats"""
    if not key_list or not all(key_list):  # ignore invalid key name
        return
    # Load stats with limited attempts
    load_attempts = 10
    while load_attempts > 0:
        stats_user = load_stats_json_file(
            filepath=filepath,
            filename=filename,
            show_log=False,
        )
        if stats_user is not None:
            break
        load_attempts -= 1
        logger.info("USERDATA: unable to load %s%s, %s attempt(s) left", filename, FileExt.STATS, load_attempts)
        sleep(0.05)
    # Create backup if failed to load stats
    if stats_user is None:
        logger.info("USERDATA: unable to load %s%s, creating backup", filename, FileExt.STATS)
        if not create_backup_file(f"{filename}{FileExt.STATS}", filepath, set_backup_timestamp(), show_log=True):
            return  # abort saving if failed to create backup
        stats_user = {}  # reset stats
    # Get data from matching key
    loaded_dict = stats_user
    for key in key_list:
        loaded_dict = get_sub_dict(loaded_dict, key)
    # Verify and update new data
    default_dict = DriverStats.__dict__
    default_type = get_type_hints(DriverStats)
    for key, value in stats_update.__dict__.items():
        # Add new default value if not exists
        if key not in loaded_dict:
            loaded_dict[key] = default_dict[key]
        # Check value type, auto correct if mismatch
        if not isinstance(loaded_dict[key], default_type[key]):
            loaded_dict[key] = convert_value_type(loaded_dict[key], default_dict[key], default_type[key])
        # Update laptime value faster than old value
        if DriverStats.is_lap_time(key):
            if loaded_dict[key] <= 0:  # reset invalid time
                loaded_dict[key] = MAX_SECONDS
            if loaded_dict[key] > value > 0:
                loaded_dict[key] = value
            continue
        # Update value (increment)
        loaded_dict[key] += value
    # Save new data
    save_stats_json_file(
        stats_user=stats_user,
        filepath=filepath,
        filename=filename,
    )


def load_stats_json_file(
    filepath: str, filename: str = StatsFile.DRIVER, extension: str = FileExt.STATS, show_log: bool = True
) -> dict | None:
    """Load stats json file, create new if not exists, or returns "None" if invalid"""
    try:
        with open(f"{filepath}{filename}{extension}", "r", encoding="utf-8") as jsonfile:
            stats_user = json.load(jsonfile)
            if not isinstance(stats_user, dict):
                raise TypeError
            return stats_user
    except FileNotFoundError:
        if show_log:
            logger.info("MISSING: %s stats (%s) data, create new stats", filename, extension)
        stats_user = {}
        save_json_file(stats_user, filename, filepath, extension, compact_json=True)
        return stats_user
    except (AttributeError, TypeError, KeyError, ValueError):
        if show_log:
            logger.info("MISSING: invalid %s stats (%s) data", filename, extension)
    return None


def save_stats_json_file(
    stats_user: dict, filepath: str, filename: str = StatsFile.DRIVER, extension: str = FileExt.STATS
) -> None:
    """Save stats to json file"""
    save_and_verify_json_file(
        dict_user=stats_user,
        filename=f"{filename}{extension}",
        filepath=filepath,
        max_attempts=10,
        compact_json=True,
    )

```

# File: tinypedal/userfile/fuel_delta.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Fuel/Energy delta file function
"""

from __future__ import annotations

import csv
import logging

from ..validator import invalid_save_name, valid_delta_set

logger = logging.getLogger(__name__)


def load_fuel_delta_file(
    filepath: str, filename: str, extension: str, defaults: tuple
) -> tuple[tuple, float, float]:
    """Load fuel/energy delta file (*.fuel, *.energy)"""
    try:
        with open(f"{filepath}{filename}{extension}", newline="", encoding="utf-8") as csvfile:
            data_reader = csv.reader(csvfile, quoting=csv.QUOTE_NONNUMERIC)
            temp_list = tuple(tuple(data) for data in data_reader)
        # Validate data
        lastlist = valid_delta_set(temp_list)
        used_last = lastlist[-1][1]
        laptime_last = lastlist[-1][2]
        return lastlist, used_last, laptime_last
    except FileNotFoundError:
        logger.info("MISSING: consumption delta (%s) data", extension)
    except (IndexError, ValueError, TypeError):
        logger.info("MISSING: invalid consumption delta (%s) data", extension)
    return defaults


def save_fuel_delta_file(
    filepath: str, filename: str, extension: str, dataset: tuple
) -> None:
    """Save fuel/energy delta file (*.fuel, *.energy)"""
    if len(dataset) < 10 or invalid_save_name(filename):
        return
    with open(f"{filepath}{filename}{extension}", "w", newline="", encoding="utf-8") as csvfile:
        data_writer = csv.writer(csvfile)
        data_writer.writerows(dataset)
        logger.info("USERDATA: %s%s saved", filename, extension)

```

# File: tinypedal/userfile/heatmap.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Heatmap preset function
"""

from __future__ import annotations

import re

from ..const_file import ConfigType
from ..regex_pattern import COMMON_TYRE_COMPOUNDS
from ..setting import cfg
from ..template.setting_brakes import BRAKEINFO_DEFAULT
from ..template.setting_compounds import COMPOUNDINFO_DEFAULT
from ..template.setting_heatmap import HEATMAP_DEFAULT_BRAKE, HEATMAP_DEFAULT_TYRE
from ..validator import invalid_save_name, is_hex_color


# Brake function
def add_missing_brake(brake_name: str) -> dict:
    """Add missing brake style to brakes preset"""
    new_data = BRAKEINFO_DEFAULT.copy()
    cfg.user.brakes[brake_name] = new_data
    cfg.save(cfg_type=ConfigType.BRAKES)
    return new_data


def save_brake_failure_thickness(brake_name: str, failure: float) -> None:
    """Save brake failure thickness (mm) to brakes preset when brake fails"""
    if invalid_save_name(brake_name):
        return
    brake = cfg.user.brakes.get(brake_name)
    if brake is None:
        new_data = BRAKEINFO_DEFAULT.copy()
        new_data["failure_thickness"] = failure
        cfg.user.brakes[brake_name] = new_data
    else:
        brake["failure_thickness"] = failure
    cfg.save(cfg_type=ConfigType.BRAKES)


def set_predefined_brake_name(class_name: str, vehicle_name: str, is_front: bool) -> str:
    """Set common brake name"""
    if class_name == "":
        return ""
    suffix_name = "Front Brake" if is_front else "Rear Brake"
    brand_name = cfg.user.brands.get(vehicle_name, "")
    if brand_name != "":
        return f"{class_name} - {brand_name} {suffix_name}"
    return f"{class_name} - {suffix_name}"


def select_brake_failure_thickness(brake_name: str) -> float:
    """Select brake failure thickness, minimum thickness 0.0"""
    brake = cfg.user.brakes.get(brake_name)
    if brake is not None:
        return max(brake.get("failure_thickness", 0.0), 0.0)
    if not invalid_save_name(brake_name):
        add_missing_brake(brake_name)
    return 0.0


def select_brake_heatmap_name(brake_name: str) -> str:
    """Select brake heatmap name from brakes preset"""
    brake = cfg.user.brakes.get(brake_name)
    if brake is None:
        if invalid_save_name(brake_name):
            return HEATMAP_DEFAULT_BRAKE
        brake = add_missing_brake(brake_name)
    return brake.get("heatmap", HEATMAP_DEFAULT_BRAKE)


def brake_failure_thickness(class_name: str, vehicle_name: str) -> tuple[float, float, float, float]:
    """Get failure thickness"""
    failure_thickness_f = select_brake_failure_thickness(
        set_predefined_brake_name(class_name, vehicle_name, True)
    )
    failure_thickness_r = select_brake_failure_thickness(
        set_predefined_brake_name(class_name, vehicle_name, False)
    )
    return (
        failure_thickness_f,
        failure_thickness_f,
        failure_thickness_r,
        failure_thickness_r,
    )


# Tyre function
def add_missing_compound(compound_name: str) -> dict:
    """Add missing compound style to compounds preset"""
    new_data = COMPOUNDINFO_DEFAULT.copy()
    new_data["symbol"] = set_predefined_compound_symbol(compound_name)
    cfg.user.compounds[compound_name] = new_data
    cfg.save(cfg_type=ConfigType.COMPOUNDS)
    return new_data


def set_predefined_compound_symbol(compound_name: str) -> str:
    """Set common tyre compound name to predefined symbol"""
    for compound in COMMON_TYRE_COMPOUNDS:
        if re.search(compound[0], compound_name, flags=re.IGNORECASE):
            return compound[1]
    return "?"


def select_compound_symbol(compound_name: str) -> str:
    """Select compound symbol"""
    compound = cfg.user.compounds.get(compound_name)
    if compound is not None:
        return compound.get("symbol", "?")
    if not invalid_save_name(compound_name):
        add_missing_compound(compound_name)
    return set_predefined_compound_symbol(compound_name)


def select_tyre_heatmap_name(compound_name: str) -> str:
    """Select tyre heatmap name from compounds preset"""
    compound = cfg.user.compounds.get(compound_name)
    if compound is None:
        if invalid_save_name(compound_name):
            return HEATMAP_DEFAULT_TYRE
        compound = add_missing_compound(compound_name)
    return compound.get("heatmap", HEATMAP_DEFAULT_TYRE)


# Heatmap function
def verify_heatmap(heatmap_dict: dict | None) -> bool:
    """Verify color in heatmap"""
    if not heatmap_dict:
        return False
    for color in heatmap_dict.values():
        if not is_hex_color(color):
            return False
    return True


def load_heatmap_style(
    heatmap_name: str, default_name: str, swap_style: bool = False,
    fg_color: str = "", bg_color: str = "") -> tuple[tuple[float, str], ...]:
    """Load heatmap preset (dictionary) & set color style sheet

    key = temperature string, value = hex color string.
    Convert key to float, sort by key.

    Args:
        heatmap_name: heatmap preset name.
        default_name: default preset name.
        swap_style: assign heatmap color as background color if True, otherwise as foreground.
        fg_color: assign foreground color if swap_style True.
        bg_color: assign background color if swap_style False.

    Returns:
        tuple(tuple(temperature value, color style sheet string))
    """
    heatmap_dict = cfg.user.heatmap.get(heatmap_name)
    if not verify_heatmap(heatmap_dict):
        heatmap_dict = cfg.default.heatmap[default_name]
    if swap_style:
        return tuple(sorted(
            (float(temp), f"color:{fg_color};background:{heatmap_color};")
            for temp, heatmap_color in heatmap_dict.items()
        ))
    return tuple(sorted(
        (float(temp), f"color:{heatmap_color};background:{bg_color};")
        for temp, heatmap_color in heatmap_dict.items()
    ))


#def load_heatmap(heatmap_name: str, default_name: str) -> list[tuple[float, str]]:
#    """Load heatmap preset (dictionary)
#
#    key = temperature string, value = hex color string.
#    Convert key to float, sort by key.
#
#    Args:
#        heatmap_name: heatmap preset name.
#        default_name: default preset name.
#
#    Returns:
#        list(tuple(temperature value, hex color string))
#    """
#    heatmap_dict = cfg.user.heatmap.get(heatmap_name)
#    if not verify_heatmap(heatmap_dict):
#        heatmap_dict = cfg.default.heatmap[default_name]
#    return sorted(
#        (float(temp), heatmap_color)
#        for temp, heatmap_color in heatmap_dict.items()
#    )

```

# File: tinypedal/userfile/sector_best.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Sector best file function
"""

from __future__ import annotations

import csv
import logging

from ..const_file import FileExt
from ..validator import invalid_save_name

logger = logging.getLogger(__name__)


def load_sector_best_file(
    filepath:str, filename: str, session_id: tuple, defaults: list, extension: str = FileExt.SECTOR
) -> tuple[list, list, list, list]:
    """Load sector best file (*.sector)"""
    try:
        with open(f"{filepath}{filename}{extension}", newline="", encoding="utf-8") as csvfile:
            temp_list = list(csv.reader(csvfile, quoting=csv.QUOTE_NONNUMERIC))
        # Check if same session
        if (temp_list[0][0] == session_id[0] and  # session_stamp
            temp_list[0][1] <= session_id[1] and  # session_etime
            temp_list[0][2] <= session_id[2]):    # session_tlaps
            # Session best data
            best_s_tb = [temp_list[1][0], temp_list[1][1], temp_list[1][2]]
            best_s_pb = [temp_list[2][0], temp_list[2][1], temp_list[2][2]]
        else:
            best_s_tb = defaults.copy()
            best_s_pb = defaults.copy()
        # All time best data
        all_best_s_tb = [temp_list[3][0], temp_list[3][1], temp_list[3][2]]
        all_best_s_pb = [temp_list[4][0], temp_list[4][1], temp_list[4][2]]
        return best_s_tb, best_s_pb, all_best_s_tb, all_best_s_pb
    except FileNotFoundError:
        logger.info("MISSING: sector best (%s) data", extension)
    except (IndexError, ValueError, TypeError):
        logger.info("MISSING: invalid sector best (%s) data", extension)
    return defaults.copy(), defaults.copy(), defaults.copy(), defaults.copy()


def save_sector_best_file(
    filepath: str, filename: str, dataset: tuple, extension: str = FileExt.SECTOR
) -> None:
    """Save sector best file (*.sector)

    sector(CSV) file structure:
        Line 0: session stamp, session elapsed time, session total laps
        Line 1: session theoretical best sector time
        Line 2: session personal best sector time
        Line 3: all time theoretical best sector time
        Line 4: all time personal best sector time
    """
    if len(dataset) != 5 or invalid_save_name(filename):
        return
    with open(f"{filepath}{filename}{extension}", "w", newline="", encoding="utf-8") as csvfile:
        data_writer = csv.writer(csvfile)
        data_writer.writerows(dataset)
        logger.info("USERDATA: %s%s saved", filename, extension)

```

# File: tinypedal/userfile/track_info.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Track info preset function
"""

from __future__ import annotations

from ..const_file import ConfigType
from ..setting import cfg
from ..template.setting_tracks import TRACKINFO_DEFAULT
from ..validator import invalid_save_name


def add_missing_track(track_name: str) -> dict:
    """Add missing track info to tracks preset"""
    new_data = TRACKINFO_DEFAULT.copy()
    cfg.user.tracks[track_name] = new_data
    return new_data


def load_track_info(track_name: str) -> dict:
    """Load track info from tracks preset"""
    return cfg.user.tracks.get(track_name, TRACKINFO_DEFAULT)


def save_track_info(track_name: str, **track_info: dict) -> None:
    """Save track info to tracks preset"""
    if invalid_save_name(track_name):
        return
    track = cfg.user.tracks.get(track_name)
    if not isinstance(track, dict):
        track = add_missing_track(track_name)
    track.update(track_info)
    cfg.save(cfg_type=ConfigType.TRACKS)

```

# File: tinypedal/userfile/track_map.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Track map file function
"""

from __future__ import annotations

import logging
import xml.dom.minidom
import xml.parsers.expat

from ..const_file import FileExt
from ..validator import invalid_save_name

logger = logging.getLogger(__name__)


def string_pair_to_int(string: str) -> tuple[int, int]:
    """Convert string pair "x,y" to int list"""
    value = string.split(",")
    return int(value[0]), int(value[1])


def string_pair_to_float(string: str) -> tuple[float, float]:
    """Convert string pair "x,y" to float list"""
    value = string.split(",")
    return float(value[0]), float(value[1])


def list_pair_to_string(data: tuple | list) -> str:
    """Convert list pair (x,y) to string pair"""
    return f"{data[0]},{data[1]}"


def points_to_coords(points: str) -> tuple[tuple[float, float], ...]:
    """Convert svg points strings to raw coordinates

    Args:
        points: "x,y x,y ..." svg points strings.

    Returns:
        ((x,y), (x,y), ...) raw coordinates.
    """
    return tuple(map(string_pair_to_float, points.split(" ")))


def coords_to_points(coords: tuple | list) -> str:
    """Convert raw coordinates to svg points strings

    Args:
        coords: ((x,y), (x,y), ...) raw coordinates.

    Returns:
        "x,y x,y ..." svg points strings.
    """
    return " ".join(map(list_pair_to_string, coords))


def load_track_map_file(filepath: str, filename: str, extension: str = FileExt.SVG):
    """Load svg track map file (*.svg)"""
    try:
        dom = xml.dom.minidom.parse(f"{filepath}{filename}{extension}")
        desc_col = dom.documentElement.getElementsByTagName("desc")
        path_col = dom.documentElement.getElementsByTagName("polyline")
        svg_coords = svg_dists = None
        for tags in path_col:
            if tags.getAttribute("id") == "map":
                svg_coords = tags.getAttribute("points")
                continue
            if tags.getAttribute("id") == "dist":
                svg_dists = tags.getAttribute("points")
                continue
        # Convert to coordinates list
        if not isinstance(svg_coords, str):
            raise ValueError
        if not isinstance(svg_dists, str):
            raise ValueError
        raw_coords = points_to_coords(svg_coords)
        raw_dists = points_to_coords(svg_dists)
        sector_index = string_pair_to_int(desc_col[0].childNodes[0].nodeValue)
        return raw_coords, raw_dists, sector_index
    except FileNotFoundError:
        logger.info("MISSING: track map (%s) data", extension)
    except (AttributeError, IndexError, ValueError, xml.parsers.expat.ExpatError):
        logger.info("MISSING: invalid track map (%s) data", extension)
    return None, None, None


def save_track_map_file(
    filepath: str, filename: str, view_box: str,
    raw_coords: tuple, raw_dists: tuple, sector_index: tuple,
    extension: str = FileExt.SVG
) -> None:
    """Save track map file (*.svg)"""
    if invalid_save_name(filename):
        return
    # Convert to svg coordinates
    svg_coords = coords_to_points(raw_coords)
    svg_dists = coords_to_points(raw_dists)
    # Create new svg file
    new_svg = xml.dom.minidom.Document()
    # Create comments
    root_comment = new_svg.createComment(" Track map generated with TinyPedal ")
    new_svg.appendChild(root_comment)
    # Create svg
    root_node = new_svg.createElement("svg")
    root_node.setAttribute("viewBox", view_box)
    root_node.setAttribute("version", "1.1")
    root_node.setAttribute("xmlns", "unlinked: www_w3_org/2000/svg")
    new_svg.appendChild(root_node)
    # Create title
    title_node = new_svg.createElement("title")
    title_text = new_svg.createTextNode(filename)
    title_node.appendChild(title_text)
    root_node.appendChild(title_node)
    # Create desc
    desc_comment = new_svg.createComment(" Sector coordinates index ")
    root_node.appendChild(desc_comment)
    desc_node = new_svg.createElement("desc")
    desc_text = new_svg.createTextNode(f"{sector_index[0]},{sector_index[1]}")
    desc_node.appendChild(desc_text)
    root_node.appendChild(desc_node)
    # Create map
    map_comment = new_svg.createComment(" Raw global coordinates ")
    root_node.appendChild(map_comment)
    map_node = new_svg.createElement("polyline")
    map_node.setAttribute("id", "map")
    map_node.setAttribute("fill", "none")
    map_node.setAttribute("stroke", "black")
    map_node.setAttribute("stroke-width", "10")
    map_node.setAttribute("points", svg_coords)
    root_node.appendChild(map_node)
    # Create distance
    dist_comment = new_svg.createComment(" Raw distance reference points ")
    root_node.appendChild(dist_comment)
    dist_node = new_svg.createElement("polyline")
    dist_node.setAttribute("id", "dist")
    dist_node.setAttribute("fill", "none")
    dist_node.setAttribute("stroke", "none")
    dist_node.setAttribute("stroke-width", "0")
    dist_node.setAttribute("points", svg_dists)
    root_node.appendChild(dist_node)
    # Save svg
    with open(f"{filepath}{filename}{extension}", "w", encoding="utf-8") as svgfile:
        new_svg.writexml(svgfile, indent="", addindent="\t", newl="\n", encoding="utf-8")
        logger.info("USERDATA: %s%s saved", filename, extension)

```

# File: tinypedal/userfile/json_setting.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Setting file function
"""

from __future__ import annotations

import json
import logging
import os
import shutil
from time import localtime, monotonic, sleep, strftime
from typing import Callable

from ..const_file import FileExt
from ..setting_validator import PresetValidator

logger = logging.getLogger(__name__)


def set_backup_timestamp(prefix: str = ".backup-", timestamp: bool = True) -> str:
    """Set backup timestamp"""
    if timestamp:
        time_stamp = strftime("%Y-%m-%d-%H-%M-%S", localtime())
    else:
        time_stamp = ""
    return f"{prefix}{time_stamp}"


def copy_setting(dict_user: dict) -> dict:
    """Copy setting"""
    for item in dict_user.values():
        if isinstance(item, dict):
            return {key: item.copy() for key, item in dict_user.items()}
        break
    return dict_user.copy()


def load_setting_json_file(
    filename: str, filepath: str, dict_def: dict, file_info: str = "user preset",
    validator: Callable[[dict, dict], dict] = PresetValidator.user_preset,
) -> dict:
    """Load setting json file & verify"""
    filename_source = f"{filepath}{filename}"
    try:
        with open(filename_source, "r", encoding="utf-8") as jsonfile:
            setting_user = json.load(jsonfile)
        # Verify & assign setting
        setting_user = validator(setting_user, dict_def)
    except FileNotFoundError:
        logger.info("USERDATA: %s not found, fall back to default", filename)
        setting_user = copy_setting(dict_def)
    except (AttributeError, IndexError, KeyError, TypeError, ValueError, OSError):
        logger.error("USERDATA: %s failed loading, fall back to default", filename)
        create_backup_file(filename, filepath, set_backup_timestamp(), show_log=True)
        setting_user = copy_setting(dict_def)

    logger.info("USERDATA: %s loaded (%s)", filename, file_info)
    return setting_user


def load_style_json_file(
    filename: str, filepath: str, dict_def: dict, file_info: str = "style preset",
    validator: Callable[[dict], bool] | None = None,
) -> dict:
    """Load style json file & verify (optional)"""
    filename_source = f"{filepath}{filename}"
    msg_text = "loaded"
    try:
        with open(filename_source, "r", encoding="utf-8") as jsonfile:
            style_user = json.load(jsonfile)
        # Whether to validate style
        if validator is not None:
            if validator(style_user):
                create_backup_file(filename, filepath, set_backup_timestamp(), show_log=True)
                msg_text = "updated"
    except FileNotFoundError:
        logger.info("USERDATA: %s not found, fall back to default", filename)
        style_user = copy_setting(dict_def)
        msg_text = "updated"
    except (AttributeError, IndexError, KeyError, TypeError, ValueError, OSError):
        logger.error("USERDATA: %s failed loading, fall back to default", filename)
        create_backup_file(filename, filepath, set_backup_timestamp(), show_log=True)
        style_user = copy_setting(dict_def)
        msg_text = "updated"

    if msg_text == "updated":
        save_json_file(style_user, filename, filepath)

    logger.info("USERDATA: %s %s (%s)", filename, msg_text, file_info)
    return style_user


def save_json_file(
    dict_user: dict, filename: str, filepath: str, extension: str = "", compact_json: bool = False
) -> None:
    """Save json file"""
    filename_source = f"{filepath}{filename}{extension}"
    with open(filename_source, "w", encoding="utf-8") as jsonfile:
        if compact_json:
            json.dump(dict_user, jsonfile, separators=(",", ":"))
        else:
            json.dump(dict_user, jsonfile, indent=4)


def verify_json_file(
    dict_user: dict, filename: str, filepath: str, extension: str = ""
) -> bool:
    """Verify saved json file"""
    filename_source = f"{filepath}{filename}{extension}"
    try:
        with open(filename_source, "r", encoding="utf-8") as jsonfile:
            return json.load(jsonfile) == dict_user
    except FileNotFoundError:
        logger.error("USERDATA: not found %s", filename_source)
    except (ValueError, OSError):
        logger.error("USERDATA: unable to verify %s", filename_source)
    return False


def create_backup_file(
    filename: str, filepath: str, extension: str = FileExt.BAK, show_log: bool = False
) -> bool:
    """Create backup file before saving"""
    filename_source = f"{filepath}{filename}"
    filename_backup = f"{filepath}{filename}{extension}"
    try:
        shutil.copyfile(filename_source, filename_backup)
        if show_log:
            logger.info("USERDATA: backup saved %s", filename_backup)
        return True
    except FileNotFoundError:
        logger.error("USERDATA: not found %s", filename_source)
    except PermissionError:
        logger.error("USERDATA: no permission to access %s", filename_source)
    except OSError:
        logger.error("USERDATA: unable to create backup %s", filename_source)
    return False


def restore_backup_file(
    filename: str, filepath: str, extension: str = FileExt.BAK
) -> bool:
    """Restore backup file if saving failed"""
    filename_backup = f"{filepath}{filename}{extension}"
    filename_source = f"{filepath}{filename}"
    try:
        shutil.copyfile(filename_backup, filename_source)
        logger.info("USERDATA: backup restored %s", filename_source)
        return True
    except FileNotFoundError:
        logger.error("USERDATA: backup not found %s", filename_backup)
    except PermissionError:
        logger.error("USERDATA: no permission to access backup %s", filename_backup)
    except OSError:
        logger.error("USERDATA: unable to restore backup %s", filename_backup)
    return False


def copy_and_rename_backup_file(
    filename: str, filepath: str, extension: str = FileExt.BAK
) -> bool:
    """Copy and rename backup file if restoring backup failed"""
    filename_backup = f"{filepath}{filename}{extension}"
    filename_renamed = f"{filepath}{filename}{set_backup_timestamp()}"
    try:
        shutil.copyfile(filename_backup, filename_renamed)
        logger.info("USERDATA: backup renamed %s", filename_renamed)
        return True
    except FileNotFoundError:
        logger.error("USERDATA: backup not found %s", filename_backup)
    except PermissionError:
        logger.error("USERDATA: no permission to access backup %s", filename_backup)
    except OSError:
        logger.error("USERDATA: unable to copy and rename backup %s", filename_backup)
    return False


def delete_backup_file(
    filename: str, filepath: str, extension: str = FileExt.BAK
) -> bool:
    """Delete backup file"""
    filename_backup = f"{filepath}{filename}{extension}"
    try:
        if os.path.exists(filename_backup):
            os.remove(filename_backup)
        return True
    except FileNotFoundError:
        logger.error("USERDATA: backup not found %s", filename_backup)
    except PermissionError:
        logger.error("USERDATA: no permission to access backup %s", filename_backup)
    except OSError:
        logger.error("USERDATA: unable to delete backup %s", filename_backup)
    return False


def save_and_verify_json_file(
    dict_user: dict,
    filename: str,
    filepath: str,
    max_attempts: int = 10,
    compact_json: bool = False,
) -> None:
    """Save and verify json file, backup or restore if saving failed"""
    file_found = os.path.exists(f"{filepath}{filename}")
    # Create backup: abort saving if backup failed; skip backup and create new if not exist
    if not file_found:
        logger.info("USERDATA: %s not found, create new", filename)
    elif not create_backup_file(filename, filepath):
        logger.info("USERDATA: %s saving abort", filename)
        return
    # Start saving attempts
    attempts = max_attempts
    timer_start = monotonic()
    while attempts > 0:
        save_json_file(dict_user, filename, filepath, compact_json=compact_json)
        if verify_json_file(dict_user, filename, filepath):
            break
        attempts -= 1
        logger.error("USERDATA: %s failed saving, %s attempt(s) left", filename, attempts)
        sleep(0.05)
    timer_end = round((monotonic() - timer_start) * 1000)
    # Clean up
    if attempts > 0:
        state_text = "saved"
    else:
        if file_found and not restore_backup_file(filename, filepath):
            copy_and_rename_backup_file(filename, filepath)
        state_text = "failed saving"
    if file_found:
        delete_backup_file(filename, filepath)
    logger.info(
        "USERDATA: %s %s (took %sms, %s/%s attempts)",
        filename,
        state_text,
        timer_end,
        max_attempts - attempts,
        attempts,
    )

```

# File: tinypedal/userfile/track_notes.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Track & pace notes file function
"""

from __future__ import annotations

import csv
import logging
import os
from operator import itemgetter
from typing import Any, Callable, Iterable

from ..const_common import CRLF
from ..const_file import FileFilter

NOTESTYPE_PACE = "Pace Notes"
NOTESTYPE_TRACK = "Track Notes"

COLUMN_DISTANCE = "distance"
COLUMN_PACENOTE = "pace note"
COLUMN_TRACKNOTE = "track note"
COLUMN_COMMENT = "comment"

HEADER_PACE_NOTES = COLUMN_DISTANCE, COLUMN_PACENOTE, COLUMN_COMMENT
HEADER_TRACK_NOTES = COLUMN_DISTANCE, COLUMN_TRACKNOTE, COLUMN_COMMENT

METADATA_FIELDNAMES = "TITLE", "AUTHOR", "DATE", "DESCRIPTION"

logger = logging.getLogger(__name__)


def set_notes_filter(notes_type: str) -> str:
    """Set notes file filter"""
    if notes_type == NOTESTYPE_PACE:
        filter_set = (  # pace notes filters
            FileFilter.TPPN,
            FileFilter.GPLINI,
            FileFilter.CSV,
            FileFilter.INI,
            FileFilter.ALL,
        )
    else:
        filter_set = (  # track notes filters
            FileFilter.TPTN,
            FileFilter.CSV,
            FileFilter.INI,
            FileFilter.ALL,
        )
    return ";;".join(filter_set)


def set_notes_header(notes_type: str) -> tuple[str, ...]:
    """Set notes header"""
    if notes_type == NOTESTYPE_PACE:
        return HEADER_PACE_NOTES
    return HEADER_TRACK_NOTES


def set_notes_parser(file_filter: str) -> Callable:
    """Set notes parser"""
    if file_filter == FileFilter.GPLINI:
        return parse_gpl_notes
    return parse_csv_notes


def set_notes_writer(file_filter: str) -> Callable:
    """Set notes writer"""
    if file_filter == FileFilter.GPLINI:
        return write_gpl_notes
    return write_csv_notes


def create_notes_metadata() -> dict:
    """Create notes metadata"""
    return {key: "" for key in METADATA_FIELDNAMES}


def parse_csv_notes(notes_file: Iterable[str], table_header: tuple[str, ...]):
    """Parse TinyPedal notes"""
    notes_reader = csv.DictReader(
        notes_file, fieldnames=table_header, restval="", restkey="unknown")
    column_key = table_header[0]
    column_value = table_header[1]
    metadata_checked = False
    meta_info = create_notes_metadata()
    notes_temp = []
    for note_line in notes_reader:
        # Load metadata
        if not metadata_checked:
            key = note_line[column_key]
            if key in meta_info:
                meta_info[key] = note_line[column_value]
                continue
            if key == column_key:  # found start of header, set checked
                metadata_checked = True
                continue
        # Load notes
        if verify_notes(note_line, column_key):
            if not metadata_checked:  # found first valid number, set checked
                metadata_checked = True
            notes_temp.append(note_line)
    return sorted(notes_temp, key=itemgetter(column_key)), meta_info


def parse_gpl_notes(notes_file: Iterable[str], table_header: tuple[str, ...]):
    """Parse GPL pace notes"""
    meta_info = create_notes_metadata()
    column_key = table_header[0]
    metadata_checked = False
    notes_temp = []
    for note_line in notes_file:
        # Skip comments and empty lines
        if note_line.startswith(";") or ".mp3" not in note_line:
            # Load metadata
            if not metadata_checked:
                for meta_key in meta_info:
                    if meta_key in note_line:
                        meta_info[meta_key] = note_line.lstrip(f";{meta_key}:").strip()
                        continue
            continue
        # Parse notes
        split_line = note_line.rstrip().split(",", 1)
        pace_note = split_line[0].strip()[:-4]  # strip extension
        if len(split_line) > 1:
            if not metadata_checked:  # found first valid number, set checked
                metadata_checked = True
            split_string = split_line[-1].split(";", 1)
            distance = float(split_string[0].strip())
            if len(split_string) > 1:
                annotation = split_string[1].strip()
            else:
                annotation = ""
            notes_temp.append(
                {
                    table_header[0]: distance,
                    table_header[1]: pace_note,
                    table_header[2]: annotation,
                }
            )
    return sorted(notes_temp, key=itemgetter(column_key)), meta_info


def parse_csv_notes_only(notes_file: Iterable[str], table_header: tuple[str, ...]):
    """Parse TinyPedal notes without metadata"""
    column_key = table_header[0]
    notes_read = csv.DictReader(
        notes_file, fieldnames=table_header, restval="", restkey="unknown")
    lastlist = (note_line for note_line in notes_read if verify_notes(note_line, column_key))
    return sorted(lastlist, key=itemgetter(column_key))


def load_notes_file(
    filepath: str, filename: str, table_header: tuple[str, ...],
    parser: Callable = parse_csv_notes, extension: str = ""):
    """Load notes file"""
    try:
        filename_full = f"{filepath}{filename}{extension}"
        if os.path.getsize(filename_full) > 1024000:  # limit file size under 1024kb
            raise TypeError

        with open(filename_full, newline="", encoding="utf-8") as temp_file:
            return parser(temp_file, table_header)

    except FileNotFoundError:
        logger.info("MISSING: track notes (%s) data", extension)
    except (AttributeError, IndexError, KeyError, TypeError, ValueError, OSError):
        logger.info("MISSING: invalid track notes (%s) data", extension)
    return None


def write_csv_notes(
    notes_file: Any, table_header: tuple, dataset: list, metadata: dict, _: str):
    """Write TinyPedal notes format to file"""
    # Write TinyPedal file version
    notes_file.write(f"TINYPEDAL {table_header[1].upper()}S FILE VERSION,1")
    notes_file.write(CRLF * 2)
    # Write metadata
    meta_output = CRLF.join(f"{key},\"{value}\"" for key, value in metadata.items())
    notes_file.write(meta_output)
    notes_file.write(CRLF * 2)
    # Write notes
    notes_writer = csv.DictWriter(
        notes_file, fieldnames=table_header, extrasaction="ignore", quoting=csv.QUOTE_MINIMAL
    )
    notes_writer.writeheader()
    notes_writer.writerows(dataset)


def write_gpl_notes(
    notes_file: Any, table_header: tuple, dataset: list, metadata: dict, filename: str):
    """Write GPL pace notes format to file

    Pace notes formatting follows GPL pace notes 'Version 3' specification by Lee Bowden.
    """
    # Write metadata
    meta_output = CRLF.join(f";{key}: {value}" for key, value in metadata.items())
    line_separator = f";{'*' * 27}{CRLF}"
    notes_file.write(line_separator)
    notes_file.write(f";GPL PACE NOTES .INI FILE  Version 3{CRLF}")
    notes_file.write(f";{filename[:-4]}{CRLF}")
    notes_file.write(line_separator)
    notes_file.write(CRLF)
    notes_file.write(meta_output)
    notes_file.write(CRLF * 2)
    notes_file.write(line_separator)
    notes_file.write(CRLF)
    notes_file.write(f";Any line beginning with a ; is a comment and is ignored{CRLF}")
    notes_file.write(f";Any information to the right of a ; is a comment and is ignored{CRLF}")
    notes_file.write(f";Any line beginning with a space is ignored{CRLF}")
    notes_file.write(CRLF)
    notes_file.write(line_separator)
    notes_file.write(CRLF)
    notes_file.write(f";This section contains the sound entries with:{CRLF}")
    notes_file.write(f";1) Sound filename including the .mp3 suffix{CRLF}")
    notes_file.write(f";2) Distance in meters from the track start point to play the sound{CRLF}")
    notes_file.write(CRLF)
    notes_file.write(line_separator)
    notes_file.write(CRLF)
    # Write notes
    for note_line in dataset:
        notes_file.write(
            f"{note_line[table_header[1]]}.mp3, "  # sound file name
            f"{note_line[table_header[0]]:.0f}; "  # distance integer
            f"{note_line[table_header[2]]}{CRLF}"  # comment
        )
    notes_file.write(CRLF)


def save_notes_file(
    filepath: str, filename: str, table_header: tuple, dataset: list, metadata: dict,
    writer: Callable = write_csv_notes, extension: str = ""
) -> None:
    """Save notes file"""
    if len(dataset) < 1:
        return
    with open(f"{filepath}{filename}{extension}", "w", newline="", encoding="utf-8") as temp_file:
        writer(temp_file, table_header, dataset, metadata, filename)


def verify_notes(note_line: dict, column_key: str) -> bool:
    """Verify notes and show errors"""
    try:
        note_line[column_key] = float(note_line[column_key])
        return True
    except (KeyError, ValueError):
        return False

```

# File: tinypedal/widget/__init__.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Widget modules

Add new widget to import list below in ascending order,
file name must match corresponding key name
in template/setting_widget.py dictionary.
"""

__all__ = [
    "battery",
    "brake_bias",
    "brake_performance",
    "brake_pressure",
    "brake_temperature",
    "brake_wear",
    "cruise",
    "damage",
    "deltabest",
    "deltabest_extended",
    "differential",
    "drs",
    "electric_motor",
    "elevation",
    "engine",
    "flag",
    "force",
    "friction_circle",
    "fuel",
    "fuel_energy_saver",
    "gear",
    "heading",
    "instrument",
    "lap_time_history",
    "laps_and_position",
    "navigation",
    "p2p",
    "pace_notes",
    "pedal",
    "pit_stop_estimate",
    "radar",
    "rake_angle",
    "relative",
    "relative_finish_order",
    "ride_height",
    "rivals",
    "roll_angle",
    "rpm_led",
    "sectors",
    "session",
    "slip_ratio",
    "speedometer",
    "standings",
    "steering",
    "steering_wheel",
    "stint_history",
    "suspension_force",
    "suspension_position",
    "suspension_travel",
    "system_performance",
    "timing",
    "track_map",
    "track_notes",
    "trailing",
    "tyre_carcass",
    "tyre_inner_layer",
    "tyre_load",
    "tyre_pressure",
    "tyre_temperature",
    "tyre_wear",
    "virtual_energy",
    "weather",
    "weather_forecast",
    "weight_distribution",
    "wheel_camber",
    "wheel_toe",
]

from . import *

```

# File: tinypedal/widget/_common.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Overlay base common class.
"""

from __future__ import annotations

from time import monotonic
from typing import NamedTuple

from PySide2.QtCore import QPoint
from PySide2.QtWidgets import QApplication, QFrame, QLabel, QWidget


class FontMetrics(NamedTuple):
    """Font metrics info"""

    width: int = 0
    height: int = 0
    leading: int = 0
    capital: int = 0
    descent: int = 0


class ExLabel(QLabel):
    """Extended label"""

    def __init__(self, parent):
        super().__init__(parent)
        self.last = None
        self._style_hash = 0

    def updateStyle(self, style_sheet: str):
        """Update only if style changed"""
        style_hash = hash(style_sheet)
        if self._style_hash != style_hash:
            self._style_hash = style_hash
            self.setStyleSheet(style_sheet)


class ExFrame(QFrame):
    """Extended frame"""

    def __init__(self, parent):
        super().__init__(parent)
        self.last = None
        self._style_hash = 0

    def updateStyle(self, style_sheet: str):
        """Update only if style changed"""
        style_hash = hash(style_sheet)
        if self._style_hash != style_hash:
            self._style_hash = style_hash
            self.setStyleSheet(style_sheet)


class MousePosition:
    """Mouse position & snapping"""

    __slots__ = (
        "_init_pos",
        "_grid_x",
        "_grid_y",
        "_delta_x",
        "_delta_y",
        "_last_x",
        "_last_y",
        "_screen_name",
        "_grid_move",
        "_grid_size",
        "_snap_gap",
        "_snap_distance",
    )

    def __init__(self):
        self.reset()

    def reset(self):
        """Reset"""
        self._init_pos = None
        self._grid_x = None
        self._grid_y = None
        self._delta_x = 0
        self._delta_y = 0
        self._last_x = 0
        self._last_y = 0
        self._screen_name = None
        self._grid_move = False
        self._grid_size = 1
        self._snap_gap = 0
        self._snap_distance = 0

    def valid(self) -> bool:
        """Is initial position valid"""
        return isinstance(self._init_pos, QPoint)

    def config(self, init_pos: QPoint, grid_move: bool, grid_size: int, snap_gap: int, snap_distance: int):
        """Config mouse move"""
        self._init_pos = init_pos
        self._grid_move = grid_move
        self._grid_size = max(grid_size, 1)
        self._snap_gap = max(0, snap_gap)
        self._snap_distance = max(snap_gap, snap_distance)

    def update_grid(self, widget: QWidget):
        """Update widget snap position grid"""
        # Update grid if active screen name changed
        screen = widget.screen()
        if self._screen_name == screen.name():
            return
        self._screen_name = screen.name()
        # Restricted screen area (excludes task bar, system menu, etc)
        scr_x, scr_y, scr_width, scr_height = screen.availableGeometry().getRect()
        # Full screen area
        scrfull_x, scrfull_y, scrfull_width, scrfull_height = screen.geometry().getRect()
        # Update grid set (avoid duplicates)
        x_grid = {scr_x, scr_x + scr_width, scrfull_x, scrfull_x + scrfull_width}
        y_grid = {scr_y, scr_y + scr_height, scrfull_y, scrfull_y + scrfull_height}
        # Add widget x, y coords
        try:
            for other_widget in QApplication.topLevelWidgets():
                if (
                    not hasattr(other_widget, "widget_name")
                    or widget is other_widget
                    or not other_widget.isVisible()
                    or screen is not other_widget.screen()
                ):
                    continue
                other_x, other_y, other_width, other_height = other_widget.geometry().getRect()
                x_grid.add(other_x)
                x_grid.add(other_x + other_width)
                y_grid.add(other_y)
                y_grid.add(other_y + other_height)
        except (RuntimeError, AttributeError, TypeError, ValueError):
            pass
        # Sort grid (necessary to avoid snapping jumping)
        self._grid_x = sorted(x_grid)
        self._grid_y = sorted(y_grid)

    def moving(self, global_pos: QPoint) -> QPoint:
        """Moving position"""
        pos = global_pos - self._init_pos
        if self._grid_move:
            return pos / self._grid_size * self._grid_size
        return pos

    def snapping(self, widget: QWidget, global_pos: QPoint) -> QPoint:
        """Snapping to reference grid"""
        self.update_grid(widget)
        # Update delta since last pos
        pos = global_pos - self._init_pos
        new_x = pos.x()
        new_y = pos.y()
        widget_width = widget.width()
        widget_height = widget.height()
        self._delta_x = min(max(new_x - self._last_x + self._delta_x, -5), 5)
        self._delta_y = min(max(new_y - self._last_y + self._delta_y, -5), 5)
        self._last_x = new_x
        self._last_y = new_y
        # Horizontal snap
        if self._delta_x < 0:  # moving left
            x_left = new_x
            for x_pos_other in self._grid_x:
                if abs(x_left - x_pos_other) < self._snap_distance:
                    new_x = x_pos_other + self._snap_gap
        elif self._delta_x > 0:  # moving right
            x_right = new_x + widget_width
            for x_pos_other in self._grid_x:
                if abs(x_right - x_pos_other) < self._snap_distance:
                    new_x = x_pos_other - widget_width - self._snap_gap
        # Vertical snap
        if self._delta_y < 0:  # moving up
            y_top = new_y
            for y_pos_other in self._grid_y:
                if abs(y_top - y_pos_other) < self._snap_distance:
                    new_y = y_pos_other + self._snap_gap
        elif self._delta_y > 0:  # moving down
            y_bottom = new_y + widget_height
            for y_pos_other in self._grid_y:
                if abs(y_bottom - y_pos_other) < self._snap_distance:
                    new_y = y_pos_other - widget_height - self._snap_gap
        # Update pos
        pos.setX(new_x)
        pos.setY(new_y)
        return pos


class WarningFlash:
    """Warning flash state"""

    __slots__ = (
        "_last_condition",
        "_highlight",
        "_highlight_seconds",
        "_highlight_timer",
        "_interval_seconds",
        "_interval_timer",
        "_flash_count",
        "_flash_max",
    )

    def __init__(self, duration: float, interval: float, max_count: int):
        self._last_condition = False
        self._highlight = False
        self._highlight_seconds = max(duration, 0.2)
        self._highlight_timer = 0.0
        self._interval_seconds = max(interval, 0.2)
        self._interval_timer = 0.0
        self._flash_count = 0
        self._flash_max = max(max_count, 3)

    def state(self, condition: bool) -> bool:
        """Update warning flash state"""
        elapsed = monotonic()

        if self._last_condition != condition:
            self._last_condition = condition
            if condition:
                self._highlight_timer = elapsed
                self._highlight = False
                self._interval_timer = 0
                self._flash_count = 0

        if not condition:
            return False
        elif self._flash_count >= self._flash_max:
            return True

        if elapsed - self._highlight_timer < self._highlight_seconds:
            if not self._highlight:
                self._flash_count += 1
            self._highlight = True
            self._interval_timer = elapsed
        else:
            self._highlight = False
            if elapsed - self._interval_timer >= self._interval_seconds:
                self._highlight_timer = elapsed

        return self._highlight

```

# File: tinypedal/widget/_painter.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Overlay base painter class.
"""

from __future__ import annotations

from PySide2.QtCore import QRectF, Qt
from PySide2.QtGui import QFont, QPainter, QPen, QPixmap
from PySide2.QtWidgets import QWidget

from ..const_common import GEAR_SEQUENCE


def split_pixmap_icon(
    pixmap_icon: QPixmap, icon_size: int, h_offset: int = 0, v_offset: int = 0) -> QPixmap:
    """Split pixmap icon set"""
    pixmap = QPixmap(icon_size, icon_size)
    pixmap.fill(Qt.transparent)
    painter = QPainter(pixmap)
    painter.drawPixmap(0, 0, pixmap_icon, icon_size * h_offset, icon_size * v_offset, 0, 0)
    return pixmap


class WheelGaugeBar(QWidget):
    """Wheel gauge bar"""

    def __init__(
        self,
        parent,
        padding_x: int,
        bar_width: int,
        bar_height: int,
        font_offset: int = 0,
        display_range: int = 100,
        input_color: str = "",
        fg_color: str = "",
        bg_color: str = "",
        mark_width: int = 0,
        mark_color: str = "",
        maxrange_height: int = 0,
        maxrange_color: str = "",
        right_side: bool = False,
        top_side: bool = True,
    ):
        super().__init__(parent)
        self.last = -1
        self.display_range = display_range
        self.width_scale = bar_width / self.display_range
        self.input_color = input_color
        self.bg_color = bg_color
        self.mark_color = mark_color
        self.maxrange_color = maxrange_color
        self.rect_bg = QRectF(0, 0, bar_width, bar_height)
        self.rect_input = self.rect_bg.adjusted(0, 0, 0, 0)
        self.rect_text = self.rect_bg.adjusted(padding_x, font_offset, -padding_x, 0)
        self.right_side = right_side

        if self.mark_color:
            self.rect_mark = QRectF(0, 0, mark_width, bar_height)
        else:
            self.rect_mark = self.rect_bg

        if self.maxrange_color:
            if top_side:
                self.rect_max = QRectF(0, 0, bar_width, maxrange_height)
            else:
                self.rect_max = QRectF(0, bar_height - maxrange_height, bar_width, maxrange_height)
            if right_side:
                self.rect_max.setWidth(0)
            else:
                self.rect_max.setX(bar_width)
        else:
            self.rect_max = self.rect_bg

        if right_side:
            self.align = Qt.AlignRight | Qt.AlignVCenter
        else:
            self.align = Qt.AlignLeft | Qt.AlignVCenter

        self.pen = QPen()
        self.pen.setColor(fg_color)
        self.setFixedSize(bar_width, bar_height)

    def update_input(self, input_value: float):
        """Update input value"""
        if self.right_side:
            self.rect_input.setWidth(input_value * self.width_scale)
        else:
            self.rect_input.setX((self.display_range - input_value) * self.width_scale)
        self.update()

    def update_mark(self, mark_value: float):
        """Update mark"""
        if self.right_side:
            self.rect_mark.moveRight(mark_value * self.width_scale)
        else:
            self.rect_mark.moveLeft((self.display_range - mark_value) * self.width_scale)

    def update_maxrange(self, input_value: float):
        """Update max range"""
        if self.right_side:
            self.rect_max.setWidth(input_value * self.width_scale)
        else:
            self.rect_max.setX((self.display_range - input_value) * self.width_scale)

    def paintEvent(self, event):
        """Draw normal without warning or negative highlighting"""
        painter = QPainter(self)
        painter.fillRect(self.rect_bg, self.bg_color)
        painter.fillRect(self.rect_input, self.input_color)
        if self.mark_color:
            painter.fillRect(self.rect_mark, self.mark_color)
        if self.maxrange_color:
            painter.fillRect(self.rect_max, self.maxrange_color)
        painter.setPen(self.pen)
        painter.drawText(self.rect_text, self.align, f"{self.last:.0f}")


class PedalInputBar(QWidget):
    """Pedal input bar"""

    def __init__(
        self,
        parent,
        pedal_length: int,
        pedal_extend: int,
        pedal_size: tuple[int, int, int, int],
        raw_size: tuple[int, int, int, int],
        filtered_size: tuple[int, int, int, int],
        max_size: tuple[int, int, int, int],
        reading_size: tuple[int, int, int, int],
        fg_color: str = "",
        bg_color: str = "",
        input_color: str = "",
        ffb_color: str = "",
        show_reading: bool = False,
        horizontal_style: bool = False,
    ):
        super().__init__(parent)
        self.last = None
        self.is_maxed = False
        self.show_reading = show_reading
        self.input_reading = 0.0
        self.pedal_length = pedal_length
        self.pedal_extend = pedal_extend
        self.input_color = input_color
        self.bg_color = bg_color
        self.rect_pedal = QRectF(*pedal_size)
        self.rect_raw = QRectF(*raw_size)
        self.rect_filtered = QRectF(*filtered_size)
        self.rect_text = QRectF(*reading_size)
        self.horizontal_style = horizontal_style

        if ffb_color:
            self.rect_max = self.rect_pedal
            self.max_color = ffb_color
        else:
            self.rect_max = QRectF(*max_size)
            self.max_color = input_color

        self.pen = QPen()
        self.pen.setColor(fg_color)
        self.setFixedSize(pedal_size[2], pedal_size[3])

    def update_input(self, input_raw: float, input_filtered: float):
        """Update input value - horizontal style"""
        self.input_reading = max(input_raw, input_filtered) * 100
        if self.horizontal_style:
            scaled_raw = self.__scale_horizontal(input_raw)
            scaled_filtered = self.__scale_horizontal(input_filtered)
            self.rect_raw.setRight(scaled_raw)
            self.rect_filtered.setRight(scaled_filtered)
            self.is_maxed = scaled_raw >= self.pedal_length
        else:
            scaled_raw = self.__scale_vertical(input_raw)
            scaled_filtered = self.__scale_vertical(input_filtered)
            self.rect_raw.setTop(scaled_raw)
            self.rect_filtered.setTop(scaled_filtered)
            self.is_maxed = scaled_raw <= self.pedal_extend
        self.update()

    def __scale_horizontal(self, input_value: float) -> float:
        """Scale input - horizontal style"""
        return input_value * self.pedal_length

    def __scale_vertical(self, input_value: float) -> float:
        """Scale input - vertical style"""
        return (1 - input_value) * self.pedal_length + self.pedal_extend

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.fillRect(self.rect_pedal, self.bg_color)
        painter.fillRect(self.rect_raw, self.input_color)
        painter.fillRect(self.rect_filtered, self.input_color)
        if self.is_maxed:
            painter.fillRect(self.rect_max, self.max_color)
        if self.show_reading:
            painter.setPen(self.pen)
            painter.drawText(self.rect_text, Qt.AlignCenter, f"{self.input_reading:.0f}")


class ProgressBar(QWidget):
    """Progress bar"""

    def __init__(
        self,
        parent,
        width: int,
        height: int,
        offset_x: int,
        offset_y: int,
        font: QFont,
        input_color: str = "",
        fg_color: str = "",
        bg_color: str = "",
        decimals: int = 0,
        show_reading: bool = False,
        align: Qt.Alignment = Qt.AlignCenter,
        right_side: bool = False,
    ):
        super().__init__(parent)
        self.last = -1
        self.input_reading = 0.0
        if show_reading:
            height = max(font.pixelSize(), height)
            self.setFont(font)
        self.bar_width = width
        self.rect_bar = QRectF(0, 0, width, height)
        self.rect_input = QRectF(0, 0, width, height)
        self.rect_text = QRectF(width * (offset_x - 0.5), offset_y, width, height)
        self.input_color = input_color
        self.bg_color = bg_color
        self.show_reading = show_reading
        self.align = align
        self.right_side = right_side
        self.pen = QPen()
        self.pen.setColor(fg_color)
        self.decimals = max(decimals, 0)
        self.setFixedSize(width, height)

    def update_input(self, input_value: float, input_reading: float):
        """Update input"""
        self.input_reading = input_reading
        if self.right_side:
            self.rect_input.setLeft((1 - input_value) * self.bar_width)
        else:
            self.rect_input.setRight(input_value * self.bar_width)
        self.update()

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.fillRect(self.rect_bar, self.bg_color)
        painter.fillRect(self.rect_input, self.input_color)
        if self.show_reading:
            painter.setPen(self.pen)
            painter.drawText(self.rect_text, self.align, f"{self.input_reading:.{self.decimals}f}")


class FuelLevelBar(QWidget):
    """Fuel level bar"""

    def __init__(
        self,
        parent,
        width: int,
        height: int,
        start_mark_width: int,
        refill_mark_width: int,
        input_color: str = "",
        bg_color: str = "",
        start_mark_color: str = "",
        refill_mark_color: str = "",
        show_start_mark: bool = True,
        show_refill_mark: bool = True,
    ):
        super().__init__(parent)
        self.last = None
        self.bar_width = width
        self.rect_bar = QRectF(0, 0, width, height)
        self.rect_input = QRectF(0, 0, width, height)
        self.rect_start = QRectF(0, 0, start_mark_width, height)
        self.rect_refuel = QRectF(0, 0, refill_mark_width, height)
        self.input_color = input_color
        self.bg_color = bg_color
        self.start_mark_color = start_mark_color
        self.refill_mark_color = refill_mark_color
        self.show_start_mark = show_start_mark
        self.show_refill_mark = show_refill_mark
        self.setFixedSize(width, height)

    def update_input(self, input_value: float, start_value: float, refill_value: float):
        """Update input"""
        self.rect_input.setRight(input_value * self.bar_width)
        self.rect_start.moveLeft(start_value * self.bar_width)
        self.rect_refuel.moveLeft(refill_value * self.bar_width)
        self.update()

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.fillRect(self.rect_bar, self.bg_color)
        painter.fillRect(self.rect_input, self.input_color)
        if self.show_start_mark:
            painter.fillRect(self.rect_start, self.start_mark_color)
        if self.show_refill_mark:
            painter.fillRect(self.rect_refuel, self.refill_mark_color)


class GearGaugeBar(QWidget):
    """Gear gauge bar"""

    def __init__(
        self,
        parent,
        width: int,
        height: int,
        font_speed: QFont,
        gear_size: tuple[int, int, int, int],
        speed_size: tuple[int, int, int, int],
        fg_color: str,
        bg_color: str,
        show_speed: bool = True,
    ):
        super().__init__(parent)
        self.last = -1
        self.gear = "N"
        self.speed = 0
        self.color_index = 0
        self.show_speed = show_speed
        self.font_speed = font_speed
        self.bg_color = bg_color
        self.rect_gear = QRectF(*gear_size)
        self.rect_speed = QRectF(*speed_size)
        self.rect_bar = QRectF(0, 0, width, height)

        self.pen = QPen()
        self.pen.setColor(fg_color)
        self.setFixedSize(width, height)

    def update_input(self, gear: int, speed: int, color_index: int, bg_color: str):
        """Update input"""
        self.gear = GEAR_SEQUENCE(gear, "N")
        self.speed = speed
        self.color_index = color_index
        self.bg_color = bg_color
        self.update()

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.fillRect(self.rect_bar, self.bg_color)
        if self.color_index == -4:  # flicker trigger
            return
        painter.setPen(self.pen)
        painter.drawText(self.rect_gear, Qt.AlignCenter, self.gear)
        if self.show_speed:
            painter.setFont(self.font_speed)
            painter.drawText(self.rect_speed, Qt.AlignCenter, f"{self.speed:03.0f}")


class TextBar(QWidget):
    """Text bar"""

    def __init__(
        self,
        parent,
        width: int,
        height: int,
        font_offset: int,
        fg_color: str,
        bg_color: str,
        text: str = "",
    ):
        super().__init__(parent)
        self.last = -1
        self.text = text
        self.fg_color = fg_color
        self.bg_color = bg_color
        self.rect_bar = QRectF(0, 0, width, height)
        self.rect_text = self.rect_bar.adjusted(0, font_offset, 0, 0)
        self.setFixedSize(width, height)

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.fillRect(self.rect_bar, self.bg_color)
        pen = QPen()
        pen.setColor(self.fg_color)
        painter.setPen(pen)
        painter.drawText(self.rect_text, Qt.AlignCenter, self.text)

```

# File: tinypedal/widget/battery.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Battery Widget
"""

from ..module_info import minfo
from ._base import Overlay
from ._common import WarningFlash


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 8 + bar_padx
        self.freeze_duration = min(max(self.wcfg["freeze_duration"], 0), 30)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Battery charge
        if self.wcfg["show_battery_charge"]:
            self.bar_style_charge = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_battery_charge"],
                    bg_color=self.wcfg["bkg_color_battery_charge"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_battery_charge"],
                    bg_color=self.wcfg["warning_color_low_battery"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_battery_charge"],
                    bg_color=self.wcfg["warning_color_high_battery"])
            )
            self.bar_charge = self.set_qlabel(
                text="BATTERY",
                style=self.bar_style_charge[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_charge,
                column=self.wcfg["column_index_battery_charge"],
            )

        # Battery drain
        if self.wcfg["show_battery_drain"]:
            bar_style_drain = self.set_qss(
                fg_color=self.wcfg["font_color_battery_drain"],
                bg_color=self.wcfg["bkg_color_battery_drain"]
            )
            self.bar_drain = self.set_qlabel(
                text="B DRAIN",
                style=bar_style_drain,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_drain,
                column=self.wcfg["column_index_battery_drain"],
            )

        # Battery regen
        if self.wcfg["show_battery_regen"]:
            bar_style_regen = self.set_qss(
                fg_color=self.wcfg["font_color_battery_regen"],
                bg_color=self.wcfg["bkg_color_battery_regen"]
            )
            self.bar_regen = self.set_qlabel(
                text="B REGEN",
                style=bar_style_regen,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_regen,
                column=self.wcfg["column_index_battery_regen"],
            )

        # Battery charge net change
        if self.wcfg["show_estimated_net_change"]:
            bar_style_net = self.set_qss(
                fg_color=self.wcfg["font_color_estimated_net_change"],
                bg_color=self.wcfg["bkg_color_estimated_net_change"]
            )
            self.bar_net = self.set_qlabel(
                text="B   NET",
                style=bar_style_net,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_net,
                column=self.wcfg["column_index_estimated_net_change"],
            )

        # Activation timer
        if self.wcfg["show_activation_timer"]:
            bar_style_timer = self.set_qss(
                fg_color=self.wcfg["font_color_activation_timer"],
                bg_color=self.wcfg["bkg_color_activation_timer"]
            )
            self.bar_timer = self.set_qlabel(
                text="B TIMER",
                style=bar_style_timer,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_timer,
                column=self.wcfg["column_index_activation_timer"],
            )

        if self.wcfg["show_battery_charge_warning_flash"]:
            self.warn_flash = WarningFlash(
                self.wcfg["warning_flash_highlight_duration"],
                self.wcfg["warning_flash_interval"],
                self.wcfg["number_of_warning_flashes"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Battery charge & usage
        if self.wcfg["show_battery_charge"]:
            battery_charge = minfo.hybrid.batteryCharge

            if battery_charge >= self.wcfg["high_battery_threshold"]:
                batt_warning = 2
            elif battery_charge <= self.wcfg["low_battery_threshold"]:
                batt_warning = 1
            else:
                batt_warning = 0

            if self.wcfg["show_battery_charge_warning_flash"]:
                batt_highlight = self.warn_flash.state(batt_warning)
                if batt_highlight:
                    padding = 0.00000001  # add padding for switching state
                else:
                    batt_warning = 0
                    padding = 0
            else:
                padding = 0

            self.update_charge(self.bar_charge, battery_charge + padding, self.bar_style_charge[batt_warning])

        if 0 <= minfo.delta.lapTimeCurrent < self.freeze_duration:
            battery_drain = minfo.hybrid.batteryDrainLast
            battery_regen = minfo.hybrid.batteryRegenLast
        else:
            battery_drain = minfo.hybrid.batteryDrain
            battery_regen = minfo.hybrid.batteryRegen

        if self.wcfg["show_battery_drain"]:
            self.update_drain(self.bar_drain, battery_drain)

        if self.wcfg["show_battery_regen"]:
            self.update_regen(self.bar_regen, battery_regen)

        if self.wcfg["show_estimated_net_change"]:
            net_change = minfo.hybrid.batteryNetChange
            self.update_net(self.bar_net, net_change)

        # Motor activation timer
        if self.wcfg["show_activation_timer"]:
            active_timer = minfo.hybrid.motorActiveTimer
            self.update_timer(self.bar_timer, active_timer)

    # GUI update methods
    def update_charge(self, target, data, color):
        """Battery charge"""
        if target.last != data:
            target.last = data
            target.setText(f"B{data: >7.2f}"[:8])
            target.updateStyle(color)

    def update_drain(self, target, data):
        """Battery drain"""
        if target.last != data:
            target.last = data
            target.setText(f"-{data: >7.2f}"[:8])

    def update_regen(self, target, data):
        """Battery regen"""
        if target.last != data:
            target.last = data
            target.setText(f"+{data: >7.2f}"[:8])

    def update_net(self, target, data):
        """Battery charge net change"""
        if target.last != data:
            target.last = data
            target.setText(f"N{data: >+7.2f}"[:8])

    def update_timer(self, target, data):
        """Motor activation timer"""
        if target.last != data:
            target.last = data
            target.setText(f"{data: >7.2f}s"[:8])

```

# File: tinypedal/widget/brake_bias.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Brake bias Widget
"""

from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.decimals_bias = max(self.wcfg["decimal_places_brake_bias"], 0)
        self.decimals_delta = max(self.wcfg["decimal_places_baseline_bias_delta"], 0)
        self.decimals_migt = max(self.wcfg["decimal_places_brake_migration"], 1)
        self.prefix_bias = self.wcfg["prefix_brake_bias"]
        self.prefix_delta = self.wcfg["prefix_baseline_bias_delta"]
        self.prefix_migt = self.wcfg["prefix_brake_migration"]
        self.suffix_migt = self.wcfg["suffix_brake_migration"]
        self.sign_text = "%" if self.wcfg["show_percentage_sign"] else ""

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Brake bias
        text_bbias = self.format_brake_bias(0.5)
        bar_style_bbias = self.set_qss(
            fg_color=self.wcfg["font_color_brake_bias"],
            bg_color=self.wcfg["bkg_color_brake_bias"]
        )
        self.bar_bbias = self.set_qlabel(
            text=text_bbias,
            style=bar_style_bbias,
            width=font_m.width * len(text_bbias) + bar_padx,
        )
        self.set_primary_orient(
            target=self.bar_bbias,
            column=self.wcfg["column_index_brake_bias"],
        )

        # Baseline bias delta
        if self.wcfg["show_baseline_bias_delta"]:
            text_delta = self.format_bias_delta(0)
            bar_style_delta = self.set_qss(
                fg_color=self.wcfg["font_color_baseline_bias_delta"],
                bg_color=self.wcfg["bkg_color_baseline_bias_delta"]
            )
            self.bar_delta = self.set_qlabel(
                text=text_delta,
                style=bar_style_delta,
                width=font_m.width * len(text_delta) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_delta,
                column=self.wcfg["column_index_baseline_bias_delta"],
            )

        # Brake migration
        if self.wcfg["show_brake_migration"]:
            text_bmigt = self.format_brake_migt(0)
            bar_style_bmigt = self.set_qss(
                fg_color=self.wcfg["font_color_brake_migration"],
                bg_color=self.wcfg["bkg_color_brake_migration"]
            )
            self.bar_bmigt = self.set_qlabel(
                text=text_bmigt,
                style=bar_style_bmigt,
                width=font_m.width * len(text_bmigt) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_bmigt,
                column=self.wcfg["column_index_brake_migration"],
            )

        # Last data
        self.baseline_bias = 0
        self.brake_bmigt = BrakeMigration(self.wcfg["electric_braking_allocation"])

    def post_update(self):
        self.brake_bmigt.reset()

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Brake bias
        bbias = api.read.brake.bias_front()
        self.update_bbias(self.bar_bbias, bbias)

        # Baseline bias delta
        if self.wcfg["show_baseline_bias_delta"]:
            if (not self.baseline_bias  # in case not start from pit
                or ((api.read.vehicle.in_pits() or api.read.session.pre_race())
                     and api.read.vehicle.speed() < 0.1)):
                self.baseline_bias = bbias

            self.update_delta(self.bar_delta, bbias - self.baseline_bias)

        # Brake migration
        if self.wcfg["show_brake_migration"]:
            bmigt = self.brake_bmigt.calc(
                api.read.inputs.brake_raw(),
                bbias,
                api.read.brake.pressure()
            )
            self.update_bmigt(self.bar_bmigt, bmigt)

    # GUI update methods
    def update_bbias(self, target, data):
        """Brake bias"""
        if target.last != data:
            target.last = data
            target.setText(self.format_brake_bias(data))

    def update_delta(self, target, data):
        """Baseline bias delta"""
        if target.last != data:
            target.last = data
            target.setText(self.format_bias_delta(data))

    def update_bmigt(self, target, data):
        """Brake migration"""
        if target.last != data:
            target.last = data
            target.setText(self.format_brake_migt(data))

    # Additional methods
    def format_brake_bias(self, value: float) -> str:
        """Format brake bias"""
        value *= 100
        front = f"{self.prefix_bias}{value:02.{self.decimals_bias}f}"
        if self.wcfg["show_front_and_rear"]:
            return f"{front}:{100 - value:02.{self.decimals_bias}f}"
        return f"{front}{self.sign_text}"

    def format_bias_delta(self, value: float) -> str:
        """Format baseline bias delta"""
        return f"{self.prefix_delta}{value * 100:+01.{self.decimals_delta}f}"

    def format_brake_migt(self, value: float) -> str:
        """Format brake migration"""
        reading = f"{value * 100:.{self.decimals_migt}f}"[:2 + self.decimals_migt]
        return f"{self.prefix_migt}{reading}{self.suffix_migt}"


class BrakeMigration:
    """Brake migration detection & calculation"""

    __slots__ = (
        "_bpres_max",
        "_bpres_scale",
        "_ebrake_alloc",
        "_auto_detect",
    )

    def __init__(self, ebrake_alloc: int) -> None:
        """
        Args:
            ebrake_alloc: electric braking allocation, -1 = auto detect, 0 = front, 1 = rear.
        """
        self._bpres_max = 0.0
        self._bpres_scale = 1.0
        self._ebrake_alloc = ebrake_alloc
        self._auto_detect = bool(ebrake_alloc == -1)

    def calc(self, brake_raw: float, brake_bias: float, brake_pres: list) -> float:
        """Calculate brake migration

        Args:
            brake_raw: raw brake input.
            brake_bias: front brake bias (fraction).
            brake_pres: brake pressure (4 tyres).

        Returns:
            Brake migration (fraction).
        """
        bpres_sum = sum(brake_pres)

        if self._bpres_max < bpres_sum:
            self._bpres_max = bpres_sum
            self._bpres_scale = 2 / bpres_sum

        if brake_raw > max(brake_pres) > 0:
            max_front = max(brake_pres[:2])
            max_rear = max(brake_pres[2:])

            if self._auto_detect and minfo.hybrid.motorState == 3 and max_rear > 0:
                max_brake_ratio = max_front / max_rear
                if max_brake_ratio < 0.25:
                    self._ebrake_alloc = 0  # front ebrake
                elif max_brake_ratio > 4:
                    self._ebrake_alloc = 1  # rear ebrake

            if self._ebrake_alloc == 0:
                bias_rear = max_rear * self._bpres_scale
                bias_front_live = 1 - bias_rear / brake_raw
            else:
                bias_front = max_front * self._bpres_scale
                bias_front_live = bias_front / brake_raw

            return max(bias_front_live - brake_bias, +0)
        return 0

    def reset(self):
        """Reset"""
        self._bpres_max = 0.0
        self._bpres_scale = 1.0

```

# File: tinypedal/widget/brake_performance.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Brake performance Widget
"""

from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 5 + bar_padx

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Transient max braking rate
        if self.wcfg["show_transient_max_braking_rate"]:
            bar_style_trans_rate = self.set_qss(
                fg_color=self.wcfg["font_color_transient_max_braking_rate"],
                bg_color=self.wcfg["bkg_color_transient_max_braking_rate"]
            )
            self.bar_trans_rate = self.set_qlabel(
                text="0.00g",
                style=bar_style_trans_rate,
                width=bar_width,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_trans_rate,
                column=self.wcfg["column_index_transient_max_braking_rate"],
            )

        # Max braking rate
        if self.wcfg["show_max_braking_rate"]:
            bar_style_max_rate = self.set_qss(
                fg_color=self.wcfg["font_color_max_braking_rate"],
                bg_color=self.wcfg["bkg_color_max_braking_rate"]
            )
            self.bar_max_rate = self.set_qlabel(
                text="0.00g",
                style=bar_style_max_rate,
                width=bar_width,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_max_rate,
                column=self.wcfg["column_index_max_braking_rate"],
            )

        # Delta braking rate
        if self.wcfg["show_delta_braking_rate"]:
            self.bar_style_delta_rate = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_braking_rate"],
                    bg_color=self.wcfg["bkg_color_braking_rate_loss"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_braking_rate"],
                    bg_color=self.wcfg["bkg_color_braking_rate_gain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_braking_rate"],
                    bg_color=self.wcfg["bkg_color_delta_braking_rate"])
            )
            self.bar_delta_rate = self.set_qlabel(
                text="+0.00",
                style=self.bar_style_delta_rate[2],
                width=bar_width,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_delta_rate,
                column=self.wcfg["column_index_delta_braking_rate"],
            )

        # Front wheel lock duration
        if self.wcfg["show_front_wheel_lock_duration"]:
            bar_style_lock_f = self.set_qss(
                fg_color=self.wcfg["font_color_front_wheel_lock_duration"],
                bg_color=self.wcfg["bkg_color_front_wheel_lock_duration"]
            )
            self.bar_lock_f = self.set_qlabel(
                text="F 0.0",
                style=bar_style_lock_f,
                width=bar_width,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_lock_f,
                column=self.wcfg["column_index_front_wheel_lock_duration"],
            )

        # Front wheel lock duration
        if self.wcfg["show_rear_wheel_lock_duration"]:
            bar_style_lock_r = self.set_qss(
                fg_color=self.wcfg["font_color_rear_wheel_lock_duration"],
                bg_color=self.wcfg["bkg_color_rear_wheel_lock_duration"]
            )
            self.bar_lock_r = self.set_qlabel(
                text="R 0.0",
                style=bar_style_lock_r,
                width=bar_width,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_lock_r,
                column=self.wcfg["column_index_rear_wheel_lock_duration"],
            )

        # Last data
        self.lock_timer = WheelLockTimer(
            self.wcfg["show_front_wheel_lock_duration"] or self.wcfg["show_rear_wheel_lock_duration"],
            self.wcfg["wheel_lock_threshold"]
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Transient max braking rate
        if self.wcfg["show_transient_max_braking_rate"]:
            transient_rate = minfo.force.transientMaxBrakingRate
            self.update_braking_rate(self.bar_trans_rate, transient_rate)

        # Max braking rate
        if self.wcfg["show_max_braking_rate"]:
            max_rate = minfo.force.maxBrakingRate
            self.update_braking_rate(self.bar_max_rate, max_rate)

        # Delta braking rate
        if self.wcfg["show_delta_braking_rate"]:
            delta_rate = minfo.force.deltaBrakingRate
            self.update_delta_rate(self.bar_delta_rate, delta_rate)

        # Wheel lock duration
        if self.lock_timer.enabled:
            self.lock_timer.calc(
                api.read.inputs.brake_raw(),
                api.read.timing.start(),
                api.read.timing.elapsed(),
                minfo.wheels.slipRatio,
            )

        if self.wcfg["show_front_wheel_lock_duration"]:
            self.update_lock_time_f(self.bar_lock_f, self.lock_timer.front)

        if self.wcfg["show_rear_wheel_lock_duration"]:
            self.update_lock_time_r(self.bar_lock_r, self.lock_timer.rear)

    # GUI update methods
    def update_braking_rate(self, target, data):
        """Braking rate (g force)"""
        if target.last != data:
            target.last = data
            target.setText(f"{data: >4.2f}g"[:5])

    def update_delta_rate(self, target, data):
        """Delta braking rate"""
        if target.last != data:
            target.last = data
            if self.wcfg["show_delta_braking_rate_in_percentage"]:
                max_rate = minfo.force.maxBrakingRate
                if max_rate:
                    data /= max_rate
                else:
                    data = 0
                text = f"{data:+.0%}"
            else:
                text = f"{data:+.2f}"
            target.setText(text[:5])
            target.updateStyle(self.bar_style_delta_rate[data > 0])

    def update_lock_time_f(self, target, data):
        """Front wheel lock duration"""
        if target.last != data:
            target.last = data
            target.setText(f"F{data: >4.1f}"[:5])

    def update_lock_time_r(self, target, data):
        """Rear wheel lock duration"""
        if target.last != data:
            target.last = data
            target.setText(f"R{data: >4.1f}"[:5])


class WheelLockTimer:
    """Wheel lock timer"""

    __slots__ = (
        "enabled",
        "front",
        "rear",
        "_last_elapsed_time",
        "_last_start_time",
        "_lock_threshold",
    )

    def __init__(self, enabled: bool, lock_threshold: float) -> None:
        """
        Args:
            enabled: whether lock timer enabled.
            lock_threshold: wheel lock (slip ratio) detection threshold.
        """
        self.enabled = enabled
        self.front = 0.0
        self.rear = 0.0
        self._last_elapsed_time = 0.0
        self._last_start_time = 0.0
        self._lock_threshold = lock_threshold

    def calc(self, brake_raw: float, start_time: float, elapsed_time: float, slip_ratio: list):
        """Calculate wheel lock duration

        Args:
            brake_raw: raw brake input.
            start_time: current lap start time.
            elapsed_time: current lap elapsed time.
            slip_ratio: slip ratio (4 tyres).
        """
        if brake_raw > 0.03:
            if start_time != self._last_start_time:
                self._last_start_time = start_time
                self.front = 0  # reset on new lap
                self.rear = 0
            delta_etime = elapsed_time - self._last_elapsed_time
            if delta_etime > 0:
                if min(slip_ratio[:2]) < -self._lock_threshold:
                    self.front += delta_etime
                if min(slip_ratio[2:]) < -self._lock_threshold:
                    self.rear += delta_etime
        self._last_elapsed_time = elapsed_time

```

# File: tinypedal/widget/brake_pressure.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Brake pressure Widget
"""

from ..api_control import api
from ..const_common import WHEELS_NA, WHEELS_ZERO
from ._base import Overlay
from ._painter import WheelGaugeBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        bar_gap = self.wcfg["bar_gap"]
        bar_gap_hori = self.wcfg["horizontal_gap"]
        bar_gap_vert = self.wcfg["vertical_gap"]
        layout = self.set_grid_layout(gap=bar_gap)
        self.set_primary_layout(layout=layout)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        bar_width = max(self.wcfg["bar_width"], 20)
        bar_height = int(font_m.capital + pady * 2)
        brake_input_color = (
            self.wcfg["brake_input_color"]
            if self.wcfg["show_brake_input"]
            else ""
        )

        # Caption
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_family=self.wcfg["font_name"],
                font_size=int(self.wcfg['font_size'] * self.wcfg['font_scale_caption']),
                font_weight=self.wcfg["font_weight"],
            )
            cap_bar = self.set_qlabel(
                text=self.wcfg["caption_text"],
                style=bar_style_desc,
                fixed_width=bar_width * 2 + bar_gap_hori,
            )
            self.set_primary_orient(
                target=cap_bar,
                column=0,
            )

        # Brake pressure
        layout_inner = self.set_grid_layout(gap_hori=bar_gap_hori, gap_vert=bar_gap_vert)
        self.bars_bpres = tuple(
            WheelGaugeBar(
                self,
                padding_x=padx,
                bar_width=bar_width,
                bar_height=bar_height,
                font_offset=font_offset,
                input_color=self.wcfg["highlight_color"],
                fg_color=self.wcfg["font_color"],
                bg_color=self.wcfg["bkg_color"],
                maxrange_color=brake_input_color,
                maxrange_height=max(self.wcfg["brake_input_size"], 0),
                right_side=idx % 2,
                top_side=idx < 2,
            ) for idx in range(4)
        )
        self.set_grid_layout_quad(
            layout=layout_inner,
            targets=self.bars_bpres,
        )
        self.set_primary_orient(
            target=layout_inner,
            column=1,
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        brake_pressure = api.read.brake.pressure(scale=100)
        brake_inputs = WHEELS_NA

        if self.wcfg["show_brake_input"]:
            raw_brake = api.read.inputs.brake_raw()
            if raw_brake > 0:
                raw_brake *= 100
                bbias = api.read.brake.bias_front()
                raw_brake_f = raw_brake * bbias
                raw_brake_r = raw_brake * (1 - bbias)
                brake_inputs = raw_brake_f, raw_brake_f, raw_brake_r, raw_brake_r
            else:
                brake_inputs = WHEELS_ZERO

        for idx, bar_bpres in enumerate(self.bars_bpres):
            self.update_bpres(bar_bpres, brake_pressure[idx], brake_inputs[idx])

    # GUI update methods
    def update_bpres(self, target, data, inputs):
        """Brake pressure"""
        if target.last != data:
            target.last = data
            if inputs != -1:
                target.update_maxrange(inputs)
            target.update_input(data)

```

# File: tinypedal/widget/brake_temperature.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Brake temperature Widget
"""

from functools import partial

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NA, TEXT_PLACEHOLDER
from ..units import set_unit_temperature
from ..userfile.heatmap import (
    HEATMAP_DEFAULT_BRAKE,
    load_heatmap_style,
    select_brake_heatmap_name,
    set_predefined_brake_name,
)
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        inner_gap = self.wcfg["inner_gap"]
        self.leading_zero = min(max(self.wcfg["leading_zero"], 1), 3) + 0.0  # no decimal
        self.sign_text = "Â°" if self.wcfg["show_degree_sign"] else ""
        text_width = 3 + len(self.sign_text) + (self.cfg.units["temperature_unit"] == "Fahrenheit")
        self.off_brake_duration = max(self.wcfg["off_brake_duration"], 0)

        # Config units
        self.unit_temp = set_unit_temperature(self.cfg.units["temperature_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Heatmap style list: 0 - fl, 1 - fr, 2 - rl, 3 - rr
        self.heatmap_styles = 4 * [
            load_heatmap_style(
                heatmap_name=self.wcfg["heatmap_name"],
                default_name=HEATMAP_DEFAULT_BRAKE,
                swap_style=not self.wcfg["swap_style"],
                fg_color=self.wcfg["font_color_temperature"],
                bg_color=self.wcfg["bkg_color_temperature"],
            )
        ]

        # Brake temperature
        layout_btemp = self.set_grid_layout(gap=inner_gap)
        bar_style_btemp = self.set_qss(
            fg_color=self.wcfg["font_color_temperature"],
            bg_color=self.wcfg["bkg_color_temperature"]
        )
        self.bars_btemp = self.set_qlabel(
            text=TEXT_NA,
            style=bar_style_btemp,
            width=font_m.width * text_width + bar_padx,
            count=4,
            last=0,
        )
        self.set_grid_layout_quad(
            layout=layout_btemp,
            targets=self.bars_btemp,
        )
        self.set_primary_orient(
            target=layout_btemp,
            column=self.wcfg["column_index_temperature"],
        )

        # Average brake temperature
        if self.wcfg["show_average"]:
            layout_btavg = self.set_grid_layout(gap=inner_gap)
            bar_style_btavg = self.set_qss(
                fg_color=self.wcfg["font_color_average"],
                bg_color=self.wcfg["bkg_color_average"]
            )
            self.bars_btavg = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_btavg,
                width=font_m.width * text_width + bar_padx,
                count=4,
                last=0,
            )
            self.set_grid_layout_quad(
                layout=layout_btavg,
                targets=self.bars_btavg,
            )
            self.set_primary_orient(
                target=layout_btavg,
                column=self.wcfg["column_index_average"],
            )
            average_samples = int(min(max(self.wcfg["average_sampling_duration"], 1), 600) / (self._update_interval * 0.001))
            self.calc_ema_btemp = partial(calc.exp_mov_avg, calc.ema_factor(average_samples))

        # Last data
        self.last_in_pits = -1
        self.last_vehicle_name = None
        self.last_lap_etime = 0
        self.off_brake_timer = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Update while in pit (or switched pit state)
        in_pits = api.read.vehicle.in_pits()
        if in_pits or self.last_in_pits != in_pits:
            self.last_in_pits = in_pits

            # Heatmap style
            if self.wcfg["enable_heatmap_auto_matching"]:
                vehicle_name = api.read.vehicle.vehicle_name()
                if self.last_vehicle_name != vehicle_name:
                    self.last_vehicle_name = vehicle_name
                    self.update_heatmap(api.read.vehicle.class_name(), vehicle_name)

        # Brake temperature
        btemp = api.read.brake.temperature()
        for brake_idx, bar_btemp in enumerate(self.bars_btemp):
            self.update_btemp(bar_btemp, round(btemp[brake_idx]), brake_idx)

        # Brake average temperature
        if self.wcfg["show_average"]:
            lap_etime = api.read.timing.elapsed()
            if self.last_lap_etime != lap_etime:
                self.last_lap_etime = lap_etime

                if self.off_brake_timer > lap_etime:
                    self.off_brake_timer = lap_etime

                if api.read.inputs.brake_raw() > 0.01:
                    self.off_brake_timer = lap_etime

                # Update if braked in the past 1 second
                if lap_etime - self.off_brake_timer <= self.off_brake_duration:
                    for brake_idx, bar_btavg in enumerate(self.bars_btavg):
                        btavg = self.calc_ema_btemp(bar_btavg.last, btemp[brake_idx])
                        self.update_btavg(bar_btavg, btavg)

    # GUI update methods
    def update_btemp(self, target, data, index):
        """Brake temperature"""
        if target.last != data:
            target.last = data
            if data < -100:
                target.setText(TEXT_PLACEHOLDER)
            else:
                target.setText(f"{self.unit_temp(data):0{self.leading_zero}f}{self.sign_text}")
            target.updateStyle(calc.select_grade(self.heatmap_styles[index], data))

    def update_btavg(self, target, data):
        """Brake average temperature"""
        if target.last != data:
            target.last = data
            if data < -100:
                target.setText(TEXT_PLACEHOLDER)
            else:
                target.setText(f"{self.unit_temp(data):0{self.leading_zero}f}{self.sign_text}")

    # Additional methods
    def update_heatmap(self, class_name: str, vehicle_name: str):
        """Update heatmap"""
        heatmap_f = select_brake_heatmap_name(
            set_predefined_brake_name(class_name, vehicle_name, True)
        )
        heatmap_r = select_brake_heatmap_name(
            set_predefined_brake_name(class_name, vehicle_name, False)
        )
        heatmap_style_f = load_heatmap_style(
            heatmap_name=heatmap_f,
            default_name=HEATMAP_DEFAULT_BRAKE,
            swap_style=not self.wcfg["swap_style"],
            fg_color=self.wcfg["font_color_temperature"],
            bg_color=self.wcfg["bkg_color_temperature"],
        )
        heatmap_style_r = load_heatmap_style(
            heatmap_name=heatmap_r,
            default_name=HEATMAP_DEFAULT_BRAKE,
            swap_style=not self.wcfg["swap_style"],
            fg_color=self.wcfg["font_color_temperature"],
            bg_color=self.wcfg["bkg_color_temperature"],
        )
        self.heatmap_styles[0] = heatmap_style_f
        self.heatmap_styles[1] = heatmap_style_f
        self.heatmap_styles[2] = heatmap_style_r
        self.heatmap_styles[3] = heatmap_style_r

```

# File: tinypedal/widget/brake_wear.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Brake Wear Widget
"""

from .. import calculation as calc
from ..const_common import TEXT_NA
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 4 + bar_padx
        self.threshold_remaining = min(max(self.wcfg["warning_threshold_remaining"], 0), 100) * 0.01

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        bar_style_desc = self.set_qss(
            fg_color=self.wcfg["font_color_caption"],
            bg_color=self.wcfg["bkg_color_caption"],
            font_size=int(self.wcfg['font_size'] * 0.8)
        )

        # Remaining brake thickness
        if self.wcfg["show_remaining"]:
            layout_remain = self.set_grid_layout()
            self.bar_style_remain = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_remaining"],
                    bg_color=self.wcfg["bkg_color_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_remaining"])
            )
            self.bars_remain = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_remain[0],
                width=bar_width,
                count=4,
                last=0,
            )
            self.set_grid_layout_quad(
                layout=layout_remain,
                targets=self.bars_remain,
            )
            self.set_primary_orient(
                target=layout_remain,
                column=self.wcfg["column_index_remaining"],
            )

            if self.wcfg["show_caption"]:
                cap_remain = self.set_qlabel(
                    text=self.wcfg["caption_text_remaining"],
                    style=bar_style_desc,
                )
                layout_remain.addWidget(cap_remain, 0, 0, 1, 0)

        # Wear difference
        if self.wcfg["show_wear_difference"]:
            layout_diff = self.set_grid_layout()
            self.bar_style_diff = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_wear_difference"],
                    bg_color=self.wcfg["bkg_color_wear_difference"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_wear_difference"])
            )
            self.bars_diff = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_diff[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_diff,
                targets=self.bars_diff,
            )
            self.set_primary_orient(
                target=layout_diff,
                column=self.wcfg["column_index_wear_difference"],
            )

            if self.wcfg["show_caption"]:
                cap_diff = self.set_qlabel(
                    text=self.wcfg["caption_text_wear_difference"],
                    style=bar_style_desc,
                )
                layout_diff.addWidget(cap_diff, 0, 0, 1, 0)

        # Live wear difference
        if self.wcfg["show_live_wear_difference"]:
            layout_live = self.set_grid_layout()
            self.bar_style_live = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_live_wear_difference"],
                    bg_color=self.wcfg["bkg_color_live_wear_difference"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_live_wear_difference"])
            )
            self.bars_live = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_live[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_live,
                targets=self.bars_live,
            )
            self.set_primary_orient(
                target=layout_live,
                column=self.wcfg["column_index_live_wear_difference"],
            )

            if self.wcfg["show_caption"]:
                cap_live = self.set_qlabel(
                    text=self.wcfg["caption_text_live_wear_difference"],
                    style=bar_style_desc,
                )
                layout_live.addWidget(cap_live, 0, 0, 1, 0)

        # Estimated lifespan in laps
        if self.wcfg["show_lifespan_laps"]:
            layout_laps = self.set_grid_layout()
            self.bar_style_laps = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_lifespan_laps"],
                    bg_color=self.wcfg["bkg_color_lifespan_laps"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_lifespan_laps"])
            )
            self.bars_laps = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_laps[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_laps,
                targets=self.bars_laps,
            )
            self.set_primary_orient(
                target=layout_laps,
                column=self.wcfg["column_index_lifespan_laps"],
            )

            if self.wcfg["show_caption"]:
                cap_laps = self.set_qlabel(
                    text=self.wcfg["caption_text_lifespan_laps"],
                    style=bar_style_desc,
                )
                layout_laps.addWidget(cap_laps, 0, 0, 1, 0)

        # Estimated lifespan in minutes
        if self.wcfg["show_lifespan_minutes"]:
            layout_mins = self.set_grid_layout()
            self.bar_style_mins = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_lifespan_minutes"],
                    bg_color=self.wcfg["bkg_color_lifespan_minutes"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_lifespan_minutes"])
            )
            self.bars_mins = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_mins[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_mins,
                targets=self.bars_mins,
            )
            self.set_primary_orient(
                target=layout_mins,
                column=self.wcfg["column_index_lifespan_minutes"],
            )

            if self.wcfg["show_caption"]:
                cap_mins = self.set_qlabel(
                    text=self.wcfg["caption_text_lifespan_minutes"],
                    style=bar_style_desc,
                )
                layout_mins.addWidget(cap_mins, 0, 0, 1, 0)

    def timerEvent(self, event):
        """Update when vehicle on track"""
        for idx in range(4):
            brake_curr = minfo.wheels.currentBrakeThickness[idx]
            is_failed = brake_curr <= 0

            # Calculate effective thickness in millimeters
            failure_thickness = minfo.wheels.failureBrakeThickness[idx]
            max_thickness = minfo.wheels.maxBrakeThickness[idx] - failure_thickness
            brake_curr -= failure_thickness
            live_wear = minfo.wheels.currentlapBrakeWear[idx]
            est_wear = minfo.wheels.estimatedBrakeWear[idx]
            est_valid_wear = minfo.wheels.estimatedValidBrakeWear[idx]

            if max_thickness <= 0:  # bypass invalid value
                max_thickness = 99999999

            # Convert to percent
            live_wear_percent = live_wear * 100 / max_thickness
            est_wear_percent = est_wear * 100 / max_thickness
            if not self.wcfg["show_thickness"]:
                brake_curr *= 100 / max_thickness
                live_wear *= 100 / max_thickness
                est_wear *= 100 / max_thickness
                est_valid_wear *= 100 / max_thickness

            # Remaining brake thickness
            if self.wcfg["show_remaining"]:
                if self.wcfg["show_thickness"]:
                    threshold_remaining = self.threshold_remaining * max_thickness
                else:
                    threshold_remaining = self.threshold_remaining * 100
                self.update_remain(self.bars_remain[idx], brake_curr, threshold_remaining, is_failed)

            # Wear differences
            if self.wcfg["show_wear_difference"]:
                self.update_diff(self.bars_diff[idx], est_wear, est_wear_percent)

            # Live wear difference
            if self.wcfg["show_live_wear_difference"]:
                self.update_live(self.bars_live[idx], live_wear, live_wear_percent)

            # Estimated lifespan in laps
            if self.wcfg["show_lifespan_laps"]:
                wear_laps = calc.wear_lifespan_in_laps(brake_curr, est_valid_wear)
                self.update_laps(self.bars_laps[idx], wear_laps)

            # Estimated lifespan in minutes
            if self.wcfg["show_lifespan_minutes"]:
                wear_mins = calc.wear_lifespan_in_mins(brake_curr, est_valid_wear, minfo.delta.lapTimePace)
                self.update_mins(self.bars_mins[idx], wear_mins)

    # GUI update methods
    def update_remain(self, target, data, threshold_remaining, is_failed):
        """Remaining brake thickness"""
        if target.last != data:
            target.last = data
            if is_failed:
                text = "FAIL"
            else:
                text = self.format_num(data)
            target.setText(text)
            target.updateStyle(
                self.bar_style_remain[data <= threshold_remaining]
            )

    def update_diff(self, target, data, percent):
        """Wear differences"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_diff[percent > self.wcfg["warning_threshold_wear"]]
            )

    def update_live(self, target, data, percent):
        """Live wear differences"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_live[percent > self.wcfg["warning_threshold_wear"]]
            )

    def update_laps(self, target, data):
        """Estimated lifespan in laps"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_laps[data <= self.wcfg["warning_threshold_laps"]]
            )

    def update_mins(self, target, data):
        """Estimated lifespan in minutes"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_mins[data <= self.wcfg["warning_threshold_minutes"]]
            )

    # Additional methods
    @staticmethod
    def format_num(value):
        """Format number"""
        return f"{value:.2f}"[:4].strip(".")

```

# File: tinypedal/widget/cruise.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Cruise Widget
"""

from time import gmtime, strftime

from .. import calculation as calc
from ..api_control import api
from ..const_common import COMPASS_BEARINGS, TEXT_NA
from ..module_info import minfo
from ..units import set_symbol_distance, set_unit_distance
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.odm_digits = max(int(self.wcfg["odometer_maximum_digits"]), 1)
        self.time_scale_override = max(int(self.wcfg["track_clock_time_scale"]), 0)
        if self.cfg.units["odometer_unit"] == "Meter":
            self.odm_digits += 0.0
            self.odm_range = int(int(self.odm_digits) * "9")
        else:
            self.odm_range = float(self.odm_digits * "9") + 0.9
            self.odm_digits += 2.1

        # Config units
        self.unit_dist = set_unit_distance(self.cfg.units["distance_unit"])
        self.symbol_dist = set_symbol_distance(self.cfg.units["distance_unit"])
        self.unit_odm = set_unit_distance(self.cfg.units["odometer_unit"])
        self.symbol_odm = set_symbol_distance(self.cfg.units["odometer_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Track clock
        if self.wcfg["show_track_clock"]:
            text_clock = strftime(self.wcfg["track_clock_format"], gmtime(0))
            bar_style_track_clock = self.set_qss(
                fg_color=self.wcfg["font_color_track_clock"],
                bg_color=self.wcfg["bkg_color_track_clock"]
            )
            self.bar_track_clock = self.set_qlabel(
                text=text_clock,
                style=bar_style_track_clock,
                width=font_m.width * len(text_clock) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_track_clock,
                column=self.wcfg["column_index_track_clock"],
            )

        # Track clock time scale
        if self.wcfg["show_time_scale"]:
            text_time_scale = "X1"
            bar_style_time_scale = self.set_qss(
                fg_color=self.wcfg["font_color_time_scale"],
                bg_color=self.wcfg["bkg_color_time_scale"]
            )
            self.bar_time_scale = self.set_qlabel(
                text=text_time_scale,
                style=bar_style_time_scale,
                width=font_m.width * 3 + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_time_scale,
                column=self.wcfg["column_index_time_scale"],
            )

        # Compass
        if self.wcfg["show_compass"]:
            text_compass = f"{180:03.0f}Â°{calc.select_grade(COMPASS_BEARINGS, 180): >2}"
            bar_style_compass = self.set_qss(
                fg_color=self.wcfg["font_color_compass"],
                bg_color=self.wcfg["bkg_color_compass"]
            )
            self.bar_compass = self.set_qlabel(
                text=text_compass,
                style=bar_style_compass,
                width=font_m.width * len(text_compass) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_compass,
                column=self.wcfg["column_index_compass"],
            )

        # Elevation
        if self.wcfg["show_elevation"]:
            text_elevation = f"â†‘{self.unit_dist(0): >5.0f}{self.symbol_dist}"
            bar_style_elevation = self.set_qss(
                fg_color=self.wcfg["font_color_elevation"],
                bg_color=self.wcfg["bkg_color_elevation"]
            )
            self.bar_elevation = self.set_qlabel(
                text=text_elevation,
                style=bar_style_elevation,
                width=font_m.width * len(text_elevation) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_elevation,
                column=self.wcfg["column_index_elevation"],
            )

        # Odometer
        if self.wcfg["show_odometer"]:
            text_odometer = f"{min(self.unit_odm(0), self.odm_range):>{self.odm_digits}f}{self.symbol_odm}"
            bar_style_odometer = self.set_qss(
                fg_color=self.wcfg["font_color_odometer"],
                bg_color=self.wcfg["bkg_color_odometer"]
            )
            self.bar_odometer = self.set_qlabel(
                text=text_odometer,
                style=bar_style_odometer,
                width=font_m.width * len(text_odometer) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_odometer,
                column=self.wcfg["column_index_odometer"],
            )

        # Distance into lap
        if self.wcfg["show_distance_into_lap"]:
            text_lap_distance = f"{self.unit_dist(0): >6.0f}{self.symbol_dist}"
            bar_style_lap_distance = self.set_qss(
                fg_color=self.wcfg["font_color_distance_into_lap"],
                bg_color=self.wcfg["bkg_color_distance_into_lap"]
            )
            self.bar_lap_distance = self.set_qlabel(
                text=text_lap_distance,
                style=bar_style_lap_distance,
                width=font_m.width * len(text_lap_distance) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_lap_distance,
                column=self.wcfg["column_index_distance_into_lap"],
            )

        # Cornering radius
        if self.wcfg["show_cornering_radius"]:
            text_cornering_radius = f"r{self.unit_dist(0): >4.0f}{self.symbol_dist}"
            bar_style_cornering_radius = self.set_qss(
                fg_color=self.wcfg["font_color_cornering_radius"],
                bg_color=self.wcfg["bkg_color_cornering_radius"]
            )
            self.bar_cornering_radius = self.set_qlabel(
                text=text_cornering_radius,
                style=bar_style_cornering_radius,
                width=font_m.width * len(text_cornering_radius) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_cornering_radius,
                column=self.wcfg["column_index_cornering_radius"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        if self.wcfg["enable_track_clock_synchronization"]:
            time_scale = api.read.session.time_scale()
        else:
            time_scale = self.time_scale_override
        track_time = calc.clock_time(api.read.session.elapsed(), api.read.session.start(), time_scale)

        # Track clock
        if self.wcfg["show_track_clock"]:
            self.update_track_clock(self.bar_track_clock, track_time)

        # Track clock time scale
        if self.wcfg["show_time_scale"]:
            self.update_time_scale(self.bar_time_scale, time_scale)

        # Compass
        if self.wcfg["show_compass"]:
            orientation = api.read.vehicle.orientation_yaw_radians()
            self.update_compass(self.bar_compass, orientation)

        # Elevation
        if self.wcfg["show_elevation"]:
            elevation = api.read.vehicle.position_vertical()
            self.update_elevation(self.bar_elevation, elevation)

        # Odometer
        if self.wcfg["show_odometer"]:
            traveled_distance = int(minfo.stats.metersDriven)
            self.update_odometer(self.bar_odometer, traveled_distance)

        # Distance into lap
        if self.wcfg["show_distance_into_lap"]:
            lap_distance = minfo.delta.lapDistance
            self.update_lap_distance(self.bar_lap_distance, lap_distance)

        # Cornering radius
        if self.wcfg["show_cornering_radius"]:
            cornering_radius = minfo.wheels.corneringRadius
            self.update_cornering_radius(self.bar_cornering_radius, cornering_radius)

    # GUI update methods
    def update_track_clock(self, target, data):
        """Track clock"""
        if target.last != data:
            target.last = data
            target.setText(strftime(self.wcfg["track_clock_format"], gmtime(data)))

    def update_time_scale(self, target, data):
        """Track clock time scale"""
        if target.last != data:
            target.last = data
            if 0 <= data <= 60:
                text = f"X{data}"
            else:
                text = TEXT_NA
            target.setText(text)

    def update_compass(self, target, data):
        """Compass"""
        if target.last != data:
            target.last = data
            degree = 180 - calc.rad2deg(data)
            target.setText(f"{degree:03.0f}Â°{calc.select_grade(COMPASS_BEARINGS, degree): >2}")

    def update_elevation(self, target, data):
        """Elevation"""
        if target.last != data:
            target.last = data
            target.setText(f"â†‘{self.unit_dist(data): >5.0f}{self.symbol_dist}")

    def update_odometer(self, target, data):
        """Odometer"""
        if target.last != data:
            target.last = data
            target.setText(f"{min(self.unit_odm(data), self.odm_range): >{self.odm_digits}f}{self.symbol_odm}")

    def update_lap_distance(self, target, data):
        """Distance into lap"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.unit_dist(data): >6.0f}{self.symbol_dist}")

    def update_cornering_radius(self, target, data):
        """Cornering radius"""
        if target.last != data:
            target.last = data
            meter = self.unit_dist(data)
            if meter > 9999:
                meter = 0
            target.setText(f"r{meter: >4.0f}{self.symbol_dist}")

```

# File: tinypedal/widget/damage.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Damage Widget
"""

from PySide2.QtCore import QRect, Qt
from PySide2.QtGui import QBrush, QPainter, QPen

from .. import calculation as calc
from ..api_control import api
from ..const_common import FLOAT_INF, WHEELS_ZERO
from ._base import Overlay
from ._common import WarningFlash


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        display_margin = max(int(self.wcfg["display_margin"]), 0)
        inner_gap = max(int(self.wcfg["inner_gap"]), 0)

        parts_max_width = max(int(self.wcfg["parts_max_width"]), 4)
        parts_max_height = max(int(self.wcfg["parts_max_height"]), 4)

        parts_full_width = parts_max_width * 3 + inner_gap * 2
        parts_full_height = parts_max_height * 3 + inner_gap * 2
        parts_width = max(min(
            int(self.wcfg["parts_width"]),
            parts_max_width * 0.5,
            parts_max_height * 0.5), 1)

        display_width = parts_full_width + display_margin * 2
        display_height = parts_full_height + display_margin * 2
        impact_cone_size = max(display_width, display_height)
        self.impact_cone_angle = max(min(self.wcfg["last_impact_cone_angle"], 90), 2)

        # Rect parts
        self.rect_mask = QRect(
            display_margin + parts_width, display_margin + parts_width,
            parts_full_width - parts_width * 2, parts_full_height - parts_width * 2
        )
        self.rects_wheels = self.create_wheels_rect(
            display_margin, parts_width, inner_gap, parts_full_width, parts_full_height
        )
        self.rects_parts = self.create_parts_rect(
            display_margin, inner_gap, parts_width, parts_max_width, parts_max_height
        )

        # Rect
        self.rect_background = QRect(0, 0, display_width, display_height)
        self.rect_integrity = self.rect_background.adjusted(0, font_offset, 0, 0)
        self.rect_impact_cone = QRect(
            display_width * 0.5 - impact_cone_size,
            display_height * 0.5 - impact_cone_size,
            impact_cone_size * 2,
            impact_cone_size * 2
        )

        # Config canvas
        self.resize(display_width, display_height)

        self.pen_text = QPen()
        self.pen_text.setColor(self.wcfg["font_color_integrity"])
        self.brush_cone = QBrush(Qt.SolidPattern)
        self.brush_cone.setColor(self.wcfg["last_impact_cone_color"])

        if self.wcfg["show_detached_warning_flash"]:
            self.warn_flash = WarningFlash(
                self.wcfg["warning_flash_highlight_duration"],
                self.wcfg["warning_flash_interval"],
                FLOAT_INF,
            )

        # Last data
        self.detached_parts = False
        self.damage_aero = -1.0
        self.damage_body = WHEELS_ZERO * 2
        self.damage_wheel = WHEELS_ZERO
        self.damage_susp = WHEELS_ZERO
        self.last_impact_time = None
        self.last_impact_expired = True

    def timerEvent(self, event):
        """Update when vehicle on track"""
        update_later = False

        # Last impact time & position
        if self.wcfg["show_last_impact_cone"]:
            impact_time = api.read.vehicle.impact_time()

            if self.last_impact_time != impact_time:
                self.last_impact_time = impact_time
                self.last_impact_expired = api.read.vehicle.impact_magnitude() < 1
                update_later = True

            if (not self.last_impact_expired and
                api.read.timing.elapsed() - self.last_impact_time
                > self.wcfg["last_impact_cone_duration"]):
                self.last_impact_expired = True
                update_later = True

        # Damage body
        temp_damage_body = api.read.vehicle.damage_severity()
        if self.damage_body != temp_damage_body:
            self.damage_body = temp_damage_body
            update_later = True

        # Damage aero
        temp_damage_aero = api.read.vehicle.aero_damage()
        if self.damage_aero != temp_damage_aero:
            self.damage_aero = temp_damage_aero
            update_later = True

        # Damage wheel
        temp_damage_wheel = api.read.wheel.is_detached()
        if self.damage_wheel != temp_damage_wheel:
            self.damage_wheel = temp_damage_wheel
            update_later = True

        # Damage suspension
        temp_damage_susp = api.read.wheel.suspension_damage()
        if self.damage_susp != temp_damage_susp:
            self.damage_susp = temp_damage_susp
            update_later = True

        # Update if any detached parts
        if self.detached_parts:
            self.detached_parts = False
            update_later = True

        if update_later:
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        self.draw_damage_body(painter)
        self.draw_mask_background(painter)
        self.draw_damage_wheel(painter)
        if not self.last_impact_expired:
            self.draw_impact_cone(painter)
        if self.wcfg["show_integrity_reading"]:
            self.draw_readings(painter)

    def draw_mask_background(self, painter):
        """Draw mask & background"""
        painter.setCompositionMode(QPainter.CompositionMode_DestinationOut)
        painter.fillRect(self.rect_mask, Qt.white)
        if self.wcfg["show_background"]:  # draw background below mask
            painter.setCompositionMode(QPainter.CompositionMode_DestinationOver)
            painter.fillRect(self.rect_background, self.wcfg["bkg_color"])
        painter.setCompositionMode(QPainter.CompositionMode_SourceOver)

    def draw_damage_body(self, painter):
        """Draw damage body"""
        for rect_part, damage_body in zip(self.rects_parts, self.damage_body):
            painter.fillRect(rect_part, self.color_damage_body(damage_body))

    def draw_damage_wheel(self, painter):
        """Draw damage wheel"""
        for rect_wheel, damage_wheel, damage_susp in zip(self.rects_wheels, self.damage_wheel, self.damage_susp):
            painter.fillRect(rect_wheel, self.color_damage_wheel(damage_wheel, damage_susp))

    def draw_impact_cone(self, painter):
        """Draw impact cone"""
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.setPen(Qt.NoPen)
        painter.setBrush(self.brush_cone)
        raw_angle = calc.rad2deg(calc.oriyaw2rad(*api.read.vehicle.impact_position()))
        start_angle = 16 * (raw_angle - 90 - self.impact_cone_angle * 0.5)
        length_angle = 16 * self.impact_cone_angle
        painter.drawPie(self.rect_impact_cone, start_angle, length_angle)

    def draw_readings(self, painter):
        """Draw body integrity readings"""
        if self.wcfg["show_aero_integrity_if_available"] and self.damage_aero >= 0:
            damage_value = self.damage_aero
        else:
            damage_value = sum(self.damage_body) / 16
        if not self.wcfg["show_inverted_integrity"]:
            damage_value = 1 - damage_value
        painter.setPen(self.pen_text)
        painter.drawText(self.rect_integrity, Qt.AlignCenter, f"{damage_value:.0%}"[:4])

    # Additional methods
    def color_damage_body(self, value: int) -> str:
        """Body damage color"""
        # light body damage
        if value == 1:
            return self.wcfg["body_color_damage_light"]
        # heavy body damage
        if value == 2:
            return self.wcfg["body_color_damage_heavy"]
        # body parts detached
        if value >= 3:
            self.detached_parts = True
            if self.wcfg["show_detached_warning_flash"] and self.warn_flash.state(True):
                return self.wcfg["warning_color_detached"]
            return self.wcfg["body_color_detached"]
        # no damage
        return self.wcfg["body_color"]

    def color_damage_wheel(self, wheel_detached: bool, susp_damage: float) -> int:
        """Wheel and suspension damage color"""
        # wheel detached
        if wheel_detached:
            self.detached_parts = True
            if self.wcfg["show_detached_warning_flash"] and self.warn_flash.state(True):
                return self.wcfg["warning_color_detached"]
            return self.wcfg["wheel_color_detached"]
        # no damage
        if susp_damage < self.wcfg["suspension_damage_light_threshold"]:
            return self.wcfg["suspension_color"]
        # light suspension damage
        if susp_damage < self.wcfg["suspension_damage_medium_threshold"]:
            return self.wcfg["suspension_color_damage_light"]
        # medium suspension damage
        if susp_damage < self.wcfg["suspension_damage_heavy_threshold"]:
            return self.wcfg["suspension_color_damage_medium"]
        # heavy suspension damage
        if susp_damage < self.wcfg["suspension_damage_totaled_threshold"]:
            return self.wcfg["suspension_color_damage_heavy"]
        # suspension totaled
        return self.wcfg["suspension_color_damage_totaled"]

    def create_wheels_rect(
        self, display_margin, parts_width, inner_gap, parts_full_width, parts_full_height):
        """Wheel parts rect, row by row from left to right, top to bottom"""
        wheel_width = max(int(self.wcfg["wheel_width"]), 1)
        wheel_height = max(int(self.wcfg["wheel_height"]), 1)
        offset_w = parts_width + inner_gap
        offset_x = parts_full_width - wheel_width - offset_w
        offset_y = parts_full_height - wheel_height - offset_w
        wheels_rect = (
            # front left
            QRect(display_margin + offset_w, display_margin + offset_w, wheel_width, wheel_height),
            # front right
            QRect(display_margin + offset_x, display_margin + offset_w, wheel_width, wheel_height),
            # rear left
            QRect(display_margin + offset_w, display_margin + offset_y, wheel_width, wheel_height),
            # rear right
            QRect(display_margin + offset_x, display_margin + offset_y, wheel_width, wheel_height),
        )
        return wheels_rect

    def create_parts_rect(self, display_margin, inner_gap, parts_width, parts_max_width, parts_max_height):
        """Body parts rect, row by row from left to right, top to bottom"""
        offset_y = inner_gap + parts_max_height
        width_ratio = min(max(self.wcfg["parts_width_ratio"], 0.1), 1.0)
        side_scale = width_ratio * 2 / (1 + width_ratio)
        part_side_width = max(round(parts_max_width * side_scale), parts_width)
        part_center_width = parts_max_width * 3 - part_side_width * 2
        parts_rect = (
            # front left
            QRect(display_margin, display_margin, part_side_width, parts_max_height),
            # front center
            QRect(display_margin + inner_gap + part_side_width, display_margin, part_center_width, parts_max_height),
            # front right
            QRect(display_margin + inner_gap * 2 + part_side_width + part_center_width, display_margin, part_side_width, parts_max_height),
            # center left
            QRect(display_margin, display_margin + offset_y, part_side_width, parts_max_height),
            # center right
            QRect(display_margin + inner_gap * 2 + part_side_width + part_center_width, display_margin + offset_y, part_side_width, parts_max_height),
            # rear left
            QRect(display_margin, display_margin + offset_y * 2, part_side_width, parts_max_height),
            # rear center
            QRect(display_margin + inner_gap + part_side_width, display_margin + offset_y * 2, part_center_width, parts_max_height),
            # rear right
            QRect(display_margin + inner_gap * 2 + part_side_width + part_center_width, display_margin + offset_y * 2, part_side_width, parts_max_height),
        )
        return parts_rect

```

# File: tinypedal/widget/deltabest.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Deltabest Widget
"""

from PySide2.QtCore import QRectF, Qt
from PySide2.QtGui import QPainter, QPen

from .. import calculation as calc
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        self.laptime_source = f"lapTime{self.wcfg['deltabest_source']}"
        self.delta_source = f"delta{self.wcfg['deltabest_source']}"
        bar_gap = self.wcfg["bar_gap"]
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        self.dbar_length = int(self.wcfg["bar_length"] * 0.5)
        dbar_height = int(self.wcfg["bar_height"])

        self.decimals = max(self.wcfg["decimal_places"], 1)
        self.delta_display_range = calc.decimal_strip(self.wcfg["delta_display_range"], self.decimals)
        self.max_padding = 4 + self.decimals
        self.delta_width = font_m.width * self.max_padding + padx * 2
        delta_height = font_m.capital + pady * 2

        if self.wcfg["layout"] == 0:
            pos_y1 = 0
        else:
            pos_y1 = delta_height + bar_gap

        if self.wcfg["show_delta_bar"]:
            pos_x2 = self.dbar_length - self.delta_width * 0.5
        else:
            pos_x2 = 0

        if self.wcfg["layout"] == 0 and self.wcfg["show_delta_bar"]:
            pos_y2 = dbar_height + bar_gap
        else:
            pos_y2 = 0

        self.rect_deltabar = QRectF(0, pos_y1, self.dbar_length * 2, dbar_height)
        self.rect_deltapos = QRectF(0, pos_y1, self.dbar_length, dbar_height)
        self.rect_delta = QRectF(pos_x2, pos_y2, self.delta_width, delta_height)
        self.rect_text_delta = self.rect_delta.adjusted(0, font_offset, 0, 0)

        self.freeze_duration = min(max(self.wcfg["freeze_duration"], 0), 30)
        self.delta_color = self.wcfg["bkg_color_time_gain"], self.wcfg["bkg_color_time_loss"]

        # Config canvas
        if self.wcfg["show_delta_bar"]:
            self.resize(self.dbar_length * 2, dbar_height + bar_gap + delta_height)
        else:
            self.resize(self.delta_width, delta_height)

        self.pen_text = QPen()

        # Last data
        self.delta_best = 0
        self.last_laptime = 0
        self.new_lap = True

    def timerEvent(self, event):
        """Update when vehicle on track"""
        if minfo.delta.lapTimeCurrent < self.freeze_duration:
            temp_best = minfo.delta.lapTimeLast - self.last_laptime
            self.new_lap = True
        else:
            if self.new_lap:
                self.last_laptime = getattr(minfo.delta, self.laptime_source)
                self.new_lap = False

            temp_best = getattr(minfo.delta, self.delta_source)

        if self.delta_best != temp_best:
            self.delta_best = temp_best
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        delta_pos = self.delta_position(
            self.wcfg["bar_display_range"],
            self.delta_best,
            self.dbar_length)
        highlight_color = self.delta_color[self.delta_best > 0]

        # Draw deltabar
        if self.wcfg["show_delta_bar"]:
            self.rect_deltapos.setLeft(delta_pos)
            painter.fillRect(self.rect_deltabar, self.wcfg["bkg_color_deltabar"])
            painter.fillRect(self.rect_deltapos, highlight_color)

            if self.wcfg["show_animated_deltabest"]:
                pos_x = calc.zero_max(
                    delta_pos - self.delta_width * 0.5,
                    self.dbar_length * 2 - self.delta_width,
                )
                self.rect_delta.moveLeft(pos_x)
                self.rect_text_delta.moveLeft(pos_x)

        # Draw delta readings
        if self.wcfg["swap_style"]:
            self.pen_text.setColor(self.wcfg["bkg_color_deltabest"])
            bg_color = highlight_color
        else:
            self.pen_text.setColor(highlight_color)
            bg_color =  self.wcfg["bkg_color_deltabest"]

        painter.fillRect(self.rect_delta, bg_color)
        painter.setPen(self.pen_text)
        painter.drawText(
            self.rect_text_delta,
            Qt.AlignCenter,
            f"{calc.sym_max(self.delta_best, self.delta_display_range):+.{self.decimals}f}"[:self.max_padding]
        )

    # Additional methods
    @staticmethod
    def delta_position(rng, delta, length):
        """Delta position"""
        return (1 - calc.sym_max(delta, rng) / rng) * length

```

# File: tinypedal/widget/deltabest_extended.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Deltabest extended Widget
"""

from .. import calculation as calc
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.freeze_duration = min(max(self.wcfg["freeze_duration"], 0), 30)
        self.decimals = max(self.wcfg["decimal_places"], 1)
        self.delta_display_range = calc.decimal_strip(self.wcfg["delta_display_range"], self.decimals)
        self.max_padding = 3 + self.decimals
        text_def = f"--.{'-' * self.decimals}"

        if self.wcfg["layout"] == 0:
            prefix_just = max(
                len(self.wcfg["prefix_all_time_deltabest"]),
                len(self.wcfg["prefix_session_deltabest"]),
                len(self.wcfg["prefix_stint_deltabest"]),
                len(self.wcfg["prefix_deltalast"]),
            )
        else:
            prefix_just = 0

        self.prefix_atbest = self.wcfg["prefix_all_time_deltabest"].ljust(prefix_just)
        self.prefix_ssbest = self.wcfg["prefix_session_deltabest"].ljust(prefix_just)
        self.prefix_stbest = self.wcfg["prefix_stint_deltabest"].ljust(prefix_just)
        self.prefix_labest = self.wcfg["prefix_deltalast"].ljust(prefix_just)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # All time deltabest
        if self.wcfg["show_all_time_deltabest"]:
            text_atbest = f"{self.prefix_atbest}{text_def}"
            bar_style_atbest = self.set_qss(
                fg_color=self.wcfg["font_color_all_time_deltabest"],
                bg_color=self.wcfg["bkg_color_all_time_deltabest"]
            )
            self.bar_atbest = self.set_qlabel(
                text=text_atbest,
                style=bar_style_atbest,
                width=font_m.width * len(text_atbest) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_atbest,
                column=self.wcfg["column_index_all_time_deltabest"],
            )

        # Session deltabest
        if self.wcfg["show_session_deltabest"]:
            text_ssbest = f"{self.prefix_ssbest}{text_def}"
            bar_style_ssbest = self.set_qss(
                fg_color=self.wcfg["font_color_session_deltabest"],
                bg_color=self.wcfg["bkg_color_session_deltabest"]
            )
            self.bar_ssbest = self.set_qlabel(
                text=text_ssbest,
                style=bar_style_ssbest,
                width=font_m.width * len(text_ssbest) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_ssbest,
                column=self.wcfg["column_index_session_deltabest"],
            )

        # Stint deltabest
        if self.wcfg["show_stint_deltabest"]:
            text_stbest = f"{self.prefix_stbest}{text_def}"
            bar_style_stbest = self.set_qss(
                fg_color=self.wcfg["font_color_stint_deltabest"],
                bg_color=self.wcfg["bkg_color_stint_deltabest"]
            )
            self.bar_stbest = self.set_qlabel(
                text=text_stbest,
                style=bar_style_stbest,
                width=font_m.width * len(text_stbest) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_stbest,
                column=self.wcfg["column_index_stint_deltabest"],
            )

        # Deltalast
        if self.wcfg["show_deltalast"]:
            text_labest = f"{self.prefix_labest}{text_def}"
            bar_style_labest = self.set_qss(
                fg_color=self.wcfg["font_color_deltalast"],
                bg_color=self.wcfg["bkg_color_deltalast"]
            )
            self.bar_labest = self.set_qlabel(
                text=text_labest,
                style=bar_style_labest,
                width=font_m.width * len(text_labest) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_labest,
                column=self.wcfg["column_index_deltalast"],
            )

        # Last data
        self.last_laptimes = [0.0] * 4
        self.new_lap = True

    def timerEvent(self, event):
        """Update when vehicle on track"""
        if minfo.delta.lapTimeCurrent < self.freeze_duration:
            alltime_best = minfo.delta.lapTimeLast - self.last_laptimes[0]
            session_best = minfo.delta.lapTimeLast - self.last_laptimes[1]
            stint_best = minfo.delta.lapTimeLast - self.last_laptimes[2]
            delta_last = minfo.delta.lapTimeLast - self.last_laptimes[3]
            self.new_lap = True
        else:
            if self.new_lap:
                self.last_laptimes[0] = minfo.delta.lapTimeBest
                self.last_laptimes[1] = minfo.delta.lapTimeSession
                self.last_laptimes[2] = minfo.delta.lapTimeStint
                self.last_laptimes[3] = minfo.delta.lapTimeLast
                self.new_lap = False

            alltime_best = minfo.delta.deltaBest
            session_best = minfo.delta.deltaSession
            stint_best = minfo.delta.deltaStint
            delta_last = minfo.delta.deltaLast

        # All time deltabest
        if self.wcfg["show_all_time_deltabest"]:
            self.update_deltabest(self.bar_atbest, alltime_best, self.prefix_atbest)

        # Session deltabest
        if self.wcfg["show_session_deltabest"]:
            self.update_deltabest(self.bar_ssbest, session_best, self.prefix_ssbest)

        # Stint deltabest
        if self.wcfg["show_stint_deltabest"]:
            self.update_deltabest(self.bar_stbest, stint_best, self.prefix_stbest)

        # Deltalast
        if self.wcfg["show_stint_deltabest"]:
            self.update_deltabest(self.bar_labest, delta_last, self.prefix_labest)

    # GUI update methods
    def update_deltabest(self, target, data, prefix):
        """Update deltabest"""
        if target.last != data:
            target.last = data
            text = f"{calc.sym_max(data, self.delta_display_range): >+{self.max_padding}.{self.decimals}f}"[:self.max_padding]
            target.setText(f"{prefix}{text}")

```

# File: tinypedal/widget/differential.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Differential Widget
"""

from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.decimals = max(self.wcfg["decimal_places"], 0)
        self.max_padding = 3 + self.decimals + (self.decimals > 0)

        if self.wcfg["layout"] == 0:
            prefix_just = max(
                len(self.wcfg["prefix_power_front"]),
                len(self.wcfg["prefix_coast_front"]),
                len(self.wcfg["prefix_power_rear"]),
                len(self.wcfg["prefix_coast_rear"]),
            )
        else:
            prefix_just = 0

        self.prefix_power_f = self.wcfg["prefix_power_front"].ljust(prefix_just)
        self.prefix_coast_f = self.wcfg["prefix_coast_front"].ljust(prefix_just)
        self.prefix_power_r = self.wcfg["prefix_power_rear"].ljust(prefix_just)
        self.prefix_coast_r = self.wcfg["prefix_coast_rear"].ljust(prefix_just)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Power locking front
        if self.wcfg["show_power_locking_front"]:
            text_power_front = f"{self.prefix_power_f}{self.format_reading(1)}"
            bar_style_power_front = self.set_qss(
                fg_color=self.wcfg["font_color_power_locking_front"],
                bg_color=self.wcfg["bkg_color_power_locking_front"]
            )
            self.bar_power_front = self.set_qlabel(
                text=text_power_front,
                style=bar_style_power_front,
                width=font_m.width * len(text_power_front) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_power_front,
                column=self.wcfg["column_index_power_locking_front"],
            )

        # Coast locking front
        if self.wcfg["show_coast_locking_front"]:
            text_coast_front = f"{self.prefix_coast_f}{self.format_reading(1)}"
            bar_style_coast_front = self.set_qss(
                fg_color=self.wcfg["font_color_coast_locking_front"],
                bg_color=self.wcfg["bkg_color_coast_locking_front"]
            )
            self.bar_coast_front = self.set_qlabel(
                text=text_coast_front,
                style=bar_style_coast_front,
                width=font_m.width * len(text_coast_front) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_coast_front,
                column=self.wcfg["column_index_coast_locking_front"],
            )

        # Power locking rear
        if self.wcfg["show_power_locking_rear"]:
            text_power_rear = f"{self.prefix_power_r}{self.format_reading(1)}"
            bar_style_power_rear = self.set_qss(
                fg_color=self.wcfg["font_color_power_locking_rear"],
                bg_color=self.wcfg["bkg_color_power_locking_rear"]
            )
            self.bar_power_rear = self.set_qlabel(
                text=text_power_rear,
                style=bar_style_power_rear,
                width=font_m.width * len(text_power_rear) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_power_rear,
                column=self.wcfg["column_index_power_locking_rear"],
            )

        # Coast locking rear
        if self.wcfg["show_coast_locking_rear"]:
            text_coast_rear = f"{self.prefix_coast_r}{self.format_reading(1)}"
            bar_style_coast_rear = self.set_qss(
                fg_color=self.wcfg["font_color_coast_locking_rear"],
                bg_color=self.wcfg["bkg_color_coast_locking_rear"]
            )
            self.bar_coast_rear = self.set_qlabel(
                text=text_coast_rear,
                style=bar_style_coast_rear,
                width=font_m.width * len(text_coast_rear) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_coast_rear,
                column=self.wcfg["column_index_coast_locking_rear"],
            )

        # Last data
        self.power_timer_f = DiffLockingTimer(self.wcfg["power_locking_reset_cooldown"])
        self.coast_timer_f = DiffLockingTimer(self.wcfg["coast_locking_reset_cooldown"])
        self.power_timer_r = DiffLockingTimer(self.wcfg["power_locking_reset_cooldown"])
        self.coast_timer_r = DiffLockingTimer(self.wcfg["coast_locking_reset_cooldown"])

    def timerEvent(self, event):
        """Update when vehicle on track"""
        lap_etime = api.read.timing.elapsed()
        raw_throttle = api.read.inputs.throttle_raw()
        locking_front = minfo.wheels.lockingPercentFront
        locking_rear = minfo.wheels.lockingPercentRear
        on_throttle = raw_throttle > self.wcfg["on_throttle_threshold"]
        off_throttle = raw_throttle < self.wcfg["off_throttle_threshold"]

        # Power locking front
        if self.wcfg["show_power_locking_front"] and on_throttle:
            min_power_f = self.power_timer_f.update(locking_front, lap_etime)
            self.update_locking(self.bar_power_front, min_power_f, self.prefix_power_f)

        # Coast locking front
        if self.wcfg["show_coast_locking_front"] and off_throttle:
            min_coast_f = self.coast_timer_f.update(locking_front, lap_etime)
            self.update_locking(self.bar_coast_front, min_coast_f, self.prefix_coast_f)

        # Power locking rear
        if self.wcfg["show_power_locking_rear"] and on_throttle:
            min_power_r = self.power_timer_r.update(locking_rear, lap_etime)
            self.update_locking(self.bar_power_rear, min_power_r, self.prefix_power_r)

        # Coast locking rear
        if self.wcfg["show_coast_locking_rear"] and off_throttle:
            min_coast_r = self.coast_timer_r.update(locking_rear, lap_etime)
            self.update_locking(self.bar_coast_rear, min_coast_r, self.prefix_coast_r)

    # GUI update methods
    def update_locking(self, target, data, prefix):
        """Differential locking percent"""
        if target.last != data:
            target.last = data
            target.setText(f"{prefix}{self.format_reading(data)}")

    # Additional methods
    def format_reading(self, value):
        """Format reading"""
        if self.wcfg["show_inverted_locking"]:
            value = 1 - value
        return f"{value: >{self.max_padding}.{self.decimals}%}"[:self.max_padding]


class DiffLockingTimer:
    """Differential locking timer"""

    __slots__ = (
        "_cooldown",
        "_timer",
        "_min_locking",
    )

    def __init__(self, cooldown: float) -> None:
        """
        Args:
            cooldown: minimum locking percent reset cooldown (seconds).
        """
        self._cooldown = cooldown
        self._timer = 0.0
        self._min_locking = 1.0

    def update(self, locking: float, elapsed_time: float) -> float:
        """Update minimum locking percent

        Args:
            locking: locking percent (fraction).
            elapsed_time: current lap elapsed time.

        Returns:
            Minimum locking percent (fraction).
        """
        if self._min_locking > locking:
            self._min_locking = locking
            self._timer = elapsed_time
        elif elapsed_time - self._timer > self._cooldown:
            self._min_locking = 1  # reset
        elif self._timer > elapsed_time:  # timer correction
            self._timer = elapsed_time
        return self._min_locking

```

# File: tinypedal/widget/drs.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
DRS Widget
"""

from PySide2.QtCore import QRectF, Qt
from PySide2.QtGui import QPainter, QPen

from ..api_control import api
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        drs_width = font_m.width * len(self.wcfg["drs_text"]) + padx * 2
        drs_height = int(font_m.capital + pady * 2)

        self.drs_color = (
            (self.wcfg["font_color_not_available"], self.wcfg["bkg_color_not_available"]),
            (self.wcfg["font_color_available"], self.wcfg["bkg_color_available"]),
            (self.wcfg["font_color_allowed"], self.wcfg["bkg_color_allowed"]),
            (self.wcfg["font_color_activated"], self.wcfg["bkg_color_activated"]),
        )

        # Rect
        self.rect_drs = QRectF(0, 0, drs_width, drs_height)
        self.rect_text = self.rect_drs.adjusted(0, font_offset, 0, 0)

        # Config canvas
        self.resize(drs_width, drs_height)
        self.pen_text = QPen()

        # Last data
        self.drs_state = -1

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # DRS update
        drs_state = api.read.switch.drs_status()
        if self.drs_state != drs_state:
            self.drs_state = drs_state
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.fillRect(self.rect_drs, self.drs_color[self.drs_state][1])
        self.pen_text.setColor(self.drs_color[self.drs_state][0])
        painter.setPen(self.pen_text)
        painter.drawText(self.rect_text, Qt.AlignCenter, self.wcfg["drs_text"])

```

# File: tinypedal/widget/electric_motor.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Electric motor Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..units import set_symbol_power, set_unit_power, set_unit_temperature
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 8 + bar_padx

        # Config units
        self.unit_temp = set_unit_temperature(self.cfg.units["temperature_unit"])
        self.unit_power = set_unit_power(self.cfg.units["power_unit"])
        self.symbol_power = set_symbol_power(self.cfg.units["power_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Motor temperature
        if self.wcfg["show_motor_temperature"]:
            self.bar_style_motor = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_motor_temperature"],
                    bg_color=self.wcfg["bkg_color_motor_temperature"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_motor_temperature"],
                    bg_color=self.wcfg["warning_color_overheat"])
            )
            self.bar_motor = self.set_qlabel(
                text="M TEMP",
                style=self.bar_style_motor[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_motor,
                column=self.wcfg["column_index_motor_temperature"],
            )

        # Motor water temperature
        if self.wcfg["show_water_temperature"]:
            self.bar_style_water = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_water_temperature"],
                    bg_color=self.wcfg["bkg_color_water_temperature"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_water_temperature"],
                    bg_color=self.wcfg["warning_color_overheat"])
            )
            self.bar_water = self.set_qlabel(
                text="W TEMP",
                style=self.bar_style_water[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_water,
                column=self.wcfg["column_index_water_temperature"],
            )

        # Motor rpm
        if self.wcfg["show_rpm"]:
            bar_style_rpm = self.set_qss(
                fg_color=self.wcfg["font_color_rpm"],
                bg_color=self.wcfg["bkg_color_rpm"]
            )
            self.bar_rpm = self.set_qlabel(
                text="RPM",
                style=bar_style_rpm,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_rpm,
                column=self.wcfg["column_index_rpm"],
            )

        # Motor torque
        if self.wcfg["show_torque"]:
            bar_style_torque = self.set_qss(
                fg_color=self.wcfg["font_color_torque"],
                bg_color=self.wcfg["bkg_color_torque"]
            )
            self.bar_torque = self.set_qlabel(
                text="TORQUE",
                style=bar_style_torque,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_torque,
                column=self.wcfg["column_index_torque"],
            )

        # Motor power
        if self.wcfg["show_power"]:
            bar_style_power = self.set_qss(
                fg_color=self.wcfg["font_color_power"],
                bg_color=self.wcfg["bkg_color_power"]
            )
            self.bar_power = self.set_qlabel(
                text="POWER",
                style=bar_style_power,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_power,
                column=self.wcfg["column_index_power"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Motor temperature
        if self.wcfg["show_motor_temperature"]:
            temp_motor = round(api.read.emotor.motor_temperature(), 2)
            self.update_motor(self.bar_motor, temp_motor)

        # Water temperature
        if self.wcfg["show_water_temperature"]:
            temp_water = round(api.read.emotor.water_temperature(), 2)
            self.update_water(self.bar_water, temp_water)

        # Motor rpm
        if self.wcfg["show_rpm"]:
            rpm = int(api.read.emotor.rpm())
            self.update_rpm(self.bar_rpm, rpm)

        # Motor torque
        if self.wcfg["show_torque"]:
            torque = round(api.read.emotor.torque(), 2)
            self.update_torque(self.bar_torque, torque)

        # Motor power
        if self.wcfg["show_power"]:
            power = round(calc.engine_power(
                api.read.emotor.torque(), api.read.emotor.rpm()), 2)
            self.update_power(self.bar_power, power)

    # GUI update methods
    def update_motor(self, target, data):
        """Motor temperature"""
        if target.last != data:
            target.last = data
            target.setText(f"M{self.unit_temp(data): >6.1f}Â°")
            target.updateStyle(self.bar_style_motor[data >= self.wcfg["overheat_threshold_motor"]])

    def update_water(self, target, data):
        """Water temperature"""
        if target.last != data:
            target.last = data
            target.setText(f"W{self.unit_temp(data): >6.1f}Â°")
            target.updateStyle(self.bar_style_water[data >= self.wcfg["overheat_threshold_water"]])

    def update_rpm(self, target, data):
        """Motor rpm"""
        if target.last != data:
            target.last = data
            target.setText(f"{data: >5}rpm")

    def update_torque(self, target, data):
        """Motor torque"""
        if target.last != data:
            target.last = data
            text = f"{data: >6.2f}"[:6]
            target.setText(f"{text}Nm")

    def update_power(self, target, data):
        """Motor power"""
        if target.last != data:
            target.last = data
            text = f"{self.unit_power(data): >6.2f}"[:6]
            target.setText(f"{text}{self.symbol_power}")

```

# File: tinypedal/widget/elevation.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Elevation Widget
"""

from PySide2.QtCore import QRectF, Qt
from PySide2.QtGui import QBrush, QPainter, QPainterPath, QPen, QPixmap

from .. import calculation as calc
from ..api_control import api
from ..module_info import minfo
from ..units import set_symbol_distance, set_unit_distance
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        self.display_width = max(self.wcfg["display_width"], 20)
        self.display_height = max(self.wcfg["display_height"], 10)
        self.display_margin_top = min(max(self.wcfg["display_margin_top"], 0), int(self.display_height / 2))
        self.display_margin_bottom = min(max(self.wcfg["display_margin_bottom"], 0), int(self.display_height / 2))
        self.display_detail_level = max(self.wcfg["display_detail_level"], 0)

        self.rect_text_elevation = QRectF(
            self.display_width * self.wcfg["elevation_reading_offset_x"] - font_m.width * 5,
            self.display_height * self.wcfg["elevation_reading_offset_y"] - font_m.height * 0.5 + font_offset,
            font_m.width * 10,
            font_m.height
        )
        self.rect_text_scale = QRectF(
            self.display_width * self.wcfg["elevation_scale_offset_x"] - font_m.width * 5,
            self.display_height * self.wcfg["elevation_scale_offset_y"] - font_m.height * 0.5 + font_offset,
            font_m.width * 10,
            font_m.height
        )
        self.elevation_text_alignment = self.set_text_alignment(self.wcfg["elevation_reading_text_alignment"])
        self.scale_text_alignment = self.set_text_alignment(self.wcfg["elevation_scale_text_alignment"])

        # Config units
        self.unit_dist = set_unit_distance(self.cfg.units["distance_unit"])
        self.symbol_dist = set_symbol_distance(self.cfg.units["distance_unit"])

        # Config canvas
        self.resize(self.display_width, self.display_height)
        self.pixmap_background = QPixmap(self.display_width, self.display_height)
        self.pixmap_progress = QPixmap(self.display_width, self.display_height)
        self.pixmap_progress_line = QPixmap(self.display_width, self.display_height)
        self.pixmap_marks = QPixmap(self.display_width, self.display_height)

        self.pen_mark = QPen()
        self.pen_mark.setWidth(self.wcfg["position_mark_width"])
        self.pen_mark.setColor(self.wcfg["position_mark_color"])
        self.pen_text = QPen()
        self.pen_text.setColor(self.wcfg["font_color"])

        # Last data
        self.last_modified = 0
        self.veh_pos = 0
        self.map_scaled = None
        self.map_range = (0,10,0,10)
        self.map_scale = 1,1

        self.update_elevation(-1)

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Elevation map
        modified = minfo.mapping.lastModified
        self.update_elevation(modified)

        # Vehicle position
        temp_veh_pos = self.display_width * api.read.lap.progress()
        if self.veh_pos != temp_veh_pos:
            self.veh_pos = temp_veh_pos
            self.update()

    # GUI update methods
    def update_elevation(self, data):
        """Elevation map update"""
        if self.last_modified != data:
            self.last_modified = data
            raw_data = minfo.mapping.elevations if data != -1 else None
            map_path = self.create_elevation_path(raw_data)
            self.draw_background(map_path)
            self.draw_progress(map_path)
            self.draw_progress_line(map_path)
            self.draw_marks(map_path)

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.drawPixmap(0, 0, self.pixmap_background)

        # Draw elevation progress
        if self.wcfg["show_elevation_progress"]:
            painter.drawPixmap(0, 0, self.pixmap_progress, 0, 0, self.veh_pos, 0)

        # Draw marks
        painter.drawPixmap(0, 0, self.pixmap_marks)

        if self.wcfg["show_elevation_progress_line"]:
            painter.drawPixmap(0, 0, self.pixmap_progress_line, 0, 0, self.veh_pos, 0)

        if self.wcfg["show_position_mark"]:
            painter.setPen(self.pen_mark)
            painter.drawLine(self.veh_pos, 0, self.veh_pos, self.display_height)

        # Draw readings
        painter.setPen(self.pen_text)
        if self.wcfg["show_elevation_reading"]:
            painter.drawText(
                self.rect_text_elevation,
                self.elevation_text_alignment,
                f"{self.unit_dist(api.read.vehicle.position_vertical()):.1f}{self.symbol_dist}"
            )
        if self.wcfg["show_elevation_scale"]:
            # Format elevation scale (meter or feet per pixel)
            map_scale = round(self.unit_dist(1 / self.map_scale[1]), 2) if self.map_scale[1] else 1
            painter.drawText(
                self.rect_text_scale,
                self.scale_text_alignment,
                f"1:{map_scale}"
            )

    def create_elevation_path(self, raw_coords=None):
        """Create elevation path"""
        map_path = QPainterPath()
        if raw_coords:
            self.map_scaled, self.map_range, self.map_scale = calc.scale_elevation(
                raw_coords,
                self.display_width,
                self.display_height - self.display_margin_top - self.display_margin_bottom)

            # Correct start & finish nodes position
            sf_y_average = (self.map_scaled[0][1] + self.map_scaled[-1][1]) * 0.5

            # Set boundary start node
            map_path.moveTo(-999, self.map_scaled[-2][1])  # 2nd last node y pos

            # Set middle nodes
            total_nodes = len(self.map_scaled) - 1
            skip_node = calc.skip_map_nodes(total_nodes, self.display_width, self.display_detail_level)
            last_dist = 0
            last_skip = 0
            for index, coords in enumerate(self.map_scaled):
                if index == 0:
                    map_path.lineTo(0, sf_y_average)
                elif index >= total_nodes:  # don't skip last node
                    map_path.lineTo(self.display_width, sf_y_average)
                elif coords[0] > last_dist and last_skip >= skip_node:
                    map_path.lineTo(*coords)
                    last_skip = 0
                    last_dist = coords[0]
                last_skip += 1

            # Set boundary end node
            map_path.lineTo(self.display_width + 999, self.map_scaled[1][1])  # 2nd node y pos
            map_path.lineTo(self.display_width + 999, -999)
            map_path.lineTo(-999, -999)
            map_path.closeSubpath()

        # Temp map
        else:
            self.map_scaled = None
            map_path.moveTo(-999, self.display_height * 0.5)
            map_path.lineTo(self.display_width + 999, self.display_height * 0.5)
            map_path.lineTo(self.display_width + 999, -999)
            map_path.lineTo(-999, -999)
            map_path.closeSubpath()

        return map_path

    def draw_background(self, map_path):
        """Draw background image"""
        if self.wcfg["show_background"]:
            self.pixmap_background.fill(self.wcfg["bkg_color"])
        else:
            self.pixmap_background.fill(Qt.transparent)
        painter = QPainter(self.pixmap_background)
        painter.setRenderHint(QPainter.Antialiasing, True)

        # Set vertical flip to correct elevation direction
        painter.setViewport(0, self.display_height, self.display_width, -self.display_height)

        # Add margin offset
        if self.map_scaled:
            painter.translate(0, self.display_margin_bottom)

        # Draw elevation background
        if self.wcfg["show_elevation_background"]:
            brush = QBrush(Qt.SolidPattern)
            brush.setColor(self.wcfg["bkg_color_elevation"])
            painter.setBrush(brush)
            painter.setPen(Qt.NoPen)
            painter.drawPath(map_path)

    def draw_progress(self, map_path):
        """Draw progress image"""
        self.pixmap_progress.fill(Qt.transparent)
        painter = QPainter(self.pixmap_progress)
        painter.setRenderHint(QPainter.Antialiasing, True)

        # Set vertical flip to correct elevation direction
        painter.setViewport(0, self.display_height, self.display_width, -self.display_height)

        # Add margin offset
        if self.map_scaled:
            painter.translate(0, self.display_margin_bottom)

        # Draw elevation progress
        brush = QBrush(Qt.SolidPattern)
        brush.setColor(self.wcfg["elevation_progress_color"])
        painter.setBrush(brush)
        painter.setPen(Qt.NoPen)
        painter.drawPath(map_path)

    def draw_progress_line(self, map_path):
        """Draw progress line image"""
        self.pixmap_progress_line.fill(Qt.transparent)
        painter = QPainter(self.pixmap_progress_line)
        painter.setRenderHint(QPainter.Antialiasing, True)

        # Set vertical flip to correct elevation direction
        painter.setViewport(0, self.display_height, self.display_width, -self.display_height)

        # Add margin offset
        if self.map_scaled:
            painter.translate(0, self.display_margin_bottom)

        # Draw elevation progress line
        pen = QPen()
        pen.setJoinStyle(Qt.RoundJoin)
        pen.setWidth(self.wcfg["elevation_progress_line_width"])
        pen.setColor(self.wcfg["elevation_progress_line_color"])
        painter.setPen(pen)
        painter.drawPath(map_path)

    def draw_marks(self, map_path):
        """Draw marks image"""
        self.pixmap_marks.fill(Qt.transparent)
        painter = QPainter(self.pixmap_marks)
        painter.setRenderHint(QPainter.Antialiasing, True)

        # Set vertical flip to correct elevation direction
        painter.setViewport(0, self.display_height, self.display_width, -self.display_height)

        # Add margin offset
        if self.map_scaled:
            painter.translate(0, self.display_margin_bottom)

        # Set pen style
        pen = QPen()
        pen.setJoinStyle(Qt.RoundJoin)

        # Draw elevation line
        if self.wcfg["show_elevation_line"]:
            pen.setWidth(self.wcfg["elevation_line_width"])
            pen.setColor(self.wcfg["elevation_line_color"])
            painter.setPen(pen)
            painter.drawPath(map_path)

        # Draw start line
        if self.wcfg["show_start_line"]:
            pen.setWidth(self.wcfg["start_line_width"])
            pen.setColor(self.wcfg["start_line_color"])
            painter.setPen(pen)
            painter.drawLine(0, -999, 0, 999)
            painter.drawLine(self.display_width, -999, self.display_width, 999)

        # Draw sector line
        sectors_index = minfo.mapping.sectors
        if self.wcfg["show_sector_line"] and self.map_scaled and isinstance(sectors_index, tuple):
            pen.setWidth(self.wcfg["sector_line_width"])
            pen.setColor(self.wcfg["sector_line_color"])
            painter.setPen(pen)
            for index in sectors_index:
                pos_x = self.map_scaled[index][0]
                painter.drawLine(pos_x, -999, pos_x, 999)

        # Draw zero elevation line
        if self.wcfg["show_zero_elevation_line"] and self.map_scaled:
            pen.setWidth(self.wcfg["zero_elevation_line_width"])
            pen.setColor(self.wcfg["zero_elevation_line_color"])
            painter.setPen(pen)
            # scale * (0pos - min_range)
            zero_elevation = self.map_scale[1] * -self.map_range[2]
            painter.drawLine(0, zero_elevation, self.display_width, zero_elevation)

```

# File: tinypedal/widget/engine.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Engine Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..units import (
    set_symbol_power,
    set_symbol_pressure,
    set_unit_power,
    set_unit_pressure,
    set_unit_temperature,
)
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 8 + bar_padx

        # Config units
        self.unit_temp = set_unit_temperature(self.cfg.units["temperature_unit"])
        self.unit_power = set_unit_power(self.cfg.units["power_unit"])
        self.symbol_power = set_symbol_power(self.cfg.units["power_unit"])
        self.unit_pres = set_unit_pressure(self.cfg.units["turbo_pressure_unit"])
        self.symbol_pres = set_symbol_pressure(self.cfg.units["turbo_pressure_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Oil temperature
        if self.wcfg["show_oil_temperature"]:
            self.bar_style_oil = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_oil"],
                    bg_color=self.wcfg["bkg_color_oil"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_oil"],
                    bg_color=self.wcfg["warning_color_overheat"])
            )
            self.bar_oil = self.set_qlabel(
                text="Oil T",
                style=self.bar_style_oil[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_oil,
                column=self.wcfg["column_index_oil"],
            )

        # Water temperature
        if self.wcfg["show_water_temperature"]:
            self.bar_style_water = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_water"],
                    bg_color=self.wcfg["bkg_color_water"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_water"],
                    bg_color=self.wcfg["warning_color_overheat"])
            )
            self.bar_water = self.set_qlabel(
                text="Water T",
                style=self.bar_style_water[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_water,
                column=self.wcfg["column_index_water"],
            )

        # Turbo pressure
        if self.wcfg["show_turbo_pressure"]:
            bar_style_turbo = self.set_qss(
                fg_color=self.wcfg["font_color_turbo"],
                bg_color=self.wcfg["bkg_color_turbo"]
            )
            self.bar_turbo = self.set_qlabel(
                text="Turbo",
                style=bar_style_turbo,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_turbo,
                column=self.wcfg["column_index_turbo"],
            )

        # Engine RPM
        if self.wcfg["show_rpm"]:
            bar_style_rpm = self.set_qss(
                fg_color=self.wcfg["font_color_rpm"],
                bg_color=self.wcfg["bkg_color_rpm"]
            )
            self.bar_rpm = self.set_qlabel(
                text="RPM",
                style=bar_style_rpm,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_rpm,
                column=self.wcfg["column_index_rpm"],
            )

        # Engine RPM maximum
        if self.wcfg["show_rpm_maximum"]:
            bar_style_rpm_max = self.set_qss(
                fg_color=self.wcfg["font_color_rpm_maximum"],
                bg_color=self.wcfg["bkg_color_rpm_maximum"]
            )
            self.bar_rpm_max = self.set_qlabel(
                text="MAX RPM",
                style=bar_style_rpm_max,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_rpm_max,
                column=self.wcfg["column_index_rpm_maximum"],
            )

        # Engine torque
        if self.wcfg["show_torque"]:
            bar_style_torque = self.set_qss(
                fg_color=self.wcfg["font_color_torque"],
                bg_color=self.wcfg["bkg_color_torque"]
            )
            self.bar_torque = self.set_qlabel(
                text="TORQUE",
                style=bar_style_torque,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_torque,
                column=self.wcfg["column_index_torque"],
            )

        # Engine power
        if self.wcfg["show_power"]:
            bar_style_power = self.set_qss(
                fg_color=self.wcfg["font_color_power"],
                bg_color=self.wcfg["bkg_color_power"]
            )
            self.bar_power = self.set_qlabel(
                text="POWER",
                style=bar_style_power,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_power,
                column=self.wcfg["column_index_power"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Oil temperature
        if self.wcfg["show_oil_temperature"]:
            temp_oil = round(api.read.engine.oil_temperature(), 2)
            self.update_oil(self.bar_oil, temp_oil)

        # Water temperature
        if self.wcfg["show_water_temperature"]:
            temp_water = round(api.read.engine.water_temperature(), 2)
            self.update_water(self.bar_water, temp_water)

        # Turbo pressure
        if self.wcfg["show_turbo_pressure"]:
            turbo = int(api.read.engine.turbo())
            self.update_turbo(self.bar_turbo, turbo)

        # Engine RPM
        if self.wcfg["show_rpm"]:
            rpm = int(api.read.engine.rpm())
            self.update_rpm(self.bar_rpm, rpm)

        # Engine RPM maximum
        if self.wcfg["show_rpm_maximum"]:
            rpm_max = int(api.read.engine.rpm_max())
            self.update_rpm_max(self.bar_rpm_max, rpm_max)

        # Engine torque
        if self.wcfg["show_torque"]:
            torque = round(api.read.engine.torque(), 2)
            self.update_torque(self.bar_torque, torque)

        # Engine power
        if self.wcfg["show_power"]:
            power = round(calc.engine_power(
                api.read.engine.torque(), api.read.engine.rpm()), 2)
            self.update_power(self.bar_power, power)

    # GUI update methods
    def update_oil(self, target, data):
        """Oil temperature"""
        if target.last != data:
            target.last = data
            target.setText(f"O{self.unit_temp(data): >6.1f}Â°")
            target.updateStyle(self.bar_style_oil[data >= self.wcfg["overheat_threshold_oil"]])

    def update_water(self, target, data):
        """Water temperature"""
        if target.last != data:
            target.last = data
            target.setText(f"W{self.unit_temp(data): >6.1f}Â°")
            target.updateStyle(self.bar_style_water[data >= self.wcfg["overheat_threshold_water"]])

    def update_turbo(self, target, data):
        """Turbo pressure"""
        if target.last != data:
            target.last = data
            text = f"{self.unit_pres(data * 0.001):03.3f}"[:5]
            target.setText(f"{text}{self.symbol_pres}")

    def update_rpm(self, target, data):
        """Engine RPM"""
        if target.last != data:
            target.last = data
            target.setText(f"{data: >5}rpm")

    def update_rpm_max(self, target, data):
        """Engine RPM maximum"""
        if target.last != data:
            target.last = data
            target.setText(f"{data: >5}max")

    def update_torque(self, target, data):
        """Engine torque"""
        if target.last != data:
            target.last = data
            text = f"{data: >6.2f}"[:6]
            target.setText(f"{text}Nm")

    def update_power(self, target, data):
        """Engine power"""
        if target.last != data:
            target.last = data
            text = f"{self.unit_power(data): >6.2f}"[:6]
            target.setText(f"{text}{self.symbol_power}")

```

# File: tinypedal/widget/flag.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Flag Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import MAX_SECONDS
from ..module_info import minfo
from ..units import set_symbol_distance, set_unit_distance, set_unit_fuel
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 7 + bar_padx

        # Config units
        self.unit_fuel = set_unit_fuel(self.cfg.units["fuel_unit"])
        self.unit_dist = set_unit_distance(self.cfg.units["distance_unit"])
        self.symbol_dist = set_symbol_distance(self.cfg.units["distance_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Pit status
        if self.wcfg["show_pit_timer"]:
            self.bar_style_pit_timer = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit_timer"],
                    bg_color=self.wcfg["bkg_color_pit_timer"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit_timer_stopped"],
                    bg_color=self.wcfg["bkg_color_pit_timer_stopped"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit_closed"],
                    bg_color=self.wcfg["bkg_color_pit_closed"])
            )
            self.bar_pit_timer = self.set_qlabel(
                text="PITST0P",
                style=self.bar_style_pit_timer[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_pit_timer,
                column=self.wcfg["column_index_pit_timer"],
            )

        # Low fuel warning
        if self.wcfg["show_low_fuel"]:
            bar_style_lowfuel = self.set_qss(
                fg_color=self.wcfg["font_color_low_fuel"],
                bg_color=self.wcfg["bkg_color_low_fuel"]
            )
            self.bar_lowfuel = self.set_qlabel(
                text="LOWFUEL",
                style=bar_style_lowfuel,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_lowfuel,
                column=self.wcfg["column_index_low_fuel"],
            )

        # Speed limiter
        if self.wcfg["show_speed_limiter"]:
            bar_style_limiter = self.set_qss(
                fg_color=self.wcfg["font_color_speed_limiter"],
                bg_color=self.wcfg["bkg_color_speed_limiter"]
            )
            self.bar_limiter = self.set_qlabel(
                text=self.wcfg["speed_limiter_text"],
                style=bar_style_limiter,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_limiter,
                column=self.wcfg["column_index_speed_limiter"],
            )

        # Yellow flag
        if self.wcfg["show_yellow_flag"]:
            bar_style_yellowflag = self.set_qss(
                fg_color=self.wcfg["font_color_yellow_flag"],
                bg_color=self.wcfg["bkg_color_yellow_flag"]
            )
            self.bar_yellowflag = self.set_qlabel(
                text="YELLOW",
                style=bar_style_yellowflag,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_yellowflag,
                column=self.wcfg["column_index_yellow_flag"],
            )

        # Blue flag
        if self.wcfg["show_blue_flag"]:
            bar_style_blueflag = self.set_qss(
                fg_color=self.wcfg["font_color_blue_flag"],
                bg_color=self.wcfg["bkg_color_blue_flag"]
            )
            self.bar_blueflag = self.set_qlabel(
                text="BLUE",
                style=bar_style_blueflag,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_blueflag,
                column=self.wcfg["column_index_blue_flag"],
            )

        # Start lights
        if self.wcfg["show_startlights"]:
            self.bar_style_startlights = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_startlights"],
                    bg_color=self.wcfg["bkg_color_red_lights"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_startlights"],
                    bg_color=self.wcfg["bkg_color_green_flag"])
            )
            self.bar_startlights = self.set_qlabel(
                text="SLIGHTS",
                style=self.bar_style_startlights[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_startlights,
                column=self.wcfg["column_index_startlights"],
            )

        # Incoming traffic
        if self.wcfg["show_traffic"]:
            bar_style_traffic = self.set_qss(
                fg_color=self.wcfg["font_color_traffic"],
                bg_color=self.wcfg["bkg_color_traffic"]
            )
            self.bar_traffic = self.set_qlabel(
                text="TRAFFIC",
                style=bar_style_traffic,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_traffic,
                column=self.wcfg["column_index_traffic"],
            )

        # Pit request
        if self.wcfg["show_pit_request"]:
            bar_style_pit_request = self.set_qss(
                fg_color=self.wcfg["font_color_pit_request"],
                bg_color=self.wcfg["bkg_color_pit_request"]
            )
            self.bar_pit_request = self.set_qlabel(
                text="PIT REQ",
                style=bar_style_pit_request,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_pit_request,
                column=self.wcfg["column_index_pit_request"],
            )

        # Finish state
        if self.wcfg["show_finish_state"]:
            self.bar_style_finish_state = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_finish"],
                    bg_color=self.wcfg["bkg_color_finish"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_disqualify"],
                    bg_color=self.wcfg["bkg_color_disqualify"])
            )
            self.bar_finish_state = self.set_qlabel(
                text="FINISH",
                style=self.bar_style_finish_state[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_finish_state,
                column=self.wcfg["column_index_finish_state"],
            )

        # Last data
        self.pit_timer = PitTimer(self.wcfg["pit_time_highlight_duration"])
        self.green_timer = GreenFlagTimer(self.wcfg["green_flag_duration"])
        self.blue_timer = BlueFlagTimer(self.wcfg["show_blue_flag_for_race_only"])
        self.traffic_timer = TrafficTimer(
            self.wcfg["traffic_maximum_time_gap"],
            self.wcfg["traffic_pitout_duration"],
            self.wcfg["traffic_low_speed_threshold"],
        )

    def post_update(self):
        self.pit_timer.reset()
        self.blue_timer.reset()
        self.traffic_timer.reset()
        self.green_timer.reset()

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Read state data
        lap_etime = api.read.timing.elapsed()
        in_pits = api.read.vehicle.in_pits()
        in_race = api.read.session.in_race()

        # Pit timer
        if self.wcfg["show_pit_timer"]:
            if in_pits and api.read.vehicle.in_garage():
                pitting_state = MAX_SECONDS
            else:
                pitting_state = self.pit_timer.update(in_pits, lap_etime)
            self.update_pit_timer(self.bar_pit_timer, pitting_state)

        # Low fuel update
        if self.wcfg["show_low_fuel"]:
            fuel_usage = self.is_lowfuel(in_race)
            self.update_lowfuel(self.bar_lowfuel, fuel_usage)

        # Pit limiter
        if self.wcfg["show_speed_limiter"]:
            limiter_state = api.read.switch.speed_limiter()
            self.update_limiter(self.bar_limiter, limiter_state)

        # Blue flag
        if self.wcfg["show_blue_flag"]:
            blue_state = self.blue_timer.update(in_race, lap_etime)
            self.update_blueflag(self.bar_blueflag, blue_state)

        # Yellow flag
        if self.wcfg["show_yellow_flag"]:
            yellow_state = self.yellow_flag_state(in_race)
            self.update_yellowflag(self.bar_yellowflag, yellow_state)

        # Start lights
        if self.wcfg["show_startlights"]:
            green_state = self.green_timer.update(lap_etime)
            self.update_startlights(self.bar_startlights, green_state)

        # Incoming traffic
        if self.wcfg["show_traffic"]:
            traffic = self.traffic_timer.update(in_pits, lap_etime)
            self.update_traffic(self.bar_traffic, traffic)

        # Pit request
        if self.wcfg["show_pit_request"]:
            pit_request = self.pit_in_countdown()
            self.update_pit_request(self.bar_pit_request, pit_request)

        # Finish state
        if self.wcfg["show_finish_state"]:
            finish_state = api.read.vehicle.finish_state()
            self.update_finish_state(self.bar_finish_state, finish_state)

    # GUI update methods
    def update_pit_timer(self, target, data):
        """Pit timer"""
        if target.last != data:
            target.last = data
            if data != MAX_SECONDS:
                if data < 0:  # finished pits
                    color = self.bar_style_pit_timer[1]
                    state = f"F{-data: >6.2f}"[:7]
                elif api.read.session.pit_open():
                    color = self.bar_style_pit_timer[0]
                    state = f"P{data: >6.2f}"[:7]
                else:  # pit closed
                    color = self.bar_style_pit_timer[2]
                    state = self.wcfg["pit_closed_text"]
                target.setText(state)
                target.updateStyle(color)
                target.show()
            else:
                target.hide()

    def update_lowfuel(self, target, data):
        """Low fuel warning"""
        if target.last != data:
            target.last = data
            if data != "":
                target.setText(data)
                target.show()
            else:
                target.hide()

    def update_limiter(self, target, data):
        """Speed limiter"""
        if target.last != data:
            target.last = data
            if data == 1:
                target.show()
            else:
                target.hide()

    def update_blueflag(self, target, data):
        """Blue flag"""
        if target.last != data:
            target.last = data
            if data != MAX_SECONDS:
                target.setText(f"BLUE{data:3.0f}"[:7])
                target.show()
            else:
                target.hide()

    def update_yellowflag(self, target, data):
        """Yellow flag"""
        if target.last != data:
            target.last = data
            if data != MAX_SECONDS:
                text = f"{self.unit_dist(data):+.0f}{self.symbol_dist}"
                target.setText(f"Y{text: >6}"[:7])
                target.show()
            else:
                target.hide()

    def update_startlights(self, target, data):
        """Start lights"""
        if target.last != data:
            target.last = data
            if data > 0:
                target.setText(f"{self.wcfg['red_lights_text'][:6]: <6}{data}")
                target.updateStyle(self.bar_style_startlights[0])
                target.show()
            elif data == 0:
                target.setText(self.wcfg["green_flag_text"])
                target.updateStyle(self.bar_style_startlights[1])
                target.show()
            else:
                target.hide()

    def update_traffic(self, target, data):
        """Incoming traffic"""
        if target.last != data:
            target.last = data
            if data != MAX_SECONDS:
                target.setText(f"â‰¥{data: >5.1f}s"[:7])
                target.show()
            else:
                target.hide()

    def update_pit_request(self, target, data):
        """Pit request"""
        if target.last != data:
            target.last = data
            if data != "":
                target.setText(data)
                target.show()
            else:
                target.hide()

    def update_finish_state(self, target, data):
        """Finish state"""
        if target.last != data:
            target.last = data
            if data == 1:
                target.setText(self.wcfg["finish_text"])
                target.updateStyle(self.bar_style_finish_state[0])
                target.show()
            elif data == 3:
                target.setText(self.wcfg["disqualify_text"])
                target.updateStyle(self.bar_style_finish_state[1])
                target.show()
            else:
                target.hide()

    # Additional methods
    def is_lowfuel(self, in_race):
        """Is low fuel"""
        if self.wcfg["show_low_fuel_for_race_only"] and not in_race:
            return ""

        if api.read.vehicle.max_virtual_energy() and minfo.energy.estimatedLaps < minfo.fuel.estimatedLaps:
            prefix = "LE"
            amount_curr = minfo.energy.amountCurrent
            est_laps = minfo.energy.estimatedLaps
        else:
            prefix = "LF"
            amount_curr = minfo.fuel.amountCurrent
            est_laps = minfo.fuel.estimatedLaps

        if (amount_curr > self.wcfg["low_fuel_volume_threshold"] or
            est_laps > self.wcfg["low_fuel_lap_threshold"]):
            return ""  # not low fuel

        if prefix == "LF":
            amount_curr = self.unit_fuel(amount_curr)
        return f"{prefix}{amount_curr: >5.2f}"[:7]

    def pit_in_countdown(self) -> str:
        """Pit in countdown (laps)"""
        if not api.read.vehicle.pit_request():
            return ""

        if api.read.vehicle.max_virtual_energy():
            est_laps = min(minfo.fuel.estimatedLaps, minfo.energy.estimatedLaps)
        else:
            est_laps = minfo.fuel.estimatedLaps
        cd_laps = calc.pit_in_countdown_laps(est_laps, api.read.lap.progress())

        safe_laps = f"{cd_laps:.2f}"[:3].strip(".")
        est_laps = f"{est_laps:.2f}"[:3].strip(".")
        return f"{safe_laps: <3}â‰¤{est_laps: >3}"

    def yellow_flag_state(self, in_race: bool) -> float:
        """Yellow flag state"""
        if not self.wcfg["show_yellow_flag_for_race_only"] or in_race:
            if api.read.session.yellow_flag():
                yellow_ahead = minfo.vehicles.nearestYellowAhead
                if yellow_ahead <= self.wcfg["yellow_flag_maximum_range_ahead"]:
                    return yellow_ahead
                yellow_behind = minfo.vehicles.nearestYellowBehind
                if yellow_behind >= -self.wcfg["yellow_flag_maximum_range_behind"]:
                    return yellow_behind
        return MAX_SECONDS


class GreenFlagTimer:
    """Green flag timer"""

    __slots__ = (
        "_last_lap_stime",
        "_green_flag_duration",
    )

    def __init__(self, green_flag_duration: bool):
        self._last_lap_stime = -1
        self._green_flag_duration = green_flag_duration

    def update(self, elapsed_time: float) -> int:
        """Check start lights and green flag state"""
        if api.read.session.in_countdown():
            self._last_lap_stime = api.read.timing.start()

        if self._last_lap_stime == -1:
            return -1  # bypass checking after green flag

        start_timer = elapsed_time - self._last_lap_stime
        if start_timer > self._green_flag_duration:
            self._last_lap_stime = -1
            return -1 # disable green flag
        if start_timer < 0:
            return api.read.session.start_lights()  # enable red lights
        return 0  # enable green flag

    def reset(self):
        """Reset"""
        self._last_lap_stime = -1


class TrafficTimer:
    """Traffic timer"""

    __slots__ = (
        "_timer_start",
        "_last_in_pits",
        "_max_time_gap",
        "_pitout_duration",
        "_low_speed_threshold",
    )

    def __init__(self, max_time_gap: bool, pitout_duration: float, low_speed_threshold: float):
        self._timer_start = 0.0
        self._last_in_pits = 0
        self._max_time_gap = max_time_gap
        self._pitout_duration = pitout_duration
        self._low_speed_threshold = low_speed_threshold

    def update(self, in_pits: bool, elapsed_time: float) -> float:
        """Check incoming traffic and time gap"""
        if self._last_in_pits > in_pits:
            self._timer_start = elapsed_time
        self._last_in_pits = in_pits

        if self._timer_start and elapsed_time - self._timer_start > self._pitout_duration:
            self._timer_start = 0

        traffic_time = minfo.vehicles.nearestTraffic
        if traffic_time < self._max_time_gap:
            if (api.read.vehicle.speed() < self._low_speed_threshold > 0
                or in_pits or self._timer_start):
                return traffic_time
        return MAX_SECONDS

    def reset(self):
        """Reset"""
        self._timer_start = 0
        self._last_in_pits = 0


class BlueFlagTimer:
    """Blue flag timer"""

    __slots__ = (
        "_timer_start",
        "_race_only",
    )

    def __init__(self, race_only: bool):
        self._timer_start = 0.0
        self._race_only = race_only

    def update(self, in_race: bool, elapsed_time: float) -> float:
        """Check blue flag state"""
        if not self._race_only or in_race:
            if api.read.session.blue_flag():
                if not self._timer_start:
                    self._timer_start = elapsed_time
                return elapsed_time - self._timer_start
            self._timer_start = 0
        return MAX_SECONDS

    def reset(self):
        """Reset"""
        self._timer_start = 0


class PitTimer:
    """Pit timer"""

    __slots__ = (
        "_timer_start",
        "_last_in_pits",
        "_last_pit_time",
        "_max_duration",
    )

    def __init__(self, highlight_duration: float):
        self._timer_start = 0.0
        self._last_in_pits = 0
        self._last_pit_time = 0.0
        self._max_duration = highlight_duration

    def update(self, in_pits: bool, elapsed_time: float) -> float:
        """Check pit state"""
        if self._last_in_pits < in_pits:
            self._timer_start = elapsed_time
        self._last_in_pits = in_pits

        if not self._timer_start:
            return MAX_SECONDS

        pit_timer = elapsed_time - self._timer_start
        if in_pits:
            self._last_pit_time = pit_timer
        elif pit_timer - self._last_pit_time <= self._max_duration:
            pit_timer = -self._last_pit_time  # set negative for highlighting
        else:
            self._timer_start = 0  # stop timer
            pit_timer = MAX_SECONDS
        return pit_timer

    def reset(self):
        """Reset"""
        self._timer_start = 0
        self._last_in_pits = 0
        self._last_pit_time = 0

```

# File: tinypedal/widget/force.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Force Widget
"""

from ..const_common import TEXT_NA
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 6 + bar_padx

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # G force
        if self.wcfg["show_g_force"]:
            bar_style_gforce_lgt = self.set_qss(
                fg_color=self.wcfg["font_color_g_force"],
                bg_color=self.wcfg["bkg_color_g_force"]
            )
            self.bar_gforce_lgt = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_gforce_lgt,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_gforce_lgt,
                column=self.wcfg["column_index_long_gforce"],
            )

            bar_style_gforce_lat = self.set_qss(
                fg_color=self.wcfg["font_color_g_force"],
                bg_color=self.wcfg["bkg_color_g_force"]
            )
            self.bar_gforce_lat = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_gforce_lat,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_gforce_lat,
                column=self.wcfg["column_index_lat_gforce"],
            )

        # Downforce ratio
        if self.wcfg["show_downforce_ratio"]:
            bar_style_df_ratio = self.set_qss(
                fg_color=self.wcfg["font_color_downforce_ratio"],
                bg_color=self.wcfg["bkg_color_downforce_ratio"]
            )
            self.bar_df_ratio = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_df_ratio,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_df_ratio,
                column=self.wcfg["column_index_downforce_ratio"],
            )

        # Front downforce
        if self.wcfg["show_front_downforce"]:
            self.bar_style_df_front = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_front_downforce"],
                    bg_color=self.wcfg["bkg_color_front_downforce"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_front_downforce"],
                    bg_color=self.wcfg["warning_color_liftforce"])
            )
            self.bar_df_front = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_df_front[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_df_front,
                column=self.wcfg["column_index_front_downforce"],
            )

        # Rear downforce
        if self.wcfg["show_rear_downforce"]:
            self.bar_style_df_rear = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_rear_downforce"],
                    bg_color=self.wcfg["bkg_color_rear_downforce"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_rear_downforce"],
                    bg_color=self.wcfg["warning_color_liftforce"])
            )
            self.bar_df_rear = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_df_rear[0],
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_df_rear,
                column=self.wcfg["column_index_rear_downforce"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # G force
        if self.wcfg["show_g_force"]:
            # Longitudinal g-force
            gf_lgt = round(minfo.force.lgtGForceRaw, 2)
            self.update_gf_lgt(self.bar_gforce_lgt, gf_lgt)

            # Lateral g-force
            gf_lat = round(minfo.force.latGForceRaw, 2)
            self.update_gf_lat(self.bar_gforce_lat, gf_lat)

        # Downforce ratio
        if self.wcfg["show_downforce_ratio"]:
            df_ratio = round(minfo.force.downForceRatio, 2)
            self.update_df_ratio(self.bar_df_ratio, df_ratio)

        # Front downforce
        if self.wcfg["show_front_downforce"]:
            df_front = round(minfo.force.downForceFront)
            self.update_df_front(self.bar_df_front, df_front)

        # Rear downforce
        if self.wcfg["show_rear_downforce"]:
            df_rear = round(minfo.force.downForceRear)
            self.update_df_rear(self.bar_df_rear, df_rear)

    # GUI update methods
    def update_gf_lgt(self, target, data):
        """Longitudinal g-force"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.gforce_lgt(data)} {abs(data):.2f}")

    def update_gf_lat(self, target, data):
        """Lateral g-force"""
        if target.last != data:
            target.last = data
            target.setText(f"{abs(data):.2f} {self.gforce_lat(data)}")

    def update_df_ratio(self, target, data):
        """Downforce ratio"""
        if target.last != data:
            target.last = data
            text = f"{data:.2f}"[:5].strip(".")
            target.setText(f"{text}%")

    def update_df_front(self, target, data):
        """Downforce front"""
        if target.last != data:
            target.last = data
            target.setText(f"F{abs(data):5.0f}"[:6])
            target.updateStyle(self.bar_style_df_front[data < 0])

    def update_df_rear(self, target, data):
        """Downforce rear"""
        if target.last != data:
            target.last = data
            target.setText(f"R{abs(data):5.0f}"[:6])
            target.updateStyle(self.bar_style_df_rear[data < 0])

    # Additional methods
    @staticmethod
    def gforce_lgt(g_force):
        """Longitudinal g-force direction symbol"""
        if g_force > 0.1:
            return "â–¼"
        if g_force < -0.1:
            return "â–²"
        return "â—"

    @staticmethod
    def gforce_lat(g_force):
        """Lateral g-force direction symbol"""
        if g_force > 0.1:
            return "â—€"
        if g_force < -0.1:
            return "â–¶"
        return "â—"

```

# File: tinypedal/widget/friction_circle.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Friction circle Widget
"""

from collections import deque

from PySide2.QtCore import QPointF, QRectF, Qt
from PySide2.QtGui import QBrush, QColor, QPainter, QPen, QPixmap, QRadialGradient

from .. import calculation as calc
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        text_width = font_m.width * 4
        display_size = max(int(self.wcfg["display_size"]), 20)
        self.display_radius_g = max(self.wcfg["display_radius_g"], 1)
        self.global_scale = (display_size * 0.5) / self.display_radius_g
        self.area_size = display_size + font_m.height * 2
        self.area_center = self.area_size * 0.5

        self.dot_size = max(self.wcfg["dot_size"], 1)
        self.rect_text_top = QRectF(
            self.area_center - text_width * 0.5,
            font_offset,
            text_width,
            font_m.height
        )
        self.rect_text_bottom = QRectF(
            self.area_center - text_width * 0.5,
            self.area_size - font_m.height + font_offset,
            text_width,
            font_m.height
        )
        self.rect_text_left = QRectF(
            0,
            self.area_center - font_m.height + font_offset,
            text_width,
            font_m.height
        )
        self.rect_text_right = QRectF(
            self.area_size - text_width,
            self.area_center - font_m.height + font_offset,
            text_width,
            font_m.height
        )

        # Config canvas
        self.resize(self.area_size, self.area_size)
        self.pixmap_background = QPixmap(self.area_size, self.area_size)
        self.pixmap_dot = QPixmap(self.dot_size * 2, self.dot_size * 2)
        self.pixmap_trace = QPixmap(self.area_size, self.area_size)
        self.pixmap_trace.fill(Qt.transparent)
        if self.wcfg["show_trace_fade_out"]:
            trace_alpha = int(255 * min(max(self.wcfg["trace_fade_out_step"], 0.1), 0.9) / 2)
            self.fademask_color = QColor(0, 0, 0, trace_alpha)
            self.rect_fademask = QRectF(0, 0, self.area_size, self.area_size)

        self.pen_mark = QPen()
        self.pen_trace = QPen()
        self.pen_trace.setWidth(self.wcfg["trace_width"])
        self.pen_trace.setColor(self.wcfg["trace_color"])
        self.pen_trace.setStyle(Qt.SolidLine)
        self.pen_trace.setCapStyle(Qt.RoundCap)
        self.pen_text_raw = QPen()
        self.pen_text_raw.setColor(self.wcfg["font_color"])
        self.pen_text_max = QPen()
        self.pen_text_max.setColor(self.wcfg["font_color_highlight"])

        self.draw_background(self.area_center)
        self.draw_dot()

        # Last data
        self.gforce_raw = 0,0
        self.data_gforce = deque([], max(self.wcfg["trace_max_samples"], 5))
        self.last_x = self.area_center
        self.last_y = self.area_center

    def post_update(self):
        self.data_gforce.clear()

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Read acceleration data
        if self.wcfg["show_inverted_orientation"]:
            temp_gforce_raw = (  # accel top, brake bottom
                round(minfo.force.lgtGForceRaw, 3),
                round(-minfo.force.latGForceRaw, 3),
            )
        else:
            temp_gforce_raw = (  # brake top, accel bottom
                round(-minfo.force.lgtGForceRaw, 3),
                round(minfo.force.latGForceRaw, 3),
            )

        if self.gforce_raw != temp_gforce_raw:
            self.gforce_raw = temp_gforce_raw
            # Scale position coordinate to global
            self.last_x = temp_gforce_raw[1] * self.global_scale + self.area_center
            self.last_y = temp_gforce_raw[0] * self.global_scale + self.area_center
            if self.wcfg["show_trace"]:
                self.data_gforce.append(QPointF(self.last_x, self.last_y))
                self.draw_trace()
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)
        # Draw g circle background
        painter.drawPixmap(0, 0, self.pixmap_background)
        # Draw max average g circle
        if self.wcfg["show_max_average_lateral_g_circle"]:
            self.draw_circle_mark(
                painter,
                self.wcfg["max_average_lateral_g_circle_style"],
                minfo.force.maxAvgLatGForce,
                self.wcfg["max_average_lateral_g_circle_width"],
                self.wcfg["max_average_lateral_g_circle_color"]
            )
        # Draw trace
        if self.wcfg["show_trace"]:
            painter.drawPixmap(0, 0, self.pixmap_trace)
        # Draw dot
        if self.wcfg["show_dot"]:
            painter.drawPixmap(
                self.last_x - self.dot_size, self.last_y - self.dot_size, self.pixmap_dot)
        # Draw text
        if self.wcfg["show_readings"]:
            self.draw_text(painter)

    def draw_background(self, center):
        """Draw g circle background (one time)"""
        if self.wcfg["show_background"]:
            self.pixmap_background.fill(self.wcfg["bkg_color"])
        else:
            self.pixmap_background.fill(Qt.transparent)
        painter = QPainter(self.pixmap_background)
        painter.setRenderHint(QPainter.Antialiasing, True)

        if self.wcfg["show_circle_background"]:
            painter.setPen(Qt.NoPen)
            scale = round(self.display_radius_g * self.global_scale)
            if self.wcfg["show_fade_out"]:
                rad_gra = QRadialGradient(center, center, scale)
                rad_gra.setColorAt(
                    calc.zero_one(self.wcfg["fade_in_radius"]),
                    self.wcfg["bkg_color_circle"])
                rad_gra.setColorAt(
                    calc.zero_one(self.wcfg["fade_out_radius"]),
                    Qt.transparent)
                painter.setBrush(rad_gra)
            else:
                brush = QBrush(Qt.SolidPattern)
                brush.setColor(self.wcfg["bkg_color_circle"])
                painter.setBrush(brush)
            painter.drawEllipse(center - scale, center - scale, scale * 2, scale * 2)

        # Draw center mark
        if self.wcfg["show_center_mark"]:
            if self.wcfg["center_mark_style"]:
                self.pen_mark.setStyle(Qt.SolidLine)
            else:
                self.pen_mark.setStyle(Qt.DashLine)
            scale = self.global_scale * min(
                self.wcfg["center_mark_radius_g"], self.display_radius_g
            )
            self.pen_mark.setWidth(self.wcfg["center_mark_width"])
            self.pen_mark.setColor(self.wcfg["center_mark_color"])
            painter.setPen(self.pen_mark)
            painter.drawLine(center, center, center - scale, center)
            painter.drawLine(center, center, center, center + scale)
            painter.drawLine(center, center, center, center - scale)
            painter.drawLine(center, center, center + scale, center)

        # Draw circle mark
        if self.wcfg["show_reference_circle"]:
            painter.setBrush(Qt.NoBrush)
            for idx in range(1, 6):
                self.draw_circle_mark(
                    painter,
                    self.wcfg[f"reference_circle_{idx}_style"],
                    self.wcfg[f"reference_circle_{idx}_radius_g"],
                    self.wcfg[f"reference_circle_{idx}_width"],
                    self.wcfg[f"reference_circle_{idx}_color"]
                )

    def draw_circle_mark(self, painter, style, radius, width, color):
        """Draw circle mark"""
        if radius <= self.display_radius_g and width > 0:
            scale = round(radius * self.global_scale)
            pos = self.area_center - scale
            size = scale * 2
            self.pen_mark.setStyle(Qt.SolidLine if style else Qt.DashLine)
            self.pen_mark.setWidth(width)
            self.pen_mark.setColor(color)
            painter.setPen(self.pen_mark)
            painter.drawEllipse(pos, pos, size, size)

    def draw_trace(self):
        """Draw trace image"""
        painter = QPainter(self.pixmap_trace)
        painter.setRenderHint(QPainter.Antialiasing, True)
        if self.wcfg["show_trace_fade_out"]:
            painter.setCompositionMode(QPainter.CompositionMode_DestinationOut)
            painter.fillRect(self.rect_fademask, self.fademask_color)
            painter.setCompositionMode(QPainter.CompositionMode_SourceOver)
        else:
            self.pixmap_trace.fill(Qt.transparent)
        painter.setPen(self.pen_trace)
        if self.wcfg["trace_style"]:
            painter.drawPoints(self.data_gforce)
        else:
            painter.drawPolyline(self.data_gforce)

    def draw_dot(self):
        """Draw dot image (one time)"""
        self.pixmap_dot.fill(Qt.transparent)
        painter = QPainter(self.pixmap_dot)
        painter.setRenderHint(QPainter.Antialiasing, True)
        if self.wcfg["dot_outline_width"] > 0:
            pen = QPen()
            pen.setWidth(self.wcfg["dot_outline_width"])
            pen.setColor(self.wcfg["dot_outline_color"])
            painter.setPen(pen)
        else:
            painter.setPen(Qt.NoPen)
        brush = QBrush(Qt.SolidPattern)
        brush.setColor(self.wcfg["dot_color"])
        painter.setBrush(brush)
        painter.drawEllipse(self.dot_size * 0.5, self.dot_size * 0.5, self.dot_size, self.dot_size)

    def draw_text(self, painter):
        """Draw text"""
        # Current G reading
        painter.setPen(self.pen_text_raw)
        painter.drawText(
            self.rect_text_top,
            Qt.AlignCenter,
            f"{abs(self.gforce_raw[0]):.2f}"
        )
        painter.drawText(
            self.rect_text_right,
            Qt.AlignCenter,
            f"{abs(self.gforce_raw[1]):.2f}"
        )
        # Max G reading
        painter.setPen(self.pen_text_max)
        painter.drawText(
            self.rect_text_bottom,
            Qt.AlignCenter,
            f"{minfo.force.maxLgtGForce:.2f}"[:4]
        )
        painter.drawText(
            self.rect_text_left,
            Qt.AlignCenter,
            f"{minfo.force.maxLatGForce:.2f}"[:4]
        )

```

# File: tinypedal/widget/fuel.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Fuel Widget
"""

from .. import calculation as calc
from ..module_info import minfo
from ..units import set_unit_fuel
from ._base import Overlay
from ._common import WarningFlash
from ._painter import FuelLevelBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        text_def = "-.--"
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.bar_width = max(self.wcfg["bar_width"], 3)
        style_width = font_m.width * self.bar_width + bar_padx
        column_count = 0

        # Config units
        self.unit_fuel = set_unit_fuel(self.cfg.units["fuel_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Create layout
        layout_upper = self.set_grid_layout()
        layout_lower = self.set_grid_layout()
        layout.addLayout(layout_upper, self.wcfg["column_index_upper"], 0)
        layout.addLayout(layout_lower, self.wcfg["column_index_lower"], 0)

        # Caption style
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_size=int(self.wcfg['font_size'] * 0.8)
            )
            row_idx_upper = 2 * self.wcfg["swap_upper_caption"]
            row_idx_lower = 2 - 2 * self.wcfg["swap_lower_caption"]

        # Remaining
        self.bar_style_curr = (
            self.set_qss(
                fg_color=self.wcfg["font_color_remain"],
                bg_color=self.wcfg["bkg_color_remain"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_remain"],
                bg_color=self.wcfg["warning_color_low_fuel"])
        )
        self.bar_curr = self.set_qlabel(
            text=text_def,
            style=self.bar_style_curr[0],
            fixed_width=style_width,
        )
        self.bar_curr.decimals = max(self.wcfg["decimal_places_remain"], 0)
        layout_upper.addWidget(self.bar_curr, 1, 1)
        column_count += 1

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_remain"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_upper.addWidget(cap_temp, row_idx_upper, 1)

        # Total needed
        self.bar_style_need = (
            self.set_qss(
                fg_color=self.wcfg["font_color_refuel"],
                bg_color=self.wcfg["bkg_color_refuel"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_refuel"],
                bg_color=self.wcfg["warning_color_low_fuel"])
        )
        self.bar_need = self.set_qlabel(
            text=text_def,
            style=self.bar_style_need[0],
            fixed_width=style_width,
        )
        self.bar_need.decimals = max(self.wcfg["decimal_places_refuel"], 0)
        layout_upper.addWidget(self.bar_need, 1, 2)
        column_count += 1

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=(
                    self.wcfg["caption_text_absolute_refuel"]
                    if self.wcfg["show_absolute_refueling"]
                    else self.wcfg["caption_text_refuel"]
                ),
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_upper.addWidget(cap_temp, row_idx_upper, 2)

        # Estimated laps can last
        bar_style_laps = self.set_qss(
            fg_color=self.wcfg["font_color_laps"],
            bg_color=self.wcfg["bkg_color_laps"]
        )
        self.bar_laps = self.set_qlabel(
            text=text_def,
            style=bar_style_laps,
            fixed_width=style_width,
        )
        self.bar_laps.decimals = max(self.wcfg["decimal_places_laps"], 0)
        layout_lower.addWidget(self.bar_laps, 1, 1)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_laps"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_lower.addWidget(cap_temp, row_idx_lower, 1)

        # Estimated minutes can last
        bar_style_mins = self.set_qss(
            fg_color=self.wcfg["font_color_minutes"],
            bg_color=self.wcfg["bkg_color_minutes"]
        )
        self.bar_mins = self.set_qlabel(
            text=text_def,
            style=bar_style_mins,
            fixed_width=style_width,
        )
        self.bar_mins.decimals = max(self.wcfg["decimal_places_minutes"], 0)
        layout_lower.addWidget(self.bar_mins, 1, 2)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_minutes"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_lower.addWidget(cap_temp, row_idx_lower, 2)

        # Estimated consumption
        bar_style_used = self.set_qss(
            fg_color=self.wcfg["font_color_used"],
            bg_color=self.wcfg["bkg_color_used"]
        )
        self.bar_used = self.set_qlabel(
            text=text_def,
            style=bar_style_used,
            fixed_width=style_width,
        )
        self.bar_used.decimals = max(self.wcfg["decimal_places_used"], 0)
        layout_upper.addWidget(self.bar_used, 1, 3)
        column_count += 1

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_used"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_upper.addWidget(cap_temp, row_idx_upper, 3)

        # Estimated one less pit consumption
        bar_style_save = self.set_qss(
            fg_color=self.wcfg["font_color_save"],
            bg_color=self.wcfg["bkg_color_save"]
        )
        self.bar_save = self.set_qlabel(
            text=text_def,
            style=bar_style_save,
            fixed_width=style_width,
        )
        self.bar_save.decimals = max(self.wcfg["decimal_places_save"], 0)
        layout_lower.addWidget(self.bar_save, 1, 3)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_save"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_lower.addWidget(cap_temp, row_idx_lower, 3)

        if self.wcfg["show_estimated_pitstop_count"]:
            # Estimate pit stop counts when pitting at end of current stint
            bar_style_pits = self.set_qss(
                fg_color=self.wcfg["font_color_pits"],
                bg_color=self.wcfg["bkg_color_pits"]
            )
            self.bar_pits = self.set_qlabel(
                text=text_def,
                style=bar_style_pits,
                fixed_width=style_width,
            )
            self.bar_pits.decimals = max(self.wcfg["decimal_places_pits"], 0)
            layout_upper.addWidget(self.bar_pits, 1, 0)
            column_count += 1

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_pits"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_upper.addWidget(cap_temp, row_idx_upper, 0)

            # Estimate pit stop counts when pitting at end of current lap
            bar_style_early = self.set_qss(
                fg_color=self.wcfg["font_color_early"],
                bg_color=self.wcfg["bkg_color_early"]
            )
            self.bar_early = self.set_qlabel(
                text=text_def,
                style=bar_style_early,
                fixed_width=style_width,
            )
            self.bar_early.decimals = max(self.wcfg["decimal_places_early"], 0)
            layout_lower.addWidget(self.bar_early, 1, 0)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_early"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_lower.addWidget(cap_temp, row_idx_lower, 0)

        if self.wcfg["show_delta_and_end_remaining"]:
            # Delta consumption
            bar_style_delta = self.set_qss(
                fg_color=self.wcfg["font_color_delta"],
                bg_color=self.wcfg["bkg_color_delta"]
            )
            self.bar_delta = self.set_qlabel(
                text=text_def,
                style=bar_style_delta,
                fixed_width=style_width,
            )
            self.bar_delta.decimals = max(self.wcfg["decimal_places_delta"], 0)
            layout_upper.addWidget(self.bar_delta, 1, 4)
            column_count += 1

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_delta"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_upper.addWidget(cap_temp, row_idx_upper, 4)

            # Estimated end remaining
            bar_style_end = self.set_qss(
                fg_color=self.wcfg["font_color_end"],
                bg_color=self.wcfg["bkg_color_end"]
            )
            self.bar_end = self.set_qlabel(
                text=text_def,
                style=bar_style_end,
                fixed_width=style_width,
            )
            self.bar_end.decimals = max(self.wcfg["decimal_places_end"], 0)
            layout_lower.addWidget(self.bar_end, 1, 4)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_end"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_lower.addWidget(cap_temp, row_idx_lower, 4)

        # Fuel level bar
        if self.wcfg["show_fuel_level_bar"]:
            self.bar_level = FuelLevelBar(
                self,
                width=(font_m.width * self.bar_width + bar_padx) * column_count,
                height=max(self.wcfg["fuel_level_bar_height"], 1),
                start_mark_width=max(self.wcfg["starting_fuel_level_mark_width"], 1),
                refill_mark_width=max(self.wcfg["refueling_level_mark_width"], 1),
                input_color=self.wcfg["highlight_color_fuel_level"],
                bg_color=self.wcfg["bkg_color_fuel_level"],
                start_mark_color=self.wcfg["starting_fuel_level_mark_color"],
                refill_mark_color=self.wcfg["refueling_level_mark_color"],
                show_start_mark=self.wcfg["show_starting_fuel_level_mark"],
                show_refill_mark=self.wcfg["show_refueling_level_mark"],
            )
            layout.addWidget(self.bar_level, self.wcfg["column_index_middle"], 0)

        if self.wcfg["show_low_fuel_warning_flash"]:
            self.warn_flash = WarningFlash(
                self.wcfg["warning_flash_highlight_duration"],
                self.wcfg["warning_flash_interval"],
                self.wcfg["number_of_warning_flashes"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        is_low_fuel = minfo.fuel.estimatedLaps <= self.wcfg["low_fuel_lap_threshold"]
        if self.wcfg["show_low_fuel_warning_flash"] and minfo.fuel.estimatedValidConsumption:
            is_low_fuel = self.warn_flash.state(is_low_fuel)
            if is_low_fuel:
                padding = 0.00000001  # add padding for switching state
            else:
                padding = 0
        else:
            padding = 0

        # Remaining
        amount_curr = self.unit_fuel(minfo.fuel.amountCurrent)
        self.update_fuel(self.bar_curr, amount_curr + padding, self.bar_style_curr[is_low_fuel])

        # Total needed
        if self.wcfg["show_absolute_refueling"]:
            amount_need = calc.sym_max(self.unit_fuel(minfo.fuel.neededAbsolute), 9999)
            self.update_fuel(self.bar_need, amount_need + padding, self.bar_style_need[is_low_fuel])
        else:
            amount_need = calc.sym_max(self.unit_fuel(minfo.fuel.neededRelative), 9999)
            self.update_fuel(self.bar_need, amount_need + padding, self.bar_style_need[is_low_fuel], "+")

        # Estimated laps can last
        est_runlaps = min(minfo.fuel.estimatedLaps, 9999)
        self.update_fuel(self.bar_laps, est_runlaps)

        # Estimated minutes can last
        est_runmins = min(minfo.fuel.estimatedMinutes, 9999)
        self.update_fuel(self.bar_mins, est_runmins)

        # Estimated consumption
        used_last = self.unit_fuel(minfo.fuel.estimatedConsumption)
        self.update_fuel(self.bar_used, used_last)

        # Estimated one less pit consumption
        fuel_save = calc.zero_max(self.unit_fuel(minfo.fuel.oneLessPitConsumption), 99.99)
        self.update_fuel(self.bar_save, fuel_save)

        if self.wcfg["show_estimated_pitstop_count"]:
            # Estimate pit stop counts when pitting at end of current stint
            est_pits_end = calc.zero_max(minfo.fuel.estimatedNumPitStopsEnd, 99.99)
            self.update_fuel(self.bar_pits, est_pits_end)

            # Estimate pit stop counts when pitting at end of current lap
            est_pits_early = calc.zero_max(minfo.fuel.estimatedNumPitStopsEarly, 99.99)
            self.update_fuel(self.bar_early, est_pits_early)

        if self.wcfg["show_delta_and_end_remaining"]:
            # Delta consumption
            delta_fuel = self.unit_fuel(minfo.fuel.deltaConsumption)
            self.update_fuel(self.bar_delta, delta_fuel, None, "+")

            # Estimated end remaining
            amount_end = self.unit_fuel(minfo.fuel.amountEndStint)
            self.update_fuel(self.bar_end, amount_end)

        # Fuel level bar
        if self.wcfg["show_fuel_level_bar"]:
            level_capacity = minfo.fuel.capacity
            level_curr = minfo.fuel.amountCurrent
            level_start = minfo.fuel.amountStart
            level_refill = level_curr + minfo.fuel.neededRelative
            level_state = round(level_curr + level_start + level_refill, 3)
            if level_capacity and self.bar_level.last != level_state:
                self.bar_level.last = level_state
                self.bar_level.update_input(
                    level_curr / level_capacity,
                    level_start / level_capacity,
                    level_refill / level_capacity,
                )

    # GUI update methods
    def update_fuel(self, target, data, color=None, sign=""):
        """Update fuel data"""
        if target.last != data:
            target.last = data
            text = f"{data:{sign}.{target.decimals}f}"[:self.bar_width].strip(".")
            target.setText(text)
            if color:  # low fuel warning
                target.updateStyle(color)

```

# File: tinypedal/widget/fuel_energy_saver.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Fuel energy saver Widget
"""

from math import floor

from .. import calculation as calc
from ..api_control import api
from ..const_common import ENERGY_TYPE_ID, MAX_SECONDS, TEXT_PLACEHOLDER
from ..module_info import minfo
from ..units import set_unit_fuel
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap_hori=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        self.pit_bias = self.wcfg["enable_pit_entry_bias"]
        self.pitstop_threshold = self.wcfg["remaining_pitstop_threshold"]
        layout_reversed = self.wcfg["layout"] != 0
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.char_width = max(self.wcfg["bar_width"], 4)
        bar_width = font_m.width * self.char_width + bar_padx
        self.center_slot = min(max(self.wcfg["number_of_less_laps"], 0), 5) + 1 + self.pit_bias  # column offset
        self.total_slot = min(max(self.wcfg["number_of_more_laps"], 1), 10) + 1 + self.center_slot
        self.decimals_consumption = max(self.wcfg["decimal_places_consumption"], 0)
        self.decimals_delta = max(self.wcfg["decimal_places_delta"], 0)
        self.min_reserve = max(self.wcfg["minimum_reserve"], 0)

        # Config units
        self.unit_fuel = set_unit_fuel(self.cfg.units["fuel_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Target lap row
        bar_style_lap = (
            self.set_qss(
                fg_color=self.wcfg["font_color_target_laps"],
                bg_color=self.wcfg["bkg_color_target_laps"],
                font_size=int(self.wcfg['font_size'] * 0.8)),
            self.set_qss(
                fg_color=self.wcfg["font_color_current_laps"],
                bg_color=self.wcfg["bkg_color_current_laps"],
                font_size=int(self.wcfg['font_size'] * 0.8))
        )
        self.bars_target_lap = self.set_qlabel(
            text=TEXT_PLACEHOLDER,
            style=bar_style_lap[0],
            width=bar_width,
            count=self.total_slot,
            last=-MAX_SECONDS,
        )
        if self.pit_bias:
            self.bars_target_lap[0].setText("BIAS")
            self.bars_target_lap[1].setText("LAST")
        else:
            self.bars_target_lap[0].setText("LAST")
        self.bars_target_lap[self.center_slot].updateStyle(bar_style_lap[1])
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_target_lap,
            row_index=0,
            right_to_left=layout_reversed,
        )

        # Target consumption row
        bar_style_target_use = self.set_qss(
            fg_color=self.wcfg["font_color_target_consumption"],
            bg_color=self.wcfg["bkg_color_target_consumption"]
        )
        self.bars_target_use = self.set_qlabel(
            text=TEXT_PLACEHOLDER,
            style=bar_style_target_use,
            width=bar_width,
            last=-MAX_SECONDS,
            count=self.total_slot,
        )
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_target_use,
            row_index=1,
            right_to_left=layout_reversed,
        )

        # Delat consumption row
        self.delta_color = (
            self.set_qss(
                fg_color=self.wcfg["font_color_lap_gain"],
                bg_color=self.wcfg["bkg_color_delta_consumption"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_lap_loss"],
                bg_color=self.wcfg["bkg_color_delta_consumption"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_delta_consumption"],
                bg_color=self.wcfg["bkg_color_delta_consumption"])
        )
        self.bars_delta = self.set_qlabel(
            text=TEXT_PLACEHOLDER,
            style=self.delta_color[2],
            width=bar_width,
            count=self.total_slot,
            last=-MAX_SECONDS,
        )
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_delta,
            row_index=2,
            right_to_left=layout_reversed,
        )

        # Last data
        self.reset_stint = True  # reset stint stats
        self.start_laps = 0  # laps number at start of current stint
        self.last_tyre_life = 0
        self.last_fuel_curr = 0

    def post_update(self):
        self.reset_stint = True

    def timerEvent(self, event):
        """Update when vehicle on track"""
        in_pits = api.read.vehicle.in_pits()
        tyre_life = sum(api.read.tyre.wear())
        lap_num = api.read.lap.number()
        energy_type = api.read.vehicle.max_virtual_energy()
        pit_bias = 0.0

        if energy_type:
            fuel_curr = minfo.energy.amountCurrent
            fuel_est = minfo.energy.estimatedConsumption
            fuel_used_curr = minfo.energy.amountUsedCurrent
            fuel_used_last_raw = minfo.energy.lastLapConsumption
            est_pits = minfo.energy.estimatedNumPitStopsEnd
        else:
            fuel_curr = minfo.fuel.amountCurrent
            fuel_est = minfo.fuel.estimatedConsumption
            fuel_used_curr = minfo.fuel.amountUsedCurrent
            fuel_used_last_raw = minfo.fuel.lastLapConsumption
            est_pits = minfo.fuel.estimatedNumPitStopsEnd

        if self.pit_bias:
            pit_pos = minfo.mapping.pitEntryPosition
            track_length = api.read.lap.track_length()
            if 0 < pit_pos < track_length and est_pits > self.pitstop_threshold:
                pit_bias = 1 - pit_pos / track_length

        # Check stint status
        if not in_pits:
            self.last_fuel_curr = fuel_curr
            self.last_tyre_life = tyre_life
        # Reset stint if changed tyre or refueled or back in garage
        elif (self.last_tyre_life < tyre_life or
            self.last_fuel_curr < fuel_curr or api.read.vehicle.in_garage()):
            self.reset_stint = True

        if self.reset_stint:
            self.reset_stint = False
            self.start_laps = lap_num

        laps_done = max(lap_num - self.start_laps, 0)
        # Total fuel remaining count from start of current lap
        total_fuel_remaining = max(fuel_curr + fuel_used_curr - self.min_reserve + pit_bias * fuel_est, 0)
        # Estimate laps current fuel can last, minus center slot offset
        # Round to 1 decimal to reduce sensitivity
        est_runlaps = floor(round(calc.end_stint_laps(
            total_fuel_remaining, fuel_est), 1)) - self.center_slot

        # Pit entry bias
        if self.pit_bias:
            # Bias percent
            self.update_pit_bias(self.bars_delta[0], pit_bias)
            # Bias amount
            self.update_target_use(self.bars_target_use[0], pit_bias * fuel_est, energy_type)

        # Fuel or energy
        self.update_energy_type(self.bars_delta[self.pit_bias], energy_type)
        # Last lap consumption
        self.update_target_use(self.bars_target_use[self.pit_bias], fuel_used_last_raw, energy_type)

        # Update slots
        for index in range(1 + self.pit_bias, self.total_slot):
            # Progressive fuel saving
            total_laps_target = est_runlaps + index

            # Total laps + extra laps
            if index == self.center_slot:
                target_laps = f"{laps_done}/{laps_done + total_laps_target:d}"
            else:
                target_laps = f"{laps_done + total_laps_target:d}"
            self.update_total_laps(self.bars_target_lap[index], target_laps)

            # Target consumption
            if total_laps_target > 0 and fuel_est > 0:
                target_use = total_fuel_remaining / total_laps_target
            else:
                target_use = -MAX_SECONDS
            self.update_target_use(
                self.bars_target_use[index], target_use, energy_type)

            # Delta consumption
            if total_laps_target > 0 and fuel_est > 0:
                delta = fuel_est - target_use
            else:
                delta = -MAX_SECONDS
            self.update_delta(self.bars_delta[index], delta, energy_type)

    # GUI update methods
    def update_target_use(self, target, data, energy_type):
        """Target consumption"""
        if target.last != data:
            target.last = data
            if data > -MAX_SECONDS:
                if not energy_type:
                    data = self.unit_fuel(data)
                use_text = f"{data:.{self.decimals_consumption}f}"[:self.char_width]
            else:
                use_text = TEXT_PLACEHOLDER
            target.setText(use_text)

    def update_delta(self, target, data, energy_type):
        """Delta consumption between target & current"""
        if target.last != data:
            target.last = data
            if data > -MAX_SECONDS:
                if not energy_type:
                    data = self.unit_fuel(data)
                delta_text = f"{data:+.{self.decimals_delta}f}"[:self.char_width]
                style = self.delta_color[data >= 0]
            else:
                delta_text = TEXT_PLACEHOLDER
                style = self.delta_color[2]
            target.setText(delta_text)
            target.updateStyle(style)

    def update_total_laps(self, target, data):
        """Total laps"""
        if target.last != data:
            target.last = data
            target.setText(data)

    def update_energy_type(self, target, data):
        """Energy type"""
        if target.last != data:
            target.last = data
            target.setText(ENERGY_TYPE_ID[data > 0])

    def update_pit_bias(self, target, data):
        """Pit entry bias"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:.1%}"[:self.char_width])

```

# File: tinypedal/widget/gear.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Gear Widget
"""

from ..api_control import api
from ..module_info import minfo
from ..units import set_unit_speed
from ._base import Overlay
from ._painter import GearGaugeBar, ProgressBar, TextBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight_gear"]
        )
        self.setFont(font)

        (font_speed, font_offset, limiter_width, gauge_width, gauge_height, gear_size, speed_size
         ) = self.set_gauge_size(font)
        font_rpm = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size_rpm"],
            self.wcfg["font_weight_rpm"]
        )
        font_batt = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size_battery"],
            self.wcfg["font_weight_battery"]
        )

        # Config units
        self.unit_speed = set_unit_speed(self.cfg.units["speed_unit"])

        # Gear gauge
        self.gauge_color = (
            self.wcfg["bkg_color"],  # 0, -4 flicker
            self.wcfg["rpm_color_safe"],  # 1
            self.wcfg["rpm_color_redline"],  # 2
            self.wcfg["rpm_color_over_rev"],  # 3
        )
        self.bar_gauge = GearGaugeBar(
            self,
            width=gauge_width,
            height=gauge_height,
            font_speed=font_speed,
            gear_size=gear_size,
            speed_size=speed_size,
            fg_color=self.wcfg["font_color"],
            bg_color=self.wcfg["bkg_color"],
            show_speed=self.wcfg["show_speed"],
        )
        self.set_primary_orient(
            target=self.bar_gauge,
            column=self.wcfg["column_index_gauge"],
        )

        # RPM bar
        if self.wcfg["show_rpm_bar"]:
            self.bar_rpmbar = ProgressBar(
                self,
                width=gauge_width,
                height=max(self.wcfg["rpm_bar_height"], 1),
                offset_x=self.wcfg["rpm_reading_offset_x"],
                offset_y=self.calc_font_offset(self.get_font_metrics(font_rpm)),
                font=font_rpm,
                input_color=self.wcfg["rpm_bar_color"],
                fg_color=self.wcfg["font_color_rpm"],
                bg_color=self.wcfg["rpm_bar_bkg_color"],
                decimals=self.wcfg["rpm_decimal_places"],
                show_reading=self.wcfg["show_rpm_reading"],
                align=self.set_text_alignment(self.wcfg["rpm_reading_text_alignment"]),
                right_side=self.wcfg["show_inverted_rpm"],
            )
            self.set_primary_orient(
                target=self.bar_rpmbar,
                column=self.wcfg["column_index_rpm"],
            )

        # Battery bar
        if self.wcfg["show_battery_bar"]:
            self.battbar_color = (
                self.wcfg["battery_bar_color"],
                self.wcfg["battery_bar_color_regen"],
                self.wcfg["warning_color_low_battery"],
                self.wcfg["warning_color_high_battery"],
            )
            self.bar_battbar = ProgressBar(
                self,
                width=gauge_width,
                height=max(self.wcfg["battery_bar_height"], 1),
                offset_x=self.wcfg["battery_reading_offset_x"],
                offset_y=self.calc_font_offset(self.get_font_metrics(font_batt)),
                font=font_batt,
                input_color=self.battbar_color[0],
                fg_color=self.wcfg["font_color_battery"],
                bg_color=self.wcfg["battery_bar_bkg_color"],
                decimals=self.wcfg["battery_decimal_places"],
                show_reading=self.wcfg["show_battery_reading"],
                align=self.set_text_alignment(self.wcfg["battery_reading_text_alignment"]),
                right_side=self.wcfg["show_inverted_battery"],
            )
            self.bar_battbar.state = None
            self.set_primary_orient(
                target=self.bar_battbar,
                column=self.wcfg["column_index_battery"],
            )

        # Speed limiter
        if self.wcfg["show_speed_limiter"]:
            self.bar_limiter = TextBar(
                self,
                width=limiter_width,
                height=gauge_height,
                font_offset=font_offset,
                fg_color=self.wcfg["font_color_speed_limiter"],
                bg_color=self.wcfg["bkg_color_speed_limiter"],
                text=self.wcfg["speed_limiter_text"],
            )
            self.set_primary_orient(
                target=self.bar_limiter,
                column=self.wcfg["column_index_gauge"],
                row=1,
            )

        # Last data
        self.flicker = 0
        self.shifting_timer_start = 0
        self.shifting_timer = 0
        self.rpm_safe = 0
        self.rpm_red = 0
        self.rpm_crit = 0
        self.rpm_range = 0
        self.rpm_max = 0
        self.gear_max = 0
        self.last_gear = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # RPM reference
        rpm_max = api.read.engine.rpm_max()
        if self.rpm_max != rpm_max:
            self.rpm_max = rpm_max
            self.rpm_safe = int(rpm_max * self.wcfg["rpm_multiplier_safe"])
            self.rpm_red = int(rpm_max * self.wcfg["rpm_multiplier_redline"])
            self.rpm_crit = int(rpm_max * self.wcfg["rpm_multiplier_critical"])
            self.rpm_range = rpm_max - self.rpm_safe
            self.gear_max = api.read.engine.gear_max()

        # Shifting timer
        gear = api.read.engine.gear()
        lap_etime = api.read.timing.elapsed()
        if self.last_gear != gear:
            self.last_gear = gear
            self.shifting_timer_start = lap_etime
        self.shifting_timer = lap_etime - self.shifting_timer_start

        # Gauge
        rpm = api.read.engine.rpm()
        speed = api.read.vehicle.speed()
        self.update_gauge(self.bar_gauge, rpm, gear, speed)

        # RPM bar
        if self.wcfg["show_rpm_bar"]:
            self.update_rpmbar(self.bar_rpmbar, rpm)

        # Battery bar
        if self.wcfg["show_battery_bar"]:
            battery = minfo.hybrid.batteryCharge
            motor_state = minfo.hybrid.motorState
            self.update_battbar(self.bar_battbar, battery, motor_state)

        # Speed limier
        if self.wcfg["show_speed_limiter"]:
            limiter = api.read.switch.speed_limiter()
            self.update_limiter(self.bar_limiter, limiter)

    # GUI update methods
    def update_gauge(self, target, rpm, gear, speed):
        """Gauge bar"""
        gauge_state = rpm + gear + speed
        if target.last != gauge_state:
            target.last = gauge_state
            color_index = self.color_rpm(rpm, gear, speed)
            target.update_input(
                gear,
                self.unit_speed(speed),
                color_index,
                self.gauge_color[color_index],
            )

    def update_rpmbar(self, target, data):
        """RPM bar"""
        if target.last != data:
            target.last = data
            rpm_offset = data - self.rpm_safe
            if self.rpm_range > 0 <= rpm_offset:  # show only above offset
                rpm_percent = rpm_offset / self.rpm_range
            else:
                rpm_percent = 0
            target.update_input(rpm_percent, data)

    def update_battbar(self, target, data, state):
        """Battery bar"""
        available = state > 0  # available check only
        if target.state != available:
            target.state = available
            # Hide if electric motor unavailable
            target.setHidden(not available)
        charge = state + data  # add state to finalize last change
        if target.last != charge:
            target.last = charge
            if state == 3:
                color_index = 1
            elif data >= self.wcfg["high_battery_threshold"]:
                color_index = 3
            elif data <= self.wcfg["low_battery_threshold"]:
                color_index = 2
            else:
                color_index = 0
            target.input_color = self.battbar_color[color_index]
            target.update_input(data * 0.01, data)

    def update_limiter(self, target, data):
        """Limiter"""
        if target.last != data:
            target.last = data
            target.setHidden(not data)

    # Additional methods
    def color_rpm(self, rpm, gear, speed):
        """RPM indicator color"""
        self.flicker = not self.flicker
        if (self.wcfg["show_rpm_flickering_above_critical"] and
            self.flicker and
            gear < self.gear_max and
            rpm >= self.rpm_crit):
            return -4
        if (not gear and
            speed > self.wcfg["neutral_warning_speed_threshold"] and
            self.shifting_timer >= self.wcfg["neutral_warning_time_threshold"]
            ) or rpm > self.rpm_max:
            return 3
        if rpm >= self.rpm_red:
            return 2
        if rpm >= self.rpm_safe:
            return 1
        return 0

    def set_gauge_size(self, font):
        """Set gauge size"""
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)
        if self.wcfg["show_speed_below_gear"]:
            font_scale_speed = self.wcfg["font_scale_speed"]
        else:
            font_scale_speed = 1
        font_speed = self.config_font(
            self.wcfg["font_name"],
            round(self.wcfg["font_size"] * font_scale_speed),
            self.wcfg["font_weight_speed"]
        )

        # Config variable
        inner_gap = self.wcfg["inner_gap"]
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        limiter_width = (
            font_m.width * len(self.wcfg["speed_limiter_text"])
            + round(font_m.width * self.wcfg["speed_limiter_padding_horizontal"]) * 2)

        gear_width = font_m.width + padx * 2
        gear_height = font_m.capital + pady * 2
        speed_width = round(font_m.width * 3 * font_scale_speed) + padx * 2
        speed_height = round(font_m.capital * font_scale_speed) + pady * 2

        if self.wcfg["show_speed_below_gear"]:
            gauge_width = gear_width
            gauge_height = gear_height + (inner_gap + speed_height) * self.wcfg["show_speed"]
            speed_size = (0, gear_height + inner_gap + font_offset, gear_width, speed_height)

        else:
            gauge_width = gear_width + (inner_gap + speed_width) * self.wcfg["show_speed"]
            gauge_height = gear_height
            speed_size = (gear_width + inner_gap, font_offset, speed_width, gear_height)
        gear_size = (0, font_offset, gear_width, gear_height)
        return (font_speed, font_offset, limiter_width, gauge_width, gauge_height,
                gear_size, speed_size)

```

# File: tinypedal/widget/heading.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Heading Widget
"""

from PySide2.QtCore import QPointF, QRectF, Qt
from PySide2.QtGui import QBrush, QPainter, QPen, QPixmap

from .. import calculation as calc
from ..api_control import api
from ..const_file import ImageFile
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        self.area_size = max(int(self.wcfg["display_size"]), 20)
        self.area_center = self.area_size * 0.5
        self.decimals = max(int(self.wcfg["decimal_places"]), 0)
        text_width = font_m.width * (5 + self.decimals)

        self.dir_line = (
            QPointF(0, -self.area_center * self.wcfg["direction_line_head_scale"]),
            QPointF(0, self.area_center * self.wcfg["direction_line_tail_scale"])
        )
        self.yaw_line = (
            QPointF(0, -self.area_center * self.wcfg["yaw_line_head_scale"]),
            QPointF(0, self.area_center * self.wcfg["yaw_line_tail_scale"])
        )
        self.slip_angle_line = (
            QPointF(0, -self.area_center * self.wcfg["slip_angle_line_head_scale"]),
            QPointF(0, self.area_center * self.wcfg["slip_angle_line_tail_scale"])
        )
        self.rect_text_yaw = QRectF(
            self.area_size * self.wcfg["yaw_angle_offset_x"] - text_width * 0.5,
            self.area_size * self.wcfg["yaw_angle_offset_y"] - font_m.height * 0.5 + font_offset,
            text_width,
            font_m.height
        )
        self.rect_text_slip = QRectF(
            self.area_size * self.wcfg["slip_angle_offset_x"] - text_width * 0.5,
            self.area_size * self.wcfg["slip_angle_offset_y"] - font_m.height * 0.5 + font_offset,
            text_width,
            font_m.height
        )

        # Config canvas
        self.resize(self.area_size, self.area_size)
        self.pixmap_background = QPixmap(self.area_size, self.area_size)
        self.pixmap_dot = QPixmap(self.area_size, self.area_size)
        self.pixmap_icon = QPixmap(ImageFile.COMPASS).scaledToWidth(
            int(self.area_size * 1.5),
            mode=Qt.SmoothTransformation
        )

        self.pen_yaw = QPen()
        self.pen_yaw.setCapStyle(Qt.RoundCap)
        self.pen_yaw.setWidth(self.wcfg["yaw_line_width"])
        self.pen_yaw.setColor(self.wcfg["yaw_line_color"])
        self.pen_slip = QPen()
        self.pen_slip.setCapStyle(Qt.RoundCap)
        self.pen_slip.setWidth(self.wcfg["slip_angle_line_width"])
        self.pen_slip.setColor(self.wcfg["slip_angle_line_color"])
        self.pen_direction = QPen()
        self.pen_direction.setCapStyle(Qt.RoundCap)
        self.pen_direction.setWidth(self.wcfg["direction_line_width"])
        self.pen_direction.setColor(self.wcfg["direction_line_color"])
        self.pen_text_yaw = QPen()
        self.pen_text_yaw.setColor(self.wcfg["font_color_yaw_angle"])
        self.pen_text_slip = QPen()
        self.pen_text_slip.setColor(self.wcfg["font_color_slip_angle"])

        self.draw_background(self.area_center)
        self.draw_dot(max(self.wcfg["dot_size"], 1))

        # Last data
        self.veh_ori_yaw = 0
        self.last_pos = 0,0
        self.yaw_angle = 0
        self.slip_angle = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Read speed, position data
        speed = api.read.vehicle.speed()
        pos_curr = (api.read.vehicle.position_longitudinal(),
                    api.read.vehicle.position_lateral())

        # Vehicle orientation yaw
        temp_veh_ori_yaw = calc.rad2deg(api.read.vehicle.orientation_yaw_radians()) + 180

        # Direction of travel yaw angle
        if self.last_pos != pos_curr and speed > 1:
            self.yaw_angle = temp_veh_ori_yaw - calc.rad2deg(calc.oriyaw2rad(
                pos_curr[0] - self.last_pos[0], pos_curr[1] - self.last_pos[1])) + 180
            self.last_pos = pos_curr
        elif speed <= 1:
            self.yaw_angle = 0
            self.last_pos = pos_curr

        # Slip angle
        if speed > 1:
            self.slip_angle = calc.rad2deg(
                (api.read.wheel.slip_angle_fl() + api.read.wheel.slip_angle_fr()) * 0.5)
        else:
            self.slip_angle = 0

        if self.veh_ori_yaw != temp_veh_ori_yaw:
            self.veh_ori_yaw = temp_veh_ori_yaw
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.setRenderHint(QPainter.SmoothPixmapTransform, True)
        # Draw circle background
        painter.drawPixmap(0, 0, self.pixmap_background)
        # Draw compass bearing
        painter.translate(self.area_center, self.area_center)
        painter.rotate(self.veh_ori_yaw)
        painter.drawPixmap(
            -self.area_center, -self.area_center,
            self.area_size, self.area_size,
            self.pixmap_icon)
        painter.resetTransform()
        # Draw yaw line
        if self.wcfg["show_yaw_line"]:
            painter.setPen(self.pen_yaw)
            painter.translate(self.area_center, self.area_center)
            painter.drawPolyline(self.yaw_line)
            painter.resetTransform()
        # Draw slip angle line
        if self.wcfg["show_slip_angle_line"]:
            painter.setPen(self.pen_slip)
            painter.translate(self.area_center, self.area_center)
            painter.rotate(self.slip_angle)
            painter.drawPolyline(self.slip_angle_line)
            painter.resetTransform()
        # Draw direction line
        if self.wcfg["show_direction_line"]:
            painter.setPen(self.pen_direction)
            painter.translate(self.area_center, self.area_center)
            painter.rotate(self.yaw_angle)
            painter.drawPolyline(self.dir_line)
            painter.resetTransform()
        # Draw dot
        if self.wcfg["show_dot"]:
            painter.drawPixmap(0, 0, self.pixmap_dot)
        # Draw text
        if self.wcfg["show_yaw_angle_reading"]:
            painter.setPen(self.pen_text_yaw)
            painter.drawText(
                self.rect_text_yaw,
                Qt.AlignCenter,
                self.format_angle(self.display_yaw_angle(self.yaw_angle))
            )
        if self.wcfg["show_slip_angle_reading"]:
            painter.setPen(self.pen_text_slip)
            painter.drawText(
                self.rect_text_slip,
                Qt.AlignCenter,
                self.format_angle(self.slip_angle)
            )

    def draw_background(self, center):
        """Draw circle background image"""
        if self.wcfg["show_background"]:
            self.pixmap_background.fill(self.wcfg["bkg_color"])
        else:
            self.pixmap_background.fill(Qt.transparent)
        painter = QPainter(self.pixmap_background)
        painter.setRenderHint(QPainter.Antialiasing, True)

        # Draw circle background
        if self.wcfg["show_circle_background"]:
            painter.setPen(Qt.NoPen)
            brush = QBrush(Qt.SolidPattern)
            brush.setColor(self.wcfg["bkg_color_circle"])
            painter.setBrush(brush)
            painter.drawEllipse(0, 0, self.area_size, self.area_size)

        # Draw center mark
        if self.wcfg["show_center_mark"]:
            pen = QPen()
            if self.wcfg["center_mark_style"]:
                pen.setStyle(Qt.SolidLine)
            else:
                pen.setStyle(Qt.DashLine)
            mark_scale = self.area_center * min(self.wcfg["center_mark_length_scale"], 1)
            pen.setWidth(self.wcfg["center_mark_width"])
            pen.setColor(self.wcfg["center_mark_color"])
            painter.setPen(pen)
            painter.drawLine(center, center, center - mark_scale, center)
            painter.drawLine(center, center, center, center + mark_scale)
            painter.drawLine(center, center, center, center - mark_scale)
            painter.drawLine(center, center, center + mark_scale, center)

    def draw_dot(self, dot_size):
        """Draw dot image"""
        self.pixmap_dot.fill(Qt.transparent)
        painter = QPainter(self.pixmap_dot)
        painter.setRenderHint(QPainter.Antialiasing, True)
        if self.wcfg["dot_outline_width"] > 0:
            pen = QPen()
            pen.setWidth(self.wcfg["dot_outline_width"])
            pen.setColor(self.wcfg["dot_outline_color"])
            painter.setPen(pen)
        else:
            painter.setPen(Qt.NoPen)
        brush = QBrush(Qt.SolidPattern)
        brush.setColor(self.wcfg["dot_color"])
        painter.setBrush(brush)
        pos_offset = (self.area_size - dot_size) * 0.5
        painter.drawEllipse(pos_offset, pos_offset, dot_size, dot_size)

    # Additional methods
    @staticmethod
    def display_yaw_angle(angle):
        """Set yaw angle display range"""
        if angle < -180:
            angle = 360 + angle
        elif angle > 180:
            angle = 360 - angle
        if abs(angle) > 180:
            angle = 360 - abs(angle)
        return angle

    def format_angle(self, angle):
        """Format angle text"""
        if self.wcfg["show_degree_sign"]:
            return f" {abs(angle):.{self.decimals}f}Â°"
        return f"{abs(angle):.{self.decimals}f}"

```

# File: tinypedal/widget/instrument.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Instrument Widget
"""

from PySide2.QtCore import Qt
from PySide2.QtGui import QPixmap

from ..api_control import api
from ..const_file import ImageFile
from ..module_info import minfo
from ._base import Overlay
from ._painter import split_pixmap_icon


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config variable
        icon_size = max(self.wcfg["icon_size"], 16) // 2 * 2
        self.warning_color = (
            self.set_qss(bg_color=self.wcfg["bkg_color"]),                 # 0
            self.set_qss(bg_color=self.wcfg["warning_color_stalling"]),    # 1
            self.set_qss(bg_color=self.wcfg["warning_color_clutch"]),      # 2
            self.set_qss(bg_color=self.wcfg["warning_color_wheel_lock"]),  # 3
            self.set_qss(bg_color=self.wcfg["warning_color_wheel_slip"]),  # 4
        )

        # Config canvas
        pixmap_icon = QPixmap(ImageFile.INSTRUMENT).scaledToWidth(
            icon_size * 2, mode=Qt.SmoothTransformation)
        # 0 = enabled icon state, 1 = disabled icon state.
        self.pixmap_headlights = create_icon_set(pixmap_icon, icon_size, 0)
        self.pixmap_ignition = create_icon_set(pixmap_icon, icon_size, 1)
        self.pixmap_clutch = create_icon_set(pixmap_icon, icon_size, 2)
        self.pixmap_wlock = create_icon_set(pixmap_icon, icon_size, 3)
        self.pixmap_wslip = create_icon_set(pixmap_icon, icon_size, 4)

        # Headlights
        if self.wcfg["show_headlights"]:
            self.bar_headlights = self.set_qlabel(
                fixed_width=icon_size,
                fixed_height=icon_size,
            )
            self.set_primary_orient(
                target=self.bar_headlights,
                column=self.wcfg["column_index_headlights"],
            )
            self.bar_headlights.setPixmap(self.pixmap_headlights[1])
            self.bar_headlights.updateStyle(self.warning_color[0])

        # Ignition
        if self.wcfg["show_ignition"]:
            self.bar_ignition = self.set_qlabel(
                fixed_width=icon_size,
                fixed_height=icon_size,
            )
            self.set_primary_orient(
                target=self.bar_ignition,
                column=self.wcfg["column_index_ignition"],
            )
            self.bar_ignition.setPixmap(self.pixmap_ignition[1])
            self.bar_ignition.updateStyle(self.warning_color[0])

        # Clutch
        if self.wcfg["show_clutch"]:
            self.bar_clutch = self.set_qlabel(
                fixed_width=icon_size,
                fixed_height=icon_size,
            )
            self.set_primary_orient(
                target=self.bar_clutch,
                column=self.wcfg["column_index_clutch"],
            )
            self.bar_clutch.setPixmap(self.pixmap_clutch[1])
            self.bar_clutch.updateStyle(self.warning_color[0])

        # Lock
        if self.wcfg["show_wheel_lock"]:
            self.bar_wlock = self.set_qlabel(
                fixed_width=icon_size,
                fixed_height=icon_size,
            )
            self.set_primary_orient(
                target=self.bar_wlock,
                column=self.wcfg["column_index_wheel_lock"],
            )
            self.bar_wlock.setPixmap(self.pixmap_wlock[1])
            self.bar_wlock.updateStyle(self.warning_color[0])

        # Slip
        if self.wcfg["show_wheel_slip"]:
            self.bar_wslip = self.set_qlabel(
                fixed_width=icon_size,
                fixed_height=icon_size,
            )
            self.set_primary_orient(
                target=self.bar_wslip,
                column=self.wcfg["column_index_wheel_slip"],
            )
            self.bar_wslip.setPixmap(self.pixmap_wslip[1])
            self.bar_wslip.updateStyle(self.warning_color[0])

        # Last data
        self.flicker = False

    def timerEvent(self, event):
        """Update when vehicle on track"""
        self.flicker = not self.flicker

        # Headlights
        if self.wcfg["show_headlights"]:
            headlights = api.read.switch.headlights()
            self.update_headlights(self.bar_headlights, headlights)

        # Ignition
        # 0 ignition & engine off, 1 ignition on & engine off, 2 ignition & engine on
        if self.wcfg["show_ignition"]:
            ignition = api.read.switch.ignition_starter() * (
                1 + (api.read.engine.rpm() > self.wcfg["stalling_rpm_threshold"]))
            self.update_ignition(self.bar_ignition, ignition)

        # Clutch
        # 2+ = auto clutch on, 1 or 3 = clutch activated
        if self.wcfg["show_clutch"]:
            clutch = (api.read.switch.auto_clutch() << 1) + (api.read.inputs.clutch() > 0.01)
            self.update_clutch(self.bar_clutch, clutch)

        # Wheel lock
        if self.wcfg["show_wheel_lock"]:
            wlock = (
                self.flicker and
                api.read.inputs.brake_raw() > 0 and
                min(minfo.wheels.slipRatio) < -self.wcfg["wheel_lock_threshold"]
            )
            self.update_wlock(self.bar_wlock, wlock)

        # Wheel slip
        if self.wcfg["show_wheel_slip"]:
            wslip = (
                self.flicker and
                api.read.inputs.throttle_raw() > 0 and
                max(minfo.wheels.slipRatio) >= self.wcfg["wheel_slip_threshold"]
            )
            self.update_wslip(self.bar_wslip, wslip)

    # GUI update methods
    def update_headlights(self, target, data):
        """Headlights update"""
        if target.last != data:
            target.last = data
            target.setPixmap(self.pixmap_headlights[data == 0])

    def update_ignition(self, target, data):
        """Ignition update"""
        if target.last != data:
            target.last = data
            target.setPixmap(self.pixmap_ignition[data == 0])
            target.updateStyle(self.warning_color[data == 1])

    def update_clutch(self, target, data):
        """Clutch update"""
        if target.last != data:
            target.last = data
            target.setPixmap(self.pixmap_clutch[data < 2])
            target.updateStyle(self.warning_color[data % 2 * 2])

    def update_wlock(self, target, data):
        """Wheel lock update"""
        if target.last != data:
            target.last = data
            target.setPixmap(self.pixmap_wlock[data == 0])
            target.updateStyle(self.warning_color[data * 3])

    def update_wslip(self, target, data):
        """Wheel slip update"""
        if target.last != data:
            target.last = data
            target.setPixmap(self.pixmap_wslip[data == 0])
            target.updateStyle(self.warning_color[data * 4])


def create_icon_set(pixmap_icon: QPixmap, icon_size: int, v_offset: int):
    """Create icon set"""
    return tuple(
        split_pixmap_icon(pixmap_icon, icon_size, h_offset, v_offset)
        for h_offset in range(2)
    )

```

# File: tinypedal/widget/lap_time_history.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Lap time history Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NOLAPTIME
from ..module_info import minfo
from ..units import set_unit_fuel
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap_vert=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        layout_reversed = self.wcfg["layout"] != 0
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.history_slot = min(max(self.wcfg["lap_time_history_count"], 1), 100)

        # Config units
        self.unit_fuel = set_unit_fuel(self.cfg.units["fuel_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Laps
        bar_style_laps = (
            self.set_qss(
                fg_color=self.wcfg["font_color_laps"],
                bg_color=self.wcfg["bkg_color_laps"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_laps"],
                bg_color=self.wcfg["bkg_color_last_laps"])
        )
        self.bars_laps = self.set_qlabel(
            text="---",
            style=bar_style_laps[1],
            width=font_m.width * 3 + bar_padx,
            count=self.history_slot + 1,
        )
        self.bars_laps[0].updateStyle(bar_style_laps[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_laps,
            column_index=self.wcfg["column_index_laps"],
            bottom_to_top=layout_reversed,
        )

        # Time
        self.bar_style_time = (
            self.set_qss(
                fg_color=self.wcfg["font_color_time"],
                bg_color=self.wcfg["bkg_color_time"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_time"],
                bg_color=self.wcfg["bkg_color_last_time"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_invalid_laptime"],
                bg_color=self.wcfg["bkg_color_last_time"])
        )
        self.bars_time = self.set_qlabel(
            text=TEXT_NOLAPTIME,
            style=self.bar_style_time[1],
            width=font_m.width * 8 + bar_padx,
            count=self.history_slot + 1,
        )
        self.bars_time[0].updateStyle(self.bar_style_time[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_time,
            column_index=self.wcfg["column_index_time"],
            bottom_to_top=layout_reversed,
        )

        # Fuel
        bar_style_fuel = (
            self.set_qss(
                fg_color=self.wcfg["font_color_fuel"],
                bg_color=self.wcfg["bkg_color_fuel"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_fuel"],
                bg_color=self.wcfg["bkg_color_last_fuel"])
        )
        self.bars_fuel = self.set_qlabel(
            text="-.--",
            style=bar_style_fuel[1],
            width=font_m.width * 4 + bar_padx,
            count=self.history_slot + 1,
        )
        self.bars_fuel[0].updateStyle(bar_style_fuel[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_fuel,
            column_index=self.wcfg["column_index_fuel"],
            bottom_to_top=layout_reversed,
        )

        # Tyre wear
        bar_style_wear = (
            self.set_qss(
                fg_color=self.wcfg["font_color_wear"],
                bg_color=self.wcfg["bkg_color_wear"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_wear"],
                bg_color=self.wcfg["bkg_color_last_wear"])
        )
        self.bars_wear = self.set_qlabel(
            text="---",
            style=bar_style_wear[1],
            width=font_m.width * 3 + bar_padx,
            count=self.history_slot + 1,
        )
        self.bars_wear[0].updateStyle(bar_style_wear[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_wear,
            column_index=self.wcfg["column_index_wear"],
            bottom_to_top=layout_reversed,
        )

        # Last data
        self.last_data_version = -1
        self.last_max_energy = 0.0
        self.update_laps_history(())

    def timerEvent(self, event):
        """Update when vehicle on track"""
        max_energy = api.read.vehicle.max_virtual_energy()
        # Check if virtual energy available
        if self.wcfg["show_virtual_energy_if_available"] and max_energy:
            temp_fuel_est = minfo.energy.estimatedConsumption
        else:
            temp_fuel_est = self.unit_fuel(minfo.fuel.estimatedConsumption)

        # Current laps data
        self.update_laps(self.bars_laps[0], api.read.lap.number())
        self.update_time(self.bars_time[0], minfo.delta.lapTimeEstimated)
        self.update_fuel(self.bars_fuel[0], temp_fuel_est)
        self.update_wear(self.bars_wear[0], calc.mean(minfo.wheels.estimatedTreadWear))

        # History laps data
        if (
            self.last_data_version != minfo.history.consumptionDataVersion
            or self.last_max_energy != max_energy
        ):
            self.last_data_version = minfo.history.consumptionDataVersion
            self.last_max_energy = max_energy
            self.update_laps_history(minfo.history.consumptionDataSet)

    # GUI update methods
    def update_laps(self, target, data):
        """Laps data"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:03.0f}"[:3])

    def update_time(self, target, data):
        """Time data"""
        if target.last != data:
            target.last = data
            target.setText(calc.sec2laptime_full(data)[:8])

    def update_fuel(self, target, data):
        """Fuel data"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:04.2f}"[:4])

    def update_wear(self, target, data):
        """Wear data"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:03.1f}"[:3])

    def update_laps_history(self, dataset):
        """Laps history data"""
        is_energy = bool(self.wcfg["show_virtual_energy_if_available"] and api.read.vehicle.max_virtual_energy())
        for index in range(self.history_slot):
            if index < len(dataset):
                data = dataset[index]
            else:
                data = None
            index += 1
            unavailable = False

            if data is not None and data.lapTimeLast:
                self.update_laps(self.bars_laps[index], data.lapNumber)
                self.update_time(self.bars_time[index], data.lapTimeLast)
                self.update_fuel(self.bars_fuel[index], data.lastLapUsedEnergy if is_energy else data.lastLapUsedFuel)
                self.update_wear(self.bars_wear[index], data.tyreAvgWearLast)
                # Highlight invalid lap time
                self.bars_time[index].updateStyle(self.bar_style_time[2 - data.isValidLap])
            elif not self.wcfg["show_empty_history"]:
                unavailable = True
            else:
                self.update_laps(self.bars_laps[0], 0)
                self.update_time(self.bars_time[0], 0)
                self.update_fuel(self.bars_fuel[0], 0)
                self.update_wear(self.bars_wear[0], 0)

            self.bars_laps[index].setHidden(unavailable)
            self.bars_time[index].setHidden(unavailable)
            self.bars_fuel[index].setHidden(unavailable)
            self.bars_wear[index].setHidden(unavailable)

```

# File: tinypedal/widget/laps_and_position.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Laps and position Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        text_def = "00/00"
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])

        if self.wcfg["layout"] == 0:
            self.just_right = 12
            prefix_just = max(
                len(self.wcfg["prefix_lap_number"]),
                len(self.wcfg["prefix_position_overall"]),
                len(self.wcfg["prefix_position_in_class"]),
            )
        else:
            self.just_right = 6
            prefix_just = 0

        self.prefix_lap_number = self.wcfg["prefix_lap_number"].ljust(prefix_just)
        self.prefix_pos_overall = self.wcfg["prefix_position_overall"].ljust(prefix_just)
        self.prefix_pos_inclass = self.wcfg["prefix_position_in_class"].ljust(prefix_just)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Lap number
        if self.wcfg["show_lap_number"]:
            text_lap_number = f"{self.prefix_lap_number}   0.00/0.00"
            self.bar_style_lap_number = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_lap_number"],
                    bg_color=self.wcfg["bkg_color_lap_number"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_lap_number"],
                    bg_color=self.wcfg["bkg_color_maxlap_warn"])
            )
            self.bar_lap_number = self.set_qlabel(
                text=text_lap_number,
                style=self.bar_style_lap_number[0],
                width=font_m.width * len(text_lap_number) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_lap_number,
                column=self.wcfg["column_index_lap_number"],
            )

        # Position overall
        if self.wcfg["show_position_overall"]:
            text_pos_overall = f"{self.prefix_pos_overall}{text_def: >{self.just_right}}"
            bar_style_pos_overall = self.set_qss(
                fg_color=self.wcfg["font_color_position_overall"],
                bg_color=self.wcfg["bkg_color_position_overall"]
            )
            self.bar_pos_overall = self.set_qlabel(
                text=text_pos_overall,
                style=bar_style_pos_overall,
                width=font_m.width * len(text_pos_overall) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_pos_overall,
                column=self.wcfg["column_index_position_overall"],
            )

        # Position in class
        if self.wcfg["show_position_in_class"]:
            text_pos_inclass = f"{self.prefix_pos_inclass}{text_def: >{self.just_right}}"
            bar_style_pos_inclass = self.set_qss(
                fg_color=self.wcfg["font_color_position_in_class"],
                bg_color=self.wcfg["bkg_color_position_in_class"]
            )
            self.bar_pos_inclass = self.set_qlabel(
                text=text_pos_inclass,
                style=bar_style_pos_inclass,
                width=font_m.width * len(text_pos_inclass) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_pos_inclass,
                column=self.wcfg["column_index_position_in_class"],
            )

        # Last data
        self.last_veh_total = 0
        self.last_plr_place = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Lap number
        if self.wcfg["show_lap_number"]:
            lap_into = calc.lap_progress_correction(api.read.lap.progress(), api.read.timing.current_laptime())
            self.update_lap_number(self.bar_lap_number, lap_into)

        # Position update
        if self.wcfg["show_position_overall"] or self.wcfg["show_position_in_class"]:
            plr_place = api.read.vehicle.place()
            veh_total = api.read.vehicle.total_vehicles()

            # Only update if total vehicle or player position changes
            if self.last_plr_place != plr_place or self.last_veh_total != veh_total:
                self.last_plr_place = plr_place
                self.last_veh_total = veh_total

                # Position overall
                if self.wcfg["show_position_overall"]:
                    self.update_position(
                        self.bar_pos_overall, plr_place, veh_total,
                        self.prefix_pos_overall
                    )

                # Position in class
                if self.wcfg["show_position_in_class"]:
                    plr_class = api.read.vehicle.class_name()
                    total_class_vehicle = 0
                    place_higher = 0

                    for index in range(veh_total):
                        if api.read.vehicle.class_name(index) == plr_class:
                            total_class_vehicle += 1
                            if api.read.vehicle.place(index) > plr_place:
                                place_higher += 1

                    pos_in_class = total_class_vehicle - place_higher
                    self.update_position(
                        self.bar_pos_inclass, pos_in_class, total_class_vehicle,
                        self.prefix_pos_inclass
                    )

    # GUI update methods
    def update_lap_number(self, target, data):
        """Lap number"""
        if target.last != data:
            target.last = data
            lap_num = api.read.lap.number()
            lap_max = api.read.lap.maximum()

            if api.read.session.lap_type():
                text_lap_total = f"{lap_max:.2f}"[:6]
            else:
                session_time = api.read.session.remaining()
                if session_time <= 0:
                    lap_total = 0
                else:
                    lap_total = lap_num + calc.end_timer_laps_remain(data, minfo.delta.lapTimePace, session_time)
                text_lap_total = f"~{lap_total:.2f}"[:6]

            text_laps_done = f"{lap_num + data:.2f}"[:5]
            text_laps = f"{text_laps_done}/{text_lap_total}"[:12]
            target.setText(f"{self.prefix_lap_number}{text_laps: >12}")
            target.updateStyle(self.bar_style_lap_number[lap_num - lap_max >= -1])

    def update_position(self, target, place, total, prefix):
        """Driver place & total vehicles"""
        text_pos = f"{place:02.0f}/{total:02.0f}"
        target.setText(f"{prefix}{text_pos: >{self.just_right}}")

```

# File: tinypedal/widget/navigation.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Navigation Widget
"""

from PySide2.QtCore import QPointF, QRectF, Qt
from PySide2.QtGui import QBrush, QPainter, QPainterPath, QPen, QPixmap, QRadialGradient

from .. import calculation as calc
from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        self.area_size = max(int(self.wcfg["display_size"]), 20)
        self.global_scale = self.area_size / max(self.wcfg["view_radius"], 5)
        self.area_center = self.area_size * 0.5
        self.view_range = self.wcfg["view_radius"] * 2.5
        self.veh_offset_y = self.area_size * max(self.wcfg["vehicle_offset"], 0)
        self.veh_size = max(int(self.wcfg["vehicle_size"]), 1)

        if self.wcfg["show_circle_vehicle_shape"]:
            self.veh_shape = QRectF(
                self.veh_size * 0.5,
                self.veh_size * 0.5,
                self.veh_size,
                self.veh_size
            )
        else:
            self.veh_shape = (
                QPointF(self.veh_size, self.veh_size * 0.5),
                QPointF(self.veh_size * 1.5, self.veh_size * 1.5),
                QPointF(self.veh_size, self.veh_size * 1.3),
                QPointF(self.veh_size * 0.5, self.veh_size * 1.5),
            )
        self.veh_text_shape = QRectF(
            -self.veh_size * 0.5,
            -self.veh_size * 0.5 + font_offset,
            self.veh_size,
            self.veh_size
        )

        self.map_path = None
        self.sfinish_path = None
        self.sector_path = None
        self.create_map_path()

        # Config canvas
        self.resize(self.area_size, self.area_size)
        self.pixmap_background = QPixmap(self.area_size, self.area_size)
        self.pixmap_mask = QPixmap(self.area_size, self.area_size)

        self.pixmap_veh_player = self.draw_vehicle_pixmap("player")
        self.pixmap_veh_leader = self.draw_vehicle_pixmap("leader")
        self.pixmap_veh_in_pit = self.draw_vehicle_pixmap("in_pit")
        self.pixmap_veh_yellow = self.draw_vehicle_pixmap("yellow")
        self.pixmap_veh_laps_ahead = self.draw_vehicle_pixmap("laps_ahead")
        self.pixmap_veh_laps_behind = self.draw_vehicle_pixmap("laps_behind")
        self.pixmap_veh_same_lap = self.draw_vehicle_pixmap("same_lap")

        self.pen_outline = QPen()
        self.pen_outline.setJoinStyle(Qt.RoundJoin)
        self.pen_outline.setWidth(self.wcfg["map_width"] + self.wcfg["map_outline_width"])
        self.pen_outline.setColor(self.wcfg["map_outline_color"])
        self.pen_map = QPen()
        self.pen_map.setJoinStyle(Qt.RoundJoin)
        self.pen_map.setWidth(self.wcfg["map_width"])
        self.pen_map.setColor(self.wcfg["map_color"])
        self.pen_sfinish = QPen()
        self.pen_sfinish.setWidth(self.wcfg["start_line_width"])
        self.pen_sfinish.setColor(self.wcfg["start_line_color"])
        self.pen_sector = QPen()
        self.pen_sector.setWidth(self.wcfg["sector_line_width"])
        self.pen_sector.setColor(self.wcfg["sector_line_color"])
        self.pen_text = QPen()
        self.pen_text.setColor(self.wcfg["font_color"])

        # Last data
        self.last_veh_data_version = None
        self.last_modified = 0
        self.map_scaled = None
        self.map_size = 1,1
        self.map_offset = 0,0

        self.draw_background()
        self.draw_map_mask_pixmap()
        self.update_map(-1)

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Map
        modified = minfo.mapping.lastModified
        self.update_map(modified)

        # Vehicles
        veh_data_version = minfo.vehicles.dataSetVersion
        if self.last_veh_data_version != veh_data_version:
            self.last_veh_data_version = veh_data_version
            self.update()

    # GUI update methods
    def update_map(self, data):
        """Map update"""
        if self.last_modified != data:
            self.last_modified = data
            self.create_map_path(minfo.mapping.coordinates)

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)
        # Draw map
        self.draw_map_image(painter)
        # Draw vehicles
        self.draw_vehicle(painter, minfo.vehicles.dataSet, minfo.relative.drawOrder)
        # Apply mask
        if self.wcfg["show_fade_out"]:
            painter.setCompositionMode(QPainter.CompositionMode_DestinationOut)
            painter.drawPixmap(0, 0, self.pixmap_mask)
        # Draw background below map & mask
        if self.wcfg["show_background"] or self.wcfg["show_circle_background"]:
            painter.setCompositionMode(QPainter.CompositionMode_DestinationOver)
            painter.drawPixmap(0, 0, self.pixmap_background)

    def draw_background(self):
        """Draw background"""
        if self.wcfg["show_background"]:
            self.pixmap_background.fill(self.wcfg["bkg_color"])
        else:
            self.pixmap_background.fill(Qt.transparent)

        # Draw circle background
        if self.wcfg["show_circle_background"]:
            painter = QPainter(self.pixmap_background)
            painter.setRenderHint(QPainter.Antialiasing, True)

            if self.wcfg["circle_outline_width"] > 0:
                pen = QPen()
                pen.setWidth(self.wcfg["circle_outline_width"])
                pen.setColor(self.wcfg["circle_outline_color"])
                painter.setPen(pen)
            else:
                painter.setPen(Qt.NoPen)

            brush = QBrush(Qt.SolidPattern)
            brush.setColor(self.wcfg["bkg_color_circle"])
            painter.setBrush(brush)
            painter.drawEllipse(
                self.wcfg["circle_outline_width"],
                self.wcfg["circle_outline_width"],
                (self.area_center - self.wcfg["circle_outline_width"]) * 2,
                (self.area_center - self.wcfg["circle_outline_width"]) * 2
            )

    def create_map_path(self, raw_coords=None):
        """Create map path"""
        if raw_coords:
            map_path = QPainterPath()
            dist = calc.distance(raw_coords[0], raw_coords[-1])
            (self.map_scaled, self.map_size, self.map_offset
             ) = calc.zoom_map(raw_coords, self.global_scale)
            for index, coords in enumerate(self.map_scaled):
                if index == 0:
                    map_path.moveTo(*coords)
                else:
                    map_path.lineTo(*coords)
            # Close map loop if start & end distance less than 500 meters
            if dist < 500:
                map_path.closeSubpath()
            # Create start/finish path
            sfinish_path = QPainterPath()
            self.create_sector_path(
                sfinish_path, self.map_scaled, 0, self.wcfg["start_line_length"])
            # Create sectors paths
            sectors_index = minfo.mapping.sectors
            if isinstance(sectors_index, tuple):
                sector_path = QPainterPath()
                for index in sectors_index:
                    self.create_sector_path(
                        sector_path, self.map_scaled, index, self.wcfg["sector_line_length"]
                    )
            else:
                sector_path = None
        else:
            self.map_scaled = None
            self.map_size = 1,1
            self.map_offset = 0,0
            map_path = None
            sfinish_path = None
            sector_path = None

        self.map_path = map_path
        self.sfinish_path = sfinish_path
        self.sector_path = sector_path

    def draw_map_image(self, painter):
        """Draw map image"""
        # Transform map coordinates
        # Player vehicle orientation yaw radians + 180 deg rotation correction
        plr_ori_rad = api.read.vehicle.orientation_yaw_radians() + 3.14159265
        # x, y position & offset relative to player
        rot_pos_x, rot_pos_y = calc.rotate_coordinate(
            plr_ori_rad,   # plr_ori_rad, rotate view
            api.read.vehicle.position_longitudinal() * self.global_scale - self.map_offset[0],
            api.read.vehicle.position_lateral() * self.global_scale - self.map_offset[1]
        )
        # Apply center offset & rotation
        painter.translate(self.area_center - rot_pos_x, self.veh_offset_y - rot_pos_y)
        painter.rotate(calc.rad2deg(plr_ori_rad))

        if self.map_path:
            # Draw map outline
            if self.wcfg["map_outline_width"] > 0:
                painter.setPen(self.pen_outline)
                painter.drawPath(self.map_path)

            # Draw map
            painter.setPen(self.pen_map)
            painter.drawPath(self.map_path)

        # Draw start/finish line
        if self.wcfg["show_start_line"] and self.sfinish_path:
            painter.setPen(self.pen_sfinish)
            painter.drawPath(self.sfinish_path)

        # Draw sectors line
        if self.wcfg["show_sector_line"] and self.sector_path:
            painter.setPen(self.pen_sector)
            painter.drawPath(self.sector_path)

        painter.resetTransform()

    def draw_vehicle(self, painter, veh_info, veh_draw_order):
        """Draw vehicles"""
        painter.setRenderHint(QPainter.SmoothPixmapTransform, True)
        if self.wcfg["show_vehicle_standings"]:
            painter.setPen(self.pen_text)

        # Draw vehicle within view range
        for index in veh_draw_order:
            data = veh_info[index]
            # Draw player vehicle
            if data.isPlayer:
                painter.translate(self.area_center, self.veh_offset_y)
                painter.drawPixmap(-self.veh_size, -self.veh_size, self.pixmap_veh_player)

                if self.wcfg["show_vehicle_standings"]:
                    painter.drawText(
                        self.veh_text_shape, Qt.AlignCenter,
                        f"{data.positionOverall}")
                painter.resetTransform()

            # Draw opponent vehicle in view range
            elif data.relativeStraightDistance < self.view_range:
                # Rotated position relative to player
                # Position = raw position * global scale + offset
                pos_x = data.relativeRotatedPositionX * self.global_scale + self.area_center
                pos_y = data.relativeRotatedPositionY * self.global_scale + self.veh_offset_y
                painter.translate(pos_x, pos_y)

                if not self.wcfg["show_circle_vehicle_shape"]:
                    painter.rotate(calc.rad2deg(-data.relativeOrientationRadians))
                painter.drawPixmap(
                    -self.veh_size, -self.veh_size,
                    self.color_veh_pixmap(data))

                if self.wcfg["show_vehicle_standings"]:
                    painter.resetTransform()
                    painter.translate(pos_x, pos_y)
                    painter.drawText(
                        self.veh_text_shape, Qt.AlignCenter,
                        f"{data.positionOverall}")
                painter.resetTransform()

    def draw_map_mask_pixmap(self):
        """Map mask pixmap"""
        self.pixmap_mask.fill(Qt.black)
        painter = QPainter(self.pixmap_mask)
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.setCompositionMode(QPainter.CompositionMode_SourceIn)
        rad_gra = QRadialGradient(self.area_center, self.area_center, self.area_center)
        rad_gra.setColorAt(calc.zero_one(self.wcfg["fade_in_radius"]), Qt.transparent)
        rad_gra.setColorAt(calc.zero_one(self.wcfg["fade_out_radius"]), Qt.black)
        painter.setBrush(rad_gra)
        painter.setPen(Qt.NoPen)
        painter.drawEllipse(0, 0, self.area_size, self.area_size)

    def draw_vehicle_pixmap(self, suffix):
        """Draw vehicles pixmap"""
        pixmap_veh = QPixmap(self.veh_size * 2, self.veh_size * 2)
        pixmap_veh.fill(Qt.transparent)
        painter = QPainter(pixmap_veh)
        painter.setRenderHint(QPainter.Antialiasing, True)
        if self.wcfg["vehicle_outline_width"] > 0:
            pen = QPen()
            pen.setWidth(self.wcfg["vehicle_outline_width"])
            pen.setColor(self.wcfg["vehicle_outline_color"])
            painter.setPen(pen)
        else:
            painter.setPen(Qt.NoPen)
        brush = QBrush(Qt.SolidPattern)
        brush.setColor(self.wcfg[f"vehicle_color_{suffix}"])
        painter.setBrush(brush)
        if self.wcfg["show_circle_vehicle_shape"]:
            painter.drawEllipse(self.veh_shape)
        else:
            painter.drawPolygon(self.veh_shape)
        return pixmap_veh

    # Additional methods
    def color_veh_pixmap(self, veh_info):
        """Compare lap differences & set color"""
        if veh_info.positionOverall == 1:
            return self.pixmap_veh_leader
        if veh_info.inPit:
            return self.pixmap_veh_in_pit
        if veh_info.isYellow and not veh_info.inPit:
            return self.pixmap_veh_yellow
        if veh_info.isLapped > 0:
            return self.pixmap_veh_laps_ahead
        if veh_info.isLapped < 0:
            return self.pixmap_veh_laps_behind
        return self.pixmap_veh_same_lap

    def create_sector_path(self, path, dataset, node_index, length):
        """Create sector line path"""
        max_node = len(dataset) - 1
        pos_x1, pos_y1, pos_x2, pos_y2 = calc.line_intersect_coords(
            dataset[calc.zero_max(node_index, max_node)],  # point a
            dataset[calc.zero_max(node_index + 1, max_node)],  # point b
            1.57079633,  # 90 degree rotation
            length
        )
        path.moveTo(pos_x1, pos_y1)
        path.lineTo(pos_x2, pos_y2)
        return path

```

# File: tinypedal/widget/p2p.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
P2P Widget
"""

from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Battery charge
        if self.wcfg["show_battery_charge"]:
            self.bar_style_charge = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_battery_cooldown"],  # 0 cooldown
                    bg_color=self.wcfg["bkg_color_battery_cooldown"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_battery_charge"],  # 1 ready
                    bg_color=self.wcfg["bkg_color_battery_charge"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_battery_charge"],  # 2 drain
                    bg_color=self.wcfg["bkg_color_battery_drain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_battery_charge"],  # 3 regen
                    bg_color=self.wcfg["bkg_color_battery_regen"])
            )
            self.bar_charge = self.set_qlabel(
                text="P2P",
                style=self.bar_style_charge[1],
                width=font_m.width * 3 + bar_padx,
            )
            layout.addWidget(self.bar_charge, 0, self.wcfg["column_index_battery_charge"])

        # Activation timer
        if self.wcfg["show_activation_timer"]:
            self.bar_style_timer = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_activation_timer"],
                    bg_color=self.wcfg["bkg_color_activation_timer"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_activation_cooldown"],
                    bg_color=self.wcfg["bkg_color_activation_cooldown"])
            )
            self.bar_timer = self.set_qlabel(
                text="0.00",
                style=self.bar_style_timer[0],
                width=font_m.width * 4 + bar_padx,
            )
            layout.addWidget(self.bar_timer, 0, self.wcfg["column_index_activation_timer"])

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Battery charge
        if self.wcfg["show_battery_charge"]:
            state = minfo.hybrid.motorState
            if state == 1:  # cooldown check
                state = (
                    api.read.engine.gear() >= self.wcfg["activation_threshold_gear"] and
                    api.read.vehicle.speed() * 3.6 > self.wcfg["activation_threshold_speed"] and
                    api.read.inputs.throttle_raw() >= self.wcfg["activation_threshold_throttle"] and
                    minfo.hybrid.motorInactiveTimer >= self.wcfg["minimum_activation_time_delay"] and
                    minfo.hybrid.motorActiveTimer < self.wcfg["maximum_activation_time_per_lap"] - 0.05
                )
            battery_charge = minfo.hybrid.batteryCharge, state
            self.update_battery_charge(self.bar_charge, battery_charge)

        # Activation timer
        if self.wcfg["show_activation_timer"]:
            active_timer = minfo.hybrid.motorActiveTimer, minfo.hybrid.motorState
            self.update_active_timer(self.bar_timer, active_timer)

    # GUI update methods
    def update_battery_charge(self, target, data):
        """Battery charge"""
        if target.last != data:
            target.last = data
            if data[0] < 99.5:
                format_text = f"Â±{data[0]:02.0f}"
            else:
                format_text = "MAX"
            target.setText(format_text)
            target.updateStyle(self.bar_style_charge[data[1]])

    def update_active_timer(self, target, data):
        """P2P activation timer"""
        if target.last != data:
            target.last = data
            target.setText(f"{data[0]:.2f}"[:4])
            target.updateStyle(self.bar_style_timer[data[1] != 2])

```

# File: tinypedal/widget/pace_notes.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Pace notes Widget
"""

from ..api_control import api
from ..const_common import TEXT_NOTAVAILABLE
from ..module_info import minfo
from ..userfile.track_notes import COLUMN_COMMENT, COLUMN_DISTANCE, COLUMN_PACENOTE
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        notes_width = max(int(self.wcfg["pace_notes_width"]), 1)
        comments_width = max(int(self.wcfg["comments_width"]), 1)
        debugging_width = max(int(self.wcfg["debugging_width"]), 1)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        if self.wcfg["show_background"]:
            bg_color_notes = self.wcfg["bkg_color_pace_notes"]
            bg_color_comments = self.wcfg["bkg_color_comments"]
            bg_color_debugging = self.wcfg["bkg_color_debugging"]
        else:
            bg_color_notes = ""
            bg_color_comments = ""
            bg_color_debugging = ""

        # Pace notes
        if self.wcfg["show_pace_notes"]:
            bar_style_notes = self.set_qss(
                fg_color=self.wcfg["font_color_pace_notes"],
                bg_color=bg_color_notes
            )
            self.bar_notes = self.set_qlabel(
                text="PACE NOTES",
                style=bar_style_notes,
                width=font_m.width * notes_width + bar_padx,
                align=self.wcfg["pace_notes_text_alignment"],
            )
            self.set_primary_orient(
                target=self.bar_notes,
                column=self.wcfg["column_index_pace_notes"],
            )

        # Comments
        if self.wcfg["show_comments"]:
            bar_style_comments = self.set_qss(
                fg_color=self.wcfg["font_color_comments"],
                bg_color=bg_color_comments
            )
            self.bar_comments = self.set_qlabel(
                text="COMMENTS",
                style=bar_style_comments,
                width=font_m.width * comments_width + bar_padx,
                align=self.wcfg["comments_text_alignment"],
            )
            self.set_primary_orient(
                target=self.bar_comments,
                column=self.wcfg["column_index_comments"],
            )

        # Debugging info
        if self.wcfg["show_debugging"]:
            bar_style_debugging = self.set_qss(
                fg_color=self.wcfg["font_color_debugging"],
                bg_color=bg_color_debugging
            )
            self.bar_debugging = self.set_qlabel(
                text="DEBUGGING",
                style=bar_style_debugging,
                width=font_m.width * debugging_width + bar_padx,
                align=self.wcfg["debugging_text_alignment"],
            )
            self.set_primary_orient(
                target=self.bar_debugging,
                column=self.wcfg["column_index_debugging"],
            )

        # Last data
        self.last_notes_index = None
        self.last_auto_hide = False
        self.last_etime = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        pit_override = self.wcfg["show_pit_notes_while_in_pit"] and api.read.vehicle.in_pits()

        if pit_override or api.read.vehicle.in_garage():
            self.update_auto_hide(False)
        elif minfo.pacenotes.currentNote:
            if self.wcfg["maximum_display_duration"] <= 0:
                self.update_auto_hide(False)
            else:
                etime = api.read.timing.elapsed()
                notes_index = minfo.pacenotes.currentIndex
                if self.last_notes_index != notes_index:
                    self.last_notes_index = notes_index
                    self.last_etime = etime
                if self.last_etime > etime:
                    self.last_etime = etime
                self.update_auto_hide(
                    etime - self.last_etime > self.wcfg["maximum_display_duration"])
        elif self.wcfg["auto_hide_if_not_available"]:
            self.update_auto_hide(True)

        if self.wcfg["show_pace_notes"]:
            if pit_override:
                notes = self.wcfg["pit_notes_text"]
            else:
                notes = minfo.pacenotes.currentNote.get(COLUMN_PACENOTE, TEXT_NOTAVAILABLE)
            self.update_notes(self.bar_notes, notes)

        if self.wcfg["show_comments"]:
            if pit_override:
                comments = self.wcfg["pit_comments_text"]
            else:
                comments = minfo.pacenotes.currentNote.get(COLUMN_COMMENT, TEXT_NOTAVAILABLE)
            self.update_comments(self.bar_comments, comments)

        if self.wcfg["show_debugging"]:
            if pit_override:
                debugging = TEXT_NOTAVAILABLE
            else:
                debugging = minfo.pacenotes.currentNote.get(COLUMN_DISTANCE, TEXT_NOTAVAILABLE)
            self.update_debugging(self.bar_debugging, debugging)

    # GUI update methods
    def update_notes(self, target, data):
        """Pace notes"""
        if target.last != data:
            target.last = data
            target.setText(data)

    def update_comments(self, target, data):
        """Comments"""
        if target.last != data:
            target.last = data
            if self.wcfg["enable_comments_line_break"]:
                data = data.replace("\\n", "\n")
            target.setText(data)

    def update_debugging(self, target, data):
        """Debugging info"""
        if target.last != data:
            target.last = data
            if data != TEXT_NOTAVAILABLE:
                data = (
                    f"IDX:{minfo.pacenotes.currentIndex + 1} "
                    f"POS:{data:.0f}>>{minfo.pacenotes.nextNote.get(COLUMN_DISTANCE, 0):.0f}m"
                )
            target.setText(data)

    def update_auto_hide(self, auto_hide):
        """Auto hide"""
        if self.last_auto_hide != auto_hide:
            self.last_auto_hide = auto_hide
            if self.wcfg["show_pace_notes"]:
                self.bar_notes.setHidden(auto_hide)
            if self.wcfg["show_comments"]:
                self.bar_comments.setHidden(auto_hide)
            if self.wcfg["show_debugging"]:
                self.bar_debugging.setHidden(auto_hide)

```

# File: tinypedal/widget/pedal.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Pedal Widget
"""

from ..api_control import api
from ._base import Overlay
from ._painter import PedalInputBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)

        pedal_size = self.set_pedal_size(font)

        # Throttle
        if self.wcfg["show_throttle"]:
            self.bar_throttle = PedalInputBar(
                self,
                *pedal_size,
                fg_color=self.wcfg["font_color_throttle"],
                bg_color=self.wcfg["bkg_color"],
                input_color=self.wcfg["throttle_color"],
                show_reading=self.wcfg["show_readings"],
                horizontal_style=self.wcfg["enable_horizontal_style"],
            )
            self.set_primary_orient(
                target=self.bar_throttle,
                column=self.wcfg["column_index_throttle"],
                option="enable_horizontal_style",
                default=1,
            )

        # Brake
        if self.wcfg["show_brake"]:
            self.bar_brake = PedalInputBar(
                self,
                *pedal_size,
                fg_color=self.wcfg["font_color_brake"],
                bg_color=self.wcfg["bkg_color"],
                input_color=self.wcfg["brake_color"],
                show_reading=self.wcfg["show_readings"],
                horizontal_style=self.wcfg["enable_horizontal_style"],
            )
            self.set_primary_orient(
                target=self.bar_brake,
                column=self.wcfg["column_index_brake"],
                option="enable_horizontal_style",
                default=1,
            )

        # Clutch
        if self.wcfg["show_clutch"]:
            self.bar_clutch = PedalInputBar(
                self,
                *pedal_size,
                fg_color=self.wcfg["font_color_clutch"],
                bg_color=self.wcfg["bkg_color"],
                input_color=self.wcfg["clutch_color"],
                show_reading=self.wcfg["show_readings"],
                horizontal_style=self.wcfg["enable_horizontal_style"],
            )
            self.set_primary_orient(
                target=self.bar_clutch,
                column=self.wcfg["column_index_clutch"],
                option="enable_horizontal_style",
                default=1,
            )

        # Force feedback
        if self.wcfg["show_ffb_meter"]:
            self.bar_ffb = PedalInputBar(
                self,
                *pedal_size,
                fg_color=self.wcfg["font_color_ffb"],
                bg_color=self.wcfg["bkg_color"],
                input_color=self.wcfg["ffb_color"],
                ffb_color=self.wcfg["ffb_clipping_color"],
                show_reading=self.wcfg["show_readings"],
                horizontal_style=self.wcfg["enable_horizontal_style"],
            )
            self.set_primary_orient(
                target=self.bar_ffb,
                column=self.wcfg["column_index_ffb"],
                option="enable_horizontal_style",
                default=1,
            )

        # Last data
        self.max_brake_pres = 0.01

    def post_update(self):
        self.max_brake_pres = 0.01

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Throttle
        if self.wcfg["show_throttle"]:
            raw_throttle = api.read.inputs.throttle_raw()
            if self.wcfg["show_throttle_filtered"]:
                throttle = raw_throttle + api.read.inputs.throttle()
            else:
                throttle = raw_throttle + raw_throttle
            self.update_pedal(self.bar_throttle, throttle, raw_throttle)

        # Brake
        if self.wcfg["show_brake"]:
            raw_brake = api.read.inputs.brake_raw()
            if self.wcfg["show_brake_filtered"]:
                if self.wcfg["show_brake_pressure"]:
                    f_brake = self.filtered_brake_pressure(api.read.brake.pressure())
                else:
                    f_brake = api.read.inputs.brake()
                brake = raw_brake + f_brake
            else:
                brake = raw_brake + raw_brake
            self.update_pedal(self.bar_brake, brake, raw_brake)

        # Clutch
        if self.wcfg["show_clutch"]:
            raw_clutch = api.read.inputs.clutch_raw()
            if self.wcfg["show_clutch_filtered"]:
                clutch = raw_clutch + api.read.inputs.clutch()
            else:
                clutch = raw_clutch + raw_clutch
            self.update_pedal(self.bar_clutch, clutch, raw_clutch)

        # Force feedback
        if self.wcfg["show_ffb_meter"]:
            ffb = abs(api.read.inputs.force_feedback())
            self.update_ffb(self.bar_ffb, ffb)

    # GUI update methods
    def update_pedal(self, target, data, raw):
        """Pedal update"""
        if target.last != data:
            target.last = data
            target.update_input(raw, data - raw)

    def update_ffb(self, target, data):
        """FFB update"""
        if target.last != data:
            target.last = data
            target.update_input(data, data)

    # Additional methods
    def filtered_brake_pressure(self, value):
        """Percentage filtered brake pressure"""
        brake_pres = sum(value)
        if brake_pres > self.max_brake_pres:
            self.max_brake_pres = brake_pres
        return brake_pres / self.max_brake_pres

    def set_pedal_size(self, font):
        """Set pedal size"""
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        max_gap = max(self.wcfg["inner_gap"], 0)
        pedal_length = max(int(self.wcfg["bar_length"]), 10)
        pedal_extend = max(int(self.wcfg["max_indicator_height"]), 0) + max_gap
        pedal_uwidth = max(int(self.wcfg["bar_width_unfiltered"]), 1)
        pedal_fwidth = max(int(self.wcfg["bar_width_filtered"]), 1)
        bar_length = pedal_length + pedal_extend
        bar_width = pedal_uwidth + pedal_fwidth
        readings_offset = bar_length * (self.wcfg["readings_offset"] - 0.5)

        if self.wcfg["enable_horizontal_style"]:
            pedal_size = 0, 0, bar_length, bar_width
            raw_size = 0, 0, bar_length, pedal_uwidth
            filtered_size = 0, pedal_uwidth, bar_length, pedal_fwidth
            max_size = pedal_length + max_gap, 0, pedal_extend - max_gap, bar_width
            reading_size = readings_offset, font_offset, bar_length, bar_width
        else:
            pedal_size = 0, 0, bar_width, bar_length
            raw_size = 0, 0, pedal_uwidth, bar_length
            filtered_size = pedal_uwidth, 0, pedal_fwidth, bar_length
            max_size = 0, 0, bar_width, pedal_extend - max_gap
            reading_size = 0, readings_offset + font_offset, bar_width, bar_length
        return (pedal_length, pedal_extend, pedal_size, raw_size,
                filtered_size, max_size, reading_size)

```

# File: tinypedal/widget/pit_stop_estimate.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Pit stop estimate Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..module_info import minfo
from ..units import set_unit_fuel
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        text_def = "-.--"
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.bar_width = max(self.wcfg["bar_width"], 3)
        style_width = font_m.width * self.bar_width + bar_padx

        # Config units
        self.unit_fuel = set_unit_fuel(self.cfg.units["fuel_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Create layout
        layout_upper = self.set_grid_layout()
        layout_lower = self.set_grid_layout()
        layout.addLayout(layout_upper, self.wcfg["column_index_upper"], 0)
        layout.addLayout(layout_lower, self.wcfg["column_index_lower"], 0)

        # Caption style
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_size=int(self.wcfg['font_size'] * 0.8)
            )
            row_idx_upper = 2 * self.wcfg["swap_upper_caption"]
            row_idx_lower = 2 - 2 * self.wcfg["swap_lower_caption"]

        # Estimated pit pass through time
        bar_style_pass = self.set_qss(
            fg_color=self.wcfg["font_color_pass_duration"],
            bg_color=self.wcfg["bkg_color_pass_duration"]
        )
        self.bar_pass = self.set_qlabel(
            text=text_def,
            style=bar_style_pass,
            fixed_width=style_width,
        )
        self.bar_pass.decimals = max(self.wcfg["decimal_places_pass_duration"], 0)
        layout_upper.addWidget(self.bar_pass, 1, 0)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_pass_duration"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_upper.addWidget(cap_temp, row_idx_upper, 0)

        # Pit timer
        bar_style_timer = self.set_qss(
            fg_color=self.wcfg["font_color_pit_timer"],
            bg_color=self.wcfg["bkg_color_pit_timer"]
        )
        self.bar_timer = self.set_qlabel(
            text=text_def,
            style=bar_style_timer,
            fixed_width=style_width,
        )
        self.bar_timer.decimals = max(self.wcfg["decimal_places_pit_timer"], 0)
        layout_lower.addWidget(self.bar_timer, 1, 0)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_pit_timer"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_lower.addWidget(cap_temp, row_idx_lower, 0)

        # Estimated pit stop time
        self.bar_style_stop = (
            self.set_qss(
                fg_color=self.wcfg["font_color_stop_duration"],
                bg_color=self.wcfg["bkg_color_stop_duration"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_stop_duration"],
                bg_color=self.wcfg["warning_color_lengthy_stop"])
        )
        self.bar_stop = self.set_qlabel(
            text=text_def,
            style=self.bar_style_stop[0],
            fixed_width=style_width,
        )
        self.bar_stop.decimals = max(self.wcfg["decimal_places_stop_duration"], 0)
        layout_upper.addWidget(self.bar_stop, 1, 1)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_stop_duration"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_upper.addWidget(cap_temp, row_idx_upper, 1)

        # Estimated min total pit time
        bar_style_minpit = self.set_qss(
            fg_color=self.wcfg["font_color_minimum_total_duration"],
            bg_color=self.wcfg["bkg_color_minimum_total_duration"]
        )
        self.bar_minpit = self.set_qlabel(
            text=text_def,
            style=bar_style_minpit,
            fixed_width=style_width,
            last=-1,
        )
        self.bar_minpit.decimals = max(self.wcfg["decimal_places_minimum_total_duration"], 0)
        layout_lower.addWidget(self.bar_minpit, 1, 1)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_minimum_total_duration"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_lower.addWidget(cap_temp, row_idx_lower, 1)

        if self.wcfg["show_relative_refilling"]:
            # Relative refilling
            bar_style_refill = self.set_qss(
                fg_color=self.wcfg["font_color_actual_relative_refill"],
                bg_color=self.wcfg["bkg_color_actual_relative_refill"]
            )
            self.bar_refill = self.set_qlabel(
                text=text_def,
                style=bar_style_refill,
                fixed_width=style_width,
            )
            self.bar_refill.decimals = max(self.wcfg["decimal_places_actual_relative_refill"], 0)
            layout_upper.addWidget(self.bar_refill, 1, 2)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_actual_relative_refill"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_upper.addWidget(cap_temp, row_idx_upper, 2)

            # Estimated total needed refill
            bar_style_needed = self.set_qss(
                fg_color=self.wcfg["font_color_total_relative_refill"],
                bg_color=self.wcfg["bkg_color_total_relative_refill"]
            )
            self.bar_needed = self.set_qlabel(
                text=text_def,
                style=bar_style_needed,
                fixed_width=style_width,
            )
            self.bar_needed.decimals = max(self.wcfg["decimal_places_total_relative_refill"], 0)
            layout_lower.addWidget(self.bar_needed, 1, 2)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_total_relative_refill"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_lower.addWidget(cap_temp, row_idx_lower, 2)

        if self.wcfg["show_pit_occupancy"]:
            # Pit occupancy
            bar_style_inpit = self.set_qss(
                fg_color=self.wcfg["font_color_pit_occupancy"],
                bg_color=self.wcfg["bkg_color_pit_occupancy"]
            )
            self.bar_inpit = self.set_qlabel(
                text="-/-",
                style=bar_style_inpit,
                fixed_width=style_width,
            )
            layout_upper.addWidget(self.bar_inpit, 1, 3)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_pit_occupancy"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_upper.addWidget(cap_temp, row_idx_upper, 3)

            # Number of pit requests
            bar_style_request = self.set_qss(
                fg_color=self.wcfg["font_color_pit_requests"],
                bg_color=self.wcfg["bkg_color_pit_requests"]
            )
            self.bar_request = self.set_qlabel(
                text="-/-",
                style=bar_style_request,
                fixed_width=style_width,
                last=-1,
            )
            layout_lower.addWidget(self.bar_request, 1, 3)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_pit_requests"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_lower.addWidget(cap_temp, row_idx_lower, 3)

    def timerEvent(self, event):
        """Update when vehicle on track"""
        min_pitstop_time = api.read.vehicle.pit_stop_time()
        abs_refill = api.read.vehicle.absolute_refill()
        pass_time = minfo.mapping.pitPassTime
        pit_timer = minfo.vehicles.dataSet[minfo.vehicles.playerIndex].pitTimer.elapsed
        is_lengthy_stop = min_pitstop_time >= self.wcfg["lengthy_stop_duration_threshold"]
        padding = 0.00000001 * is_lengthy_stop

        # Min total pit time, update while not in pit
        if not api.read.vehicle.in_pits() or self.bar_minpit.last < pass_time:
            if min_pitstop_time:
                min_total = min_pitstop_time + pass_time + self.wcfg["additional_pitstop_time"]
            else:
                min_total = 0
        else:
            min_total = self.bar_minpit.last

        # Estimated pit pass through time
        self.update_estimate(self.bar_pass, pass_time)

        # Pit timer
        self.update_estimate(self.bar_timer, pit_timer)

        # Estimated pit stop time
        self.update_estimate(self.bar_stop, min_pitstop_time + padding, self.bar_style_stop[is_lengthy_stop])

        # Estimated min total pit time
        self.update_estimate(self.bar_minpit, min_total)

        if self.wcfg["show_relative_refilling"]:
            # Calculate relative refilling
            if api.read.vehicle.max_virtual_energy():
                actual_refill = abs_refill - minfo.energy.amountCurrent
                total_refill = calc.sym_max(minfo.energy.neededRelative, 9999)
            else:
                actual_refill = self.unit_fuel(abs_refill - minfo.fuel.amountCurrent)
                total_refill = calc.sym_max(self.unit_fuel(minfo.fuel.neededRelative), 9999)

            # Relative refilling
            self.update_refill(self.bar_refill, max(actual_refill, 0))

            # Estimated total needed refill
            self.update_refill(self.bar_needed, total_refill)

        if self.wcfg["show_pit_occupancy"]:
            # Pit occupancy
            self.update_occupancy(self.bar_inpit, minfo.vehicles.totalStoppedPits, minfo.vehicles.totalInPits)

            # Number of pit requests
            self.update_occupancy(self.bar_request, minfo.vehicles.totalPitRequests, minfo.vehicles.totalOutPits)

    # GUI update methods
    def update_estimate(self, target, data, color=None):
        """Update estimate pit data"""
        if target.last != data:
            target.last = data
            text = f"{data:.{target.decimals}f}"[:self.bar_width].strip(".")
            target.setText(text)
            if color:  # lengthy stop warning
                target.updateStyle(color)

    def update_refill(self, target, data):
        """Update refilling"""
        if target.last != data:
            target.last = data
            text = f"{data:+.{target.decimals}f}"[:self.bar_width].strip(".")
            target.setText(text)

    def update_occupancy(self, target, *data):
        """Update pit occupancy"""
        if target.last != data:
            target.last = data
            target.setText(f"{data[0]}/{data[1]}")

```

# File: tinypedal/widget/radar.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Radar Widget
"""

from itertools import islice
from typing import NamedTuple

from PySide2.QtCore import QRectF, Qt
from PySide2.QtGui import (
    QBrush,
    QColor,
    QLinearGradient,
    QPainter,
    QPen,
    QPixmap,
    QRadialGradient,
)

from .. import calculation as calc
from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class IndicatorDimension(NamedTuple):
    """Indicator dimension"""

    min_range_x: float = 0
    max_range_x: float = 0
    max_range_y: float = 0
    crit_range: float = 0
    width: float = 0
    edge: float = 0
    offset: float = 0


class DistanceRect(NamedTuple):
    """Distance rectangle"""

    ahead: float = 0
    behind: float = 0
    side: float = 0


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config variable
        self.radar_radius = max(self.wcfg["radar_radius"], 5)
        self.area_center = round(  # limit minimum global scale relative to radar radius
            self.radar_radius * max(self.wcfg["global_scale"], 5 / self.radar_radius)
        )  # round to int
        self.area_size = self.area_center * 2
        self.global_scale = self.area_center / self.radar_radius  # recalibrate

        self.veh_width = max(self.wcfg["vehicle_width"], 0.01)
        self.veh_length = max(self.wcfg["vehicle_length"], 0.01)
        self.veh_shape = QRectF(
            -self.veh_width * self.global_scale * 0.5,
            -self.veh_length * self.global_scale * 0.5,
            self.veh_width * self.global_scale,
            self.veh_length * self.global_scale
        )
        self.vehicle_hide_range = self.set_range_dimension("vehicle_maximum_visible_distance")
        self.radar_hide_range = self.set_range_dimension("auto_hide_minimum_distance")
        self.radar_fade_factor = self.set_radar_fade_factor(self.radar_radius)
        self.radar_fade_color = QColor(0, 0, 0)

        # Overlap indicator
        self.indicator_dimension = self.calc_indicator_dimension(self.veh_width, self.veh_length)
        self.indicator_color = QColor(self.wcfg["indicator_color_nearby"])
        self.indicator_color_critical = QColor(self.wcfg["indicator_color_critical"])
        if self.wcfg["show_overlap_indicator_in_cone_style"]:
            cone_angle = max(self.wcfg["overlap_cone_angle"], 10)
            left_start = calc.asym_max(180 - cone_angle / 2, 90, 180)
            right_start = calc.asym_max(0 - cone_angle / 2, -270, 90)
            self.brush_cone_l = QBrush(QRadialGradient(self.area_center, self.area_center, self.area_center))
            self.brush_cone_r = QBrush(QRadialGradient(self.area_center, self.area_center, self.area_center))
            self.gradient_cone = [[0.1, Qt.transparent], [1, Qt.transparent]]
            self.cone_angle_l = left_start * 16, cone_angle * 16
            self.cone_angle_r = right_start * 16, cone_angle * 16

        # Config canvas
        self.resize(self.area_size, self.area_size)
        self.pixmap_mask = QPixmap(self.area_size, self.area_size)
        self.pixmap_marks = QPixmap(self.area_size, self.area_size)
        self.rect_radar = QRectF(0, 0, self.area_size, self.area_size)

        # Vehicle pen & brush
        if self.wcfg["vehicle_outline_width"] > 0:
            self.pen_veh = QPen()
            self.pen_veh.setWidth(self.wcfg["vehicle_outline_width"])
            self.pen_veh.setColor(self.wcfg["vehicle_outline_color"])
        else:
            self.pen_veh = Qt.NoPen
        self.brush_veh = QBrush(Qt.SolidPattern)

        self.draw_radar_marks(self.area_center)
        self.draw_radar_mask()

        # Last data
        self.last_veh_data_version = None
        self.autohide_timer_start = 1
        self.show_radar = True
        self.in_garage = True

    def timerEvent(self, event):
        """Update when vehicle on track"""
        self.in_garage = api.read.vehicle.in_garage()

        # Auto hide radar if no nearby vehicles
        if self.wcfg["auto_hide"]:
            self.set_autohide_state()

        # Vehicles
        veh_data_version = minfo.vehicles.dataSetVersion
        if self.last_veh_data_version != veh_data_version:
            self.last_veh_data_version = veh_data_version
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        if self.show_radar:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing, True)
            # Draw marks
            painter.drawPixmap(0, 0, self.pixmap_marks)
            # Draw vehicles
            self.draw_vehicle(painter, self.indicator_dimension)
            # Apply mask
            if self.wcfg["show_edge_fade_out"]:
                painter.setCompositionMode(QPainter.CompositionMode_DestinationOut)
                painter.drawPixmap(0, 0, self.pixmap_mask)
            # Draw background below map & mask
            if self.wcfg["show_background"]:
                painter.setCompositionMode(QPainter.CompositionMode_DestinationOver)
                painter.fillRect(self.rect_radar, self.wcfg["bkg_color"])
            # Apply radar fade mask
            if self.wcfg["enable_radar_fade"] and not self.in_garage:
                radar_alpha = self.radar_fade_factor * (
                    self.radar_radius - minfo.vehicles.nearestLine)
                if radar_alpha < 1:
                    if radar_alpha < 0:
                        radar_alpha = 0
                    self.radar_fade_color.setAlphaF(radar_alpha)
                    painter.setCompositionMode(QPainter.CompositionMode_DestinationIn)
                    painter.fillRect(self.rect_radar, self.radar_fade_color)

    def draw_radar_mask(self):
        """Draw radar mask"""
        self.pixmap_mask.fill(Qt.black)
        painter = QPainter(self.pixmap_mask)
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.setCompositionMode(QPainter.CompositionMode_SourceIn)
        rad_gra = QRadialGradient(self.area_center, self.area_center, self.area_center)
        rad_gra.setColorAt(calc.zero_one(self.wcfg["edge_fade_in_radius"]), Qt.transparent)
        rad_gra.setColorAt(calc.zero_one(self.wcfg["edge_fade_out_radius"]), Qt.black)
        painter.setBrush(rad_gra)
        painter.setPen(Qt.NoPen)
        painter.drawEllipse(0, 0, self.area_size, self.area_size)

    def draw_radar_marks(self, center):
        """Draw radar marks & player vehicle"""
        self.pixmap_marks.fill(Qt.transparent)
        painter = QPainter(self.pixmap_marks)
        painter.setRenderHint(QPainter.Antialiasing, True)

        # Draw center mark
        pen = QPen()
        pen.setCapStyle(Qt.FlatCap)
        if self.wcfg["show_center_mark"]:
            if not self.wcfg["center_mark_style"]:
                pen.setStyle(Qt.DashLine)
            else:
                pen.setStyle(Qt.SolidLine)
            mark_scale = self.wcfg["center_mark_radius"] * self.global_scale
            pen.setWidth(self.wcfg["center_mark_width"])
            pen.setColor(self.wcfg["center_mark_color"])
            painter.setPen(pen)
            painter.drawLine(center, center, center - mark_scale, center)
            painter.drawLine(center, center, center, center + mark_scale)
            painter.drawLine(center, center, center, center - mark_scale)
            painter.drawLine(center, center, center + mark_scale, center)

        if self.wcfg["show_angle_mark"]:
            if not self.wcfg["angle_mark_style"]:
                pen.setStyle(Qt.DashLine)
            else:
                pen.setStyle(Qt.SolidLine)
            mark_scale = self.wcfg["angle_mark_radius"] * self.global_scale
            mark_scale *= 0.7071  # radius correction
            pen.setWidth(self.wcfg["angle_mark_width"])
            pen.setColor(self.wcfg["angle_mark_color"])
            painter.setPen(pen)
            painter.drawLine(center, center, center - mark_scale, center + mark_scale)
            painter.drawLine(center, center, center + mark_scale, center - mark_scale)
            painter.drawLine(center, center, center - mark_scale, center - mark_scale)
            painter.drawLine(center, center, center + mark_scale, center + mark_scale)

        # Draw circle mark
        if self.wcfg["show_distance_circle"]:
            painter.setBrush(Qt.NoBrush)
            for idx in range(1, 6):
                self.draw_circle_mark(
                    painter, pen,
                    self.wcfg[f"distance_circle_{idx}_style"],
                    self.wcfg[f"distance_circle_{idx}_radius"],
                    self.wcfg[f"distance_circle_{idx}_width"],
                    self.wcfg[f"distance_circle_{idx}_color"]
                )

        # Draw player vehicle (one time only)
        painter.setPen(self.pen_veh)
        self.brush_veh.setColor(self.wcfg["vehicle_color_player"])
        painter.setBrush(self.brush_veh)
        painter.translate(self.area_center, self.area_center)
        painter.drawRoundedRect(
            self.veh_shape,
            self.wcfg["vehicle_border_radius"],
            self.wcfg["vehicle_border_radius"]
        )

    def draw_circle_mark(self, painter, pen, style, radius, width, color):
        """Draw circle mark"""
        if radius <= self.radar_radius and width > 0:
            scale = round(radius * self.global_scale)
            pos = self.area_center - scale
            size = scale * 2
            pen.setStyle(Qt.SolidLine if style else Qt.DashLine)
            pen.setWidth(width)
            pen.setColor(color)
            painter.setPen(pen)
            painter.drawEllipse(pos, pos, size, size)

    def draw_warning_cone(
        self, painter, nearest_left, nearest_right, indicator: IndicatorDimension):
        """Draw warning indicator as cone shape"""
        painter.setPen(Qt.NoPen)
        # Draw left side indicator
        if nearest_left > -indicator.max_range_x:
            self.gradient_cone[0][1] = self.warning_color(abs(nearest_left), indicator)
            self.brush_cone_l.gradient().setStops(self.gradient_cone)
            painter.setBrush(self.brush_cone_l)
            painter.drawPie(self.rect_radar, *self.cone_angle_l)

        # Draw right side indicator
        if nearest_right < indicator.max_range_x:
            self.gradient_cone[0][1] = self.warning_color(abs(nearest_right), indicator)
            self.brush_cone_r.gradient().setStops(self.gradient_cone)
            painter.setBrush(self.brush_cone_r)
            painter.drawPie(self.rect_radar, *self.cone_angle_r)

    def draw_warning_indicator(
        self, painter, nearest_left, nearest_right, indicator: IndicatorDimension):
        """Draw warning indicator"""
        # Draw left side indicator
        if nearest_left > -indicator.max_range_x:
            x_left = self.scale_veh_pos(nearest_left)
            pos_left = x_left - indicator.width + indicator.offset
            lin_gra = QLinearGradient(pos_left, 0, x_left + indicator.offset, 0)
            lin_gra.setColorAt(0, Qt.transparent)
            lin_gra.setColorAt(indicator.edge, self.warning_color(abs(nearest_left), indicator))
            lin_gra.setColorAt(1, Qt.transparent)
            painter.fillRect(pos_left, 0, indicator.width, self.area_size, lin_gra)

        # Draw right side indicator
        if nearest_right < indicator.max_range_x:
            x_right = self.scale_veh_pos(nearest_right)
            pos_right = x_right - indicator.offset
            lin_gra = QLinearGradient(pos_right, 0, x_right + indicator.width - indicator.offset, 0)
            lin_gra.setColorAt(0, Qt.transparent)
            lin_gra.setColorAt(1 - indicator.edge, self.warning_color(abs(nearest_right), indicator))
            lin_gra.setColorAt(1, Qt.transparent)
            painter.fillRect(pos_right, 0, indicator.width, self.area_size, lin_gra)

    def draw_vehicle(self, painter, indicator):
        """Draw opponents vehicles"""
        painter.setPen(self.pen_veh)
        # Real size in meters
        nearest_left = -indicator.max_range_x
        nearest_right = indicator.max_range_x

        # Draw opponent vehicle within radar range
        for veh_info in islice(minfo.vehicles.dataSet, minfo.vehicles.totalVehicles):
            if veh_info.isPlayer:
                continue
            # -x = left, +x = right, -y = ahead, +y = behind
            raw_pos_x = veh_info.relativeRotatedPositionX
            raw_pos_y = veh_info.relativeRotatedPositionY
            if (self.vehicle_hide_range.behind > raw_pos_y > -self.vehicle_hide_range.ahead and
                -self.vehicle_hide_range.side < raw_pos_x < self.vehicle_hide_range.side):

                # Find nearest vehicle coordinates
                if (self.wcfg["show_overlap_indicator"] and
                    abs(raw_pos_x) < indicator.max_range_x and
                    abs(raw_pos_y) < indicator.max_range_y):
                    if -indicator.min_range_x > raw_pos_x > nearest_left:
                        nearest_left = raw_pos_x
                    if indicator.min_range_x < raw_pos_x < nearest_right:
                        nearest_right = raw_pos_x

                # Draw vehicle
                self.brush_veh.setColor(self.color_lap_diff(veh_info))
                painter.setBrush(self.brush_veh)
                painter.translate(self.scale_veh_pos(raw_pos_x), self.scale_veh_pos(raw_pos_y))
                if self.wcfg["show_vehicle_orientation"]:
                    painter.rotate(calc.rad2deg(-veh_info.relativeOrientationRadians))
                painter.drawRoundedRect(
                    self.veh_shape,
                    self.wcfg["vehicle_border_radius"],
                    self.wcfg["vehicle_border_radius"]
                )
                painter.resetTransform()

        # Draw overlap indicator below vehicle shape
        if self.wcfg["show_overlap_indicator"]:
            painter.setCompositionMode(QPainter.CompositionMode_DestinationOver)
            if self.wcfg["show_overlap_indicator_in_cone_style"]:
                self.draw_warning_cone(painter, nearest_left, nearest_right, indicator)
            else:
                self.draw_warning_indicator(painter, nearest_left, nearest_right, indicator)

        # Draw circle background
        if self.wcfg["show_circle_background"]:
            painter.setCompositionMode(QPainter.CompositionMode_DestinationOver)
            painter.fillRect(self.rect_radar, self.wcfg["bkg_color_circle"])

    # Additional methods
    def scale_veh_pos(self, position):
        """Scale vehicle position coordinate to global scale"""
        return position * self.global_scale + self.area_center

    def warning_color(self, nearest_x, indicator: IndicatorDimension):
        """Overtaking warning color"""
        alpha = 1 - (nearest_x - indicator.min_range_x) / indicator.max_range_x
        if nearest_x <= indicator.crit_range:
            self.indicator_color_critical.setAlphaF(alpha)  # alpha changes with nearest distance
            return self.indicator_color_critical
        self.indicator_color.setAlphaF(alpha)
        return self.indicator_color

    def color_lap_diff(self, veh_info):
        """Compare lap differences & set color"""
        if veh_info.positionOverall == 1:
            return self.wcfg["vehicle_color_leader"]
        if veh_info.inPit:
            return self.wcfg["vehicle_color_in_pit"]
        if veh_info.isYellow and not veh_info.inPit:
            return self.wcfg["vehicle_color_yellow"]
        if veh_info.isLapped > 0:
            return self.wcfg["vehicle_color_laps_ahead"]
        if veh_info.isLapped < 0:
            return self.wcfg["vehicle_color_laps_behind"]
        return self.wcfg["vehicle_color_same_lap"]

    def set_autohide_state(self):
        """Auto hide radar if in private qualifying or no nearby vehicles"""
        # Always show in garage
        if self.in_garage:
            self.show_radar = True
            return
        # Hide in private qualifying
        if (self.wcfg["auto_hide_in_private_qualifying"] and
            api.read.session.private_qualifying() == 1 and
            api.read.session.session_type() == 2):
            self.show_radar = False
            return
        # Bypass auto hide timer if radar fade enabled
        is_nearby = self.is_nearby()
        if self.wcfg["enable_radar_fade"]:
            self.show_radar = is_nearby
            return
        # Start auto hide timer
        lap_etime = api.read.timing.elapsed()
        if is_nearby:
            self.show_radar = True
            self.autohide_timer_start = lap_etime
        # Update auto hide timer
        if self.autohide_timer_start:
            if lap_etime - self.autohide_timer_start > self.wcfg["auto_hide_time_threshold"]:
                self.show_radar = False
                self.autohide_timer_start = 0
            # Timer start should be smaller than elapsed time, reset if not
            elif self.autohide_timer_start > lap_etime:
                self.autohide_timer_start = 1

    def is_nearby(self):
        """Check nearby vehicles"""
        for veh_info in islice(minfo.vehicles.dataSet, minfo.vehicles.totalVehicles):
            # -x = left, +x = right, -y = ahead, +y = behind
            if (not veh_info.isPlayer and
                self.radar_hide_range.behind > veh_info.relativeRotatedPositionY > -self.radar_hide_range.ahead and
                -self.radar_hide_range.side < veh_info.relativeRotatedPositionX < self.radar_hide_range.side):
                return True
        return False

    def calc_indicator_dimension(self, veh_width, veh_length):
        """Calculate indicator dimension

        Range between player & opponents to show indicator.
        x is left to right range.
        y is forward to backward range.
        """
        min_range_x = veh_width * 0.9  # slightly overlapped
        max_range_x = veh_width * (max(self.wcfg["overlap_nearby_range_multiplier"], 0) + 0.9)
        max_range_y = veh_length * 1.2  # safe range for ahead & behind opponents
        crit_range = veh_width * (max(self.wcfg["overlap_critical_range_multiplier"], 0) + 0.9)
        width = veh_width * max(self.wcfg["indicator_size_multiplier"], 0.01) * self.global_scale
        edge = max((width - 3) / width, 0.001)  # for antialiasing
        offset = veh_width * self.global_scale * 0.5
        return IndicatorDimension(min_range_x, max_range_x, max_range_y, crit_range, width, edge, offset)

    def set_range_dimension(self, prefix):
        """Set range dimension for radar & autohide"""
        if self.wcfg[f"{prefix}_ahead"] < 0:
            min_ahead = self.radar_radius
        else:
            min_ahead = self.wcfg[f"{prefix}_ahead"]

        if self.wcfg[f"{prefix}_behind"] < 0:
            min_behind = self.radar_radius
        else:
            min_behind = self.wcfg[f"{prefix}_behind"]

        if self.wcfg[f"{prefix}_side"] < 0:
            min_side = self.radar_radius
        else:
            min_side = self.wcfg[f"{prefix}_side"]
        return DistanceRect(min_ahead, min_behind, min_side)

    def set_radar_fade_factor(self, radar_radius):
        """Set radar fade factor"""
        range_fade_out = min(max(self.wcfg["radar_fade_out_radius"], 0.5), 1)
        range_fade_in = min(max(self.wcfg["radar_fade_in_radius"], 0.1),
                            range_fade_out - 0.01)  # make sure not exceed fade out range
        range_diff = range_fade_out - range_fade_in
        range_scale = range_fade_out / range_diff
        return range_scale / radar_radius

```

# File: tinypedal/widget/rake_angle.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Rake angle Widget
"""

from functools import partial

from .. import calculation as calc
from ..api_control import api
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout()
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.prefix_text = self.wcfg["prefix_rake_angle"]
        self.sign_text = "Â°" if self.wcfg["show_degree_sign"] else ""
        self.decimals = max(int(self.wcfg["decimal_places"]), 1)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Rake angle
        self.bar_style_rake = (
            self.set_qss(
                fg_color=self.wcfg["font_color_rake_angle"],
                bg_color=self.wcfg["bkg_color_rake_angle"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_rake_angle"],
                bg_color=self.wcfg["warning_color_negative_rake"])
        )
        text_rake = self.format_rake(0)
        self.bar_rake = self.set_qlabel(
            text=text_rake,
            style=self.bar_style_rake[0],
            width=font_m.width * len(text_rake) + bar_padx,
            last=0,
        )
        layout.addWidget(self.bar_rake, 0, 0)

        self.calc_ema_rake = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.wcfg["rake_angle_smoothing_samples"])
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Rake angle
        ema_rake = self.calc_ema_rake(self.bar_rake.last, calc.rake(*api.read.wheel.ride_height()))
        self.update_rake(self.bar_rake, ema_rake)

    # GUI update methods
    def update_rake(self, target, data):
        """Rake data"""
        if target.last != data:
            target.last = data
            target.setText(self.format_rake(data))
            target.updateStyle(self.bar_style_rake[data < 0])

    def format_rake(self, rake):
        """Format rake"""
        rake_angle = f"{calc.slope_angle(rake, self.wcfg['wheelbase']):+.{self.decimals}f}"[:self.decimals + 3]
        if self.wcfg["show_ride_height_difference"]:
            ride_diff = f"({abs(rake):02.0f})"[:4]
        else:
            ride_diff = ""
        return f"{self.prefix_text}{rake_angle}{self.sign_text}{ride_diff}"

```

# File: tinypedal/widget/relative.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Relative Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import MAX_SECONDS, TEXT_NOLAPTIME, TEXT_PLACEHOLDER
from ..formatter import random_color_class, shorten_driver_name
from ..module_info import minfo
from ..units import set_unit_speed
from ..userfile.brand_logo import load_brand_logo_file
from ..userfile.heatmap import select_compound_symbol
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap_vert=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.drv_width = max(int(self.wcfg["driver_name_width"]), 1)
        self.veh_width = max(int(self.wcfg["vehicle_name_width"]), 1)
        self.brd_width = max(int(self.wcfg["brand_logo_width"]), 1)
        self.brd_height = max(self.wcfg["font_size"], 1)
        self.cls_width = max(int(self.wcfg["class_width"]), 0)
        self.gap_width = max(int(self.wcfg["time_gap_width"]), 1)
        self.gap_decimals = max(int(self.wcfg["time_gap_decimal_places"]), 0)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Max display players
        veh_add_front = min(max(int(self.wcfg["additional_players_front"]), 0), 60)
        veh_add_behind = min(max(int(self.wcfg["additional_players_behind"]), 0), 60)
        self.veh_range = max(7 + veh_add_front + veh_add_behind, 7)

        # Empty dataset
        self.pixmap_brandlogo = {}
        self.row_visible = [False] * self.veh_range

        # Driver position
        if self.wcfg["show_position"]:
            self.bar_style_pos = self.set_qss_lap_difference(
                fg_color=self.wcfg["font_color_position"],
                bg_color=self.wcfg["bkg_color_position"],
                plr_fg_color=self.wcfg["font_color_player_position"],
                plr_bg_color=self.wcfg["bkg_color_player_position"],
            )
            self.bars_pos = self.set_qlabel(
                style=self.bar_style_pos[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pos,
                column_index=self.wcfg["column_index_position"],
            )
        # Driver position change
        if self.wcfg["show_position_change"]:
            self.bar_style_pgl = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_same"],
                    bg_color=self.wcfg["bkg_color_position_same"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_gain"],
                    bg_color=self.wcfg["bkg_color_position_gain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_loss"],
                    bg_color=self.wcfg["bkg_color_position_loss"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_position_change"],
                    bg_color=self.wcfg["bkg_color_player_position_change"])
            )
            self.bars_pgl = self.set_qlabel(
                style=self.bar_style_pgl[0],
                width=3 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pgl,
                column_index=self.wcfg["column_index_position_change"],
            )
        # Driver name
        if self.wcfg["show_driver_name"]:
            self.bar_style_drv = self.set_qss_lap_difference(
                fg_color=self.wcfg["font_color_driver_name"],
                bg_color=self.wcfg["bkg_color_driver_name"],
                plr_fg_color=self.wcfg["font_color_player_driver_name"],
                plr_bg_color=self.wcfg["bkg_color_player_driver_name"],
            )
            self.bars_drv = self.set_qlabel(
                style=self.bar_style_drv[0],
                width=self.drv_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_drv,
                column_index=self.wcfg["column_index_driver"],
            )
        # Vehicle name
        if self.wcfg["show_vehicle_name"]:
            self.bar_style_veh = self.set_qss_lap_difference(
                fg_color=self.wcfg["font_color_vehicle_name"],
                bg_color=self.wcfg["bkg_color_vehicle_name"],
                plr_fg_color=self.wcfg["font_color_player_vehicle_name"],
                plr_bg_color=self.wcfg["bkg_color_player_vehicle_name"],
            )
            self.bars_veh = self.set_qlabel(
                style=self.bar_style_veh[0],
                width=self.veh_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_veh,
                column_index=self.wcfg["column_index_vehicle"],
            )
        # Brand logo
        if self.wcfg["show_brand_logo"]:
            self.bar_style_brd = (
                self.set_qss(
                    bg_color=self.wcfg["bkg_color_brand_logo"]),
                self.set_qss(
                    bg_color=self.wcfg["bkg_color_player_brand_logo"])
            )
            self.bars_brd = self.set_qlabel(
                style=self.bar_style_brd[0],
                width=self.brd_width,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_brd,
                column_index=self.wcfg["column_index_brand_logo"],
            )
        # Time gap
        if self.wcfg["show_time_gap"]:
            self.bar_style_gap = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_time_gap"],
                    bg_color=self.wcfg["bkg_color_time_gap"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_time_gap"],
                    bg_color=self.wcfg["bkg_color_player_time_gap"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_nearest_time_gap"],
                    bg_color=self.wcfg["bkg_color_nearest_time_gap"])
            )
            self.nearest_time_gap = (
                -max(self.wcfg["nearest_time_gap_threshold_behind"], 0),
                max(self.wcfg["nearest_time_gap_threshold_front"], 0),
            )
            self.bars_gap = self.set_qlabel(
                style=self.bar_style_gap[0],
                width=self.gap_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_gap,
                column_index=self.wcfg["column_index_timegap"],
            )
        # Vehicle laptime
        if self.wcfg["show_laptime"]:
            self.bar_style_lpt = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_laptime"],
                    bg_color=self.wcfg["bkg_color_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_laptime"],
                    bg_color=self.wcfg["bkg_color_player_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_fastest_last_laptime"],
                    bg_color=self.wcfg["bkg_color_fastest_last_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_fastest_last_laptime"],
                    bg_color=self.wcfg["bkg_color_player_fastest_last_laptime"])
            )
            self.bars_lpt = self.set_qlabel(
                style=self.bar_style_lpt[0],
                width=8 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_lpt,
                column_index=self.wcfg["column_index_laptime"],
            )
        # Vehicle best laptime
        if self.wcfg["show_best_laptime"]:
            self.bar_style_blp = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_best_laptime"],
                    bg_color=self.wcfg["bkg_color_best_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_best_laptime"],
                    bg_color=self.wcfg["bkg_color_player_best_laptime"])
            )
            self.bars_blp = self.set_qlabel(
                style=self.bar_style_blp[0],
                width=8 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_blp,
                column_index=self.wcfg["column_index_best_laptime"],
            )
        # Position in class
        if self.wcfg["show_position_in_class"]:
            self.bar_style_pic = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_in_class"],
                    bg_color=self.wcfg["bkg_color_position_in_class"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_position_in_class"],
                    bg_color=self.wcfg["bkg_color_player_position_in_class"])
            )
            self.bars_pic = self.set_qlabel(
                style=self.bar_style_pic[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pic,
                column_index=self.wcfg["column_index_position_in_class"],
            )
        # Vehicle class
        if self.wcfg["show_class"]:
            bar_style_cls = self.set_qss(
                fg_color=self.wcfg["font_color_class"],
                bg_color=self.wcfg["bkg_color_class"]
            )
            self.bars_cls = self.set_qlabel(
                style=bar_style_cls,
                width=self.cls_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_cls,
                column_index=self.wcfg["column_index_class"],
            )
        # Vehicle in pit
        if self.wcfg["show_pit_status"]:
            self.pit_status_text = (
                "",
                self.wcfg["pit_status_text"],
                self.wcfg["garage_status_text"],
                self.wcfg["yellow_flag_status_text"],
            )
            self.bar_style_pit = (
                "",
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit"],
                    bg_color=self.wcfg["bkg_color_pit"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_garage"],
                    bg_color=self.wcfg["bkg_color_garage"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_yellow_flag"],
                    bg_color=self.wcfg["bkg_color_yellow_flag"])
            )
            self.bars_pit = self.set_qlabel(
                style=self.bar_style_pit[0],
                width=max(map(len, self.pit_status_text)) * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pit,
                column_index=self.wcfg["column_index_pitstatus"],
            )
        # Tyre compound index
        if self.wcfg["show_tyre_compound"]:
            self.bar_style_tcp = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_tyre_compound"],
                    bg_color=self.wcfg["bkg_color_tyre_compound"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_tyre_compound"],
                    bg_color=self.wcfg["bkg_color_player_tyre_compound"])
            )
            self.bars_tcp = self.set_qlabel(
                style=self.bar_style_tcp[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_tcp,
                column_index=self.wcfg["column_index_tyre_compound"],
            )
        # Pitstop count
        if self.wcfg["show_pitstop_count"]:
            self.bar_style_psc = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_pitstop_count"],
                    bg_color=self.wcfg["bkg_color_pitstop_count"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_pitstop_count"],
                    bg_color=self.wcfg["bkg_color_player_pitstop_count"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit_request"],
                    bg_color=self.wcfg["bkg_color_pit_request"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_penalty_count"],
                    bg_color=self.wcfg["bkg_color_penalty_count"])
            )
            self.bars_psc = self.set_qlabel(
                style=self.bar_style_psc[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_psc,
                column_index=self.wcfg["column_index_pitstop_count"],
            )
        # Remaining energy
        if self.wcfg["show_energy_remaining"]:
            self.bar_style_nrg = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_unavailable"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_high"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_low"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_critical"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_energy_remaining"],
                    bg_color=self.wcfg["bkg_color_player_energy_remaining"])
            )
            self.bars_nrg = self.set_qlabel(
                style=self.bar_style_nrg[0],
                width=3 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_nrg,
                column_index=self.wcfg["column_index_energy_remaining"],
            )
        # Vehicle integrity
        if self.wcfg["show_vehicle_integrity"]:
            self.bar_style_dmg = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_full"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_high"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_low"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_vehicle_integrity"],
                    bg_color=self.wcfg["bkg_color_player_vehicle_integrity"])
            )
            self.bars_dmg = self.set_qlabel(
                style=self.bar_style_dmg[0],
                width=1 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_dmg,
                column_index=self.wcfg["column_index_vehicle_integrity"],
            )
        # Stint laps
        if self.wcfg["show_stint_laps"]:
            self.bar_style_stl = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_stint_laps"],
                    bg_color=self.wcfg["bkg_color_stint_laps"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_stint_laps"],
                    bg_color=self.wcfg["bkg_color_player_stint_laps"])
            )
            self.bars_stl = self.set_qlabel(
                style=self.bar_style_stl[0],
                width=5 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_stl,
                column_index=self.wcfg["column_index_stint_laps"],
            )
        # Speed trap
        if self.wcfg["show_speed_trap"]:
            self.unit_speed = set_unit_speed(self.cfg.units["speed_unit"])
            self.bar_style_spd = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_speed_trap"],
                    bg_color=self.wcfg["bkg_color_speed_trap"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_speed_trap"],
                    bg_color=self.wcfg["bkg_color_player_speed_trap"])
            )
            self.bars_spd = self.set_qlabel(
                style=self.bar_style_spd[0],
                width=5 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_spd,
                column_index=self.wcfg["column_index_speed_trap"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        relative_list = minfo.relative.relative
        total_rel_idx = len(relative_list)
        player_idx = minfo.vehicles.playerIndex
        plr_veh_info = minfo.vehicles.dataSet[player_idx]
        in_race = api.read.session.in_race()

        # Relative update
        for idx in range(self.veh_range):

            if idx < total_rel_idx:
                rel_time_gap, rel_idx = relative_list[idx]
            else:
                rel_time_gap, rel_idx = 0.0, -2

            # Set row state: 1 - show text, 0 - hide text
            if rel_idx >= 0:
                self.row_visible[idx] = True
                state = 1
            elif not self.row_visible[idx]:
                continue  # skip if already empty
            else:
                self.row_visible[idx] = False
                state = 0

            # Get vehicle dataset
            veh_info = minfo.vehicles.dataSet[rel_idx]
            # Highlighted player
            hi_player = self.wcfg["show_player_highlighted"] and veh_info.isPlayer
            # Check whether is lapped
            is_lapped = veh_info.isLapped
            # Driver position
            if self.wcfg["show_position"]:
                self.update_pos(self.bars_pos[idx], veh_info.positionOverall, is_lapped, hi_player, state)
            # Driver position change
            if self.wcfg["show_position_change"]:
                if self.wcfg["show_position_change_in_class"]:
                    pos_diff = veh_info.qualifyInClass - veh_info.positionInClass
                else:
                    pos_diff = veh_info.qualifyOverall - veh_info.positionOverall
                self.update_pgl(self.bars_pgl[idx], pos_diff, hi_player, state)
            # Driver name
            if self.wcfg["show_driver_name"]:
                self.update_drv(self.bars_drv[idx], veh_info.driverName, is_lapped, hi_player, state)
            # Vehicle name
            if self.wcfg["show_vehicle_name"]:
                self.update_veh(self.bars_veh[idx], veh_info.vehicleName, is_lapped, hi_player, state)
            # Brand logo
            if self.wcfg["show_brand_logo"]:
                self.update_brd(self.bars_brd[idx], veh_info.vehicleName, hi_player, state)
            # Time gap
            if self.wcfg["show_time_gap"]:
                self.update_gap(self.bars_gap[idx], rel_time_gap, hi_player, state)
            # Vehicle laptime
            if self.wcfg["show_laptime"]:
                if self.wcfg["show_pitstop_duration_while_requested_pitstop"] and plr_veh_info.pitRequested:
                    laptime = self.set_pittime(veh_info.inPit, veh_info.pitTimer.elapsed)
                    is_class_best = False
                elif veh_info.pitTimer.pitting:
                    laptime = self.set_pittime(veh_info.inPit, veh_info.pitTimer.elapsed)
                    is_class_best = False
                else:
                    laptime = self.set_laptime(veh_info.lastLapTime)
                    is_class_best = veh_info.isClassFastestLastLap
                self.update_lpt(self.bars_lpt[idx], laptime, is_class_best, hi_player, state)
            # Vehicle best laptime
            if self.wcfg["show_best_laptime"]:
                if in_race and self.wcfg["show_best_laptime_from_recent_laps_in_race"]:
                    laptime = veh_info.lapTimeHistory.best()
                else:
                    laptime = veh_info.bestLapTime
                self.update_blp(self.bars_blp[idx], laptime, hi_player, state)
            # Position in class
            if self.wcfg["show_position_in_class"]:
                self.update_pic(self.bars_pic[idx], veh_info.positionInClass, veh_info.vehicleClass, hi_player, state)
            # Vehicle class
            if self.wcfg["show_class"]:
                self.update_cls(self.bars_cls[idx], veh_info.vehicleClass, state)
            # Vehicle in pit
            if self.wcfg["show_pit_status"]:
                self.update_pit(self.bars_pit[idx], veh_info.inPit, veh_info.isYellow, state)
            # Tyre compound index
            if self.wcfg["show_tyre_compound"]:
                self.update_tcp(self.bars_tcp[idx], veh_info.tireCompoundFront, veh_info.tireCompoundRear, hi_player, state)
            # Pitstop count
            if self.wcfg["show_pitstop_count"]:
                self.update_psc(self.bars_psc[idx], veh_info.numPitStops, veh_info.pitRequested, hi_player, state)
            # Remaining energy
            if self.wcfg["show_energy_remaining"]:
                self.update_nrg(self.bars_nrg[idx], veh_info.energyRemaining, hi_player, state)
            # Vehicle integrity
            if self.wcfg["show_vehicle_integrity"]:
                self.update_dmg(self.bars_dmg[idx], veh_info.vehicleIntegrity, hi_player, state)
            # Stint laps
            if self.wcfg["show_stint_laps"]:
                self.update_stl(self.bars_stl[idx], veh_info.currentStintLaps, veh_info.estimatedStintLaps, hi_player, state)
            # Speed trap
            if self.wcfg["show_speed_trap"]:
                self.update_spd(self.bars_spd[idx], veh_info.speedTrap.speed, hi_player, state)

    # GUI update methods
    def update_pos(self, target, *data):
        """Driver position"""
        if target.last != data:
            target.last = data
            if data[2]:  # highlight player
                color = self.bar_style_pos[1]
            elif self.wcfg["show_lap_difference"]:
                color = self.bar_style_pos[lap_difference_index(data[1])]
            else:
                color = self.bar_style_pos[0]
            if data[-1]:
                text = f"{data[0]:02d}"
            else:
                text = ""
            target.setText(text)
            target.updateStyle(color)

    def update_pgl(self, target, *data):
        """Driver position change (gain/loss)"""
        if target.last != data:
            target.last = data
            if data[-1]:
                pos_diff = data[0]
                if pos_diff > 0:
                    text = f"â–²{pos_diff: >2}"
                    color_index = 1
                elif pos_diff < 0:
                    text = f"â–¼{-pos_diff: >2}"
                    color_index = 2
                else:
                    text = "- 0"
                    color_index = 0
                if data[1]:
                    color_index = 3
            else:
                text = ""
                color_index = 0
            target.setText(text)
            target.updateStyle(self.bar_style_pgl[color_index])

    def update_drv(self, target, *data):
        """Driver name"""
        if target.last != data:
            target.last = data
            if data[2]:  # highlight player
                color = self.bar_style_drv[1]
            elif self.wcfg["show_lap_difference"]:
                color = self.bar_style_drv[lap_difference_index(data[1])]
            else:
                color = self.bar_style_drv[0]
            if data[-1]:
                if self.wcfg["driver_name_shorten"]:
                    text = shorten_driver_name(data[0])
                else:
                    text = data[0]
                if self.wcfg["driver_name_uppercase"]:
                    text = text.upper()
                if self.wcfg["driver_name_align_center"]:
                    text = text[:self.drv_width]
                else:
                    text = text[:self.drv_width].ljust(self.drv_width)
            else:
                text = ""
            target.setText(text)
            target.updateStyle(color)

    def update_veh(self, target, *data):
        """Vehicle name"""
        if target.last != data:
            target.last = data
            if data[2]:  # highlight player
                color = self.bar_style_veh[1]
            elif self.wcfg["show_lap_difference"]:
                color = self.bar_style_veh[lap_difference_index(data[1])]
            else:
                color = self.bar_style_veh[0]
            if data[-1]:
                if self.wcfg["show_vehicle_brand_as_name"]:
                    text = self.cfg.user.brands.get(data[0], data[0])
                else:
                    text = data[0]
                if self.wcfg["vehicle_name_uppercase"]:
                    text = text.upper()
                if self.wcfg["vehicle_name_align_center"]:
                    text = text[:self.veh_width]
                else:
                    text = text[:self.veh_width].ljust(self.veh_width)
            else:
                text = ""
            target.setText(text)
            target.updateStyle(color)

    def update_brd(self, target, *data):
        """Brand logo"""
        if target.last != data:
            target.last = data
            if data[-1]:
                brand_name = self.cfg.user.brands.get(data[0], data[0])
            else:
                brand_name = ""
            target.setPixmap(self.set_brand_logo(brand_name))
            target.updateStyle(self.bar_style_brd[data[1]])

    def update_gap(self, target, *data):
        """Time gap"""
        if target.last != data:
            target.last = data
            if data[1]:  # highlight player
                color_index = 1
            elif (self.wcfg["show_highlighted_nearest_time_gap"] and data[-1] and
                  self.nearest_time_gap[0] <= data[0] <= self.nearest_time_gap[1]):
                color_index = 2
            else:
                color_index = 0
            if data[-1]:
                if self.wcfg["show_time_gap_sign"] and data[0] != 0:
                    value = f"{-data[0]:+.{self.gap_decimals}f}"
                else:
                    value = f"{abs(data[0]):.{self.gap_decimals}f}"
                if self.wcfg["time_gap_align_center"]:
                    text = value[:self.gap_width].strip(".")
                else:
                    text = value[:self.gap_width].strip(".").rjust(self.gap_width)
            else:
                text = ""
            target.setText(text)
            target.updateStyle(self.bar_style_gap[color_index])

    def update_lpt(self, target, *data):
        """Vehicle laptime"""
        if target.last != data:
            target.last = data
            if self.wcfg["show_highlighted_fastest_last_laptime"] and data[1]:
                color_index = 2 + data[2]
            else:
                color_index = data[2]
            if data[-1]:
                text = data[0]
            else:
                text = ""
            target.setText(text)
            target.updateStyle(self.bar_style_lpt[color_index])

    def update_blp(self, target, *data):
        """Vehicle best laptime"""
        if target.last != data:
            target.last = data
            if data[-1]:
                text = self.set_laptime(data[0])
            else:
                text = ""
            target.setText(text)
            target.updateStyle(self.bar_style_blp[data[1]])

    def update_pic(self, target, *data):
        """Position in class"""
        if target.last != data:
            target.last = data
            if data[-1]:
                text = f"{data[0]:02d}"
            else:
                text = ""
            if data[2]:  # player
                style = self.bar_style_pic[1]
            elif self.wcfg["show_class_style_for_position_in_class"]:
                style = f"color:{self.wcfg['font_color_position_in_class']};background:{self.set_class_style(data[1])[1]};"
            else:
                style = self.bar_style_pic[0]
            target.setText(text)
            target.updateStyle(style)

    def update_cls(self, target, *data):
        """Vehicle class"""
        if target.last != data:
            target.last = data
            text, bg_color = self.set_class_style(data[0])
            target.setText(text[:self.cls_width])
            target.updateStyle(f"color:{self.wcfg['font_color_class']};background:{bg_color};")

    def update_pit(self, target, *data):
        """Vehicle in pit"""
        if target.last != data:
            target.last = data
            index = data[0]
            if data[1] and index == 0:  # show yellow flag outside pits
                index = 3
            target.setText(self.pit_status_text[index])
            target.updateStyle(self.bar_style_pit[index])

    def update_tcp(self, target, *data):
        """Tyre compound index"""
        if target.last != data:
            target.last = data
            if data[-1]:
                text = f"{select_compound_symbol(data[0])}{select_compound_symbol(data[1])}"
            else:
                text = ""
            target.setText(text)
            target.updateStyle(self.bar_style_tcp[data[2]])

    def update_psc(self, target, *data):
        """Pitstop count"""
        if target.last != data:
            target.last = data
            if data[0] < 0:
                color_index = 3
            elif self.wcfg["show_pit_request"] and data[1]:
                color_index = 2
            elif data[2]:  # highlight player
                color_index = 1
            else:
                color_index = 0
            if not data[-1]:
                text = ""
            elif data[0] == 0:
                text = TEXT_PLACEHOLDER
            else:
                text = f"{data[0]}"
            target.setText(text)
            target.updateStyle(self.bar_style_psc[color_index])

    def update_nrg(self, target, *data):
        """Remaining energy"""
        if target.last != data:
            target.last = data
            ve = data[0]
            if data[1]:  # highlighted player
                color_index = 4
            elif ve <= -1:  # unavailable
                color_index = 0
            elif ve <= 0.1:  # 10% remaining
                color_index = 3
            elif ve <= 0.3:  # 30% remaining
                color_index = 2
            else:
                color_index = 1
            if not data[-1]:
                text = ""
            elif ve <= -1:
                text = "---"
            else:
                text = f"{ve:03.0%}"[:3]
            target.setText(text)
            target.updateStyle(self.bar_style_nrg[color_index])

    def update_dmg(self, target, *data):
        """Vehicle integrity"""
        if target.last != data:
            target.last = data
            hp = int(data[0] * 10)
            if data[1]:  # highlighted player
                color_index = 3
            elif hp >= 10:  # full integrity
                color_index = 0
            elif hp <= 5:  # low
                color_index = 2
            else:  # high
                color_index = 1
            if not data[-1]:
                text = ""
            elif hp >= 10:
                text = TEXT_PLACEHOLDER
            else:
                text = f"{hp:d}"
            target.setText(text)
            target.updateStyle(self.bar_style_dmg[color_index])

    def update_stl(self, target, *data):
        """Stint laps"""
        if target.last != data:
            target.last = data
            if data[-1]:
                stint_laps_done = data[0]
                stint_laps_est = data[1]
                if stint_laps_done <= 0:
                    text_done = "--"
                else:
                    text_done = f"{stint_laps_done:02.0f}"
                if stint_laps_est <= 0:
                    text_est = "--"
                else:
                    text_est = f"{stint_laps_est // 1:02.0f}"
                text = f"{text_done}/{text_est}"
            else:
                text = ""
            target.setText(text)
            target.updateStyle(self.bar_style_stl[data[2]])

    def update_spd(self, target, *data):
        """Speed trap"""
        if target.last != data:
            target.last = data
            if data[-1]:
                text_speed = f"{self.unit_speed(data[0]):.3f}"[:5]
            else:
                text_speed = ""
            target.setText(text_speed)
            target.updateStyle(self.bar_style_spd[data[1]])

    # Additional methods
    def set_qss_lap_difference(self, fg_color, bg_color, plr_fg_color, plr_bg_color):
        """Set style with player & lap difference:
        0 default, 1 player, 2 same lap, 3 behind lap, 4 ahead lap.
        """
        return (
            self.set_qss(  # 0 default
                fg_color=fg_color,
                bg_color=bg_color),
            self.set_qss(  # 1 player
                fg_color=plr_fg_color,
                bg_color=plr_bg_color),
            self.set_qss(  # 2 same lap
                fg_color=self.wcfg["font_color_same_lap"],
                bg_color=bg_color),
            self.set_qss(  # 3 behind lap
                fg_color=self.wcfg["font_color_laps_behind"],
                bg_color=bg_color),
            self.set_qss(  # 4 ahead lap
                fg_color=self.wcfg["font_color_laps_ahead"],
                bg_color=bg_color),
        )

    def set_brand_logo(self, brand_name: str):
        """Set brand logo"""
        if brand_name not in self.pixmap_brandlogo:  # load & cache logo
            self.pixmap_brandlogo[brand_name] = load_brand_logo_file(
                filepath=self.cfg.path.brand_logo,
                filename=brand_name,
                max_width=self.brd_width,
                max_height=self.brd_height,
            )
        return self.pixmap_brandlogo[brand_name]

    def set_class_style(self, class_name: str):
        """Compare vehicle class name with user defined dictionary"""
        style = self.cfg.user.classes.get(class_name)
        if style is not None:
            return style["alias"], style["color"]
        if class_name:
            return class_name, random_color_class(class_name)
        return class_name, self.wcfg["bkg_color_class"]

    @staticmethod
    def set_laptime(laptime):
        """Set lap time"""
        if 0 < laptime < MAX_SECONDS:
            return calc.sec2laptime_full(laptime)[:8]
        return TEXT_NOLAPTIME

    @staticmethod
    def set_pittime(inpit, pit_time):
        """Set lap time"""
        if 0 < pit_time < MAX_SECONDS:
            return f"{'PIT' if inpit else 'OUT'}{pit_time: >5.1f}"[:8]
        return TEXT_NOLAPTIME


def lap_difference_index(is_lapped, offset=2):
    """Set lap difference as index

    Returns:
        0 = same lap, 1 = behind, 2 = ahead
    """
    return (is_lapped < 0) + (is_lapped > 0) * 2 + offset

```

# File: tinypedal/widget/relative_finish_order.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Relative finish order Widget
"""

from math import ceil

from .. import calculation as calc
from ..api_control import api
from ..const_common import (
    ENERGY_TYPE_ID,
    MAX_SECONDS,
    RACELENGTH_TYPE_ID,
    TEXT_PLACEHOLDER,
)
from ..module_info import minfo
from ..units import set_unit_fuel
from ..validator import generator_init
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap_hori=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        layout_reversed = self.wcfg["layout"] != 0
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.char_width = max(self.wcfg["bar_width"], 3)
        bar_width = font_m.width * self.char_width + bar_padx
        self.range_start = max(self.wcfg["near_start_range"], 0)
        self.range_finish = max(self.wcfg["near_finish_range"], 0)
        self.total_slot = min(max(self.wcfg["number_of_prediction"], 0), 10) + 3
        self.leader_pit_time_set = list(self.create_pit_time_set(self.total_slot, "leader"))
        self.player_pit_time_set = list(self.create_pit_time_set(self.total_slot, "player"))
        self.decimals_laps = max(self.wcfg["decimal_places_laps"], 0)
        self.decimals_refill = max(self.wcfg["decimal_places_refill"], 0)
        self.extra_laps = max(self.wcfg["number_of_extra_laps"], 1)
        self.refill_sign = "" if self.wcfg["show_absolute_refilling"] else "+"

        # Config units
        self.unit_fuel = set_unit_fuel(self.cfg.units["fuel_unit"])

        self.gen_leader_pace = calc_laptime_pace(
            self.wcfg["leader_laptime_pace_samples"],
            max(self.wcfg["leader_laptime_pace_margin"], 0.1))

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Leader pit time row
        bar_style_pit_time = self.set_qss(
            fg_color=self.wcfg["font_color_pit_time"],
            bg_color=self.wcfg["bkg_color_pit_time"],
            font_size=int(self.wcfg['font_size'] * 0.8),
        )
        self.bars_pit_leader = self.set_qlabel(
            style=bar_style_pit_time,
            width=bar_width,
            count=self.total_slot,
        )
        for _pit_time, target in zip(self.leader_pit_time_set, self.bars_pit_leader):
            target.setText(f"{_pit_time:.0f}s")
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_pit_leader,
            row_index=0,
            right_to_left=layout_reversed,
        )

        # Player pit time row
        self.bars_pit_player = self.set_qlabel(
            style=bar_style_pit_time,
            width=bar_width,
            count=self.total_slot,
        )
        for _pit_time, target in zip(self.player_pit_time_set, self.bars_pit_player):
            target.setText(f"{_pit_time:.0f}s")
        self.bars_pit_player[0].setText("DIFF")
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_pit_player,
            row_index=3,
            right_to_left=layout_reversed,
        )

        # Leader lap row
        self.leader_lap_color = (
            self.set_qss(
                fg_color=self.wcfg["font_color_leader"],
                bg_color=self.wcfg["bkg_color_leader"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_near_start"],
                bg_color=self.wcfg["bkg_color_leader"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_near_finish"],
                bg_color=self.wcfg["bkg_color_leader"])
        )
        self.bars_lap_leader = self.set_qlabel(
            text=TEXT_PLACEHOLDER,
            style=self.leader_lap_color[0],
            width=bar_width,
            count=self.total_slot,
        )
        self.bars_lap_leader[0].setText("LDR")
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_lap_leader,
            row_index=1,
            right_to_left=layout_reversed,
        )

        # Player lap row
        self.player_lap_color = (
            self.set_qss(
                fg_color=self.wcfg["font_color_player"],
                bg_color=self.wcfg["bkg_color_player"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_near_start"],
                bg_color=self.wcfg["bkg_color_player"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_near_finish"],
                bg_color=self.wcfg["bkg_color_player"])
        )
        self.bars_lap_player = self.set_qlabel(
            text=TEXT_PLACEHOLDER,
            style=self.player_lap_color[0],
            width=bar_width,
            count=self.total_slot,
        )
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_lap_player,
            row_index=2,
            right_to_left=layout_reversed,
        )

        # Player refill row
        bar_style_refill = self.set_qss(
            fg_color=self.wcfg["font_color_refill"],
            bg_color=self.wcfg["bkg_color_refill"]
        )
        self.bars_refill = self.set_qlabel(
            text=TEXT_PLACEHOLDER,
            style=bar_style_refill,
            width=bar_width,
            count=self.total_slot,
        )
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_refill,
            row_index=4,
            right_to_left=layout_reversed,
        )

        # Player extra lap refill row
        if self.wcfg["show_extra_refilling"]:
            self.bars_refill_extra = self.set_qlabel(
                text=TEXT_PLACEHOLDER,
                style=bar_style_refill,
                width=bar_width,
                count=self.total_slot,
            )
            self.bars_refill_extra[0].setText(f"EX+{self.extra_laps}")
            self.set_grid_layout_table_row(
                layout=layout,
                targets=self.bars_refill_extra,
                row_index=5,
                right_to_left=layout_reversed,
            )

        # Last data
        self.relative_lap_offset = -MAX_SECONDS

    def timerEvent(self, event):
        """Update when vehicle on track"""
        is_lap_type_session = api.read.session.lap_type()
        in_formation = api.read.session.in_formation()
        energy_type = api.read.vehicle.max_virtual_energy()

        leader_index = minfo.vehicles.leaderIndex
        player_index = minfo.vehicles.playerIndex
        leader_lap_into = api.read.lap.progress(leader_index)
        player_lap_into = api.read.lap.progress()

        leader_laptime_pace = self.gen_leader_pace.send(leader_index)
        player_laptime_pace = minfo.delta.lapTimePace

        leader_valid = 0 < leader_laptime_pace < MAX_SECONDS
        player_valid = 0 < player_laptime_pace < MAX_SECONDS

        if is_lap_type_session and leader_valid and player_valid:
            laps_total = api.read.lap.maximum()
            leader_laps_left = laps_total - api.read.lap.completed_laps(leader_index) - leader_lap_into
            player_laps_left = laps_total - api.read.lap.completed_laps() - player_lap_into
            time_left = min(leader_laptime_pace, player_laptime_pace) * leader_laps_left
            laps_diff = player_laps_left - (time_left / player_laptime_pace)
        else:
            time_left = api.read.session.remaining()
            laps_diff = 0

        # Update last pit time slot
        self.leader_pit_time_set[-1] = minfo.vehicles.dataSet[leader_index].pitTimer.elapsed
        self.update_pit_time(self.bars_pit_leader[-1], self.leader_pit_time_set[-1])

        self.player_pit_time_set[-1] = minfo.vehicles.dataSet[player_index].pitTimer.elapsed
        self.update_pit_time(self.bars_pit_player[-1], self.player_pit_time_set[-1])

        # Get remaining fuel/energy & consumption
        consumption = minfo.energy if energy_type else minfo.fuel
        fuel_in_tank = 0 if self.wcfg["show_absolute_refilling"] else consumption.amountCurrent
        fuel_consumption = consumption.estimatedValidConsumption

        # Update lap progress difference & refill type
        self.update_energy_type(self.bars_refill[0], energy_type)
        self.update_race_type(self.bars_pit_leader[0], is_lap_type_session)
        lap_diff = calc.lap_progress_difference(leader_laptime_pace, player_laptime_pace)
        self.update_lap_int(self.bars_lap_player[0], lap_diff)

        # Update slots
        for index in range(1, self.total_slot):
            # Predicate player
            if not player_valid:
                lap_final, player_hi_range, full_laps_left = -MAX_SECONDS, 0, 0
            elif is_lap_type_session and index > 1:
                lap_final = calc.lap_progress_offset(  # relative lap offset based on 0s column
                    player_laptime_pace, self.relative_lap_offset, self.player_pit_time_set[index])
                player_hi_range = self.set_highlight_range(player_laptime_pace, lap_final % 1)
                full_laps_left = 0
            else:  # time-type race
                lap_into_offset = calc.lap_progress_offset(
                    player_laptime_pace, player_lap_into, self.player_pit_time_set[index])
                lap_remaining = calc.end_timer_laps_remain(
                    lap_into_offset, player_laptime_pace, time_left)
                lap_final = lap_remaining % 1
                player_hi_range = self.set_highlight_range(player_laptime_pace, lap_final)
                full_laps_left = calc.time_type_laps_remain(ceil(lap_remaining), player_lap_into)
            self.update_lap_player(self.bars_lap_player[index], lap_final, player_hi_range)

            if index == 1:  # store relative lap offset
                self.relative_lap_offset = lap_final

            # Player refill
            if (is_lap_type_session and index != 1
                or in_formation or not leader_valid or not player_valid):
                refill_player = -MAX_SECONDS
            else:
                refill_player = calc.total_fuel_needed(
                    full_laps_left,
                    fuel_consumption,
                    fuel_in_tank,
                )
            self.update_refill(self.bars_refill[index], refill_player, energy_type)

            # Player refill extra
            if self.wcfg["show_extra_refilling"]:
                if refill_player == -MAX_SECONDS:
                    refill_extra = -MAX_SECONDS
                else:
                    refill_extra = calc.total_fuel_needed(
                        full_laps_left + self.extra_laps,  # add extra laps
                        fuel_consumption,
                        fuel_in_tank,
                    )
                self.update_refill(self.bars_refill_extra[index], refill_extra, energy_type)

            # Predicate leader
            if not leader_valid or player_index == leader_index:
                leader_lap_final, leader_hi_range = -MAX_SECONDS, 0
            elif is_lap_type_session:
                # Lap-type final lap progress + lap difference from leader
                # Round up laps difference for relative final lap progress against player
                leader_lap_final = calc.lap_progress_offset(
                    leader_laptime_pace, ceil(laps_diff), self.leader_pit_time_set[index])
                leader_hi_range = self.set_highlight_range(
                    leader_laptime_pace, leader_lap_final % 1)
            else:  # time-type race
                leader_lap_into_offset = calc.lap_progress_offset(
                    leader_laptime_pace, leader_lap_into, self.leader_pit_time_set[index])
                leader_lap_remaining = calc.end_timer_laps_remain(
                    leader_lap_into_offset, leader_laptime_pace, time_left)
                leader_lap_final = leader_lap_remaining % 1
                leader_hi_range = self.set_highlight_range(
                    leader_laptime_pace, leader_lap_final)
            self.update_lap_leader(
                self.bars_lap_leader[index], leader_lap_final, leader_hi_range)

    # GUI update methods
    def update_lap_leader(self, target, data, highlight):
        """Leader final lap progress"""
        if target.last != data:
            target.last = data
            if data > -MAX_SECONDS:
                lap_text = f"{data:.{self.decimals_laps}f}"[:self.char_width]
            else:
                lap_text = TEXT_PLACEHOLDER
            target.setText(lap_text)
            target.updateStyle(self.leader_lap_color[highlight])

    def update_lap_player(self, target, data, highlight):
        """Player final lap progress"""
        if target.last != data:
            target.last = data
            if data > -MAX_SECONDS:
                lap_text = f"{data:.{self.decimals_laps}f}"[:self.char_width]
            else:
                lap_text = TEXT_PLACEHOLDER
            target.setText(lap_text)
            target.updateStyle(self.player_lap_color[highlight])

    def update_lap_int(self, target, data):
        """Lap progress difference"""
        if target.last != data:
            target.last = data
            if 0 < data:
                lap_text = f"{data:.{self.decimals_laps}f}"[:self.char_width]
            else:
                lap_text = TEXT_PLACEHOLDER
            target.setText(lap_text)

    def update_pit_time(self, target, data):
        """Leader or player pit time"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:.0f}s")

    def update_race_type(self, target, data):
        """Race type"""
        if target.last != data:
            target.last = data
            target.setText(RACELENGTH_TYPE_ID[data])

    def update_energy_type(self, target, data):
        """Energy type"""
        if target.last != data:
            target.last = data
            target.setText(ENERGY_TYPE_ID[data > 0])

    def update_refill(self, target, data, energy_type):
        """Player refill"""
        if target.last != data:
            target.last = data
            if data > -MAX_SECONDS:
                if not energy_type:
                    data = self.unit_fuel(data)
                refill_text = f"{data:{self.refill_sign}.{self.decimals_refill}f}"[:self.char_width].strip(".")
            else:
                refill_text = TEXT_PLACEHOLDER
            target.setText(refill_text)

    # Additional methods
    def create_pit_time_set(self, total_slot, suffix):
        """Create pit time set"""
        yield 0  # reserved first 2 slots
        yield 0
        for index in range(total_slot - 3):
            yield max(self.wcfg[f"prediction_{index + 1}_{suffix}_pit_time"], 0)
        yield 0  # reserved last slot

    def set_highlight_range(self, laptime_pace, lap_final):
        """Final lap highlight range"""
        if laptime_pace > 0:
            range_limit = laptime_pace / 3  # limit max range to 1/3 of laptime pace
            if lap_final < min(self.range_start, range_limit) / laptime_pace:
                return 1  # near start
            if lap_final > 1 - min(self.range_finish, range_limit) / laptime_pace:
                return -1  # near finish
        return 0


@generator_init
def calc_laptime_pace(samples: int = 6, margin: float = 5, laptime: float = MAX_SECONDS):
    """Calculate lap time pace for specific player"""
    laptime_pace = laptime
    laptime_margin = margin
    ema_factor = calc.ema_factor(samples)
    last_vehicle_class = ""
    last_lap_stime = -1.0
    is_pit_lap = 0  # whether pit in or pit out lap
    validating = 0.0

    while True:
        player_index = yield laptime_pace
        # Calculate laptime pace
        lap_stime = api.read.timing.start(player_index)
        veh_class = api.read.vehicle.class_name(player_index)
        is_pit_lap |= api.read.vehicle.in_pits(player_index)

        # Reset if vehicle class changes
        if last_vehicle_class != veh_class:
            last_vehicle_class = veh_class
            laptime_pace = api.read.timing.reference_laptime(player_index)

        if last_lap_stime != lap_stime:
            last_lap_stime = lap_stime
            validating = api.read.timing.elapsed()
            is_pit_lap = 0

        if validating:
            timer = api.read.timing.elapsed() - validating
            laptime_last = api.read.timing.last_laptime(player_index)
            if 1 < timer <= 10 and 0 < laptime_last:
                if not is_pit_lap:
                    if laptime_pace > laptime_last:
                        laptime_pace = laptime_last
                    else:
                        laptime_pace = min(
                            calc.exp_mov_avg(ema_factor, laptime_pace, laptime_last),
                            laptime_pace + laptime_margin,
                        )
                elif laptime_pace >= MAX_SECONDS:
                    laptime_pace = api.read.timing.reference_laptime(player_index)
                validating = 0
            elif timer > 10:  # switch off after 10s
                validating = 0

```

# File: tinypedal/widget/ride_height.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Ride height Widget
"""

from ..api_control import api
from ._base import Overlay
from ._painter import WheelGaugeBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        bar_gap = self.wcfg["bar_gap"]
        bar_gap_hori = self.wcfg["horizontal_gap"]
        bar_gap_vert = self.wcfg["vertical_gap"]
        layout = self.set_grid_layout(gap=bar_gap)
        self.set_primary_layout(layout=layout)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        bar_width = max(self.wcfg["bar_width"], 20)
        bar_height = int(font_m.capital + pady * 2)
        ride_height_offset = (
            self.wcfg["ride_height_offset_front_left"],
            self.wcfg["ride_height_offset_front_right"],
            self.wcfg["ride_height_offset_rear_left"],
            self.wcfg["ride_height_offset_rear_right"],
        )
        max_range = max(int(self.wcfg["ride_height_max_range"]), 10)

        # Caption
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_family=self.wcfg["font_name"],
                font_size=int(self.wcfg['font_size'] * self.wcfg['font_scale_caption']),
                font_weight=self.wcfg["font_weight"],
            )
            cap_bar = self.set_qlabel(
                text=self.wcfg["caption_text"],
                style=bar_style_desc,
                fixed_width=bar_width * 2 + bar_gap_hori,
            )
            self.set_primary_orient(
                target=cap_bar,
                column=0,
            )

        # Ride height
        layout_inner = self.set_grid_layout(gap_hori=bar_gap_hori, gap_vert=bar_gap_vert)
        self.rideh_color = (
            self.wcfg["bkg_color"],
            self.wcfg["warning_color_bottoming"],
        )
        self.bars_rideh = tuple(
            WheelGaugeBar(
                self,
                padding_x=padx,
                bar_width=bar_width,
                bar_height=bar_height,
                font_offset=font_offset,
                display_range=max_range,
                input_color=self.wcfg["highlight_color"],
                fg_color=self.wcfg["font_color"],
                bg_color=self.wcfg["bkg_color"],
                right_side=idx % 2,
            ) for idx in range(4)
        )
        for bar_rideh, offset in zip(self.bars_rideh, ride_height_offset):
            bar_rideh.offset = offset
        self.set_grid_layout_quad(
            layout=layout_inner,
            targets=self.bars_rideh,
        )
        self.set_primary_orient(
            target=layout_inner,
            column=1,
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        rideh_set = api.read.wheel.ride_height()
        for rideh, bar_rideh in zip(rideh_set, self.bars_rideh):
            self.update_rideh(bar_rideh, round(rideh))

    # GUI update methods
    def update_rideh(self, target, data):
        """Ride height"""
        if target.last != data:
            target.last = data
            target.bg_color = self.rideh_color[data < target.offset]
            target.update_input(data)

```

# File: tinypedal/widget/rivals.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Rivals Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import MAX_SECONDS, TEXT_NOLAPTIME, TEXT_PLACEHOLDER
from ..formatter import random_color_class, shorten_driver_name
from ..module_info import minfo
from ..units import set_unit_speed
from ..userfile.brand_logo import load_brand_logo_file
from ..userfile.heatmap import select_compound_symbol
from ._base import Overlay
from ._common import ExFrame


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap_vert=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.drv_width = max(int(self.wcfg["driver_name_width"]), 1)
        self.veh_width = max(int(self.wcfg["vehicle_name_width"]), 1)
        self.brd_width = max(int(self.wcfg["brand_logo_width"]), 1)
        self.brd_height = max(self.wcfg["font_size"], 1)
        self.cls_width = max(int(self.wcfg["class_width"]), 0)
        self.int_width = max(int(self.wcfg["time_interval_width"]), 1)
        self.int_decimals = max(int(self.wcfg["time_interval_decimal_places"]), 0)
        self.max_delta = calc.asym_max(int(self.wcfg["number_of_delta_laptime"]), 2, 5)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Max display players
        self.veh_range = 2

        # Empty dataset
        self.pixmap_brandlogo = {}
        self.row_visible = [True] * self.veh_range

        # Driver position
        if self.wcfg["show_position"]:
            bar_style_pos = self.set_qss(
                fg_color=self.wcfg["font_color_position"],
                bg_color=self.wcfg["bkg_color_position"]
            )
            self.bars_pos = self.set_qlabel(
                style=bar_style_pos,
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pos,
                column_index=self.wcfg["column_index_position"],
                hide_start=1,
            )
        # Driver position change
        if self.wcfg["show_position_change"]:
            self.bar_style_pgl = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_same"],
                    bg_color=self.wcfg["bkg_color_position_same"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_gain"],
                    bg_color=self.wcfg["bkg_color_position_gain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_loss"],
                    bg_color=self.wcfg["bkg_color_position_loss"])
            )
            self.bars_pgl = self.set_qlabel(
                style=self.bar_style_pgl[0],
                width=3 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pgl,
                column_index=self.wcfg["column_index_position_change"],
                hide_start=1,
            )
        # Driver name
        if self.wcfg["show_driver_name"]:
            bar_style_drv = self.set_qss(
                fg_color=self.wcfg["font_color_driver_name"],
                bg_color=self.wcfg["bkg_color_driver_name"]
            )
            self.bars_drv = self.set_qlabel(
                style=bar_style_drv,
                width=self.drv_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_drv,
                column_index=self.wcfg["column_index_driver"],
                hide_start=1,
            )
        # Vehicle name
        if self.wcfg["show_vehicle_name"]:
            bar_style_veh = self.set_qss(
                fg_color=self.wcfg["font_color_vehicle_name"],
                bg_color=self.wcfg["bkg_color_vehicle_name"]
            )
            self.bars_veh = self.set_qlabel(
                style=bar_style_veh,
                width=self.veh_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_veh,
                column_index=self.wcfg["column_index_vehicle"],
                hide_start=1,
            )
        # Brand logo
        if self.wcfg["show_brand_logo"]:
            bar_style_brd = self.set_qss(
                bg_color=self.wcfg["bkg_color_brand_logo"]
            )
            self.bars_brd = self.set_qlabel(
                style=bar_style_brd,
                width=self.brd_width,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_brd,
                column_index=self.wcfg["column_index_brand_logo"],
                hide_start=1,
            )
        # Time interval
        if self.wcfg["show_time_interval"]:
            self.bar_style_int = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_time_interval_behind"],
                    bg_color=self.wcfg["bkg_color_time_interval_behind"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_time_interval_ahead"],
                    bg_color=self.wcfg["bkg_color_time_interval_ahead"])
            )
            self.bars_int = self.set_qlabel(
                style=self.bar_style_int[0],
                width=self.int_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_int,
                column_index=self.wcfg["column_index_timeinterval"],
                hide_start=1,
            )
        # Vehicle laptime
        if self.wcfg["show_laptime"]:
            bar_style_lpt = self.set_qss(
                fg_color=self.wcfg["font_color_laptime"],
                bg_color=self.wcfg["bkg_color_laptime"]
            )
            self.bars_lpt = self.set_qlabel(
                style=bar_style_lpt,
                width=8 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_lpt,
                column_index=self.wcfg["column_index_laptime"],
                hide_start=1,
            )
        # Vehicle best laptime
        if self.wcfg["show_best_laptime"]:
            bar_style_blp = self.set_qss(
                fg_color=self.wcfg["font_color_best_laptime"],
                bg_color=self.wcfg["bkg_color_best_laptime"]
            )
            self.bars_blp = self.set_qlabel(
                style=bar_style_blp,
                width=8 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_blp,
                column_index=self.wcfg["column_index_best_laptime"],
                hide_start=1,
            )
        # Delta laptime
        if self.wcfg["show_delta_laptime"]:
            self.bar_style_dlt_delta = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_laptime_gain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_laptime_loss"]),
            )
            self.bars_dlt = tuple(
                self.set_delta_table(
                    width=4 * font_m.width,
                    columns=self.max_delta,
                    bar_padx=bar_padx // 2,
                ) for _ in range(self.veh_range)
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_dlt,
                column_index=self.wcfg["column_index_delta_laptime"],
                hide_start=1,
            )
        # Position in class
        if self.wcfg["show_position_in_class"]:
            self.bar_style_pic = self.set_qss(
                fg_color=self.wcfg["font_color_position_in_class"],
                bg_color=self.wcfg["bkg_color_position_in_class"]
            )
            self.bars_pic = self.set_qlabel(
                style=self.bar_style_pic,
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pic,
                column_index=self.wcfg["column_index_position_in_class"],
                hide_start=1,
            )
        # Vehicle class
        if self.wcfg["show_class"]:
            bar_style_cls = self.set_qss(
                fg_color=self.wcfg["font_color_class"],
                bg_color=self.wcfg["bkg_color_class"]
            )
            self.bars_cls = self.set_qlabel(
                style=bar_style_cls,
                width=self.cls_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_cls,
                column_index=self.wcfg["column_index_class"],
                hide_start=1,
            )
        # Vehicle in pit
        if self.wcfg["show_pit_status"]:
            self.pit_status_text = (
                "",
                self.wcfg["pit_status_text"],
                self.wcfg["garage_status_text"],
                self.wcfg["yellow_flag_status_text"],
            )
            self.bar_style_pit = (
                "",
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit"],
                    bg_color=self.wcfg["bkg_color_pit"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_garage"],
                    bg_color=self.wcfg["bkg_color_garage"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_yellow_flag"],
                    bg_color=self.wcfg["bkg_color_yellow_flag"])
            )
            self.bars_pit = self.set_qlabel(
                style=self.bar_style_pit[0],
                width=max(map(len, self.pit_status_text)) * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pit,
                column_index=self.wcfg["column_index_pitstatus"],
                hide_start=1,
            )
        # Tyre compound index
        if self.wcfg["show_tyre_compound"]:
            bar_style_tcp = self.set_qss(
                fg_color=self.wcfg["font_color_tyre_compound"],
                bg_color=self.wcfg["bkg_color_tyre_compound"]
            )
            self.bars_tcp = self.set_qlabel(
                style=bar_style_tcp,
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_tcp,
                column_index=self.wcfg["column_index_tyre_compound"],
                hide_start=1,
            )
        # Pitstop count
        if self.wcfg["show_pitstop_count"]:
            self.bar_style_psc = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_pitstop_count"],
                    bg_color=self.wcfg["bkg_color_pitstop_count"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit_request"],
                    bg_color=self.wcfg["bkg_color_pit_request"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_penalty_count"],
                    bg_color=self.wcfg["bkg_color_penalty_count"])
            )
            self.bars_psc = self.set_qlabel(
                style=self.bar_style_psc[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_psc,
                column_index=self.wcfg["column_index_pitstop_count"],
                hide_start=1,
            )
        # Remaining energy
        if self.wcfg["show_energy_remaining"]:
            self.bar_style_nrg = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_unavailable"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_high"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_low"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_critical"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"])
            )
            self.bars_nrg = self.set_qlabel(
                style=self.bar_style_nrg[0],
                width=3 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_nrg,
                column_index=self.wcfg["column_index_energy_remaining"],
                hide_start=1,
            )
        # Vehicle integrity
        if self.wcfg["show_vehicle_integrity"]:
            self.bar_style_dmg = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_full"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_high"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_low"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"])
            )
            self.bars_dmg = self.set_qlabel(
                style=self.bar_style_dmg[0],
                width=1 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_dmg,
                column_index=self.wcfg["column_index_vehicle_integrity"],
                hide_start=1,
            )
        # Stint laps
        if self.wcfg["show_stint_laps"]:
            bar_style_stl = self.set_qss(
                fg_color=self.wcfg["font_color_stint_laps"],
                bg_color=self.wcfg["bkg_color_stint_laps"]
            )
            self.bars_stl = self.set_qlabel(
                style=bar_style_stl,
                width=5 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_stl,
                column_index=self.wcfg["column_index_stint_laps"],
                hide_start=1,
            )
        # Speed trap
        if self.wcfg["show_speed_trap"]:
            self.unit_speed = set_unit_speed(self.cfg.units["speed_unit"])
            bar_style_spd = self.set_qss(
                fg_color=self.wcfg["font_color_speed_trap"],
                bg_color=self.wcfg["bkg_color_speed_trap"]
            )
            self.bars_spd = self.set_qlabel(
                style=bar_style_spd,
                width=5 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_spd,
                column_index=self.wcfg["column_index_speed_trap"],
                hide_start=1,
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        classes_list = minfo.relative.classes
        total_cls_idx = len(classes_list)
        player_idx = minfo.vehicles.playerIndex
        plr_veh_info = minfo.vehicles.dataSet[player_idx]
        in_race = api.read.session.in_race()

        if player_idx < total_cls_idx:
            rivals_list = classes_list[player_idx][4:6]
        else:
            rivals_list = -1,-1

        # Standings update
        for idx, rvl_idx in enumerate(rivals_list):

            # Get vehicle dataset
            if rvl_idx >= 0:
                self.row_visible[idx] = True
                state = 1
            elif not self.row_visible[idx]:
                continue  # skip if already empty
            else:
                self.row_visible[idx] = False
                state = 0

            # Get vehicle dataset
            veh_info = minfo.vehicles.dataSet[rvl_idx]
            # Driver position
            if self.wcfg["show_position"]:
                self.update_pos(self.bars_pos[idx], veh_info.positionOverall, state)
            # Driver position change
            if self.wcfg["show_position_change"]:
                if self.wcfg["show_position_change_in_class"]:
                    pos_diff = veh_info.qualifyInClass - veh_info.positionInClass
                else:
                    pos_diff = veh_info.qualifyOverall - veh_info.positionOverall
                self.update_pgl(self.bars_pgl[idx], pos_diff, state)
            # Driver name
            if self.wcfg["show_driver_name"]:
                self.update_drv(self.bars_drv[idx], veh_info.driverName, state)
            # Vehicle name
            if self.wcfg["show_vehicle_name"]:
                self.update_veh(self.bars_veh[idx], veh_info.vehicleName, state)
            # Brand logo
            if self.wcfg["show_brand_logo"]:
                self.update_brd(self.bars_brd[idx], veh_info.vehicleName, state)
            # Time interval
            if self.wcfg["show_time_interval"]:
                is_ahead = veh_info.positionOverall < plr_veh_info.positionOverall
                if is_ahead:
                    time_int = plr_veh_info.gapBehindNextInClass
                else:
                    time_int = veh_info.gapBehindNextInClass
                self.update_int(self.bars_int[idx], time_int, is_ahead, state)
            # Vehicle laptime
            if self.wcfg["show_laptime"]:
                if self.wcfg["show_pitstop_duration_while_requested_pitstop"] and plr_veh_info.pitRequested:
                    laptime = self.set_pittime(veh_info.inPit, veh_info.pitTimer.elapsed)
                elif in_race or self.wcfg["show_best_laptime"]:
                    if veh_info.pitTimer.pitting:
                        laptime = self.set_pittime(veh_info.inPit, veh_info.pitTimer.elapsed)
                    else:
                        laptime = self.set_laptime(veh_info.lastLapTime)
                else:
                    laptime = self.set_laptime(veh_info.bestLapTime)
                self.update_lpt(self.bars_lpt[idx], laptime, state)
            # Vehicle best laptime
            if self.wcfg["show_best_laptime"]:
                if in_race and self.wcfg["show_best_laptime_from_recent_laps_in_race"]:
                    laptime = veh_info.lapTimeHistory.best()
                else:
                    laptime = veh_info.bestLapTime
                self.update_blp(self.bars_blp[idx], laptime, state)
            # Position in class
            if self.wcfg["show_position_in_class"]:
                self.update_pic(self.bars_pic[idx], veh_info.positionInClass, veh_info.vehicleClass, state)
            # Vehicle class
            if self.wcfg["show_class"]:
                self.update_cls(self.bars_cls[idx], veh_info.vehicleClass, state)
            # Vehicle in pit
            if self.wcfg["show_pit_status"]:
                self.update_pit(self.bars_pit[idx], veh_info.inPit, veh_info.isYellow, state)
            # Tyre compound index
            if self.wcfg["show_tyre_compound"]:
                self.update_tcp(self.bars_tcp[idx], veh_info.tireCompoundFront, veh_info.tireCompoundRear, state)
            # Pitstop count
            if self.wcfg["show_pitstop_count"]:
                self.update_psc(self.bars_psc[idx], veh_info.numPitStops, veh_info.pitRequested, state)
            # Delta laptime
            if self.wcfg["show_delta_laptime"]:
                delta_laptime = tuple(veh_info.lapTimeHistory.delta(plr_veh_info.lapTimeHistory, self.max_delta))
                self.update_dlt(self.bars_dlt[idx], delta_laptime, state)
            # Remaining energy
            if self.wcfg["show_energy_remaining"]:
                self.update_nrg(self.bars_nrg[idx], veh_info.energyRemaining, state)
            # Vehicle integrity
            if self.wcfg["show_vehicle_integrity"]:
                self.update_dmg(self.bars_dmg[idx], veh_info.vehicleIntegrity, state)
            # Stint laps
            if self.wcfg["show_stint_laps"]:
                self.update_stl(self.bars_stl[idx], veh_info.currentStintLaps, veh_info.estimatedStintLaps, state)
            # Speed trap
            if self.wcfg["show_speed_trap"]:
                self.update_spd(self.bars_spd[idx], veh_info.speedTrap.speed, state)

    # GUI update methods
    def update_pos(self, target, *data):
        """Driver position"""
        if target.last != data:
            target.last = data
            target.setText(f"{data[0]:02d}")
            self.toggle_visibility(target, data[-1])

    def update_pgl(self, target, *data):
        """Driver position change (gain/loss)"""
        if target.last != data:
            target.last = data
            pos_diff = data[0]
            if pos_diff > 0:
                text = f"â–²{pos_diff: >2}"
                color_index = 1
            elif pos_diff < 0:
                text = f"â–¼{-pos_diff: >2}"
                color_index = 2
            else:
                text = "- 0"
                color_index = 0
            target.setText(text)
            target.updateStyle(self.bar_style_pgl[color_index])
            self.toggle_visibility(target, data[-1])

    def update_drv(self, target, *data):
        """Driver name"""
        if target.last != data:
            target.last = data
            if self.wcfg["driver_name_shorten"]:
                text = shorten_driver_name(data[0])
            else:
                text = data[0]
            if self.wcfg["driver_name_uppercase"]:
                text = text.upper()
            if self.wcfg["driver_name_align_center"]:
                text = text[:self.drv_width]
            else:
                text = text[:self.drv_width].ljust(self.drv_width)
            target.setText(text)
            self.toggle_visibility(target, data[-1])

    def update_veh(self, target, *data):
        """Vehicle name"""
        if target.last != data:
            target.last = data
            if self.wcfg["show_vehicle_brand_as_name"]:
                text = self.cfg.user.brands.get(data[0], data[0])
            else:
                text = data[0]
            if self.wcfg["vehicle_name_uppercase"]:
                text = text.upper()
            if self.wcfg["vehicle_name_align_center"]:
                text = text[:self.veh_width]
            else:
                text = text[:self.veh_width].ljust(self.veh_width)
            target.setText(text)
            self.toggle_visibility(target, data[-1])

    def update_brd(self, target, *data):
        """Brand logo"""
        if target.last != data:
            target.last = data
            target.setPixmap(self.set_brand_logo(self.cfg.user.brands.get(data[0], data[0])))
            self.toggle_visibility(target, data[-1])

    def update_int(self, target, *data):
        """Time interval"""
        if target.last != data:
            target.last = data
            if self.wcfg["time_interval_align_center"]:
                text = self.int_to_next(data[0], data[1])[:self.int_width].strip(".")
            else:
                text = self.int_to_next(data[0], data[1])[:self.int_width].strip(".").rjust(self.int_width)
            target.setText(text)
            target.updateStyle(self.bar_style_int[data[1]])
            self.toggle_visibility(target, data[-1])

    def update_lpt(self, target, *data):
        """Vehicle laptime"""
        if target.last != data:
            target.last = data
            target.setText(data[0])
            self.toggle_visibility(target, data[-1])

    def update_blp(self, target, *data):
        """Vehicle best laptime"""
        if target.last != data:
            target.last = data
            target.setText(self.set_laptime(data[0]))
            self.toggle_visibility(target, data[-1])

    def update_dlt(self, target, *data):
        """Vehicle delta laptime"""
        if target.last != data:
            target.last = data
            for bar_delta, delta in zip(target.bar_set, data[0]):
                if -999 < delta < 0:  # player time gain
                    text = f"{-delta:.1f}"[:3].strip(".")
                    color_index = 1
                elif 0 < delta < 999:  # player time loss
                    text = f"{delta:.1f}"[:3].strip(".")
                    color_index = 2
                elif delta == 0:
                    text = "0.0"
                    color_index = 0
                else:
                    text = "-.-"
                    color_index = 0
                bar_delta.setText(text)
                bar_delta.updateStyle(self.bar_style_dlt_delta[color_index])
            self.toggle_visibility(target, data[-1])

    def update_pic(self, target, *data):
        """Position in class"""
        if target.last != data:
            target.last = data
            if self.wcfg["show_class_style_for_position_in_class"]:
                style = f"color:{self.wcfg['font_color_position_in_class']};background:{self.set_class_style(data[1])[1]};"
            else:
                style = self.bar_style_pic
            target.setText(f"{data[0]:02d}")
            target.updateStyle(style)
            self.toggle_visibility(target, data[-1])

    def update_cls(self, target, *data):
        """Vehicle class"""
        if target.last != data:
            target.last = data
            text, bg_color = self.set_class_style(data[0])
            target.setText(text[:self.cls_width])
            target.updateStyle(f"color:{self.wcfg['font_color_class']};background:{bg_color};")
            self.toggle_visibility(target, data[-1])

    def update_pit(self, target, *data):
        """Vehicle in pit"""
        if target.last != data:
            target.last = data
            index = data[0]
            if data[1] and index == 0:  # show yellow flag outside pits
                index = 3
            target.setText(self.pit_status_text[index])
            target.updateStyle(self.bar_style_pit[index])
            self.toggle_visibility(target, data[-1])

    def update_tcp(self, target, *data):
        """Tyre compound index"""
        if target.last != data:
            target.last = data
            target.setText(f"{select_compound_symbol(data[0])}{select_compound_symbol(data[1])}")
            self.toggle_visibility(target, data[-1])

    def update_psc(self, target, *data):
        """Pitstop count"""
        if target.last != data:
            target.last = data
            if data[0] < 0:
                color_index = 2
            elif self.wcfg["show_pit_request"] and data[1]:
                color_index = 1
            else:
                color_index = 0
            if data[0] == 0:
                text = TEXT_PLACEHOLDER
            else:
                text = f"{data[0]}"
            target.setText(text)
            target.updateStyle(self.bar_style_psc[color_index])
            self.toggle_visibility(target, data[-1])

    def update_nrg(self, target, *data):
        """Remaining energy"""
        if target.last != data:
            target.last = data
            ve = data[0]
            if ve <= -1:  # unavailable
                color_index = 0
            elif ve <= 0.1:  # 10% remaining
                color_index = 3
            elif ve <= 0.3:  # 30% remaining
                color_index = 2
            else:
                color_index = 1
            if ve <= -1:
                text = "---"
            else:
                text = f"{ve:03.0%}"[:3]
            target.setText(text)
            target.updateStyle(self.bar_style_nrg[color_index])
            self.toggle_visibility(target, data[-1])

    def update_dmg(self, target, *data):
        """Vehicle integrity"""
        if target.last != data:
            target.last = data
            hp = int(data[0] * 10)
            if hp >= 10:  # full integrity
                color_index = 0
            elif hp <= 5:  # low
                color_index = 2
            else:  # high
                color_index = 1
            if hp >= 10:
                text = TEXT_PLACEHOLDER
            else:
                text = f"{hp:d}"
            target.setText(text)
            target.updateStyle(self.bar_style_dmg[color_index])
            self.toggle_visibility(target, data[-1])

    def update_stl(self, target, *data):
        """Stint laps"""
        if target.last != data:
            target.last = data
            stint_laps_done = data[0]
            stint_laps_est = data[1]
            if stint_laps_done <= 0:
                text_done = "--"
            else:
                text_done = f"{stint_laps_done:02.0f}"
            if stint_laps_est <= 0:
                text_est = "--"
            else:
                text_est = f"{stint_laps_est // 1:02.0f}"
            target.setText(f"{text_done}/{text_est}")
            self.toggle_visibility(target, data[-1])

    def update_spd(self, target, *data):
        """Speed trap"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.unit_speed(data[0]):.3f}"[:5])
            self.toggle_visibility(target, data[-1])

    # Additional methods
    @staticmethod
    def toggle_visibility(target, state):
        """Hide bar if unavailable"""
        target.setHidden(not state)

    def set_brand_logo(self, brand_name: str):
        """Set brand logo"""
        if brand_name not in self.pixmap_brandlogo:  # load & cache logo
            self.pixmap_brandlogo[brand_name] = load_brand_logo_file(
                filepath=self.cfg.path.brand_logo,
                filename=brand_name,
                max_width=self.brd_width,
                max_height=self.brd_height,
            )
        return self.pixmap_brandlogo[brand_name]

    def set_class_style(self, class_name: str):
        """Compare vehicle class name with user defined dictionary"""
        style = self.cfg.user.classes.get(class_name)
        if style is not None:
            return style["alias"], style["color"]
        if class_name:
            return class_name, random_color_class(class_name)
        return class_name, self.wcfg["bkg_color_class"]

    @staticmethod
    def set_laptime(laptime):
        """Set lap time"""
        if 0 < laptime < MAX_SECONDS:
            return calc.sec2laptime_full(laptime)[:8]
        return TEXT_NOLAPTIME

    @staticmethod
    def set_pittime(inpit, pit_time):
        """Set lap time"""
        if 0 < pit_time < MAX_SECONDS:
            return f"{'PIT' if inpit else 'OUT'}{pit_time: >5.1f}"[:8]
        return TEXT_NOLAPTIME

    def int_to_next(self, gap_behind_class, is_ahead):
        """Interval to next"""
        if isinstance(gap_behind_class, int):
            return f"{'+-'[is_ahead]}{gap_behind_class:.0f}L"
        return f"{'+-'[is_ahead]}{gap_behind_class:.{self.int_decimals}f}"

    def set_delta_table(self, width: int, columns: int, bar_padx: int) -> ExFrame:
        """Set delta laptime table"""
        bar_temp = ExFrame(self)
        layout = self.set_grid_layout()
        layout.setContentsMargins(bar_padx, 0, bar_padx, 0)
        bar_temp.setLayout(layout)
        bar_temp.updateStyle(self.set_qss(bg_color=self.wcfg["bkg_color_delta_laptime"]))
        bar_temp.bar_set = self.set_qlabel(
            fixed_width=width,
            count=columns,
        )
        self.set_grid_layout_table_row(
            layout=layout,
            targets=bar_temp.bar_set,
            right_to_left=self.wcfg["show_inverted_delta_laptime_layout"],
        )
        return bar_temp

```

# File: tinypedal/widget/roll_angle.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Roll angle Widget
"""

from functools import partial

from .. import calculation as calc
from ..api_control import api
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.degree_sign_text = "Â°" if self.wcfg["show_degree_and_percentage_sign"] else ""
        self.percent_sign_text = "%" if self.wcfg["show_degree_and_percentage_sign"] else ""
        self.decimals = max(int(self.wcfg["decimal_places"]), 1)

        if self.wcfg["layout"] == 0:
            prefix_just = max(
                len(self.wcfg["prefix_roll_angle_front"]),
                len(self.wcfg["prefix_roll_angle_rear"]),
                len(self.wcfg["prefix_roll_angle_difference"]),
                len(self.wcfg["prefix_roll_angle_ratio"]),
            )
        else:
            prefix_just = 0

        self.prefix_rollf = self.wcfg["prefix_roll_angle_front"].ljust(prefix_just)
        self.prefix_rollr = self.wcfg["prefix_roll_angle_rear"].ljust(prefix_just)
        self.prefix_rolld = self.wcfg["prefix_roll_angle_difference"].ljust(prefix_just)
        self.prefix_ratio = self.wcfg["prefix_roll_angle_ratio"].ljust(prefix_just)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Roll angle front
        bar_style_rollf = self.set_qss(
            fg_color=self.wcfg["font_color_roll_angle_front"],
            bg_color=self.wcfg["bkg_color_roll_angle_front"],       
        )
        text_rollf = self.format_roll(0, self.prefix_rollf)
        self.bar_rollf = self.set_qlabel(
            text=text_rollf,
            style=bar_style_rollf,
            width=font_m.width * len(text_rollf) + bar_padx,
            last=0,
        )
        self.set_primary_orient(
            target=self.bar_rollf,
            column=self.wcfg["column_index_roll_angle_front"],
        )

        # Roll angle rear
        bar_style_rollr = self.set_qss(
            fg_color=self.wcfg["font_color_roll_angle_rear"],
            bg_color=self.wcfg["bkg_color_roll_angle_rear"],
        )
        text_rollr = self.format_roll(0, self.prefix_rollr)
        self.bar_rollr = self.set_qlabel(
            text=text_rollr,
            style=bar_style_rollr,
            width=font_m.width * len(text_rollr) + bar_padx,
            last=0,
        )
        self.set_primary_orient(
            target=self.bar_rollr,
            column=self.wcfg["column_index_roll_angle_rear"],
        )

        self.calc_ema_roll = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.wcfg["roll_angle_smoothing_samples"])
        )

        # Roll angle difference
        if self.wcfg["show_roll_angle_difference"]:
            bar_style_rolld = self.set_qss(
                fg_color=self.wcfg["font_color_roll_angle_difference"],
                bg_color=self.wcfg["bkg_color_roll_angle_difference"],
            )
            text_rolld = self.format_roll(0, self.prefix_rolld)
            self.bar_rolld = self.set_qlabel(
                text=text_rolld,
                style=bar_style_rolld,
                width=font_m.width * len(text_rolld) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_rolld,
                column=self.wcfg["column_index_roll_angle_difference"],
            )

        # Roll angle ratio
        if self.wcfg["show_roll_angle_ratio"]:
            bar_style_ratio = self.set_qss(
                fg_color=self.wcfg["font_color_roll_angle_ratio"],
                bg_color=self.wcfg["bkg_color_roll_angle_ratio"],
            )
            text_ratio = self.format_ratio(0, self.prefix_ratio)
            self.bar_ratio = self.set_qlabel(
                text=text_ratio,
                style=bar_style_ratio,
                width=font_m.width * len(text_ratio) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_ratio,
                column=self.wcfg["column_index_roll_angle_ratio"],
            )
            self.calc_ema_ratio = partial(
                calc.exp_mov_avg,
                calc.ema_factor(self.wcfg["roll_angle_ratio_smoothing_samples"])
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        height_fl, height_fr, height_rl, height_rr = api.read.wheel.ride_height()

        # Roll angle
        rollf_deg = calc.slope_angle(height_fr - height_fl, self.wcfg["wheel_track_front"])
        rollr_deg = calc.slope_angle(height_rr - height_rl, self.wcfg["wheel_track_rear"])

        ema_rollf_deg = self.calc_ema_roll(self.bar_rollf.last, rollf_deg)
        ema_rollr_deg = self.calc_ema_roll(self.bar_rollr.last, rollr_deg)

        self.update_roll(self.bar_rollf, ema_rollf_deg, self.prefix_rollf)
        self.update_roll(self.bar_rollr, ema_rollr_deg, self.prefix_rollr)

        # Roll angle difference
        if self.wcfg["show_roll_angle_difference"]:
            self.update_roll(self.bar_rolld, ema_rollr_deg - ema_rollf_deg, self.prefix_rolld)

        # Roll angle ratio
        if self.wcfg["show_roll_angle_ratio"]:
            rollf_deg = int(rollf_deg * 100)
            rollr_deg = int(rollr_deg * 100)
            if rollf_deg < 0 > rollr_deg or rollf_deg > 0 < rollr_deg:
                ratio = calc.part_to_whole_ratio(abs(rollf_deg), abs(rollf_deg + rollr_deg), 50)
            else:
                ratio = 50
            ema_ratio = self.calc_ema_ratio(self.bar_ratio.last, ratio)
            self.update_ratio(self.bar_ratio, ema_ratio, self.prefix_ratio)

    # GUI update methods
    def update_roll(self, target, data, prefix):
        """Roll angle"""
        if target.last != data:
            target.last = data
            target.setText(self.format_roll(data, prefix))

    def update_ratio(self, target, data, prefix):
        """Roll angle ratio"""
        if target.last != data:
            target.last = data
            target.setText(self.format_ratio(data, prefix))

    def format_roll(self, angle, prefix):
        """Format roll angle"""
        roll_angle = f"{angle:+.{self.decimals}f}"[:self.decimals + 3]
        return f"{prefix}{roll_angle}{self.degree_sign_text}"

    def format_ratio(self, angle, prefix):
        """Format roll angle ratio"""
        roll_angle = f"{angle:.{self.decimals + 1}f}"[:self.decimals + 3]
        return f"{prefix}{roll_angle}{self.percent_sign_text}"

```

# File: tinypedal/widget/rpm_led.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
RPM LED Widget
"""

from PySide2.QtCore import QRect, Qt
from PySide2.QtGui import QBrush, QPainter, QPen

from ..api_control import api
from ..const_common import FLOAT_INF
from ._base import Overlay
from ._common import WarningFlash


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config variable
        self.double_side_led = self.wcfg["enable_double_side_led"]
        self.display_margin = max(int(self.wcfg["display_margin"]), 0)
        self.inner_gap = max(int(self.wcfg["inner_gap"]), 0)

        self.led_width = max(int(self.wcfg["led_width"]), 1)
        self.led_height = max(int(self.wcfg["led_height"]), 1)
        self.led_offset = self.led_width + self.inner_gap
        self.led_radius = max(self.wcfg["led_radius"], 0)
        self.max_led = max(int(self.wcfg["number_of_led"]), 3)

        display_width = self.led_width * self.max_led + self.inner_gap * (self.max_led - 1)
        display_height = self.led_height + self.display_margin * 2

        if self.double_side_led:
            display_width += display_width + self.inner_gap + self.display_margin * 2
        else:
            display_width += self.display_margin * 2

        self.display_width = display_width

        # Config canvas
        self.resize(display_width, display_height)

        self.rect_led = QRect(0, 0, self.led_width, self.led_height)
        self.rect_background = QRect(0, 0, display_width, display_height)

        self.pen_led = QPen()
        self.pen_led.setColor(self.wcfg["led_outline_color"])
        self.pen_led.setWidth(self.wcfg["led_outline_width"])

        self.brush_led = (
            QBrush(self.wcfg["rpm_color_off"], Qt.SolidPattern),
            QBrush(self.wcfg["rpm_color_low"], Qt.SolidPattern),
            QBrush(self.wcfg["rpm_color_safe"], Qt.SolidPattern),
            QBrush(self.wcfg["rpm_color_redline"], Qt.SolidPattern),
            QBrush(self.wcfg["rpm_color_critical"], Qt.SolidPattern),
            QBrush(self.wcfg["rpm_color_over_rev"], Qt.SolidPattern),
            QBrush(self.wcfg["speed_limiter_flash_color"], Qt.SolidPattern),
        )

        if self.wcfg["show_speed_limiter_flash"]:
            self.warn_flash_limiter = WarningFlash(
                self.wcfg["speed_limiter_flash_interval"],
                self.wcfg["speed_limiter_flash_interval"],
                FLOAT_INF,
            )

        # Last data
        self.flicker = False
        self.limiter = 0
        self.rpm_max = 0
        self.rpm_low = 0
        self.rpm_safe = 0
        self.rpm_redline = 0
        self.rpm_critical = 0
        self.rpm_overrev = 0
        self.rpm_scale = 0
        self.rpm = -1
        self.gear_max = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        update_later = False

        # RPM reference
        rpm_max = api.read.engine.rpm_max()
        if self.rpm_max != rpm_max:
            self.rpm_max = rpm_max
            self.rpm_low = rpm_max * self.wcfg["rpm_multiplier_low"]
            # offset by rpm low
            self.rpm_safe = rpm_max * self.wcfg["rpm_multiplier_safe"] - self.rpm_low
            self.rpm_redline = rpm_max * self.wcfg["rpm_multiplier_redline"] - self.rpm_low
            self.rpm_critical = rpm_max * self.wcfg["rpm_multiplier_critical"] - self.rpm_low
            self.rpm_overrev = rpm_max * self.wcfg["rpm_multiplier_over_rev"] - self.rpm_low
            # Limit rpm range in low to critical
            self.rpm_scale = self.max_led / max(self.rpm_critical, 0.0000001)
            self.gear_max = api.read.engine.gear_max()

        # Update RPM
        rpm = api.read.engine.rpm()
        if self.rpm != rpm:
            self.rpm = rpm
            update_later = True

        # Update limiter state
        if self.wcfg["show_speed_limiter_flash"]:
            self.limiter = api.read.switch.speed_limiter()
            if self.limiter:
                update_later = True

        if update_later:
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)

        if self.wcfg["show_background"]:
            painter.fillRect(self.rect_background, self.wcfg["bkg_color"])

        if self.wcfg["led_outline_width"] > 0:
            painter.setPen(self.pen_led)
        else:
            painter.setPen(Qt.NoPen)

        rpm = self.rpm - self.rpm_low

        # Set flicker state
        if self.wcfg["show_speed_limiter_flash"] and self.limiter:
            self.flicker = self.warn_flash_limiter.state(True)
        elif (
            self.wcfg["show_rpm_flickering_above_critical"]
            and rpm >= self.rpm_critical
            and api.read.engine.gear() < self.gear_max
        ):
            self.flicker = not self.flicker
        else:
            self.flicker = False

        self.draw_rpm_led(
            painter,
            rpm,
            self.rpm_scale,
            self.display_margin,
            self.display_margin,
            self.led_offset,
        )

        if self.double_side_led:
            self.draw_rpm_led(
                painter,
                rpm,
                self.rpm_scale,
                self.display_width - self.led_width - self.display_margin,
                self.display_margin,
                -self.led_offset,
            )

    def draw_rpm_led(self, painter, rpm, rpm_scale, x_offset, y_offset, led_offset):
        """Draw RPM LED"""
        rpm_scaled = rpm * rpm_scale

        for index in range(self.max_led):
            # Full
            if self.limiter:
                painter.setBrush(self.brush_led[6 if self.flicker else 0])
            elif rpm >= self.rpm_overrev:
                painter.setBrush(self.brush_led[0 if self.flicker else 5])  # over rev
            elif rpm >= self.rpm_critical:
                painter.setBrush(self.brush_led[0 if self.flicker else 4])  # critical
            # Progressive
            elif index < rpm_scaled:
                painter.setBrush(self.color_rpm_led(index / rpm_scale))
            # Off
            else:
                painter.setBrush(self.brush_led[0])

            painter.translate(x_offset, y_offset)
            if self.led_radius:
                painter.drawRoundedRect(self.rect_led, self.led_radius, self.led_radius)
            else:
                painter.drawRect(self.rect_led)
            painter.resetTransform()

            x_offset += led_offset

    def color_rpm_led(self, rpm: float):
        """Set RPM LED color"""
        if rpm < 0:
            return self.brush_led[0]  # off
        if rpm < self.rpm_safe:
            return self.brush_led[1]  # low
        if rpm < self.rpm_redline:
            return self.brush_led[2]  # safe
        if rpm < self.rpm_critical:
            return self.brush_led[3]  # redline
        return self.brush_led[0]

```

# File: tinypedal/widget/sectors.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Sectors Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import (
    MAX_SECONDS,
    PREV_SECTOR_INDEX,
    SECTOR_ABBR_ID,
    TEXT_NOLAPTIME,
)
from ..module_info import minfo
from ..validator import valid_sectors
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        bar_gap = self.wcfg["bar_gap"]
        layout = self.set_grid_layout(gap=bar_gap)
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        if self.wcfg["target_laptime"] == "Theoretical":
            self.prefix_best = "TB"
        else:
            self.prefix_best = "PB"

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Target time
        layout_laptime = self.set_grid_layout(gap=bar_gap)
        self.bar_style_time_target = (
            self.set_qss(
                fg_color=self.wcfg["font_color_time_loss"],
                bg_color=self.wcfg["bkg_color_target_time"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_time_gain"],
                bg_color=self.wcfg["bkg_color_target_time"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_target_time"],
                bg_color=self.wcfg["bkg_color_target_time"])
        )
        self.bar_time_target = self.set_qlabel(
            text=f"{self.prefix_best}{TEXT_NOLAPTIME: >9}",
            style=self.bar_style_time_target[2],
            width=font_m.width * 11 + bar_padx,
        )
        layout_laptime.addWidget(self.bar_time_target, 0, 0)

        # Current time
        bar_style_time_curr = self.set_qss(
            fg_color=self.wcfg["font_color_current_time"],
            bg_color=self.wcfg["bkg_color_current_time"]
        )
        self.bar_time_curr = self.set_qlabel(
            text=f"{TEXT_NOLAPTIME: >11}",
            style=bar_style_time_curr,
            width=font_m.width * 11 + bar_padx,
        )
        layout_laptime.addWidget(self.bar_time_curr, 0, 1)

        # Gap to best sector time
        layout_sector = self.set_grid_layout(gap=bar_gap)
        self.bar_style_gap = (
            self.set_qss(
                fg_color=self.wcfg["font_color_sector_highlighted"],
                bg_color=self.wcfg["bkg_color_time_loss"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_sector_highlighted"],
                bg_color=self.wcfg["bkg_color_time_gain"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_sector"],
                bg_color=self.wcfg["bkg_color_sector"]),
        )
        self.bars_time_gap = self.set_qlabel(
            style=self.bar_style_gap[2],
            width=font_m.width * 7 + bar_padx,
            count=3,
        )
        for idx, bar_time_gap in enumerate(self.bars_time_gap):
            bar_time_gap.setText(SECTOR_ABBR_ID[idx])
            layout_sector.addWidget(bar_time_gap, 0, idx)

        # Set layout
        if self.wcfg["layout"] == 0:  # sector time above delta
            layout.addLayout(layout_laptime, 0, 1)
            layout.addLayout(layout_sector, 1, 1)
        else:
            layout.addLayout(layout_laptime, 1, 1)
            layout.addLayout(layout_sector, 0, 1)

        # Last data
        self.last_sector_idx = -1  # previous recorded sector index value
        self.last_target_time = MAX_SECONDS
        self.freeze_timer_start = 0  # sector timer start

    def post_update(self):
        self.last_sector_idx = -1
        self.last_target_time = MAX_SECONDS
        self.freeze_timer_start = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Read Sector data
        lap_stime = api.read.timing.start()
        lap_etime = api.read.timing.elapsed()
        laptime_curr = max(lap_etime - lap_stime, 0)
        data = minfo.sectors

        # Triggered when sector changed
        if self.last_sector_idx != data.sectorIndex:

            # Activate freeze timer, reset sector index
            self.freeze_timer_start = lap_etime
            self.last_sector_idx = data.sectorIndex

            # Previous sector index
            prev_s_idx = PREV_SECTOR_INDEX[data.sectorIndex]

            # Update (time target) best sector text
            if self.wcfg["target_laptime"] == "Theoretical":
                self.last_target_time = calc.accumulated_sum(data.sectorBestTB, data.sectorIndex)
                self.update_time_target_gap(data.deltaSectorBestTB, prev_s_idx)
                if not data.noDeltaSector:
                    self.update_sector_gap(
                        self.bars_time_gap[prev_s_idx],
                        data.deltaSectorBestTB[prev_s_idx],
                    )
            else:
                self.last_target_time = calc.accumulated_sum(data.sectorBestPB, data.sectorIndex)
                self.update_time_target_gap(data.deltaSectorBestPB, prev_s_idx)
                if not data.noDeltaSector:
                    self.update_sector_gap(
                        self.bars_time_gap[prev_s_idx],
                        data.deltaSectorBestPB[prev_s_idx],
                    )

            # Freeze previous sector time
            if valid_sectors(data.sectorPrev[prev_s_idx]):  # valid previous sector time
                sum_sectortime = calc.accumulated_sum(data.sectorPrev, prev_s_idx)
                if sum_sectortime < MAX_SECONDS:  # bypass invalid value
                    laptime_curr = sum_sectortime
            self.update_time_curr(self.bar_time_curr, laptime_curr, prev_s_idx)

        # Update freeze timer
        if self.freeze_timer_start:
            # Stop freeze timer after duration
            freeze_time = self.freeze_duration(data.sectorPrev[data.sectorIndex])
            if lap_etime - self.freeze_timer_start >= freeze_time:
                self.freeze_timer_start = 0  # stop timer
                # Update target time
                self.update_time_target(self.last_target_time)
                # Restore best sector time when cross finish line
                if data.sectorIndex == 0:
                    if self.wcfg["target_laptime"] == "Theoretical":
                        self.restore_best_sector(data.sectorBestTB)
                    else:
                        self.restore_best_sector(data.sectorBestPB)
        else:
            # Update current sector time
            self.update_time_curr(self.bar_time_curr, laptime_curr, data.sectorIndex)

    # GUI update methods
    def update_sector_gap(self, target, data):
        """Gap to best sector time"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:+.3f}"[:7])
            target.updateStyle(self.bar_style_gap[data < 0])

    def update_time_curr(self, target, data, prev_s_idx):
        """Current sector time text"""
        if target.last != data:
            target.last = data
            target.setText(f"{SECTOR_ABBR_ID[prev_s_idx]}{calc.sec2laptime(data)[:8]: >9}")

    def update_time_target(self, seconds):
        """Target sector time text"""
        if seconds < MAX_SECONDS:  # bypass invalid value
            text_laptime = f"{self.prefix_best}{calc.sec2laptime(seconds)[:8]: >9}"
        else:
            text_laptime = f"{self.prefix_best}{TEXT_NOLAPTIME: >9}"
        self.bar_time_target.setText(text_laptime)
        self.bar_time_target.updateStyle(self.bar_style_time_target[2])

    def update_time_target_gap(self, delta_sec, sec_index):
        """Target sector time gap"""
        sector_gap = calc.accumulated_sum(delta_sec, sec_index)
        self.bar_time_target.setText(f"{self.prefix_best}{sector_gap: >+9.3f}"[:11])
        self.bar_time_target.updateStyle(self.bar_style_time_target[sector_gap < 0])

    def restore_best_sector(self, sector_time):
        """Restore best sector time"""
        for idx, bar_time_gap in enumerate(self.bars_time_gap):
            if valid_sectors(sector_time[idx]):
                text_s = f"{sector_time[idx]:.3f}"[:7]
            else:
                text_s = SECTOR_ABBR_ID[idx]
            bar_time_gap.setText(text_s)
            bar_time_gap.updateStyle(self.bar_style_gap[2])

    # Sector data update methods
    def freeze_duration(self, seconds):
        """Set freeze duration"""
        if valid_sectors(seconds):
            max_freeze = seconds * 0.5
        else:
            max_freeze = 3
        return calc.zero_max(self.wcfg["freeze_duration"], max_freeze)

```

# File: tinypedal/widget/session.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Session Widget
"""

from time import strftime

from .. import calculation as calc
from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.session_name_list = (
            self.wcfg["session_text_testday"],
            self.wcfg["session_text_practice"],
            self.wcfg["session_text_qualify"],
            self.wcfg["session_text_warmup"],
            self.wcfg["session_text_race"],
        )
        self.prefix_estimated_laps = self.wcfg["prefix_estimated_laps"]

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Session name
        if self.wcfg["show_session_name"]:
            text_session_name = self.session_name_list[0]
            bar_style_session_name = self.set_qss(
                fg_color=self.wcfg["font_color_session_name"],
                bg_color=self.wcfg["bkg_color_session_name"]
            )
            self.bar_session_name = self.set_qlabel(
                text=text_session_name,
                style=bar_style_session_name,
                width=font_m.width * max(map(len, self.session_name_list)) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_session_name,
                column=self.wcfg["column_index_session_name"],
            )

        # System clock
        if self.wcfg["show_system_clock"]:
            text_system_clock = strftime(self.wcfg["system_clock_format"])
            bar_style_system_clock = self.set_qss(
                fg_color=self.wcfg["font_color_system_clock"],
                bg_color=self.wcfg["bkg_color_system_clock"]
            )
            self.bar_system_clock = self.set_qlabel(
                text=text_system_clock,
                style=bar_style_system_clock,
                width=font_m.width * len(text_system_clock) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_system_clock,
                column=self.wcfg["column_index_system_clock"],
            )

        # Session time
        if self.wcfg["show_session_time"]:
            text_session_time = calc.sec2sessiontime(0)
            bar_style_session_time = self.set_qss(
                fg_color=self.wcfg["font_color_session_time"],
                bg_color=self.wcfg["bkg_color_session_time"]
            )
            self.bar_session_time = self.set_qlabel(
                text=text_session_time,
                style=bar_style_session_time,
                width=font_m.width * len(text_session_time) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_session_time,
                column=self.wcfg["column_index_session_time"],
            )

        # Estimated laps
        if self.wcfg["show_estimated_laps"]:
            text_estimated_laps = f"{self.prefix_estimated_laps}-.---"
            bar_style_estimated_laps = self.set_qss(
                fg_color=self.wcfg["font_color_estimated_laps"],
                bg_color=self.wcfg["bkg_color_estimated_laps"]
            )
            self.bar_estimated_laps = self.set_qlabel(
                text=text_estimated_laps,
                style=bar_style_estimated_laps,
                width=font_m.width * len(text_estimated_laps) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_estimated_laps,
                column=self.wcfg["column_index_estimated_laps"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        session_time = api.read.session.remaining()

        # Session name
        if self.wcfg["show_session_name"]:
            session_index = api.read.session.session_type()
            self.update_session_name(self.bar_session_name, session_index)

        # System Clock
        if self.wcfg["show_system_clock"]:
            system_time = strftime(self.wcfg["system_clock_format"])
            self.update_system_clock(self.bar_system_clock, system_time)

        # Session time
        if self.wcfg["show_session_time"]:
            self.update_session_time(self.bar_session_time, session_time)

        # Estimated laps
        if self.wcfg["show_estimated_laps"]:
            laptime_pace = minfo.delta.lapTimePace
            if not api.read.session.lap_type() and laptime_pace > 0:
                lap_into = api.read.lap.progress()
                end_timer_laps_left = calc.end_timer_laps_remain(lap_into, laptime_pace, session_time)
                laps_left = calc.time_type_laps_remain(calc.ceil(end_timer_laps_left), lap_into)
                estimated_laps = f"{laps_left:>5.3f}"[:5]
            else:
                estimated_laps = "-.---"
            self.update_estimated_laps(self.bar_estimated_laps, estimated_laps)

    # GUI update methods
    def update_session_name(self, target, data):
        """Session name"""
        if target.last != data:
            target.last = data
            target.setText(self.session_name_list[data])

    def update_system_clock(self, target, data):
        """System Clock"""
        if target.last != data:
            target.last = data
            target.setText(data)

    def update_session_time(self, target, data):
        """Session time"""
        if target.last != data:
            target.last = data
            if data < 0:
                data = 0
            target.setText(calc.sec2sessiontime(data))

    def update_estimated_laps(self, target, data):
        """Estimated laps"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.prefix_estimated_laps}{data}")

```

# File: tinypedal/widget/slip_ratio.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Slip ratio Widget
"""

from ..module_info import minfo
from ._base import Overlay
from ._painter import WheelGaugeBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        bar_gap = self.wcfg["bar_gap"]
        bar_gap_hori = self.wcfg["horizontal_gap"]
        bar_gap_vert = self.wcfg["vertical_gap"]
        layout = self.set_grid_layout(gap=bar_gap)
        self.set_primary_layout(layout=layout)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        bar_width = max(self.wcfg["bar_width"], 20)
        bar_height = int(font_m.capital + pady * 2)
        max_range = min(max(int(self.wcfg["slip_ratio_max_range"]), 10), 100)
        self.opt_range = min(max(int(self.wcfg["slip_ratio_optimal_range"]), 0), 100)

        # Caption
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_family=self.wcfg["font_name"],
                font_size=int(self.wcfg['font_size'] * self.wcfg['font_scale_caption']),
                font_weight=self.wcfg["font_weight"],
            )
            cap_bar = self.set_qlabel(
                text=self.wcfg["caption_text"],
                style=bar_style_desc,
                fixed_width=bar_width * 2 + bar_gap_hori,
            )
            self.set_primary_orient(
                target=cap_bar,
                column=0,
            )

        # Slip ratio
        layout_inner = self.set_grid_layout(gap_hori=bar_gap_hori, gap_vert=bar_gap_vert)
        self.slip_color = (
            self.wcfg["optimal_slip_ratio_color"],
            self.wcfg["critical_slip_ratio_color"],
        )
        self.bars_slip = tuple(
            WheelGaugeBar(
                self,
                padding_x=padx,
                bar_width=bar_width,
                bar_height=bar_height,
                font_offset=font_offset,
                display_range=max_range,
                input_color=self.wcfg["optimal_slip_ratio_color"],
                fg_color=self.wcfg["font_color"],
                bg_color=self.wcfg["bkg_color"],
                right_side=idx % 2,
            ) for idx in range(4)
        )
        self.set_grid_layout_quad(
            layout=layout_inner,
            targets=self.bars_slip,
        )
        self.set_primary_orient(
            target=layout_inner,
            column=1,
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        slip_set = minfo.wheels.slipRatio
        for slip, bar_slip in zip(slip_set, self.bars_slip):
            self.update_slip(bar_slip, min(round(abs(slip * 100)), 100))

    # GUI update methods
    def update_slip(self, target, data):
        """Slip ratio"""
        if target.last != data:
            target.last = data
            target.input_color = self.slip_color[data > self.opt_range]
            target.update_input(data)

```

# File: tinypedal/widget/speedometer.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Speedometer Widget
"""

from ..api_control import api
from ..units import set_unit_speed
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        decimals = max(int(self.wcfg["decimal_places"]), 0)
        zero_offset = (decimals > 0)
        bar_width = font_m.width * (3 + decimals + zero_offset) + bar_padx
        self.leading_zero = min(max(self.wcfg["leading_zero"], 1), 3) + zero_offset + decimals + decimals / 10

        # Config units
        self.unit_speed = set_unit_speed(self.cfg.units["speed_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Speed
        if self.wcfg["show_speed"]:
            bar_style_speed_curr = self.set_qss(
                fg_color=self.wcfg["font_color_speed"],
                bg_color=self.wcfg["bkg_color_speed"]
            )
            self.bar_speed_curr = self.set_qlabel(
                text="SPD",
                style=bar_style_speed_curr,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_speed_curr,
                column=self.wcfg["column_index_speed"],
            )

        if self.wcfg["show_speed_minimum"]:
            bar_style_speed_min = self.set_qss(
                fg_color=self.wcfg["font_color_speed_minimum"],
                bg_color=self.wcfg["bkg_color_speed_minimum"]
            )
            self.bar_speed_min = self.set_qlabel(
                text="MIN",
                style=bar_style_speed_min,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_speed_min,
                column=self.wcfg["column_index_speed_minimum"],
            )

        if self.wcfg["show_speed_maximum"]:
            bar_style_speed_max = self.set_qss(
                fg_color=self.wcfg["font_color_speed_maximum"],
                bg_color=self.wcfg["bkg_color_speed_maximum"]
            )
            self.bar_speed_max = self.set_qlabel(
                text="MAX",
                style=bar_style_speed_max,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_speed_max,
                column=self.wcfg["column_index_speed_maximum"],
            )

        if self.wcfg["show_speed_fastest"]:
            bar_style_speed_fast = self.set_qss(
                fg_color=self.wcfg["font_color_speed_fastest"],
                bg_color=self.wcfg["bkg_color_speed_fastest"]
            )
            self.bar_speed_fast = self.set_qlabel(
                text="TOP",
                style=bar_style_speed_fast,
                width=bar_width,
            )
            self.set_primary_orient(
                target=self.bar_speed_fast,
                column=self.wcfg["column_index_speed_fastest"],
            )

        # Last data
        self.speed_min = -1
        self.speed_max = -1
        self.speed_fast = -1
        self.off_throttle_timer_start = 0
        self.on_throttle_timer_start = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Read speed data
        speed = api.read.vehicle.speed()
        lap_etime = api.read.timing.elapsed()
        raw_throttle = api.read.inputs.throttle_raw()

        # Update current speed
        if self.wcfg["show_speed"]:
            self.update_speed(self.bar_speed_curr, speed)

        # Update minimum speed off throttle
        if self.wcfg["show_speed_minimum"] and raw_throttle < self.wcfg["off_throttle_threshold"]:
            if speed < self.speed_min:
                self.speed_min = speed
                self.off_throttle_timer_start = lap_etime
                self.update_speed(self.bar_speed_min, speed)
            if self.off_throttle_timer_start > lap_etime:
                self.off_throttle_timer_start = lap_etime
            if lap_etime - self.off_throttle_timer_start > self.wcfg["speed_minimum_reset_cooldown"]:
                self.speed_min = speed

        # Update maximum speed on throttle
        if self.wcfg["show_speed_maximum"] and raw_throttle > self.wcfg["on_throttle_threshold"]:
            if speed > self.speed_max:
                self.speed_max = speed
                self.on_throttle_timer_start = lap_etime
                self.update_speed(self.bar_speed_max, speed)
            if self.on_throttle_timer_start > lap_etime:
                self.on_throttle_timer_start = lap_etime
            if lap_etime - self.on_throttle_timer_start > self.wcfg["speed_maximum_reset_cooldown"]:
                self.speed_max = speed

        # Update fastest speed
        if self.wcfg["show_speed_fastest"]:
            if api.read.engine.gear() < 0:  # reset on reverse gear
                self.speed_fast = -1
            if speed > self.speed_fast:
                self.speed_fast = speed
                self.update_speed(self.bar_speed_fast, speed)

    # GUI update methods
    def update_speed(self, target, data):
        """Vehicle speed"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.unit_speed(data):0{self.leading_zero}f}")

```

# File: tinypedal/widget/standings.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Standings Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import MAX_SECONDS, TEXT_NOLAPTIME, TEXT_PLACEHOLDER
from ..formatter import random_color_class, shorten_driver_name
from ..module_info import minfo
from ..units import set_unit_speed
from ..userfile.brand_logo import load_brand_logo_file
from ..userfile.heatmap import select_compound_symbol
from ._base import Overlay
from ._common import ExFrame


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap_vert=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.drv_width = max(int(self.wcfg["driver_name_width"]), 1)
        self.veh_width = max(int(self.wcfg["vehicle_name_width"]), 1)
        self.brd_width = max(int(self.wcfg["brand_logo_width"]), 1)
        self.brd_height = max(self.wcfg["font_size"], 1)
        self.cls_width = max(int(self.wcfg["class_width"]), 0)
        self.gap_width = max(int(self.wcfg["time_gap_width"]), 1)
        self.int_width = max(int(self.wcfg["time_interval_width"]), 1)
        self.gap_decimals = max(int(self.wcfg["time_gap_decimal_places"]), 0)
        self.int_decimals = max(int(self.wcfg["time_interval_decimal_places"]), 0)
        self.show_class_separator = self.wcfg["split_gap"] > 0
        self.show_class_timegap = (self.wcfg["enable_multi_class_split_mode"]
            and self.wcfg["show_time_gap_from_same_class"])
        self.show_class_interval = (self.wcfg["enable_multi_class_split_mode"]
            and self.wcfg["show_time_interval_from_same_class"])
        self.max_delta = calc.asym_max(int(self.wcfg["number_of_delta_laptime"]), 2, 5)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        self.bar_split_style = f"margin-top:{self.wcfg['split_gap']}px;max-height:0;"

        # Max display players
        if self.wcfg["enable_single_class_exclusive_mode"]:
            max_display_vehicles = self.wcfg["max_vehicles_exclusive_mode"]
        elif self.wcfg["enable_multi_class_split_mode"]:
            max_display_vehicles = self.wcfg["max_vehicles_split_mode"]
        else:
            max_display_vehicles = self.wcfg["max_vehicles_combined_mode"]
        self.veh_range = min(max(int(max_display_vehicles), 5), 126)
        self.pixmap_brandlogo = {}
        self.row_visible = [False] * self.veh_range

        # Driver position
        if self.wcfg["show_position"]:
            self.bar_style_pos = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_position"],
                    bg_color=self.wcfg["bkg_color_position"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_position"],
                    bg_color=self.wcfg["bkg_color_player_position"])
            )
            self.bars_pos = self.set_qlabel(
                style=self.bar_style_pos[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pos,
                column_index=self.wcfg["column_index_position"],
                hide_start=1,
            )
        # Driver position change
        if self.wcfg["show_position_change"]:
            self.bar_style_pgl = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_same"],
                    bg_color=self.wcfg["bkg_color_position_same"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_gain"],
                    bg_color=self.wcfg["bkg_color_position_gain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_loss"],
                    bg_color=self.wcfg["bkg_color_position_loss"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_position_change"],
                    bg_color=self.wcfg["bkg_color_player_position_change"])
            )
            self.bars_pgl = self.set_qlabel(
                style=self.bar_style_pgl[0],
                width=3 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pgl,
                column_index=self.wcfg["column_index_position_change"],
                hide_start=1,
            )
        # Driver name
        if self.wcfg["show_driver_name"]:
            self.bar_style_drv = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_driver_name"],
                    bg_color=self.wcfg["bkg_color_driver_name"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_driver_name"],
                    bg_color=self.wcfg["bkg_color_player_driver_name"])
            )
            self.bars_drv = self.set_qlabel(
                style=self.bar_style_drv[0],
                width=self.drv_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_drv,
                column_index=self.wcfg["column_index_driver"],
                hide_start=1,
            )
        # Vehicle name
        if self.wcfg["show_vehicle_name"]:
            self.bar_style_veh = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_name"],
                    bg_color=self.wcfg["bkg_color_vehicle_name"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_vehicle_name"],
                    bg_color=self.wcfg["bkg_color_player_vehicle_name"])
            )
            self.bars_veh = self.set_qlabel(
                style=self.bar_style_veh[0],
                width=self.veh_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_veh,
                column_index=self.wcfg["column_index_vehicle"],
                hide_start=1,
            )
        # Brand logo
        if self.wcfg["show_brand_logo"]:
            self.bar_style_brd = (
                self.set_qss(
                    bg_color=self.wcfg["bkg_color_brand_logo"]),
                self.set_qss(
                    bg_color=self.wcfg["bkg_color_player_brand_logo"])
            )
            self.bars_brd = self.set_qlabel(
                style=self.bar_style_brd[0],
                width=self.brd_width,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_brd,
                column_index=self.wcfg["column_index_brand_logo"],
                hide_start=1,
            )
        # Time gap
        if self.wcfg["show_time_gap"]:
            self.bar_style_gap = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_time_gap"],
                    bg_color=self.wcfg["bkg_color_time_gap"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_time_gap"],
                    bg_color=self.wcfg["bkg_color_player_time_gap"])
            )
            self.bars_gap = self.set_qlabel(
                style=self.bar_style_gap[0],
                width=self.gap_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_gap,
                column_index=self.wcfg["column_index_timegap"],
                hide_start=1,
            )
        # Time interval
        if self.wcfg["show_time_interval"]:
            self.bar_style_int = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_time_interval"],
                    bg_color=self.wcfg["bkg_color_time_interval"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_time_interval"],
                    bg_color=self.wcfg["bkg_color_player_time_interval"])
            )
            self.bars_int = self.set_qlabel(
                style=self.bar_style_int[0],
                width=self.int_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_int,
                column_index=self.wcfg["column_index_timeinterval"],
                hide_start=1,
            )
        # Vehicle laptime
        if self.wcfg["show_laptime"]:
            self.bar_style_lpt = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_laptime"],
                    bg_color=self.wcfg["bkg_color_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_laptime"],
                    bg_color=self.wcfg["bkg_color_player_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_fastest_last_laptime"],
                    bg_color=self.wcfg["bkg_color_fastest_last_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_fastest_last_laptime"],
                    bg_color=self.wcfg["bkg_color_player_fastest_last_laptime"])
            )
            self.bars_lpt = self.set_qlabel(
                style=self.bar_style_lpt[0],
                width=8 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_lpt,
                column_index=self.wcfg["column_index_laptime"],
                hide_start=1,
            )
        # Vehicle best laptime
        if self.wcfg["show_best_laptime"]:
            self.bar_style_blp = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_best_laptime"],
                    bg_color=self.wcfg["bkg_color_best_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_best_laptime"],
                    bg_color=self.wcfg["bkg_color_player_best_laptime"])
            )
            self.bars_blp = self.set_qlabel(
                style=self.bar_style_blp[0],
                width=8 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_blp,
                column_index=self.wcfg["column_index_best_laptime"],
                hide_start=1,
            )
        # Delta laptime
        if self.wcfg["show_delta_laptime"]:
            self.bar_style_dlt_delta = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_laptime"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_laptime_gain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_delta_laptime_loss"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_delta_laptime"]),
            )
            self.bar_style_dlt = (
                self.set_qss(
                    bg_color=self.wcfg["bkg_color_delta_laptime"]),
                self.set_qss(
                    bg_color=self.wcfg["bkg_color_player_delta_laptime"])
            )
            self.bars_dlt = tuple(
                self.set_delta_table(
                    width=4 * font_m.width,
                    columns=self.max_delta,
                    bar_padx=bar_padx // 2,
                ) for _ in range(self.veh_range)
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_dlt,
                column_index=self.wcfg["column_index_delta_laptime"],
                hide_start=1,
            )
        # Position in class
        if self.wcfg["show_position_in_class"]:
            self.bar_style_pic = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_position_in_class"],
                    bg_color=self.wcfg["bkg_color_position_in_class"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_position_in_class"],
                    bg_color=self.wcfg["bkg_color_player_position_in_class"])
            )
            self.bars_pic = self.set_qlabel(
                style=self.bar_style_pic[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pic,
                column_index=self.wcfg["column_index_position_in_class"],
                hide_start=1,
            )
        # Vehicle class
        if self.wcfg["show_class"]:
            bar_style_cls = self.set_qss(
                fg_color=self.wcfg["font_color_class"],
                bg_color=self.wcfg["bkg_color_class"]
            )
            self.bars_cls = self.set_qlabel(
                style=bar_style_cls,
                width=self.cls_width * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_cls,
                column_index=self.wcfg["column_index_class"],
                hide_start=1,
            )
        # Vehicle in pit
        if self.wcfg["show_pit_status"]:
            self.pit_status_text = (
                "",
                self.wcfg["pit_status_text"],
                self.wcfg["garage_status_text"],
                self.wcfg["yellow_flag_status_text"],
            )
            self.bar_style_pit = (
                "",
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit"],
                    bg_color=self.wcfg["bkg_color_pit"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_garage"],
                    bg_color=self.wcfg["bkg_color_garage"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_yellow_flag"],
                    bg_color=self.wcfg["bkg_color_yellow_flag"])
            )
            self.bars_pit = self.set_qlabel(
                style=self.bar_style_pit[0],
                width=max(map(len, self.pit_status_text)) * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_pit,
                column_index=self.wcfg["column_index_pitstatus"],
                hide_start=1,
            )
        # Tyre compound index
        if self.wcfg["show_tyre_compound"]:
            self.bar_style_tcp = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_tyre_compound"],
                    bg_color=self.wcfg["bkg_color_tyre_compound"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_tyre_compound"],
                    bg_color=self.wcfg["bkg_color_player_tyre_compound"])
            )
            self.bars_tcp = self.set_qlabel(
                style=self.bar_style_tcp[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_tcp,
                column_index=self.wcfg["column_index_tyre_compound"],
                hide_start=1,
            )
        # Pitstop count
        if self.wcfg["show_pitstop_count"]:
            self.bar_style_psc = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_pitstop_count"],
                    bg_color=self.wcfg["bkg_color_pitstop_count"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_pitstop_count"],
                    bg_color=self.wcfg["bkg_color_player_pitstop_count"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_pit_request"],
                    bg_color=self.wcfg["bkg_color_pit_request"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_penalty_count"],
                    bg_color=self.wcfg["bkg_color_penalty_count"])
            )
            self.bars_psc = self.set_qlabel(
                style=self.bar_style_psc[0],
                width=2 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_psc,
                column_index=self.wcfg["column_index_pitstop_count"],
                hide_start=1,
            )
        # Remaining energy
        if self.wcfg["show_energy_remaining"]:
            self.bar_style_nrg = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_unavailable"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_high"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_low"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_energy_remaining_critical"],
                    bg_color=self.wcfg["bkg_color_energy_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_energy_remaining"],
                    bg_color=self.wcfg["bkg_color_player_energy_remaining"])
            )
            self.bars_nrg = self.set_qlabel(
                style=self.bar_style_nrg[0],
                width=3 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_nrg,
                column_index=self.wcfg["column_index_energy_remaining"],
                hide_start=1,
            )
        # Vehicle integrity
        if self.wcfg["show_vehicle_integrity"]:
            self.bar_style_dmg = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_full"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_high"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_vehicle_integrity_low"],
                    bg_color=self.wcfg["bkg_color_vehicle_integrity"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_vehicle_integrity"],
                    bg_color=self.wcfg["bkg_color_player_vehicle_integrity"])
            )
            self.bars_dmg = self.set_qlabel(
                style=self.bar_style_dmg[0],
                width=1 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_dmg,
                column_index=self.wcfg["column_index_vehicle_integrity"],
                hide_start=1,
            )
        # Stint laps
        if self.wcfg["show_stint_laps"]:
            self.bar_style_stl = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_stint_laps"],
                    bg_color=self.wcfg["bkg_color_stint_laps"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_stint_laps"],
                    bg_color=self.wcfg["bkg_color_player_stint_laps"])
            )
            self.bars_stl = self.set_qlabel(
                style=self.bar_style_stl[0],
                width=5 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_stl,
                column_index=self.wcfg["column_index_stint_laps"],
                hide_start=1,
            )
        # Speed trap
        if self.wcfg["show_speed_trap"]:
            self.unit_speed = set_unit_speed(self.cfg.units["speed_unit"])
            self.bar_style_spd = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_speed_trap"],
                    bg_color=self.wcfg["bkg_color_speed_trap"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_player_speed_trap"],
                    bg_color=self.wcfg["bkg_color_player_speed_trap"])
            )
            self.bars_spd = self.set_qlabel(
                style=self.bar_style_spd[0],
                width=5 * font_m.width + bar_padx,
                count=self.veh_range,
            )
            self.set_grid_layout_table_column(
                layout=layout,
                targets=self.bars_spd,
                column_index=self.wcfg["column_index_speed_trap"],
                hide_start=1,
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        standings_list = minfo.relative.standings
        total_std_idx = len(standings_list) - 1  # skip final -1 index
        player_idx = minfo.vehicles.playerIndex
        plr_veh_info = minfo.vehicles.dataSet[player_idx]
        in_race = api.read.session.in_race()

        # Standings update
        for idx in range(self.veh_range):

            if idx < total_std_idx:
                std_idx = standings_list[idx]
            else:
                std_idx = -2

            # Set row state: 0 - show, 1 - draw gap, 2 - hide
            if std_idx >= -1:
                self.row_visible[idx] = True
                state = (std_idx == -1)
            elif not self.row_visible[idx]:
                continue  # skip update if already empty
            else:
                self.row_visible[idx] = False
                state = 2

            # Get vehicle dataset
            veh_info = minfo.vehicles.dataSet[std_idx]
            # Highlighted player
            hi_player = self.wcfg["show_player_highlighted"] and veh_info.isPlayer
            # Driver position
            if self.wcfg["show_position"]:
                self.update_pos(self.bars_pos[idx], veh_info.positionOverall, hi_player, state)
            # Driver position change
            if self.wcfg["show_position_change"]:
                if self.wcfg["show_position_change_in_class"]:
                    pos_diff = veh_info.qualifyInClass - veh_info.positionInClass
                else:
                    pos_diff = veh_info.qualifyOverall - veh_info.positionOverall
                self.update_pgl(self.bars_pgl[idx], pos_diff, hi_player, state)
            # Driver name
            if self.wcfg["show_driver_name"]:
                self.update_drv(self.bars_drv[idx], veh_info.driverName, hi_player, state)
            # Vehicle name
            if self.wcfg["show_vehicle_name"]:
                self.update_veh(self.bars_veh[idx], veh_info.vehicleName, hi_player, state)
            # Brand logo
            if self.wcfg["show_brand_logo"]:
                self.update_brd(self.bars_brd[idx], veh_info.vehicleName, hi_player, state)
            # Time gap
            if self.wcfg["show_time_gap"]:
                if in_race:
                    if self.show_class_timegap:
                        time_gap = self.gap_to_leader_race(veh_info.gapBehindLeaderInClass, veh_info.positionInClass)
                    else:
                        time_gap = self.gap_to_leader_race(veh_info.gapBehindLeader, veh_info.positionOverall)
                else:
                    if self.show_class_timegap:
                        time_gap = self.gap_to_leader_best(veh_info.bestLapTime, veh_info.classBestLapTime)
                    else:
                        time_gap = self.gap_to_leader_best(veh_info.bestLapTime, minfo.vehicles.leaderBestLapTime)
                self.update_gap(self.bars_gap[idx], time_gap, hi_player, state)
            # Time interval
            if self.wcfg["show_time_interval"]:
                if self.show_class_interval:
                    time_int = (veh_info.positionInClass, veh_info.gapBehindNextInClass)
                else:
                    time_int = (veh_info.positionOverall, veh_info.gapBehindNext)
                self.update_int(self.bars_int[idx], time_int, hi_player, state)
            # Vehicle laptime
            if self.wcfg["show_laptime"]:
                if self.wcfg["show_pitstop_duration_while_requested_pitstop"] and plr_veh_info.pitRequested:
                    laptime = self.set_pittime(veh_info.inPit, veh_info.pitTimer.elapsed)
                    is_class_best = False
                elif in_race or self.wcfg["show_best_laptime"]:
                    if veh_info.pitTimer.pitting:
                        laptime = self.set_pittime(veh_info.inPit, veh_info.pitTimer.elapsed)
                        is_class_best = False
                    else:
                        laptime = self.set_laptime(veh_info.lastLapTime)
                        is_class_best = veh_info.isClassFastestLastLap
                else:
                    laptime = self.set_laptime(veh_info.bestLapTime)
                    is_class_best = False
                self.update_lpt(self.bars_lpt[idx], laptime, is_class_best, hi_player, state)
            # Vehicle best laptime
            if self.wcfg["show_best_laptime"]:
                if in_race and self.wcfg["show_best_laptime_from_recent_laps_in_race"]:
                    laptime = veh_info.lapTimeHistory.best()
                else:
                    laptime = veh_info.bestLapTime
                self.update_blp(self.bars_blp[idx], laptime, hi_player, state)
            # Position in class
            if self.wcfg["show_position_in_class"]:
                self.update_pic(self.bars_pic[idx], veh_info.positionInClass, veh_info.vehicleClass, hi_player, state)
            # Vehicle class
            if self.wcfg["show_class"]:
                self.update_cls(self.bars_cls[idx], veh_info.vehicleClass, state)
            # Vehicle in pit
            if self.wcfg["show_pit_status"]:
                self.update_pit(self.bars_pit[idx], veh_info.inPit, veh_info.isYellow, state)
            # Tyre compound index
            if self.wcfg["show_tyre_compound"]:
                self.update_tcp(self.bars_tcp[idx], veh_info.tireCompoundFront, veh_info.tireCompoundRear, hi_player, state)
            # Pitstop count
            if self.wcfg["show_pitstop_count"]:
                self.update_psc(self.bars_psc[idx], veh_info.numPitStops, veh_info.pitRequested, hi_player, state)
            # Delta laptime
            if self.wcfg["show_delta_laptime"]:
                delta_laptime = tuple(veh_info.lapTimeHistory.delta(plr_veh_info.lapTimeHistory, self.max_delta))
                self.update_dlt(self.bars_dlt[idx], delta_laptime, hi_player, state)
            # Remaining energy
            if self.wcfg["show_energy_remaining"]:
                self.update_nrg(self.bars_nrg[idx], veh_info.energyRemaining, hi_player, state)
            # Vehicle integrity
            if self.wcfg["show_vehicle_integrity"]:
                self.update_dmg(self.bars_dmg[idx], veh_info.vehicleIntegrity, hi_player, state)
            # Stint laps
            if self.wcfg["show_stint_laps"]:
                self.update_stl(self.bars_stl[idx], veh_info.currentStintLaps, veh_info.estimatedStintLaps, hi_player, state)
            # Speed trap
            if self.wcfg["show_speed_trap"]:
                self.update_spd(self.bars_spd[idx], veh_info.speedTrap.speed, hi_player, state)

    # GUI update methods
    def update_pos(self, target, *data):
        """Driver position"""
        if target.last != data:
            target.last = data
            target.setText(f"{data[0]:02d}")
            target.updateStyle(self.bar_style_pos[data[1]])
            self.toggle_visibility(target, data[-1])

    def update_pgl(self, target, *data):
        """Driver position change (gain/loss)"""
        if target.last != data:
            target.last = data
            pos_diff = data[0]
            if pos_diff > 0:
                text = f"â–²{pos_diff: >2}"
                color_index = 1
            elif pos_diff < 0:
                text = f"â–¼{-pos_diff: >2}"
                color_index = 2
            else:
                text = "- 0"
                color_index = 0
            if data[1]:
                color_index = 3
            target.setText(text)
            target.updateStyle(self.bar_style_pgl[color_index])
            self.toggle_visibility(target, data[-1])

    def update_drv(self, target, *data):
        """Driver name"""
        if target.last != data:
            target.last = data
            if self.wcfg["driver_name_shorten"]:
                text = shorten_driver_name(data[0])
            else:
                text = data[0]
            if self.wcfg["driver_name_uppercase"]:
                text = text.upper()
            if self.wcfg["driver_name_align_center"]:
                text = text[:self.drv_width]
            else:
                text = text[:self.drv_width].ljust(self.drv_width)
            target.setText(text)
            target.updateStyle(self.bar_style_drv[data[1]])
            self.toggle_visibility(target, data[-1])

    def update_veh(self, target, *data):
        """Vehicle name"""
        if target.last != data:
            target.last = data
            if self.wcfg["show_vehicle_brand_as_name"]:
                text = self.cfg.user.brands.get(data[0], data[0])
            else:
                text = data[0]
            if self.wcfg["vehicle_name_uppercase"]:
                text = text.upper()
            if self.wcfg["vehicle_name_align_center"]:
                text = text[:self.veh_width]
            else:
                text = text[:self.veh_width].ljust(self.veh_width)
            target.setText(text)
            target.updateStyle(self.bar_style_veh[data[1]])
            self.toggle_visibility(target, data[-1])

    def update_brd(self, target, *data):
        """Brand logo"""
        if target.last != data:
            target.last = data
            target.setPixmap(self.set_brand_logo(self.cfg.user.brands.get(data[0], data[0])))
            target.updateStyle(self.bar_style_brd[data[1]])
            self.toggle_visibility(target, data[-1])

    def update_gap(self, target, *data):
        """Time gap"""
        if target.last != data:
            target.last = data
            target.setText(data[0][:self.gap_width].strip("."))
            target.updateStyle(self.bar_style_gap[data[1]])
            self.toggle_visibility(target, data[-1])

    def update_int(self, target, *data):
        """Time interval"""
        if target.last != data:
            target.last = data
            target.setText(self.int_to_next(*data[0])[:self.int_width].strip("."))
            target.updateStyle(self.bar_style_int[data[1]])
            self.toggle_visibility(target, data[-1])

    def update_lpt(self, target, *data):
        """Vehicle laptime"""
        if target.last != data:
            target.last = data
            if self.wcfg["show_highlighted_fastest_last_laptime"] and data[1]:
                color_index = 2 + data[2]
            else:
                color_index = data[2]
            target.setText(data[0])
            target.updateStyle(self.bar_style_lpt[color_index])
            self.toggle_visibility(target, data[-1])

    def update_blp(self, target, *data):
        """Vehicle best laptime"""
        if target.last != data:
            target.last = data
            target.setText(self.set_laptime(data[0]))
            target.updateStyle(self.bar_style_blp[data[1]])
            self.toggle_visibility(target, data[-1])

    def update_dlt(self, target, *data):
        """Vehicle delta laptime"""
        if target.last != data:
            target.last = data
            is_player = data[1]
            for bar_delta, delta in zip(target.bar_set, data[0]):
                if -999 < delta < 0:  # player time gain
                    text = f"{-delta:.1f}"[:3].strip(".")
                    color_index = 1
                elif 0 < delta < 999:  # player time loss
                    text = f"{delta:.1f}"[:3].strip(".")
                    color_index = 2
                elif delta == 0:
                    text = "0.0"
                    color_index = 0
                else:
                    text = "-.-"
                    color_index = 0
                if is_player:
                    color_index = -1
                bar_delta.setText(text)
                bar_delta.updateStyle(self.bar_style_dlt_delta[color_index])
            target.updateStyle(self.bar_style_dlt[is_player])
            self.toggle_visibility_delta(target, data[-1])

    def update_pic(self, target, *data):
        """Position in class"""
        if target.last != data:
            target.last = data
            if data[2]:  # player
                style = self.bar_style_pic[1]
            elif self.wcfg["show_class_style_for_position_in_class"]:
                style = f"color:{self.wcfg['font_color_position_in_class']};background:{self.set_class_style(data[1])[1]};"
            else:
                style = self.bar_style_pic[0]
            target.setText(f"{data[0]:02d}")
            target.updateStyle(style)
            self.toggle_visibility(target, data[-1])

    def update_cls(self, target, *data):
        """Vehicle class"""
        if target.last != data:
            target.last = data
            text, bg_color = self.set_class_style(data[0])
            target.setText(text[:self.cls_width])
            target.updateStyle(f"color:{self.wcfg['font_color_class']};background:{bg_color};")
            self.toggle_visibility(target, data[-1])

    def update_pit(self, target, *data):
        """Vehicle in pit"""
        if target.last != data:
            target.last = data
            index = data[0]
            if data[1] and index == 0:  # show yellow flag outside pits
                index = 3
            target.setText(self.pit_status_text[index])
            target.updateStyle(self.bar_style_pit[index])
            self.toggle_visibility(target, data[-1])

    def update_tcp(self, target, *data):
        """Tyre compound index"""
        if target.last != data:
            target.last = data
            target.setText(f"{select_compound_symbol(data[0])}{select_compound_symbol(data[1])}")
            target.updateStyle(self.bar_style_tcp[data[2]])
            self.toggle_visibility(target, data[-1])

    def update_psc(self, target, *data):
        """Pitstop count"""
        if target.last != data:
            target.last = data
            if data[0] < 0:
                color_index = 3
            elif self.wcfg["show_pit_request"] and data[1]:
                color_index = 2
            elif data[2]:  # highlighted player
                color_index = 1
            else:
                color_index = 0
            if data[0] == 0:
                text = TEXT_PLACEHOLDER
            else:
                text = f"{data[0]}"
            target.setText(text)
            target.updateStyle(self.bar_style_psc[color_index])
            self.toggle_visibility(target, data[-1])

    def update_nrg(self, target, *data):
        """Remaining energy"""
        if target.last != data:
            target.last = data
            ve = data[0]
            if data[1]:  # highlighted player
                color_index = 4
            elif ve <= -1:  # unavailable
                color_index = 0
            elif ve <= 0.1:  # 10% remaining
                color_index = 3
            elif ve <= 0.3:  # 30% remaining
                color_index = 2
            else:
                color_index = 1
            if ve <= -1:
                text = "---"
            else:
                text = f"{ve:03.0%}"[:3]
            target.setText(text)
            target.updateStyle(self.bar_style_nrg[color_index])
            self.toggle_visibility(target, data[-1])

    def update_dmg(self, target, *data):
        """Vehicle integrity"""
        if target.last != data:
            target.last = data
            hp = int(data[0] * 10)
            if data[1]:  # highlighted player
                color_index = 3
            elif hp >= 10:  # full integrity
                color_index = 0
            elif hp <= 5:  # low
                color_index = 2
            else:  # high
                color_index = 1
            if hp >= 10:
                text = TEXT_PLACEHOLDER
            else:
                text = f"{hp:d}"
            target.setText(text)
            target.updateStyle(self.bar_style_dmg[color_index])
            self.toggle_visibility(target, data[-1])

    def update_stl(self, target, *data):
        """Stint laps"""
        if target.last != data:
            target.last = data
            stint_laps_done = data[0]
            stint_laps_est = data[1]
            if stint_laps_done <= 0:
                text_done = "--"
            else:
                text_done = f"{stint_laps_done:02.0f}"
            if stint_laps_est <= 0:
                text_est = "--"
            else:
                text_est = f"{stint_laps_est // 1:02.0f}"
            target.setText(f"{text_done}/{text_est}")
            target.updateStyle(self.bar_style_stl[data[2]])
            self.toggle_visibility(target, data[-1])

    def update_spd(self, target, *data):
        """Speed trap"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.unit_speed(data[0]):.3f}"[:5])
            target.updateStyle(self.bar_style_spd[data[1]])
            self.toggle_visibility(target, data[-1])

    # Additional methods
    def toggle_visibility(self, target, state):
        """Hide bar if unavailable"""
        if state == 0:
            target.show()
        elif state == 1 and self.show_class_separator:  # draw gap
            target.clear()
            target.updateStyle(self.bar_split_style)
            target.show()
        else:
            target.hide()

    def toggle_visibility_delta(self, target, state):
        """Hide bar if unavailable"""
        if state == 0:
            target.show()
        elif state == 1 and self.show_class_separator:  # draw gap
            for _bar in target.bar_set:
                _bar.clear()
            target.updateStyle(self.bar_split_style)
            target.show()
        else:
            target.hide()

    def set_brand_logo(self, brand_name: str):
        """Set brand logo"""
        if brand_name not in self.pixmap_brandlogo:  # load & cache logo
            self.pixmap_brandlogo[brand_name] = load_brand_logo_file(
                filepath=self.cfg.path.brand_logo,
                filename=brand_name,
                max_width=self.brd_width,
                max_height=self.brd_height,
            )
        return self.pixmap_brandlogo[brand_name]

    def set_class_style(self, class_name: str):
        """Compare vehicle class name with user defined dictionary"""
        style = self.cfg.user.classes.get(class_name)
        if style is not None:
            return style["alias"], style["color"]
        if class_name:
            return class_name, random_color_class(class_name)
        return class_name, self.wcfg["bkg_color_class"]

    @staticmethod
    def set_laptime(laptime):
        """Set lap time"""
        if 0 < laptime < MAX_SECONDS:
            return calc.sec2laptime_full(laptime)[:8]
        return TEXT_NOLAPTIME

    @staticmethod
    def set_pittime(inpit, pit_time):
        """Set lap time"""
        if 0 < pit_time < MAX_SECONDS:
            return f"{'PIT' if inpit else 'OUT'}{pit_time: >5.1f}"[:8]
        return TEXT_NOLAPTIME

    def gap_to_leader_best(self, player_best, leader_best):
        """Gap to leader's best laptime"""
        time = player_best - leader_best  # leader best
        if time == 0 and player_best > 0:
            return self.wcfg["time_gap_leader_text"]
        if time < 0 or player_best < 1:  # no time set
            return "0.0"
        return f"{time:.{self.gap_decimals}f}"

    def gap_to_leader_race(self, gap_behind, position):
        """Gap to race leader"""
        if position == 1:
            return self.wcfg["time_gap_leader_text"]
        if isinstance(gap_behind, int):
            return f"{gap_behind:.0f}L"
        return f"{gap_behind:.{self.gap_decimals}f}"

    def int_to_next(self, position, gap_behind):
        """Interval to next"""
        if position == 1:
            return self.wcfg["time_interval_leader_text"]
        if isinstance(gap_behind, int):
            return f"{gap_behind:.0f}L"
        return f"{gap_behind:.{self.int_decimals}f}"

    def set_delta_table(self, width: int, columns: int, bar_padx: int) -> ExFrame:
        """Set delta laptime table"""
        bar_temp = ExFrame(self)
        layout = self.set_grid_layout()
        layout.setContentsMargins(bar_padx, 0, bar_padx, 0)
        bar_temp.setLayout(layout)
        bar_temp.updateStyle(self.bar_style_dlt[0])
        bar_temp.bar_set = self.set_qlabel(
            fixed_width=width,
            count=columns,
        )
        self.set_grid_layout_table_row(
            layout=layout,
            targets=bar_temp.bar_set,
            right_to_left=self.wcfg["show_inverted_delta_laptime_layout"],
        )
        return bar_temp

```

# File: tinypedal/widget/steering.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Steering Widget
"""

from PySide2.QtCore import QRectF, Qt
from PySide2.QtGui import QPainter, QPen, QPixmap

from .. import calculation as calc
from ..api_control import api
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        text_height = int(font_m.capital + pady * 2) * self.wcfg["show_steering_angle"]

        self.bar_edge = max(self.wcfg["bar_edge_width"], 0)
        self.bar_width = max(self.wcfg["bar_width"], 20)
        self.bar_height = max(self.wcfg["bar_height"], text_height)

        side_width = self.bar_edge + self.bar_width
        text_pad = self.bar_edge + padx

        # Rect
        self.rect_steer = QRectF(0, 0, side_width * 2, self.bar_height)
        self.rect_steerpos = QRectF(0, 0, side_width, self.bar_height)
        self.rect_text = self.rect_steer.adjusted(text_pad, font_offset, -text_pad, 0)

        self.rect_center = QRectF(side_width - 1, 0, 2, self.bar_height)
        self.rect_edge_l = QRectF(0, 0, self.bar_edge, self.bar_height)
        self.rect_edge_r = QRectF(self.bar_edge + self.bar_width * 2, 0, self.bar_edge, self.bar_height)

        # Config canvas
        self.resize(side_width * 2, self.bar_height)
        self.pixmap_mark = QPixmap(side_width * 2, self.bar_height)

        self.pen_text = QPen()
        self.pen_text.setColor(self.wcfg["font_color"])

        self.draw_scale_mark()

        # Last data
        self.raw_steering = 0
        self.rot_range = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Steering wheel rotation
        if self.wcfg["manual_steering_range"] > 0:
            temp_rot_range = self.wcfg["manual_steering_range"]
        else:
            temp_rot_range = api.read.inputs.steering_range_physical()

        # Recalculate scale mark
        if self.wcfg["show_scale_mark"] and self.rot_range != temp_rot_range:
            self.rot_range = temp_rot_range
            mark_gap, mark_num = self.scale_mark(
                self.wcfg["scale_mark_degree"],
                self.rot_range,
                self.bar_width
            )
            self.draw_scale_mark(mark_gap, mark_num)

        # Steering
        temp_raw_steering = api.read.inputs.steering_raw()
        if self.raw_steering != temp_raw_steering:
            self.raw_steering = temp_raw_steering
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.fillRect(self.rect_steer, self.wcfg["bkg_color"])

        # Draw steering
        steer_pos = self.steer_position(self.raw_steering, self.bar_width * 2)
        self.rect_steerpos.setLeft(self.bar_edge + steer_pos)
        painter.fillRect(self.rect_steerpos, self.wcfg["steering_color"])

        # Draw edge & scale marks
        painter.drawPixmap(0, 0, self.pixmap_mark)

        # Draw readings
        if self.wcfg["show_steering_angle"]:
            painter.setPen(self.pen_text)
            angle = self.raw_steering * self.rot_range * 0.5
            if angle < 0:
                painter.drawText(self.rect_text, Qt.AlignLeft | Qt.AlignVCenter, f"{-angle:.0f}")
            elif angle > 0:
                painter.drawText(self.rect_text, Qt.AlignRight | Qt.AlignVCenter, f"{angle:.0f}")

    def draw_scale_mark(self, mark_gap=90, mark_num=0):
        """Draw scale mark"""
        self.pixmap_mark.fill(Qt.transparent)
        painter = QPainter(self.pixmap_mark)
        if self.wcfg["show_scale_mark"] and mark_num:
            mark_color = self.wcfg["scale_mark_color"]
            offset = self.bar_edge + self.bar_width
            for idx in range(mark_num):
                gap = mark_gap * (idx + 1)
                painter.fillRect(offset - gap, 0, 1, self.bar_height, mark_color)
                painter.fillRect(offset + gap, 0, 1, self.bar_height, mark_color)
        # Edge center mark
        edge_color = self.wcfg["bar_edge_color"]
        painter.fillRect(self.rect_edge_l, edge_color)
        painter.fillRect(self.rect_edge_r, edge_color)
        painter.fillRect(self.rect_center, edge_color)

    # Additional methods
    @staticmethod
    def scale_mark(degree, rot_range, width):
        """Scale mark gap (degree), mark counts"""
        mark_num = max(int(rot_range / max(degree, 10) * 0.5), 0)
        if rot_range != 0:
            return degree / (rot_range * 0.5) * width, mark_num
        return 0, mark_num

    @staticmethod
    def steer_position(pos, length):
        """Delta position"""
        return (length - calc.sym_max(pos * -length, length)) * 0.5

```

# File: tinypedal/widget/steering_wheel.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Steering wheel Widget
"""

from PySide2.QtCore import QRect, Qt
from PySide2.QtGui import QBrush, QPainter, QPen, QPixmap

from ..api_control import api
from ..const_file import ImageFile
from ..validator import image_exists
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        area_size = max(int(self.wcfg["display_size"] / 2) * 2, 10)
        area_margin = min(max(self.wcfg["display_margin"], 0), int(area_size / 4))
        self.area_center = area_size * 0.5
        wheel_size = area_size - area_margin * 2
        wheel_center = wheel_size * 0.5
        rotation_margin = min(max(self.wcfg["rotation_line_margin"], 0), int(area_size / 4))
        rotation_size = area_size - rotation_margin * 2
        rotation_size_offset = (area_size - rotation_size) * 0.5
        self.decimals = max(int(self.wcfg["decimal_places"]), 0)
        text_width = font_m.width * (5 + self.decimals)

        self.pixmap_wheel = self.load_image(
            filename=ImageFile.STEERING_WHEEL,
            userfile=self.wcfg["custom_steering_wheel_image_file"],
            size=int(wheel_size * 1.5),
            show_custom=self.wcfg["show_custom_steering_wheel"],
        )

        self.rect_bg = QRect(0, 0, area_size, area_size)
        self.rect_wheel = QRect(-wheel_center, -wheel_center, wheel_size, wheel_size)
        self.rect_rotation = QRect(
            rotation_size_offset,
            rotation_size_offset,
            rotation_size,
            rotation_size,
        )
        self.rect_text = QRect(
            area_size * self.wcfg["steering_angle_offset_x"] - text_width * 0.5,
            area_size * self.wcfg["steering_angle_offset_y"] - font_m.height * 0.5 + font_offset,
            text_width,
            font_m.height,
        )

        # Config canvas
        self.resize(area_size, area_size)

        self.pen_rotation = QPen()
        self.pen_rotation.setCapStyle(Qt.FlatCap)
        self.pen_rotation.setColor(self.wcfg["rotation_line_color"])
        self.pen_rotation.setWidth(self.wcfg["rotation_line_width"])
        self.pen_text = QPen()
        self.pen_text.setColor(self.wcfg["font_color_steering_angle"])
        self.brush_circle = QBrush(Qt.SolidPattern)
        self.brush_circle.setColor(self.wcfg["bkg_color_circle"])

        # Last data
        self.steering_angle = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Steering wheel rotation
        if self.wcfg["manual_steering_range"] > 0:
            temp_rot_range = self.wcfg["manual_steering_range"]
        else:
            temp_rot_range = api.read.inputs.steering_range_physical()

        # Steering
        temp_steering_angle = api.read.inputs.steering_raw() * temp_rot_range * 0.5
        if self.steering_angle != temp_steering_angle:
            self.steering_angle = temp_steering_angle
            self.update()

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.setRenderHint(QPainter.SmoothPixmapTransform, True)
        # Draw background
        if self.wcfg["show_background"]:
            painter.fillRect(self.rect_bg, self.wcfg["bkg_color"])
        if self.wcfg["show_circle_background"]:
            painter.setPen(Qt.NoPen)
            painter.setBrush(self.brush_circle)
            painter.drawEllipse(self.rect_bg)
        # Draw steering wheel
        painter.translate(self.area_center, self.area_center)
        painter.rotate(self.steering_angle)
        painter.drawPixmap(self.rect_wheel, self.pixmap_wheel)
        painter.resetTransform()
        # Draw rotation line
        if self.wcfg["show_rotation_line"]:
            if (not self.wcfg["show_rotation_line_while_stationary_only"] or
                self.wcfg["show_rotation_line_while_stationary_only"] and
                api.read.vehicle.speed() < 1):
                painter.setPen(self.pen_rotation)
                painter.drawArc(self.rect_rotation, 1440, -self.steering_angle * 16)
        # Draw text
        if self.wcfg["show_steering_angle"]:
            painter.setPen(self.pen_text)
            painter.drawText(
                self.rect_text,
                Qt.AlignCenter,
                self.format_angle(self.steering_angle)
            )

    # Additional methods
    def format_angle(self, angle):
        """Format angle text"""
        if self.wcfg["show_degree_sign"]:
            return f" {abs(angle):.{self.decimals}f}Â°"
        return f"{abs(angle):.{self.decimals}f}"

    @staticmethod
    def load_image(filename: str, userfile: str, size: int, show_custom: bool):
        """Load steering wheel image"""
        if show_custom:
            temp_filename = userfile
            if image_exists(temp_filename):
                filename = temp_filename
        icon_source = QPixmap(filename)
        return icon_source.scaled(size, size, mode=Qt.SmoothTransformation)

```

# File: tinypedal/widget/stint_history.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Stint history Widget
"""

from collections import deque

from .. import calculation as calc
from ..api_control import api
from ..module_info import minfo
from ..units import set_unit_fuel
from ..userfile.heatmap import select_compound_symbol
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap_vert=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        layout_reversed = self.wcfg["layout"] != 0
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        stint_slot = max(self.wcfg["stint_history_count"], 1)
        self.minimum_stint_seconds = self.wcfg["minimum_stint_threshold_minutes"] * 60

        # Config units
        self.unit_fuel = set_unit_fuel(self.cfg.units["fuel_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Tyre compound
        bar_style_cmpd = (
            self.set_qss(
                fg_color=self.wcfg["font_color_tyre"],
                bg_color=self.wcfg["bkg_color_tyre"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_stint_tyre"],
                bg_color=self.wcfg["bkg_color_last_stint_tyre"])
        )
        self.bars_cmpd = self.set_qlabel(
            text="--",
            style=bar_style_cmpd[1],
            width=font_m.width * 2 + bar_padx,
            count=stint_slot + 1,
        )
        self.bars_cmpd[0].updateStyle(bar_style_cmpd[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_cmpd,
            column_index=self.wcfg["column_index_tyre"],
            bottom_to_top=layout_reversed,
        )

        # Laps
        bar_style_laps = (
            self.set_qss(
                fg_color=self.wcfg["font_color_laps"],
                bg_color=self.wcfg["bkg_color_laps"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_stint_laps"],
                bg_color=self.wcfg["bkg_color_last_stint_laps"])
        )
        self.bars_laps = self.set_qlabel(
            text="---",
            style=bar_style_laps[1],
            width=font_m.width * 3 + bar_padx,
            count=stint_slot + 1,
        )
        self.bars_laps[0].updateStyle(bar_style_laps[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_laps,
            column_index=self.wcfg["column_index_laps"],
            bottom_to_top=layout_reversed,
        )

        # Time
        bar_style_time = (
            self.set_qss(
                fg_color=self.wcfg["font_color_time"],
                bg_color=self.wcfg["bkg_color_time"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_stint_time"],
                bg_color=self.wcfg["bkg_color_last_stint_time"])
        )
        self.bars_time = self.set_qlabel(
            text="--:--",
            style=bar_style_time[1],
            width=font_m.width * 5 + bar_padx,
            count=stint_slot + 1,
        )
        self.bars_time[0].updateStyle(bar_style_time[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_time,
            column_index=self.wcfg["column_index_time"],
            bottom_to_top=layout_reversed,
        )

        # Fuel
        bar_style_fuel = (
            self.set_qss(
                fg_color=self.wcfg["font_color_fuel"],
                bg_color=self.wcfg["bkg_color_fuel"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_stint_fuel"],
                bg_color=self.wcfg["bkg_color_last_stint_fuel"])
        )
        self.bars_fuel = self.set_qlabel(
            text="---.-",
            style=bar_style_fuel[1],
            width=font_m.width * 5 + bar_padx,
            count=stint_slot + 1,
        )
        self.bars_fuel[0].updateStyle(bar_style_fuel[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_fuel,
            column_index=self.wcfg["column_index_fuel"],
            bottom_to_top=layout_reversed,
        )

        # Tyre wear
        bar_style_wear = (
            self.set_qss(
                fg_color=self.wcfg["font_color_wear"],
                bg_color=self.wcfg["bkg_color_wear"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_last_stint_wear"],
                bg_color=self.wcfg["bkg_color_last_stint_wear"])
        )
        self.bars_wear = self.set_qlabel(
            text="---",
            style=bar_style_wear[1],
            width=font_m.width * 3 + bar_padx,
            count=stint_slot + 1,
        )
        self.bars_wear[0].updateStyle(bar_style_wear[0])
        self.set_grid_layout_table_column(
            layout=layout,
            targets=self.bars_wear,
            column_index=self.wcfg["column_index_wear"],
            bottom_to_top=layout_reversed,
        )

        # Last data
        self.last_time = 0
        self.stint_running = False
        self.reset_stint = True
        self.start_laps = 0
        self.start_time = 0
        self.start_fuel = 0
        self.start_wear = 0
        self.last_wear_avg = 0
        self.last_fuel_curr = 0
        # 0 - tyre compound, 1 - total laps, 2 - total time, 3 - total fuel, 4 - total tyre wear
        self.stint_data = ["--",0,0,0,0]
        self.history_data = deque([tuple(self.stint_data) for _ in range(stint_slot)], stint_slot)
        self.update_stint_history()

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Read stint data
        lap_num = api.read.lap.number()
        time_curr = api.read.session.elapsed()
        in_pits = api.read.vehicle.in_pits()
        in_garage = api.read.vehicle.in_garage()
        wear_avg = 100 - sum(api.read.tyre.wear()) * 25

        # Check if virtual energy available
        if self.wcfg["show_virtual_energy_if_available"] and api.read.vehicle.max_virtual_energy():
            fuel_curr = minfo.energy.amountCurrent
        else:
            fuel_curr = self.unit_fuel(minfo.fuel.amountCurrent)

        # Ignore stint
        if (
            in_garage  # ignore while in garage
            or api.read.session.pre_race()  # ignore before race starts
            or abs(self.last_time - time_curr) > 4  # ignore game pause
        ):
            self.reset_stint = True
            if self.stint_running and self.stint_data[2] >= self.minimum_stint_seconds:
                self.update_stint_history(self.stint_data)
        elif not in_pits:
            self.last_fuel_curr = fuel_curr
            self.last_wear_avg = wear_avg
            self.stint_running = True
        elif self.stint_running:
            if self.last_wear_avg > wear_avg or self.last_fuel_curr < fuel_curr:
                self.reset_stint = True
                self.update_stint_history(self.stint_data)

        self.last_time = time_curr

        if self.reset_stint:
            self.start_laps = lap_num
            self.start_time = time_curr
            self.start_fuel = fuel_curr
            self.start_wear = wear_avg
            self.reset_stint = False
            self.stint_running = False
            # Update compound info once per stint
            class_name = api.read.vehicle.class_name()
            self.stint_data[0] = "".join(
                select_compound_symbol(f"{class_name} - {tcmpd_name}")
                for tcmpd_name in api.read.tyre.compound_name()
            )

        if self.start_fuel < fuel_curr:
            self.start_fuel = fuel_curr

        # Current stint data
        self.stint_data[1] = max(lap_num - self.start_laps, 0)
        self.stint_data[2] = max(time_curr - self.start_time, 0)
        self.stint_data[3] = max(self.start_fuel - fuel_curr, 0)
        self.stint_data[4] = max(wear_avg - self.start_wear, 0)

        self.update_cmpd(self.bars_cmpd[0], self.stint_data[0])
        self.update_laps(self.bars_laps[0], self.stint_data[1])
        self.update_time(self.bars_time[0], self.stint_data[2])
        self.update_fuel(self.bars_fuel[0], self.stint_data[3])
        self.update_wear(self.bars_wear[0], self.stint_data[4])

    # GUI update methods
    def update_cmpd(self, target, data):
        """Compound data"""
        if target.last != data:
            target.last = data
            target.setText(data)

    def update_laps(self, target, data):
        """Laps data"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:03.0f}"[:3])

    def update_time(self, target, data):
        """Time data"""
        if target.last != data:
            target.last = data
            target.setText(calc.sec2stinttime(data)[:5])

    def update_fuel(self, target, data):
        """Fuel data"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:05.1f}"[:5])

    def update_wear(self, target, data):
        """Wear data"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:02.0f}%"[:3])

    def update_stint_history(self, new_stint_data=None):
        """Stint history data"""
        if new_stint_data:
            self.history_data.appendleft(tuple(new_stint_data))

        for index, data in enumerate(self.history_data):
            index += 1
            unavailable = False

            if data[2]:
                self.update_cmpd(self.bars_cmpd[index], data[0])
                self.update_laps(self.bars_laps[index], data[1])
                self.update_time(self.bars_time[index], data[2])
                self.update_fuel(self.bars_fuel[index], data[3])
                self.update_wear(self.bars_wear[index], data[4])
            elif not self.wcfg["show_empty_history"]:
                unavailable = True

            self.bars_cmpd[index].setHidden(unavailable)
            self.bars_laps[index].setHidden(unavailable)
            self.bars_time[index].setHidden(unavailable)
            self.bars_fuel[index].setHidden(unavailable)
            self.bars_wear[index].setHidden(unavailable)

```

# File: tinypedal/widget/suspension_force.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Suspension force Widget
"""

from .. import calculation as calc
from ..api_control import api
from ._base import Overlay
from ._painter import WheelGaugeBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        bar_gap = self.wcfg["bar_gap"]
        bar_gap_hori = self.wcfg["horizontal_gap"]
        bar_gap_vert = self.wcfg["vertical_gap"]
        layout = self.set_grid_layout(gap=bar_gap)
        self.set_primary_layout(layout=layout)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        bar_width = max(self.wcfg["bar_width"], 20)
        bar_height = int(font_m.capital + pady * 2)

        # Caption
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_family=self.wcfg["font_name"],
                font_size=int(self.wcfg['font_size'] * self.wcfg['font_scale_caption']),
                font_weight=self.wcfg["font_weight"],
            )
            cap_bar = self.set_qlabel(
                text=self.wcfg["caption_text"],
                style=bar_style_desc,
                fixed_width=bar_width * 2 + bar_gap_hori,
            )
            self.set_primary_orient(
                target=cap_bar,
                column=0,
            )

        # Suspension force
        layout_inner = self.set_grid_layout(gap_hori=bar_gap_hori, gap_vert=bar_gap_vert)
        self.bars_force = tuple(
            WheelGaugeBar(
                self,
                padding_x=padx,
                bar_width=bar_width,
                bar_height=bar_height,
                font_offset=font_offset,
                input_color=self.wcfg["highlight_color"],
                fg_color=self.wcfg["font_color"],
                bg_color=self.wcfg["bkg_color"],
                right_side=idx % 2,
            ) for idx in range(4)
        )
        self.set_grid_layout_quad(
            layout=layout_inner,
            targets=self.bars_force,
        )
        self.set_primary_orient(
            target=layout_inner,
            column=1,
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        force_set = api.read.wheel.suspension_force()
        sum_force = sum(force_set)
        for force, bar_force in zip(force_set, self.bars_force):
            ratio = calc.part_to_whole_ratio(force, sum_force)
            if self.wcfg["show_force_ratio"]:
                force = ratio
            self.update_force(bar_force, round(force), ratio)

    # GUI update methods
    def update_force(self, target, data, ratio):
        """Suspension force & ratio"""
        if target.last != data:
            target.last = data
            target.update_input(ratio)

```

# File: tinypedal/widget/suspension_position.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Suspension position Widget
"""

from ..api_control import api
from ..const_common import WHEELS_NA
from ..module_info import minfo
from ._base import Overlay
from ._painter import WheelGaugeBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        bar_gap = self.wcfg["bar_gap"]
        bar_gap_hori = self.wcfg["horizontal_gap"]
        bar_gap_vert = self.wcfg["vertical_gap"]
        layout = self.set_grid_layout(gap=bar_gap)
        self.set_primary_layout(layout=layout)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        bar_width = max(self.wcfg["bar_width"], 20)
        bar_height = int(font_m.capital + pady * 2)
        max_range = max(int(self.wcfg["position_max_range"]), 10)
        susp_mark_color = (
            self.wcfg["third_spring_position_mark_color"]
            if self.wcfg["show_third_spring_position_mark"]
            else ""
        )
        susp_max_color = (
            self.wcfg["maximum_position_range_color"]
            if self.wcfg["show_maximum_position_range"]
            else ""
        )

        # Caption
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_family=self.wcfg["font_name"],
                font_size=int(self.wcfg['font_size'] * self.wcfg['font_scale_caption']),
                font_weight=self.wcfg["font_weight"],
            )
            cap_bar = self.set_qlabel(
                text=self.wcfg["caption_text"],
                style=bar_style_desc,
                fixed_width=bar_width * 2 + bar_gap_hori,
            )
            self.set_primary_orient(
                target=cap_bar,
                column=0,
            )

        # Suspension position
        layout_inner = self.set_grid_layout(gap_hori=bar_gap_hori, gap_vert=bar_gap_vert)
        self.susp_color = (
            self.wcfg["positive_position_color"],
            self.wcfg["negative_position_color"],
        )
        self.bars_susp = tuple(
            WheelGaugeBar(
                self,
                padding_x=padx,
                bar_width=bar_width,
                bar_height=bar_height,
                font_offset=font_offset,
                display_range=max_range,
                input_color=self.wcfg["positive_position_color"],
                fg_color=self.wcfg["font_color"],
                bg_color=self.wcfg["bkg_color"],
                mark_width=max(self.wcfg["third_spring_position_mark_width"], 1),
                mark_color=susp_mark_color,
                maxrange_height=max(self.wcfg["maximum_position_range_size"], 0),
                maxrange_color=susp_max_color,
                right_side=idx % 2,
                top_side=idx < 2,
            ) for idx in range(4)
        )
        self.set_grid_layout_quad(
            layout=layout_inner,
            targets=self.bars_susp,
        )
        self.set_primary_orient(
            target=layout_inner,
            column=1,
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        susp_pos = minfo.wheels.currentSuspensionPosition
        third_pos = WHEELS_NA
        max_pos = WHEELS_NA

        if self.wcfg["show_third_spring_position_mark"]:
            third_pos = api.read.wheel.third_spring_deflection()

        if self.wcfg["show_maximum_position_range"]:
            max_pos = minfo.wheels.maxSuspensionPosition

        for idx, bar_susp in enumerate(self.bars_susp):
            self.update_susp(bar_susp, susp_pos[idx], third_pos[idx], max_pos[idx])

    # GUI update methods
    def update_susp(self, target, data, third, susp_max):
        """Suspension position"""
        if target.last != data:
            target.last = data
            target.input_color = self.susp_color[data < 0]
            if third != -1:
                target.update_mark(abs(third))
            if susp_max > 0:
                target.update_maxrange(susp_max)
                if data >= susp_max:  # highlight when exceeded max range
                    target.input_color = target.maxrange_color
            target.update_input(abs(data))

```

# File: tinypedal/widget/suspension_travel.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Suspension travel Widget
"""

from ..const_common import TEXT_NA
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 4 + bar_padx

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        bar_style_desc = self.set_qss(
            fg_color=self.wcfg["font_color_caption"],
            bg_color=self.wcfg["bkg_color_caption"],
            font_size=int(self.wcfg['font_size'] * 0.8)
        )

        # Total travel
        if self.wcfg["show_total_travel"]:
            layout_total = self.set_grid_layout()
            bar_style_total = self.set_qss(
                fg_color=self.wcfg["font_color_total_travel"],
                bg_color=self.wcfg["bkg_color_total_travel"]
            )
            self.bars_total = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_total,
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_total,
                targets=self.bars_total,
            )
            self.set_primary_orient(
                target=layout_total,
                column=self.wcfg["column_index_total_travel"],
            )

            if self.wcfg["show_caption"]:
                cap_total = self.set_qlabel(
                    text=self.wcfg["caption_text_total_travel"],
                    style=bar_style_desc,
                )
                layout_total.addWidget(cap_total, 0, 0, 1, 0)

        # Bump travel
        if self.wcfg["show_bump_travel"]:
            layout_bump = self.set_grid_layout()
            bar_style_bump = self.set_qss(
                fg_color=self.wcfg["font_color_bump_travel"],
                bg_color=self.wcfg["bkg_color_bump_travel"]
            )
            self.bars_bump = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_bump,
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_bump,
                targets=self.bars_bump,
            )
            self.set_primary_orient(
                target=layout_bump,
                column=self.wcfg["column_index_bump_travel"],
            )

            if self.wcfg["show_caption"]:
                cap_bump = self.set_qlabel(
                    text=self.wcfg["caption_text_bump_travel"],
                    style=bar_style_desc,
                )
                layout_bump.addWidget(cap_bump, 0, 0, 1, 0)

        # Rebound travel
        if self.wcfg["show_rebound_travel"]:
            layout_rebound = self.set_grid_layout()
            bar_style_rebound = self.set_qss(
                fg_color=self.wcfg["font_color_rebound_travel"],
                bg_color=self.wcfg["bkg_color_rebound_travel"]
            )
            self.bars_rebound = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_rebound,
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_rebound,
                targets=self.bars_rebound,
            )
            self.set_primary_orient(
                target=layout_rebound,
                column=self.wcfg["column_index_rebound_travel"],
            )

            if self.wcfg["show_caption"]:
                cap_rebound = self.set_qlabel(
                    text=self.wcfg["caption_text_rebound_travel"],
                    style=bar_style_desc,
                )
                layout_rebound.addWidget(cap_rebound, 0, 0, 1, 0)

        # Travel ratio
        if self.wcfg["show_travel_ratio"]:
            layout_ratio = self.set_grid_layout()
            bar_style_ratio = self.set_qss(
                fg_color=self.wcfg["font_color_travel_ratio"],
                bg_color=self.wcfg["bkg_color_travel_ratio"]
            )
            self.bars_ratio = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_ratio,
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_ratio,
                targets=self.bars_ratio,
            )
            self.set_primary_orient(
                target=layout_ratio,
                column=self.wcfg["column_index_travel_ratio"],
            )

            if self.wcfg["show_caption"]:
                cap_ratio = self.set_qlabel(
                    text=self.wcfg["caption_text_travel_ratio"],
                    style=bar_style_desc,
                )
                layout_ratio.addWidget(cap_ratio, 0, 0, 1, 0)

        # Minimum position
        if self.wcfg["show_minimum_position"]:
            layout_minpos = self.set_grid_layout()
            bar_style_minpos = self.set_qss(
                fg_color=self.wcfg["font_color_minimum_position"],
                bg_color=self.wcfg["bkg_color_minimum_position"]
            )
            self.bars_minpos = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_minpos,
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_minpos,
                targets=self.bars_minpos,
            )
            self.set_primary_orient(
                target=layout_minpos,
                column=self.wcfg["column_index_minimum_position"],
            )

            if self.wcfg["show_caption"]:
                cap_minpos = self.set_qlabel(
                    text=self.wcfg["caption_text_minimum_position"],
                    style=bar_style_desc,
                )
                layout_minpos.addWidget(cap_minpos, 0, 0, 1, 0)

        # Maximum position
        if self.wcfg["show_maximum_position"]:
            layout_maxpos = self.set_grid_layout()
            bar_style_maxpos = self.set_qss(
                fg_color=self.wcfg["font_color_maximum_position"],
                bg_color=self.wcfg["bkg_color_maximum_position"]
            )
            self.bars_maxpos = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_maxpos,
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_maxpos,
                targets=self.bars_maxpos,
            )
            self.set_primary_orient(
                target=layout_maxpos,
                column=self.wcfg["column_index_maximum_position"],
            )

            if self.wcfg["show_caption"]:
                cap_maxpos = self.set_qlabel(
                    text=self.wcfg["caption_text_maximum_position"],
                    style=bar_style_desc,
                )
                layout_maxpos.addWidget(cap_maxpos, 0, 0, 1, 0)

        # Live position
        if self.wcfg["show_live_position"]:
            layout_live = self.set_grid_layout()
            bar_style_live = self.set_qss(
                fg_color=self.wcfg["font_color_live_position"],
                bg_color=self.wcfg["bkg_color_live_position"]
            )
            self.bars_live = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_live,
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_live,
                targets=self.bars_live,
            )
            self.set_primary_orient(
                target=layout_live,
                column=self.wcfg["column_index_live_position"],
            )

            if self.wcfg["show_caption"]:
                cap_live = self.set_qlabel(
                    text=self.wcfg["caption_text_live_position"],
                    style=bar_style_desc,
                )
                layout_live.addWidget(cap_live, 0, 0, 1, 0)

    def timerEvent(self, event):
        """Update when vehicle on track"""
        for idx in range(4):
            min_pos = minfo.wheels.minSuspensionPosition[idx]
            max_pos = minfo.wheels.maxSuspensionPosition[idx]
            static_pos = minfo.wheels.staticSuspensionPosition[idx]

            total_travel = max_pos - min_pos

            if static_pos != 0 and static_pos < max_pos:
                bump_travel = max_pos - static_pos
            else:
                bump_travel = 0

            if static_pos != 0 and static_pos > min_pos:
                rebound_travel = static_pos - min_pos
            else:
                rebound_travel = 0

            if total_travel > 0 and total_travel >= bump_travel:
                travel_ratio = bump_travel / total_travel
            else:
                travel_ratio = 0

            # Total travel
            if self.wcfg["show_total_travel"]:
                self.update_travel(self.bars_total[idx], total_travel)

            # Bump travel
            if self.wcfg["show_bump_travel"]:
                self.update_travel(self.bars_bump[idx], bump_travel)

            # Rebound travel
            if self.wcfg["show_rebound_travel"]:
                self.update_travel(self.bars_rebound[idx], rebound_travel)

            # Travel ratio
            if self.wcfg["show_travel_ratio"]:
                self.update_ratio(self.bars_ratio[idx], travel_ratio)

            # Minimum position
            if self.wcfg["show_minimum_position"]:
                self.update_travel(self.bars_minpos[idx], min_pos)

            # Maximum position
            if self.wcfg["show_maximum_position"]:
                self.update_travel(self.bars_maxpos[idx], max_pos)

            # Live position
            if self.wcfg["show_live_position"]:
                live_pos = minfo.wheels.currentSuspensionPosition[idx]
                if self.wcfg["show_live_position_relative_to_static_position"]:
                    live_pos -= static_pos
                self.update_travel(self.bars_live[idx], live_pos)

    # GUI update methods
    def update_travel(self, target, data):
        """Suspension travel data"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:.2f}"[:4].strip("."))

    def update_ratio(self, target, data):
        """Travel ratio"""
        if target.last != data:
            target.last = data
            target.setText(f"{data:.0%}")

```

# File: tinypedal/widget/system_performance.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
System performance Widget
"""

import os
from functools import partial

import psutil

from .. import calculation as calc
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])

        if self.wcfg["layout"] == 0:
            prefix_just = max(
                len(self.wcfg["prefix_system"]),
                len(self.wcfg["prefix_tinypedal"]),
            )
        else:
            prefix_just = 0

        self.prefix_sys = self.wcfg["prefix_system"].ljust(prefix_just)
        self.prefix_app = self.wcfg["prefix_tinypedal"].ljust(prefix_just)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # System
        if self.wcfg["show_system_performance"]:
            text_system = f"{self.prefix_sys}0.00% 0.00GB"
            bar_style_system = self.set_qss(
                fg_color=self.wcfg["font_color_system"],
                bg_color=self.wcfg["bkg_color_system"]
            )
            self.bar_system = self.set_qlabel(
                text=text_system,
                style=bar_style_system,
                width=font_m.width * len(text_system) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_system,
                column=self.wcfg["column_index_system"],
            )

        # APP performance
        if self.wcfg["show_tinypedal_performance"]:
            text_app = f"{self.prefix_app}0.00% 0.00MB"
            bar_style_app = self.set_qss(
                fg_color=self.wcfg["font_color_tinypedal"],
                bg_color=self.wcfg["bkg_color_tinypedal"]
            )
            self.bar_app = self.set_qlabel(
                text=text_app,
                style=bar_style_app,
                width=font_m.width * len(text_app) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_app,
                column=self.wcfg["column_index_tinypedal"],
            )

        self.calc_ema = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.wcfg["average_samples"])
        )

        # Last data
        self.app_info = psutil.Process(os.getpid())
        self.cpu_count = os.cpu_count()

    def timerEvent(self, event):
        """Update when vehicle on track"""
        if self.wcfg["show_system_performance"]:
            sys_cpu_ema = self.calc_ema(self.bar_system.last, psutil.cpu_percent())
            self.update_system(self.bar_system, sys_cpu_ema, self.prefix_sys)

        if self.wcfg["show_tinypedal_performance"]:
            app_cpu_ema = self.calc_ema(self.bar_app.last, self.app_info.cpu_percent() / self.cpu_count)
            self.update_app(self.bar_app, app_cpu_ema, self.prefix_app)

    # GUI update methods
    def update_system(self, target, data, prefix):
        """System performance"""
        if target.last != data:
            target.last = data
            memory_used = psutil.virtual_memory().used / 1024 / 1024 / 1024
            cpu = f"{data: >4.2f}"[:4].strip(".")
            mem = f"{memory_used: >4.2f}"[:4].strip(".")
            target.setText(f"{prefix}{cpu: >4}%{mem: >5}GB")

    def update_app(self, target, data, prefix):
        """APP performance"""
        if target.last != data:
            target.last = data
            memory_used = self.app_info.memory_full_info().uss / 1024 / 1024
            cpu = f"{data: >4.2f}"[:4].strip(".")
            mem = f"{memory_used: >4.2f}"[:4].strip(".")
            target.setText(f"{prefix}{cpu: >4}%{mem: >5}MB")

```

# File: tinypedal/widget/timing.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Timing Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import MAX_SECONDS, TEXT_NOLAPTIME
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])

        if self.wcfg["layout"] == 0:
            prefix_just = max(
                len(self.wcfg["prefix_best"]),
                len(self.wcfg["prefix_last"]),
                len(self.wcfg["prefix_current"]),
                len(self.wcfg["prefix_estimated"]),
                len(self.wcfg["prefix_session_best"]),
                len(self.wcfg["prefix_session_personal_best"]),
                len(self.wcfg["prefix_stint_best"]),
                len(self.wcfg["prefix_average_pace"]),
            )
        else:
            prefix_just = 0

        self.prefix_best = self.wcfg["prefix_best"].ljust(prefix_just)
        self.prefix_last = self.wcfg["prefix_last"].ljust(prefix_just)
        self.prefix_curr = self.wcfg["prefix_current"].ljust(prefix_just)
        self.prefix_esti = self.wcfg["prefix_estimated"].ljust(prefix_just)
        self.prefix_sbst = self.wcfg["prefix_session_best"].ljust(prefix_just)
        self.prefix_spbt = self.wcfg["prefix_session_personal_best"].ljust(prefix_just)
        self.prefix_stbt = self.wcfg["prefix_stint_best"].ljust(prefix_just)
        self.prefix_avpc = self.wcfg["prefix_average_pace"].ljust(prefix_just)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Session best laptime
        if self.wcfg["show_session_best"]:
            text_sbst = f"{self.prefix_sbst}{TEXT_NOLAPTIME}"
            bar_style_sbst = self.set_qss(
                fg_color=self.wcfg["font_color_session_best"],
                bg_color=self.wcfg["bkg_color_session_best"]
            )
            self.bar_sbst = self.set_qlabel(
                text=text_sbst,
                style=bar_style_sbst,
                width=font_m.width * len(text_sbst) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_sbst,
                column=self.wcfg["column_index_session_best"],
            )

        # Personal best laptime
        if self.wcfg["show_best"]:
            text_best = f"{self.prefix_best}{TEXT_NOLAPTIME}"
            bar_style_best = self.set_qss(
                fg_color=self.wcfg["font_color_best"],
                bg_color=self.wcfg["bkg_color_best"]
            )
            self.bar_best = self.set_qlabel(
                text=text_best,
                style=bar_style_best,
                width=font_m.width * len(text_best) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_best,
                column=self.wcfg["column_index_best"],
            )

        # Last laptime
        if self.wcfg["show_last"]:
            text_last = f"{self.prefix_last}{TEXT_NOLAPTIME}"
            self.bar_style_last = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_invalid_laptime"],
                    bg_color=self.wcfg["bkg_color_last"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_last"],
                    bg_color=self.wcfg["bkg_color_last"])
            )
            self.bar_last = self.set_qlabel(
                text=text_last,
                style=self.bar_style_last[1],
                width=font_m.width * len(text_last) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_last,
                column=self.wcfg["column_index_last"],
            )

        # Current laptime
        if self.wcfg["show_current"]:
            text_curr = f"{self.prefix_curr}{TEXT_NOLAPTIME}"
            bar_style_curr = self.set_qss(
                fg_color=self.wcfg["font_color_current"],
                bg_color=self.wcfg["bkg_color_current"]
            )
            self.bar_curr = self.set_qlabel(
                text=text_curr,
                style=bar_style_curr,
                width=font_m.width * len(text_curr) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_curr,
                column=self.wcfg["column_index_current"],
            )

        # Estimated laptime
        if self.wcfg["show_estimated"]:
            text_esti = f"{self.prefix_esti}{TEXT_NOLAPTIME}"
            bar_style_esti = self.set_qss(
                fg_color=self.wcfg["font_color_estimated"],
                bg_color=self.wcfg["bkg_color_estimated"]
            )
            self.bar_esti = self.set_qlabel(
                text=text_esti,
                style=bar_style_esti,
                width=font_m.width * len(text_esti) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_esti,
                column=self.wcfg["column_index_estimated"],
            )

        # Session personal best laptime
        if self.wcfg["show_session_personal_best"]:
            text_spbt = f"{self.prefix_spbt}{TEXT_NOLAPTIME}"
            bar_style_spbt = self.set_qss(
                fg_color=self.wcfg["font_color_session_personal_best"],
                bg_color=self.wcfg["bkg_color_session_personal_best"]
            )
            self.bar_spbt = self.set_qlabel(
                text=text_spbt,
                style=bar_style_spbt,
                width=font_m.width * len(text_spbt) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_spbt,
                column=self.wcfg["column_index_session_personal_best"],
            )

        # Stint personal best laptime
        if self.wcfg["show_stint_best"]:
            text_stbt = f"{self.prefix_stbt}{TEXT_NOLAPTIME}"
            bar_style_stbt = self.set_qss(
                fg_color=self.wcfg["font_color_stint_best"],
                bg_color=self.wcfg["bkg_color_stint_best"]
            )
            self.bar_stbt = self.set_qlabel(
                text=text_stbt,
                style=bar_style_stbt,
                width=font_m.width * len(text_stbt) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_stbt,
                column=self.wcfg["column_index_stint_best"],
            )

        # Average pace laptime
        if self.wcfg["show_average_pace"]:
            text_avpc = f"{self.prefix_avpc}{TEXT_NOLAPTIME}"
            bar_style_avpc = self.set_qss(
                fg_color=self.wcfg["font_color_average_pace"],
                bg_color=self.wcfg["bkg_color_average_pace"]
            )
            self.bar_avpc = self.set_qlabel(
                text=text_avpc,
                style=bar_style_avpc,
                width=font_m.width * len(text_avpc) + bar_padx,
            )
            self.set_primary_orient(
                target=self.bar_avpc,
                column=self.wcfg["column_index_average_pace"],
            )

        # Last data
        self.player_index = 0
        self.laptime_sbst = MAX_SECONDS

    def post_update(self):
        self.laptime_sbst = MAX_SECONDS  # reset laptime

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Session best laptime
        if self.wcfg["show_session_best"]:
            if (not self.wcfg["show_session_best_from_same_class_only"]
                or api.read.vehicle.same_class(self.player_index)):
                laptime_best_tmp = api.read.timing.best_laptime(self.player_index)
                if 0 < laptime_best_tmp < self.laptime_sbst:
                    self.laptime_sbst = laptime_best_tmp

            if self.player_index < api.read.vehicle.total_vehicles():
                self.player_index += 1
            else:
                self.player_index = 0

            self.update_laptime(self.bar_sbst, self.laptime_sbst, self.prefix_sbst)

        # Personal best laptime
        if self.wcfg["show_best"]:
            laptime_best = minfo.delta.lapTimeBest
            self.update_laptime(self.bar_best, laptime_best, self.prefix_best)

        # Last laptime
        if self.wcfg["show_last"]:
            laptime_last = minfo.delta.lapTimeLast
            # Convert invalid laptime to negative for state compare
            if not minfo.delta.isValidLap:
                laptime_last *= -1
            self.update_laptime(self.bar_last, laptime_last, self.prefix_last, True)

        # Current laptime
        if self.wcfg["show_current"]:
            laptime_curr = minfo.delta.lapTimeCurrent
            self.update_laptime(self.bar_curr, laptime_curr, self.prefix_curr)

        # Estimated laptime
        if self.wcfg["show_estimated"]:
            laptime_esti = minfo.delta.lapTimeEstimated
            self.update_laptime(self.bar_esti, laptime_esti, self.prefix_esti)

        # Session personal best laptime
        if self.wcfg["show_session_personal_best"]:
            laptime_spbt = api.read.timing.best_laptime()
            self.update_laptime(self.bar_spbt, laptime_spbt, self.prefix_spbt)

        # Stint personal best laptime
        if self.wcfg["show_stint_best"]:
            laptime_stbt = minfo.delta.lapTimeStint
            self.update_laptime(self.bar_stbt, laptime_stbt, self.prefix_stbt)

        # Average pace laptime
        if self.wcfg["show_average_pace"]:
            laptime_avpc = minfo.delta.lapTimePace
            self.update_laptime(self.bar_avpc, laptime_avpc, self.prefix_avpc)

    # GUI update methods
    def update_laptime(self, target, data, prefix, verify=False):
        """Update laptime"""
        if target.last != data:
            target.last = data
            if verify:
                target.updateStyle(self.bar_style_last[data > 0])
                data = abs(data)
            if 0 < data < MAX_SECONDS:
                text = f"{prefix}{calc.sec2laptime(data)[:8]: >8}"
            else:
                text = f"{prefix}{TEXT_NOLAPTIME}"
            target.setText(text)

```

# File: tinypedal/widget/track_map.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Track map Widget
"""

from PySide2.QtCore import QRectF, Qt
from PySide2.QtGui import QBrush, QPainter, QPainterPath, QPen, QPixmap

from .. import calculation as calc
from ..api_control import api
from ..formatter import random_color_class
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        self.show_position_in_class = self.wcfg["enable_multi_class_styling"] and self.wcfg["show_position_in_class"]
        self.display_detail_level = max(self.wcfg["display_detail_level"], 0)

        veh_size_base = self.wcfg["font_size"] + round(font_m.width * self.wcfg["bar_padding"])
        veh_size_opt = veh_size_base * max(self.wcfg["vehicle_scale"], 1.0)
        veh_size_plr = veh_size_base * max(self.wcfg["vehicle_scale_player"], 1.0)

        self.veh_shape = QRectF(-veh_size_opt * 0.5, -veh_size_opt * 0.5, veh_size_opt, veh_size_opt)
        self.veh_shape_player = QRectF(-veh_size_plr * 0.5, -veh_size_plr * 0.5, veh_size_plr, veh_size_plr)
        self.veh_text_shape = QRectF(-veh_size_base * 0.5, -veh_size_base * 0.5 + font_offset, veh_size_base, veh_size_base)

        # Config canvas
        self.area_size = max(self.wcfg["area_size"], 100)
        self.area_margin = min(max(self.wcfg["area_margin"], 0), int(self.area_size/4))
        self.temp_map_size = self.area_size - self.area_margin * 2

        self.resize(self.area_size, self.area_size)
        self.pixmap_map = QPixmap(self.area_size, self.area_size)
        self.pen_veh = (
            self.set_veh_pen_style(self.wcfg["vehicle_outline_color"], self.wcfg["vehicle_outline_width"]),
            self.set_veh_pen_style(self.wcfg["vehicle_outline_player_color"], self.wcfg["vehicle_outline_player_width"]),
            self.set_veh_pen_style(self.wcfg["vehicle_outline_color_laps_ahead"], self.wcfg["vehicle_outline_width_laps_ahead"]),
            self.set_veh_pen_style(self.wcfg["vehicle_outline_color_laps_behind"], self.wcfg["vehicle_outline_width_laps_behind"]),
        )
        self.pen_text = QPen(self.wcfg["font_color"]), QPen(self.wcfg["font_color_player"])

        self.brush_classes = {}
        self.brush_overall = self.set_veh_brush_style(
            "player","leader","in_pit","yellow","laps_ahead","laps_behind","same_lap"
        )

        if self.wcfg["show_pitout_prediction"]:
            self.show_while_requested = self.wcfg["show_pitout_prediction_while_requested_pitstop"]
            self.prediction_count = min(max(self.wcfg["number_of_prediction"], 1), 20)
            self.pitout_time_offset = max(self.wcfg["pitout_time_offset"], 0)
            self.min_pit_time = self.wcfg["pitout_duration_minimum"] + self.pitout_time_offset
            self.pit_time_increment = max(self.wcfg["pitout_duration_increment"], 1)
            if self.wcfg["enabled_fixed_pitout_prediction"]:
                self.fixed_pit_times = tuple(sorted(set(self.set_fixed_pit_time())))
            self.pen_pit_styles = (
                self.set_veh_pen_style(self.wcfg["prediction_outline_color"], self.wcfg["prediction_outline_width"]),
                QPen(self.wcfg["font_color_pitstop_duration"]),
            )
            self.pit_text_shape = QRectF(-veh_size_base * 0.5 - 2, font_offset - veh_size_opt * 0.5 - veh_size_base - 3, veh_size_base + 4, veh_size_base)

        if self.wcfg["show_proximity_circle"]:
            self.pen_proximity = self.set_veh_pen_style(
                self.wcfg["proximity_circle_color"],
                self.wcfg["proximity_circle_width"],
            )
            self.rect_proximity = QRectF()

        # Last data
        self.last_modified = 0
        self.last_veh_data_version = None
        self.circular_map = True
        self.map_scaled = None
        self.map_range = (0, 10, 0, 10)
        self.map_scale = 1.0
        self.map_offset = (0, 0)
        self.map_orient = 0.0  # radians

        self.update_map(-1)

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Map
        modified = minfo.mapping.lastModified
        self.update_map(modified)

        # Vehicles
        veh_data_version = minfo.vehicles.dataSetVersion
        if self.last_veh_data_version != veh_data_version:
            self.last_veh_data_version = veh_data_version
            self.update()

    # GUI update methods
    def update_map(self, data):
        """Map update"""
        if self.last_modified != data:
            self.last_modified = data
            raw_data = minfo.mapping.coordinates if data != -1 else None
            map_path = self.create_map_path(raw_data)
            self.draw_map_image(map_path, self.circular_map)
            if self.wcfg["show_proximity_circle"]:
                self.update_proximity_rect()

    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.drawPixmap(0, 0, self.pixmap_map)
        painter.setRenderHint(QPainter.Antialiasing, True)

        if self.map_scaled:
            self.draw_vehicle_on_map(
                painter, minfo.vehicles.dataSet, minfo.relative.drawOrder
            )
        else:
            self.draw_vehicle_on_circle(
                painter, minfo.vehicles.dataSet, minfo.relative.drawOrder
            )

        if self.wcfg["show_pitout_prediction"]:
            self.draw_pitout_prediction(
                painter,
                self.map_scaled,
                minfo.vehicles.dataSet[minfo.vehicles.playerIndex],
            )

    def create_map_path(self, raw_coords=None):
        """Create map path"""
        map_path = QPainterPath()
        if raw_coords:
            dist = calc.distance(raw_coords[0], raw_coords[-1])
            angle = max(int(self.wcfg["display_orientation"]), 0)
            angle = angle - angle // 360 * 360
            self.map_orient = calc.deg2rad(angle)
            (self.map_scaled, self.map_range, self.map_scale, self.map_offset
             ) = calc.scale_map(raw_coords, self.area_size, self.area_margin, angle)

            total_nodes = len(self.map_scaled) - 1
            skip_node = calc.skip_map_nodes(total_nodes, self.temp_map_size * 3, self.display_detail_level)
            last_skip = 0
            for index, coords in enumerate(self.map_scaled):
                if index == 0:
                    map_path.moveTo(*coords)
                elif index >= total_nodes:  # don't skip last node
                    map_path.lineTo(*coords)
                elif last_skip >= skip_node:
                    map_path.lineTo(*coords)
                    last_skip = 0
                last_skip += 1

            # Close map loop if start & end distance less than 500 meters
            if dist < 500:
                map_path.closeSubpath()
                self.circular_map = True
            else:
                self.circular_map = False

        # Temp(circular) map
        else:
            self.map_scaled = None
            self.circular_map = True
            self.map_orient = 0
            map_path.addEllipse(
                self.area_margin,
                self.area_margin,
                self.temp_map_size,
                self.temp_map_size,
            )
        return map_path

    def draw_map_image(self, map_path, circular_map=True):
        """Draw map image separately"""
        if self.wcfg["show_background"]:
            self.pixmap_map.fill(self.wcfg["bkg_color"])
        else:
            self.pixmap_map.fill(Qt.transparent)
        painter = QPainter(self.pixmap_map)
        painter.setRenderHint(QPainter.Antialiasing, True)

        # Draw map inner background
        if self.wcfg["show_map_background"] and circular_map:
            brush = QBrush(Qt.SolidPattern)
            brush.setColor(self.wcfg["bkg_color_map"])
            painter.setBrush(brush)
            painter.setPen(Qt.NoPen)
            painter.drawPath(map_path)
            painter.setBrush(Qt.NoBrush)

        # Set pen style
        pen = QPen()
        pen.setJoinStyle(Qt.RoundJoin)

        # Draw map outline
        if self.wcfg["map_outline_width"] > 0:
            pen.setWidth(self.wcfg["map_width"] + self.wcfg["map_outline_width"])
            pen.setColor(self.wcfg["map_outline_color"])
            painter.setPen(pen)
            painter.drawPath(map_path)

        # Draw map
        pen.setWidth(self.wcfg["map_width"])
        pen.setColor(self.wcfg["map_color"])
        painter.setPen(pen)
        painter.drawPath(map_path)

        # Draw sector
        if self.map_scaled:
            # SF line
            if self.wcfg["show_start_line"]:
                pen.setWidth(self.wcfg["start_line_width"])
                pen.setColor(self.wcfg["start_line_color"])
                painter.setPen(pen)
                pos_x1, pos_y1, pos_x2, pos_y2 = calc.line_intersect_coords(
                    self.map_scaled[0],  # point a
                    self.map_scaled[1],  # point b
                    1.57079633,  # 90 degree rotation
                    self.wcfg["start_line_length"]
                )
                painter.drawLine(pos_x1, pos_y1, pos_x2, pos_y2)

            # Sector lines
            sectors_index = minfo.mapping.sectors
            if self.wcfg["show_sector_line"] and isinstance(sectors_index, tuple):
                pen.setWidth(self.wcfg["sector_line_width"])
                pen.setColor(self.wcfg["sector_line_color"])
                painter.setPen(pen)

                for index in sectors_index:
                    pos_x1, pos_y1, pos_x2, pos_y2 = calc.line_intersect_coords(
                        self.map_scaled[index],  # point a
                        self.map_scaled[index + 1],  # point b
                        1.57079633,  # 90 degree rotation
                        self.wcfg["sector_line_length"]
                    )
                    painter.drawLine(pos_x1, pos_y1, pos_x2, pos_y2)
        else:
            # SF line
            if self.wcfg["show_start_line"]:
                pen.setWidth(self.wcfg["start_line_width"])
                pen.setColor(self.wcfg["start_line_color"])
                painter.setPen(pen)
                painter.drawLine(
                    self.area_margin - self.wcfg["start_line_length"],
                    self.area_size * 0.5,
                    self.area_margin + self.wcfg["start_line_length"],
                    self.area_size * 0.5
                )

    def draw_vehicle_on_circle(self, painter, veh_info, veh_draw_order):
        """Draw vehicles on temporary circle map"""
        offset = self.area_size * 0.5

        for index in veh_draw_order:
            data = veh_info[index]

            inpit_offset = self.wcfg["font_size"] * data.inPit
            pos_x, pos_y = calc.rotate_coordinate(
                6.2831853 * data.currentLapProgress,
                self.temp_map_size / -2 + inpit_offset,  # x pos
                0,  # y pos
            )
            painter.translate(offset + pos_x, offset + pos_y)

            painter.setPen(self.outline_vehicle(data))
            painter.setBrush(self.color_vehicle(data))

            if data.isPlayer:
                painter.drawEllipse(self.veh_shape_player)
            else:
                painter.drawEllipse(self.veh_shape)

            # Draw text standings
            if self.wcfg["show_vehicle_standings"]:
                if self.show_position_in_class:
                    place_veh = data.positionInClass
                else:
                    place_veh = data.positionOverall
                painter.setPen(self.pen_text[data.isPlayer])
                painter.drawText(self.veh_text_shape, Qt.AlignCenter, f"{place_veh}")
            painter.resetTransform()

    def draw_vehicle_on_map(self, painter, veh_info, veh_draw_order):
        """Draw vehicles on track map"""
        # Position = coords * scale - (min_range * scale - offset)
        x_offset = self.map_range[0] * self.map_scale - self.map_offset[0]  # min range x, offset x
        y_offset = self.map_range[2] * self.map_scale - self.map_offset[1]  # min range y, offset y

        for index in veh_draw_order:
            data = veh_info[index]

            if self.map_orient:
                rot_x, rot_y = calc.rotate_coordinate(self.map_orient, data.worldPositionX, data.worldPositionY)
                pos_x = rot_x * self.map_scale - x_offset
                pos_y = rot_y * self.map_scale - y_offset
            else:
                pos_x = data.worldPositionX * self.map_scale - x_offset
                pos_y = data.worldPositionY * self.map_scale - y_offset
            painter.translate(pos_x, pos_y)

            painter.setPen(self.outline_vehicle(data))
            painter.setBrush(self.color_vehicle(data))

            if data.isPlayer:
                painter.drawEllipse(self.veh_shape_player)
                if self.wcfg["show_proximity_circle"]:
                    painter.setPen(self.pen_proximity)
                    painter.setBrush(Qt.NoBrush)
                    painter.drawEllipse(self.rect_proximity)
            else:
                painter.drawEllipse(self.veh_shape)

            # Draw text standings
            if self.wcfg["show_vehicle_standings"]:
                if self.show_position_in_class:
                    place_veh = data.positionInClass
                else:
                    place_veh = data.positionOverall
                painter.setPen(self.pen_text[data.isPlayer])
                painter.drawText(self.veh_text_shape, Qt.AlignCenter, f"{place_veh}")
            painter.resetTransform()

    def draw_pitout_prediction(self, painter, map_data, plr_veh_info):
        """Draw pitout prediction circles"""
        # Skip drawing
        if not plr_veh_info.inPit:
            if not self.show_while_requested:  # if not in pit
                return
            if not plr_veh_info.pitRequested:  # not requested pit
                return

        # Verify data set
        if not map_data:  # x, y coords
            return
        dist_data = minfo.mapping.elevations
        if not dist_data:  # distance, z coords
            return
        deltabest_data = minfo.delta.deltaBestData  # distance, seconds
        deltabest_max_index = len(deltabest_data) - 1
        if deltabest_max_index < 2:
            return
        laptime_best = deltabest_data[-1][1]
        laptime_pace = minfo.delta.lapTimePace
        if laptime_best < 1 or laptime_pace < 1:
            return

        laptime_scale = laptime_best / laptime_pace
        dist_end_index = min(len(dist_data), len(map_data)) - 1

        # Calculate pit timer & target time
        if plr_veh_info.pitRequested and not plr_veh_info.inPit:  # out pit lane
            pitin_time = target_node_time(minfo.mapping.pitEntryPosition, deltabest_data, deltabest_max_index, laptime_scale)
            pos_curr_time = target_node_time(api.read.lap.distance(), deltabest_data, deltabest_max_index, laptime_scale)
            pit_timer = pos_curr_time - pitin_time
            target_pit_time = self.min_pit_time
        else:  # in pit lane
            pit_timer = plr_veh_info.pitTimer.elapsed
            target_pit_time = target_pitstop_duration(pit_timer, self.min_pit_time, self.pit_time_increment)

        # Find time_into from deltabest_data, scale to match laptime_pace
        pitout_time = target_node_time(minfo.mapping.pitExitPosition, deltabest_data, deltabest_max_index, laptime_scale)
        pitout_time_extend = pit_timer + pitout_time

        painter.setBrush(Qt.NoBrush)

        for target_pit_time in self.get_target_pit_time(target_pit_time, pit_timer):
            # Calc estimated pitout_time_into based on laptime_pace
            offset_time_into = pitout_time_extend - target_pit_time
            pitout_time_into = (offset_time_into - offset_time_into // laptime_pace * laptime_pace) * laptime_scale
            # Find estimated distance from deltabest_data
            index_higher = calc.binary_search_higher_column(
                deltabest_data, pitout_time_into, 0, deltabest_max_index, 1)
            if index_higher > 0:
                index_lower = index_higher - 1
                estimate_dist = calc.linear_interp(
                    pitout_time_into,
                    deltabest_data[index_lower][1],
                    deltabest_data[index_lower][0],
                    deltabest_data[index_higher][1],
                    deltabest_data[index_higher][0],
                )
            else:
                estimate_dist = 0

            dist_node_index = calc.binary_search_higher_column(dist_data, estimate_dist, 0, dist_end_index)
            painter.translate(*map_data[dist_node_index])
            painter.setPen(self.pen_pit_styles[0])
            painter.drawEllipse(self.veh_shape)

            # Draw text pitstop duration
            if self.wcfg["show_pitstop_duration"]:
                painter.fillRect(self.pit_text_shape, self.wcfg["bkg_color_pitstop_duration"])
                painter.setPen(self.pen_pit_styles[1])
                text_time = f"{min(target_pit_time - self.pitout_time_offset, 999):.0f}"
                painter.drawText(self.pit_text_shape, Qt.AlignCenter, text_time)

            painter.resetTransform()

    def get_target_pit_time(self, target_pit_time: float, pit_timer: float):
        """Generate target pit time"""
        max_prediction = self.prediction_count
        # Fixed time
        if self.wcfg["enabled_fixed_pitout_prediction"]:
            pass_time = minfo.mapping.pitPassTime
            valid_count = 0
            for fixed_time in self.fixed_pit_times:
                if valid_count >= max_prediction:
                    break
                fixed_time += pass_time
                if fixed_time > pit_timer:
                    valid_count += 1
                    yield fixed_time
        # Auto incremented time
        else:
            increment = self.pit_time_increment
            for idx in range(max_prediction):
                yield target_pit_time + increment * idx

    def classes_style(self, class_name: str) -> str:
        """Get vehicle class style from brush cache"""
        if class_name in self.brush_classes:
            return self.brush_classes[class_name]
        # Get vehicle class style from user defined dictionary
        brush = QBrush(Qt.SolidPattern)
        styles = self.cfg.user.classes.get(class_name)
        if styles is not None:
            brush.setColor(styles["color"])
        else:
            brush.setColor(random_color_class(class_name))
        # Add to brush cache
        self.brush_classes[class_name] = brush
        return brush

    def update_proximity_rect(self):
        """Update proximity circle rect"""
        proxi_radius = max(self.wcfg["proximity_circle_radius"], 1)
        proxi_x = -proxi_radius * self.map_scale
        proxi_y = proxi_radius * 2 * self.map_scale
        self.rect_proximity.setRect(proxi_x, proxi_x, proxi_y, proxi_y)

    # Additional methods
    def outline_vehicle(self, veh_info):
        """Set vehicle outline"""
        if veh_info.isPlayer:
            return self.pen_veh[1]
        if not self.wcfg["show_lap_difference_outline"]:
            return self.pen_veh[0]
        if veh_info.isLapped > 0:
            return self.pen_veh[2]
        if veh_info.isLapped < 0:
            return self.pen_veh[3]
        return self.pen_veh[0]

    def color_vehicle(self, veh_info):
        """Set vehicle color"""
        if veh_info.isYellow and not veh_info.inPit:
            return self.brush_overall["yellow"]
        if veh_info.inPit and not veh_info.isPlayer:
            return self.brush_overall["in_pit"]
        if self.wcfg["enable_multi_class_styling"]:
            if self.wcfg["show_custom_player_color_in_multi_class"] and veh_info.isPlayer:
                return self.brush_overall["player"]
            return self.classes_style(veh_info.vehicleClass)
        if veh_info.isPlayer:
            return self.brush_overall["player"]
        if veh_info.positionOverall == 1:
            return self.brush_overall["leader"]
        if veh_info.isLapped > 0:
            return self.brush_overall["laps_ahead"]
        if veh_info.isLapped < 0:
            return self.brush_overall["laps_behind"]
        return self.brush_overall["same_lap"]

    def set_veh_pen_style(self, color: str, width: int):
        """Set vehicle pen style"""
        if width > 0:
            pen_veh = QPen()
            pen_veh.setWidth(width)
            pen_veh.setColor(color)
        else:
            pen_veh = Qt.NoPen
        return pen_veh

    def set_veh_brush_style(self, *suffixes: str) -> dict:
        """Set vehicle brush style"""
        return {
            suffix: QBrush(self.wcfg[f"vehicle_color_{suffix}"], Qt.SolidPattern)
            for suffix in suffixes
        }

    def set_fixed_pit_time(self):
        """Set fixed target pit time"""
        for idx in range(1, 11):
            fixed_time = self.wcfg[f"fixed_pitstop_duration_{idx}"]
            if fixed_time >= 0:
                yield fixed_time + self.pitout_time_offset


def target_pitstop_duration(pit_timer: float, min_pit_time: float, pit_time_increment: float) -> float:
    """Target pitstop duration = min pit duration + pit duration increment * number of increments"""
    overflow_increments = max(pit_timer - min_pit_time + pit_time_increment, 0) // pit_time_increment
    return min_pit_time + pit_time_increment * overflow_increments


def target_node_time(position: float, delta_data: tuple, max_index: int, laptime_scale: float) -> float:
    """Calculate target node time from target position and deltabest dataset"""
    pitin_node_index = calc.binary_search_higher_column(delta_data, position, 0, max_index, 0)
    return delta_data[pitin_node_index][1] / laptime_scale

```

# File: tinypedal/widget/track_notes.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Track notes Widget
"""

from ..api_control import api
from ..const_common import TEXT_NOTAVAILABLE
from ..module_info import minfo
from ..userfile.track_notes import COLUMN_COMMENT, COLUMN_DISTANCE, COLUMN_TRACKNOTE
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        notes_width = max(int(self.wcfg["track_notes_width"]), 1)
        comments_width = max(int(self.wcfg["comments_width"]), 1)
        debugging_width = max(int(self.wcfg["debugging_width"]), 1)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        if self.wcfg["show_background"]:
            bg_color_notes = self.wcfg["bkg_color_track_notes"]
            bg_color_comments = self.wcfg["bkg_color_comments"]
            bg_color_debugging = self.wcfg["bkg_color_debugging"]
        else:
            bg_color_notes = ""
            bg_color_comments = ""
            bg_color_debugging = ""

        # Track notes
        if self.wcfg["show_track_notes"]:
            bar_style_notes = self.set_qss(
                fg_color=self.wcfg["font_color_track_notes"],
                bg_color=bg_color_notes
            )
            self.bar_notes = self.set_qlabel(
                text="TRACK NOTES",
                style=bar_style_notes,
                width=font_m.width * notes_width + bar_padx,
                align=self.wcfg["track_notes_text_alignment"],
            )
            self.set_primary_orient(
                target=self.bar_notes,
                column=self.wcfg["column_index_track_notes"],
            )

        # Comments
        if self.wcfg["show_comments"]:
            bar_style_comments = self.set_qss(
                fg_color=self.wcfg["font_color_comments"],
                bg_color=bg_color_comments
            )
            self.bar_comments = self.set_qlabel(
                text="COMMENTS",
                style=bar_style_comments,
                width=font_m.width * comments_width + bar_padx,
                align=self.wcfg["comments_text_alignment"],
            )
            self.set_primary_orient(
                target=self.bar_comments,
                column=self.wcfg["column_index_comments"],
            )

        # Debugging info
        if self.wcfg["show_debugging"]:
            bar_style_debugging = self.set_qss(
                fg_color=self.wcfg["font_color_debugging"],
                bg_color=bg_color_debugging
            )
            self.bar_debugging = self.set_qlabel(
                text="DEBUGGING",
                style=bar_style_debugging,
                width=font_m.width * debugging_width + bar_padx,
                align=self.wcfg["debugging_text_alignment"],
            )
            self.set_primary_orient(
                target=self.bar_debugging,
                column=self.wcfg["column_index_debugging"],
            )

        # Last data
        self.last_notes_index = None
        self.last_auto_hide = False
        self.last_etime = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        pit_override = self.wcfg["show_pit_notes_while_in_pit"] and api.read.vehicle.in_pits()

        if pit_override or api.read.vehicle.in_garage():
            self.update_auto_hide(False)
        elif minfo.tracknotes.currentNote:
            if self.wcfg["maximum_display_duration"] <= 0:
                self.update_auto_hide(False)
            else:
                etime = api.read.timing.elapsed()
                notes_index = minfo.tracknotes.currentIndex
                if self.last_notes_index != notes_index:
                    self.last_notes_index = notes_index
                    self.last_etime = etime
                if self.last_etime > etime:
                    self.last_etime = etime
                self.update_auto_hide(
                    etime - self.last_etime > self.wcfg["maximum_display_duration"])
        elif self.wcfg["auto_hide_if_not_available"]:
            self.update_auto_hide(True)

        if self.wcfg["show_track_notes"]:
            if pit_override:
                notes = self.wcfg["pit_notes_text"]
            else:
                notes = minfo.tracknotes.currentNote.get(COLUMN_TRACKNOTE, TEXT_NOTAVAILABLE)
            self.update_notes(self.bar_notes, notes)

        if self.wcfg["show_comments"]:
            if pit_override:
                comments = self.wcfg["pit_comments_text"]
            else:
                comments = minfo.tracknotes.currentNote.get(COLUMN_COMMENT, TEXT_NOTAVAILABLE)
            self.update_comments(self.bar_comments, comments)

        if self.wcfg["show_debugging"]:
            if pit_override:
                debugging = TEXT_NOTAVAILABLE
            else:
                debugging = minfo.tracknotes.currentNote.get(COLUMN_DISTANCE, TEXT_NOTAVAILABLE)
            self.update_debugging(self.bar_debugging, debugging)

    # GUI update methods
    def update_notes(self, target, data):
        """Track notes"""
        if target.last != data:
            target.last = data
            if self.wcfg["track_notes_uppercase"]:
                data = data.upper()
            target.setText(data)

    def update_comments(self, target, data):
        """Comments"""
        if target.last != data:
            target.last = data
            if self.wcfg["enable_comments_line_break"]:
                data = data.replace("\\n", "\n")
            target.setText(data)

    def update_debugging(self, target, data):
        """Debugging info"""
        if target.last != data:
            target.last = data
            if data != TEXT_NOTAVAILABLE:
                data = (
                    f"IDX:{minfo.tracknotes.currentIndex + 1} "
                    f"POS:{data:.0f}>>{minfo.tracknotes.nextNote.get(COLUMN_DISTANCE, 0):.0f}m"
                )
            target.setText(data)

    def update_auto_hide(self, auto_hide):
        """Auto hide"""
        if self.last_auto_hide != auto_hide:
            self.last_auto_hide = auto_hide
            if self.wcfg["show_track_notes"]:
                self.bar_notes.setHidden(auto_hide)
            if self.wcfg["show_comments"]:
                self.bar_comments.setHidden(auto_hide)
            if self.wcfg["show_debugging"]:
                self.bar_debugging.setHidden(auto_hide)

```

# File: tinypedal/widget/trailing.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Trailing Widget
"""

from PySide2.QtCore import QPointF, QRect, Qt
from PySide2.QtGui import QPainter, QPen, QPixmap

from ..api_control import api
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)

        # Config variable
        self.margin = max(int(self.wcfg["display_margin"]), 0)
        self.display_height = max(int(self.wcfg["display_height"]), 2)
        self.area_width = max(int(self.wcfg["display_width"]), 2)
        self.area_height = self.display_height + self.margin * 2
        self.display_scale = max(int(
            self.wcfg["update_interval"] / 20 * self.wcfg["display_scale"]), 1)

        max_line_width = int(max(
            1,
            self.wcfg["throttle_line_width"],
            self.wcfg["brake_line_width"],
            self.wcfg["clutch_line_width"],
            self.wcfg["ffb_line_width"],
            self.wcfg["steering_line_width"],
        ))
        max_samples = 3 + max_line_width  # 3 offset + max line width
        self.samples_offset = max_samples - 2

        # Config canvas
        self.resize(self.area_width, self.area_height)
        self.rect_viewport = self.set_viewport_orientation()

        self.pixmap_background = QPixmap(self.area_width, self.area_height)
        self.pixmap_plot = QPixmap(self.area_width, self.area_height)
        self.pixmap_plot.fill(Qt.transparent)
        self.pixmap_plot_section = QPixmap(self.display_scale * 3, self.area_height)
        self.pixmap_plot_section.fill(Qt.transparent)

        if self.wcfg["show_throttle"]:
            self.data_throttle = self.create_data_samples(max_samples)
        if self.wcfg["show_brake"]:
            self.data_brake = self.create_data_samples(max_samples)
        if self.wcfg["show_clutch"]:
            self.data_clutch = self.create_data_samples(max_samples)
        if self.wcfg["show_ffb"]:
            self.data_ffb = self.create_data_samples(max_samples)
        if self.wcfg["show_steering"]:
            self.data_steering = self.create_data_samples(max_samples)
        if self.wcfg["show_wheel_lock"]:
            self.data_wheel_lock = self.create_data_samples(max_samples)
        if self.wcfg["show_wheel_slip"]:
            self.data_wheel_slip = self.create_data_samples(max_samples)

        self.draw_queue = sorted(self.config_draw_order(), reverse=True)
        self.draw_background()

        # Last data
        self.last_lap_etime = -1
        self.update_plot = 1

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Use elapsed time to determine whether data paused
        # Add 1 extra update compensation
        lap_etime = api.read.timing.elapsed()
        if self.last_lap_etime != lap_etime:
            self.last_lap_etime = lap_etime
            self.update_plot = 2
        elif self.update_plot > 0:
            self.update_plot -= 1

        if self.update_plot:
            throttle_raw = api.read.inputs.throttle_raw()
            brake_raw = api.read.inputs.brake_raw()

            if self.wcfg["show_throttle"]:
                if self.wcfg["show_raw_throttle"]:
                    throttle = throttle_raw
                else:
                    throttle = api.read.inputs.throttle()
                self.update_sample(self.data_throttle, throttle)

            if self.wcfg["show_brake"]:
                if self.wcfg["show_raw_brake"]:
                    brake = brake_raw
                else:
                    brake = api.read.inputs.brake()
                self.update_sample(self.data_brake, brake)

            if self.wcfg["show_clutch"]:
                if self.wcfg["show_raw_clutch"]:
                    clutch = api.read.inputs.clutch_raw()
                else:
                    clutch = api.read.inputs.clutch()
                self.update_sample(self.data_clutch, clutch)

            if self.wcfg["show_steering"]:
                if self.wcfg["show_inverted_steering"]:
                    steering = 1 - (api.read.inputs.steering() + 1) / 2
                else:
                    steering = (api.read.inputs.steering() + 1) / 2
                self.update_sample(self.data_steering, steering)

            if self.wcfg["show_ffb"]:
                if self.wcfg["show_absolute_ffb"]:
                    ffb = abs(api.read.inputs.force_feedback())
                else:
                    ffb = (api.read.inputs.force_feedback() + 1) / 2
                self.update_sample(self.data_ffb, ffb)

            if self.wcfg["show_wheel_lock"]:
                wheel_lock = min(abs(min(minfo.wheels.slipRatio)), 1)
                if wheel_lock < self.wcfg["wheel_lock_threshold"] or brake_raw <= 0.02:
                    wheel_lock = -999
                self.update_sample(self.data_wheel_lock, wheel_lock)

            if self.wcfg["show_wheel_slip"]:
                wheel_slip = min(max(minfo.wheels.slipRatio), 1)
                if wheel_slip < self.wcfg["wheel_slip_threshold"] or throttle_raw <= 0.02:
                    wheel_slip = -999
                self.update_sample(self.data_wheel_slip, wheel_slip)

            # Update after all pedal data set
            self.draw_plot_section()
            self.draw_plot()
            self.update()  # trigger paint event

    # GUI update methods
    def paintEvent(self, event):
        """Draw"""
        painter = QPainter(self)
        painter.setViewport(self.rect_viewport)
        painter.drawPixmap(0, 0, self.pixmap_background)
        painter.drawPixmap(0, 0, self.pixmap_plot)

    def draw_background(self):
        """Draw background"""
        self.pixmap_background.fill(self.wcfg["bkg_color"])
        painter = QPainter(self.pixmap_background)
        painter.setRenderHint(QPainter.Antialiasing, True)
        # Draw reference line
        if self.wcfg["show_reference_line"]:
            pen = QPen()
            for idx in range(1, 6):
                self.draw_reference_line(
                    painter, pen,
                    self.wcfg[f"reference_line_{idx}_style"],
                    self.wcfg[f"reference_line_{idx}_offset"],
                    self.wcfg[f"reference_line_{idx}_width"],
                    self.wcfg[f"reference_line_{idx}_color"]
                )

    def draw_reference_line(self, painter, pen, style, offset, width, color):
        """Draw reference line"""
        if width > 0:
            pen.setStyle(Qt.DashLine if style else Qt.SolidLine)
            pen.setWidth(width)
            pen.setColor(color)
            painter.setPen(pen)
            pos_offset = self.display_height * offset + self.margin
            painter.drawLine(0, pos_offset, self.area_width, pos_offset)

    def draw_plot(self):
        """Draw final plot"""
        painter = QPainter(self.pixmap_plot)
        painter.setCompositionMode(QPainter.CompositionMode_Source)
        # Draw last plot, +3 sample offset, -2 sample crop
        painter.drawPixmap(
            self.display_scale * 3, 0, self.pixmap_plot,
            self.display_scale * 2, 0, 0 ,0)
        # Draw section plot
        painter.drawPixmap(0, 0, self.pixmap_plot_section)

    def draw_plot_section(self):
        """Draw section plot"""
        self.pixmap_plot_section.fill(Qt.transparent)
        painter = QPainter(self.pixmap_plot_section)
        painter.setRenderHint(QPainter.Antialiasing, True)
        for _, data, pen, line_style in self.draw_queue:
            painter.setPen(pen)
            if line_style:
                painter.drawPoints(data)
            else:
                painter.drawPolyline(data)

    # Additional methods
    def create_data_samples(self, max_samples):
        """Create data sample list"""
        return tuple(QPointF(index * self.display_scale, 0) for index in range(max_samples))

    def update_sample(self, dataset, value):
        """Update input position samples"""
        # Scale & set new input position
        dataset[0].setY(value * self.display_height + self.margin)
        # Move old input data (Y) 1 display unit to right
        for index in range(self.samples_offset, -1, -1):
            dataset[index + 1].setY(dataset[index].y())

    def set_viewport_orientation(self):
        """Set viewport orientation"""
        if self.wcfg["show_inverted_pedal"]:
            y_pos = 0
            height = self.area_height
        else:
            y_pos = self.area_height
            height = -self.area_height
        if self.wcfg["show_inverted_trailing"]:  # right alignment
            x_pos = self.area_width
            width = -self.area_width
        else:
            x_pos = 0
            width = self.area_width
        return QRect(x_pos, y_pos, width, height)

    def config_draw_order(self):
        """Config plot draw order"""
        plot_names = (
            "throttle",
            "brake",
            "clutch",
            "ffb",
            "steering",
            "wheel_lock",
            "wheel_slip",
        )
        for plot_name in plot_names:
            if not self.wcfg[f"show_{plot_name}"]:
                continue
            pen = QPen()
            pen.setCapStyle(Qt.RoundCap)
            pen.setWidth(self.wcfg[f"{plot_name}_line_width"])
            pen.setColor(self.wcfg[f"{plot_name}_color"])
            yield (
                self.wcfg[f"draw_order_index_{plot_name}"],  # index
                getattr(self, f"data_{plot_name}"),  # data
                pen,  # pen style
                self.wcfg[f"{plot_name}_line_style"],  # line style
            )

```

# File: tinypedal/widget/tyre_carcass.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Tyre carcass temperature Widget
"""

from functools import partial

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NA, TEXT_PLACEHOLDER, WHEELS_ZERO
from ..units import set_unit_temperature
from ..userfile.heatmap import (
    HEATMAP_DEFAULT_TYRE,
    load_heatmap_style,
    select_compound_symbol,
    select_tyre_heatmap_name,
)
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        inner_gap = self.wcfg["inner_gap"]
        self.rate_interval = min(max(self.wcfg["rate_of_change_interval"], 1), 60)
        self.leading_zero = min(max(self.wcfg["leading_zero"], 1), 3) + 0.0  # no decimal
        self.sign_text = "Â°" if self.wcfg["show_degree_sign"] else ""
        text_width = 3 + len(self.sign_text) + (self.cfg.units["temperature_unit"] == "Fahrenheit")

        # Config units
        self.unit_temp = set_unit_temperature(self.cfg.units["temperature_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        bar_style_tcmpd = self.set_qss(
            fg_color=self.wcfg["font_color_tyre_compound"],
            bg_color=self.wcfg["bkg_color_tyre_compound"]
        )
        bar_style_ctemp = self.set_qss(
            fg_color=self.wcfg["font_color_carcass"],
            bg_color=self.wcfg["bkg_color_carcass"]
        )

        # Heatmap style list: 0 - fl, 1 - fr, 2 - rl, 3 - rr
        self.heatmap_styles = 4 * [
            load_heatmap_style(
                heatmap_name=self.wcfg["heatmap_name"],
                default_name=HEATMAP_DEFAULT_TYRE,
                swap_style=self.wcfg["swap_style"],
                fg_color=self.wcfg["font_color_carcass"],
                bg_color=self.wcfg["bkg_color_carcass"],
            )
        ]

        # Tyre carcass temperature
        layout_ctemp = self.set_grid_layout(gap=inner_gap)
        self.bars_ctemp = self.set_qlabel(
            text=TEXT_NA,
            style=bar_style_ctemp,
            width=font_m.width * text_width + bar_padx,
            count=4,
            last=0,
        )
        self.set_grid_layout_quad(
            layout=layout_ctemp,
            targets=self.bars_ctemp,
        )
        self.set_primary_orient(
            target=layout_ctemp,
            column=self.wcfg["column_index_carcass"],
        )

        if self.wcfg["show_tyre_compound"]:
            self.bars_tcmpd = self.set_qlabel(
                text=TEXT_PLACEHOLDER,
                style=bar_style_tcmpd,
                width=font_m.width + bar_padx,
                count=2,
            )
            self.set_grid_layout_vert(
                layout=layout_ctemp,
                targets=self.bars_tcmpd,
            )

        # Rate of change
        if self.wcfg["show_rate_of_change"]:
            layout_rtemp = self.set_grid_layout(gap=inner_gap)
            self.bar_style_rtemp = (
                self.set_qss(
                    fg_color=self.wcfg["bkg_color_rate_of_change"],
                    bg_color=self.wcfg["font_color_rate_loss"]),
                self.set_qss(
                    fg_color=self.wcfg["bkg_color_rate_of_change"],
                    bg_color=self.wcfg["font_color_rate_gain"]),
                self.set_qss(
                    fg_color=self.wcfg["bkg_color_rate_of_change"],
                    bg_color=self.wcfg["font_color_rate_of_change"]),
            ) if self.wcfg["swap_style"] else (
                self.set_qss(
                    fg_color=self.wcfg["font_color_rate_loss"],
                    bg_color=self.wcfg["bkg_color_rate_of_change"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_rate_gain"],
                    bg_color=self.wcfg["bkg_color_rate_of_change"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_rate_of_change"],
                    bg_color=self.wcfg["bkg_color_rate_of_change"]),
            )
            self.bars_rdiff = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_rtemp[2],
                width=font_m.width * text_width + bar_padx,
                count=4,
                last=0,
            )
            self.set_grid_layout_quad(
                layout=layout_rtemp,
                targets=self.bars_rdiff,
            )
            self.set_primary_orient(
                target=layout_rtemp,
                column=self.wcfg["column_index_rate_of_change"],
            )
            self.calc_ema_rdiff = partial(
                calc.exp_mov_avg,
                calc.ema_factor(self.wcfg["rate_of_change_smoothing_samples"])
            )

            if self.wcfg["show_tyre_compound"]:
                bars_blank = self.set_qlabel(
                    text="",
                    style=bar_style_tcmpd,
                    width=font_m.width + bar_padx,
                    count=2,
                )
                self.set_grid_layout_vert(
                    layout=layout_rtemp,
                    targets=bars_blank
                )

        # Last data
        self.last_in_pits = -1
        self.last_tcmpd_f = ""
        self.last_tcmpd_r = ""
        self.last_rtemp = list(WHEELS_ZERO)
        self.last_lap_etime = 0

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Update compound while in pit (or switched pit state)
        in_pits = api.read.vehicle.in_pits()
        if in_pits or self.last_in_pits != in_pits:
            self.last_in_pits = in_pits
            class_name = api.read.vehicle.class_name()
            tcmpd_f = f"{class_name} - {api.read.tyre.compound_name_front()}"
            tcmpd_r = f"{class_name} - {api.read.tyre.compound_name_rear()}"

            # Heatmap style
            if self.wcfg["enable_heatmap_auto_matching"]:
                if self.last_tcmpd_f != tcmpd_f:
                    self.update_heatmap(tcmpd_f, 0)
                    self.last_tcmpd_f = tcmpd_f
                if self.last_tcmpd_r != tcmpd_r:
                    self.update_heatmap(tcmpd_r, 2)
                    self.last_tcmpd_r = tcmpd_r

            # Tyre compound
            if self.wcfg["show_tyre_compound"]:
                self.update_tcmpd(self.bars_tcmpd[0], tcmpd_f)
                self.update_tcmpd(self.bars_tcmpd[1], tcmpd_r)

        # Tyre carcass temperature: 0 - fl, 1 - fr, 2 - rl, 3 - rr
        ctemp = api.read.tyre.carcass_temperature()
        for tyre_idx, bar_ctemp in enumerate(self.bars_ctemp):
            self.update_ctemp(bar_ctemp, round(ctemp[tyre_idx]), tyre_idx)

        # Rate of change
        if self.wcfg["show_rate_of_change"]:
            lap_etime = api.read.timing.elapsed()

            if self.last_lap_etime > lap_etime:
                self.last_lap_etime = lap_etime
            elif lap_etime - self.last_lap_etime >= 0.1:
                interval = self.rate_interval / (lap_etime - self.last_lap_etime)
                self.last_lap_etime = lap_etime

                for tyre_idx, bar_rdiff in enumerate(self.bars_rdiff):
                    rdiff = self.calc_ema_rdiff(
                        bar_rdiff.last,
                        (ctemp[tyre_idx] - self.last_rtemp[tyre_idx]) * interval
                    )
                    self.last_rtemp[tyre_idx] = ctemp[tyre_idx]
                    self.update_rdiff(bar_rdiff, rdiff)

    # GUI update methods
    def update_ctemp(self, target, data, index):
        """Tyre carcass temperature"""
        if target.last != data:
            target.last = data
            if data < -100:
                target.setText(TEXT_PLACEHOLDER)
            else:
                target.setText(f"{self.unit_temp(data):0{self.leading_zero}f}{self.sign_text}")
            target.updateStyle(calc.select_grade(self.heatmap_styles[index], data))

    def update_rdiff(self, target, data):
        """Rate of change"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.unit_temp(abs(data)):.1f}"[:3].strip("."))
            target.updateStyle(self.bar_style_rtemp[data > 0])

    def update_tcmpd(self, target, data):
        """Tyre compound"""
        if target.last != data:
            target.last = data
            target.setText(select_compound_symbol(data))

    def update_heatmap(self, compound, index):
        """Heatmap style"""
        heatmap_style = load_heatmap_style(
            heatmap_name=select_tyre_heatmap_name(compound),
            default_name=HEATMAP_DEFAULT_TYRE,
            swap_style=self.wcfg["swap_style"],
            fg_color=self.wcfg["font_color_carcass"],
            bg_color=self.wcfg["bkg_color_carcass"],
        )
        self.heatmap_styles[index] = heatmap_style
        self.heatmap_styles[index + 1] = heatmap_style

```

# File: tinypedal/widget/tyre_inner_layer.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Tyre inner layer temperature Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NA, TEXT_PLACEHOLDER
from ..units import set_unit_temperature
from ..userfile.heatmap import (
    HEATMAP_DEFAULT_TYRE,
    load_heatmap_style,
    select_compound_symbol,
    select_tyre_heatmap_name,
)
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(
            gap_hori=self.wcfg["horizontal_gap"],
            gap_vert=self.wcfg["vertical_gap"],
        )
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        inner_gap = self.wcfg["inner_gap"]
        self.leading_zero = min(max(self.wcfg["leading_zero"], 1), 3) + 0.0  # no decimal
        self.sign_text = "Â°" if self.wcfg["show_degree_sign"] else ""
        text_width = 3 + len(self.sign_text) + (self.cfg.units["temperature_unit"] == "Fahrenheit")

        # Config units
        self.unit_temp = set_unit_temperature(self.cfg.units["temperature_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        bar_style_tcmpd = self.set_qss(
            fg_color=self.wcfg["font_color_tyre_compound"],
            bg_color=self.wcfg["bkg_color_tyre_compound"]
        )
        bar_style_itemp = self.set_qss(
            fg_color=self.wcfg["font_color_inner_layer"],
            bg_color=self.wcfg["bkg_color_inner_layer"]
        )

        # Heatmap style list: 0 - fl, 1 - fr, 2 - rl, 3 - rr
        self.heatmap_styles = 4 * [
            load_heatmap_style(
                heatmap_name=self.wcfg["heatmap_name"],
                default_name=HEATMAP_DEFAULT_TYRE,
                swap_style=self.wcfg["swap_style"],
                fg_color=self.wcfg["font_color_inner_layer"],
                bg_color=self.wcfg["bkg_color_inner_layer"],
            )
        ]

        # Tyre inner temperature
        self.bars_itemp = self.set_table(
            text=TEXT_NA,
            style=bar_style_itemp,
            width=font_m.width * text_width + bar_padx,
            layout=layout,
            inner_gap=inner_gap,
        )

        # Tyre compound
        if self.wcfg["show_tyre_compound"]:
            self.bars_tcmpd = self.set_qlabel(
                text=TEXT_PLACEHOLDER,
                style=bar_style_tcmpd,
                width=font_m.width + bar_padx,
                count=2,
            )
            self.set_grid_layout_vert(
                layout=layout,
                targets=self.bars_tcmpd,
            )

        # Last data
        self.last_in_pits = -1
        self.last_tcmpd_f = ""
        self.last_tcmpd_r = ""

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Update compound while in pit (or switched pit state)
        in_pits = api.read.vehicle.in_pits()
        if in_pits or self.last_in_pits != in_pits:
            self.last_in_pits = in_pits
            class_name = api.read.vehicle.class_name()
            tcmpd_f = f"{class_name} - {api.read.tyre.compound_name_front()}"
            tcmpd_r = f"{class_name} - {api.read.tyre.compound_name_rear()}"

            # Heatmap style
            if self.wcfg["enable_heatmap_auto_matching"]:
                if self.last_tcmpd_f != tcmpd_f:
                    self.update_heatmap(tcmpd_f, 0)
                    self.last_tcmpd_f = tcmpd_f
                if self.last_tcmpd_r != tcmpd_r:
                    self.update_heatmap(tcmpd_r, 2)
                    self.last_tcmpd_r = tcmpd_r

            # Tyre compound
            if self.wcfg["show_tyre_compound"]:
                self.update_tcmpd(self.bars_tcmpd[0], tcmpd_f)
                self.update_tcmpd(self.bars_tcmpd[1], tcmpd_r)

        # Inner layer temperature: 0 - fl, 3 - fr, 6 - rl, 9 - rr
        if self.wcfg["show_inner_center_outer"]:
            itemp = api.read.tyre.inner_temperature_ico()
            for tyre_idx, bar_itemp in enumerate(self.bars_itemp):
                self.update_itemp(bar_itemp, round(itemp[tyre_idx]), tyre_idx // 3)
        else:  # 0 - fl, 1 - fr, 2 - rl, 3 - rr
            itemp = api.read.tyre.inner_temperature_avg()
            for tyre_idx, bar_itemp in enumerate(self.bars_itemp):
                self.update_itemp(bar_itemp, round(itemp[tyre_idx]), tyre_idx)

    # GUI update methods
    def update_itemp(self, target, data, index):
        """Tyre inner temperature"""
        if target.last != data:
            target.last = data
            if data < -100:
                target.setText(TEXT_PLACEHOLDER)
            else:
                target.setText(f"{self.unit_temp(data):0{self.leading_zero}f}{self.sign_text}")
            target.updateStyle(calc.select_grade(self.heatmap_styles[index], data))

    def update_tcmpd(self, target, data):
        """Tyre compound"""
        if target.last != data:
            target.last = data
            target.setText(select_compound_symbol(data))

    def update_heatmap(self, compound, index):
        """Heatmap style"""
        heatmap_style = load_heatmap_style(
            heatmap_name=select_tyre_heatmap_name(compound),
            default_name=HEATMAP_DEFAULT_TYRE,
            swap_style=self.wcfg["swap_style"],
            fg_color=self.wcfg["font_color_inner_layer"],
            bg_color=self.wcfg["bkg_color_inner_layer"],
        )
        self.heatmap_styles[index] = heatmap_style
        self.heatmap_styles[index + 1] = heatmap_style

    # GUI generate methods
    def set_table(self, text, style, width, layout, inner_gap):
        """Set table"""
        if self.wcfg["show_inner_center_outer"]:
            layout_inner = tuple(self.set_grid_layout(gap=inner_gap) for _ in range(4))
            bar_set = self.set_qlabel(
                text=text,
                style=style,
                width=width,
                count=12,  # 3 x 4 tyres
                last=0,
            )
            for idx, inner in enumerate(layout_inner):
                self.set_grid_layout_table_row(inner, bar_set[idx * 3:idx * 3 + 3])
            self.set_grid_layout_quad(layout, layout_inner)
        else:
            bar_set = self.set_qlabel(
                text=text,
                style=style,
                width=width,
                count=4,
                last=0,
            )
            self.set_grid_layout_quad(layout, bar_set)
        return bar_set

```

# File: tinypedal/widget/tyre_load.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Tyre load Widget
"""

from .. import calculation as calc
from ..api_control import api
from ._base import Overlay
from ._painter import WheelGaugeBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        bar_gap = self.wcfg["bar_gap"]
        bar_gap_hori = self.wcfg["horizontal_gap"]
        bar_gap_vert = self.wcfg["vertical_gap"]
        layout = self.set_grid_layout(gap=bar_gap)
        self.set_primary_layout(layout=layout)

        # Config font
        font = self.config_font(
            self.wcfg["font_name"],
            self.wcfg["font_size"],
            self.wcfg["font_weight"]
        )
        self.setFont(font)
        font_m = self.get_font_metrics(font)
        font_offset = self.calc_font_offset(font_m)

        # Config variable
        padx = round(font_m.width * self.wcfg["bar_padding_horizontal"])
        pady = round(font_m.capital * self.wcfg["bar_padding_vertical"])
        bar_width = max(self.wcfg["bar_width"], 20)
        bar_height = int(font_m.capital + pady * 2)

        # Caption
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_family=self.wcfg["font_name"],
                font_size=int(self.wcfg['font_size'] * self.wcfg['font_scale_caption']),
                font_weight=self.wcfg["font_weight"],
            )
            cap_bar = self.set_qlabel(
                text=self.wcfg["caption_text"],
                style=bar_style_desc,
                fixed_width=bar_width * 2 + bar_gap_hori,
            )
            self.set_primary_orient(
                target=cap_bar,
                column=0,
            )

        # Tyre load
        layout_inner = self.set_grid_layout(gap_hori=bar_gap_hori, gap_vert=bar_gap_vert)
        self.bars_tload = tuple(
            WheelGaugeBar(
                self,
                padding_x=padx,
                bar_width=bar_width,
                bar_height=bar_height,
                font_offset=font_offset,
                input_color=self.wcfg["highlight_color"],
                fg_color=self.wcfg["font_color"],
                bg_color=self.wcfg["bkg_color"],
                right_side=idx % 2,
            ) for idx in range(4)
        )
        self.set_grid_layout_quad(
            layout=layout_inner,
            targets=self.bars_tload,
        )
        self.set_primary_orient(
            target=layout_inner,
            column=1,
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        tload_set = api.read.tyre.load()
        sum_load = sum(tload_set)
        for tload, bar_tload in zip(tload_set, self.bars_tload):
            tratio = calc.part_to_whole_ratio(tload, sum_load)
            if self.wcfg["show_tyre_load_ratio"]:
                tload = tratio
            self.update_tload(bar_tload, round(tload), tratio)

    # GUI update methods
    def update_tload(self, target, data, ratio):
        """Tyre load & ratio"""
        if target.last != data:
            target.last = data
            target.update_input(ratio)

```

# File: tinypedal/widget/tyre_pressure.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Tyre pressure Widget
"""

from functools import partial

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NA, TEXT_PLACEHOLDER, WHEELS_ZERO
from ..units import set_unit_pressure
from ..userfile.heatmap import select_compound_symbol
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        inner_gap = self.wcfg["inner_gap"]
        self.text_width = 3 + (self.cfg.units["tyre_pressure_unit"] != "kPa")
        self.hot_pres_temp = max(self.wcfg["hot_pressure_temperature_threshold"], 0)

        # Config units
        self.unit_pres = set_unit_pressure(self.cfg.units["tyre_pressure_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        bar_style_tcmpd = self.set_qss(
            fg_color=self.wcfg["font_color_tyre_compound"],
            bg_color=self.wcfg["bkg_color_tyre_compound"]
        )
        self.bar_style_tpres = (
            self.set_qss(
                fg_color=self.wcfg["bkg_color_pressure"],
                bg_color=self.wcfg["font_color_pressure_cold"]),
            self.set_qss(
                fg_color=self.wcfg["bkg_color_pressure"],
                bg_color=self.wcfg["font_color_pressure_hot"]),
        ) if self.wcfg["swap_style"] else (
            self.set_qss(
                fg_color=self.wcfg["font_color_pressure_cold"],
                bg_color=self.wcfg["bkg_color_pressure"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_pressure_hot"],
                bg_color=self.wcfg["bkg_color_pressure"]),
        )

        # Tyre pressure
        layout_tpres = self.set_grid_layout(gap=inner_gap)
        self.bars_tpres = self.set_qlabel(
            text=TEXT_NA,
            style=self.bar_style_tpres[0],
            width=font_m.width * self.text_width + bar_padx,
            count=4,
            last=0,
        )
        self.set_grid_layout_quad(
            layout=layout_tpres,
            targets=self.bars_tpres,
        )
        self.set_primary_orient(
            target=layout_tpres,
            column=self.wcfg["column_index_pressure"],
        )

        if self.wcfg["show_tyre_compound"]:
            self.bars_tcmpd = self.set_qlabel(
                text=TEXT_PLACEHOLDER,
                style=bar_style_tcmpd,
                width=font_m.width + bar_padx,
                count=2,
            )
            self.set_grid_layout_vert(
                layout=layout_tpres,
                targets=self.bars_tcmpd,
            )

        # Pressure deviation
        if self.wcfg["show_pressure_deviation"]:
            layout_pdiff = self.set_grid_layout(gap=inner_gap)
            bar_style_pdiff = self.set_qss(
                fg_color=self.wcfg["font_color_pressure_deviation"],
                bg_color=self.wcfg["bkg_color_pressure_deviation"]
            )
            self.bars_pdiff = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_pdiff,
                width=font_m.width * self.text_width + bar_padx,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_pdiff,
                targets=self.bars_pdiff,
            )
            self.set_primary_orient(
                target=layout_pdiff,
                column=self.wcfg["column_index_pressure_deviation"],
            )

            self.tpavg = list(WHEELS_ZERO)
            average_samples = int(min(max(self.wcfg["average_sampling_duration"], 1), 600) / (self._update_interval * 0.001))
            self.calc_ema_tpres = partial(
                calc.exp_mov_avg,
                calc.ema_factor(average_samples)
            )

            if self.wcfg["show_tyre_compound"]:
                bars_blank = self.set_qlabel(
                    text="",
                    style=bar_style_tcmpd,
                    width=font_m.width + bar_padx,
                    count=2,
                )
                self.set_grid_layout_vert(
                    layout=layout_pdiff,
                    targets=bars_blank
                )

        # Last data
        self.last_in_pits = -1

    def timerEvent(self, event):
        """Update when vehicle on track"""
        in_pits = api.read.vehicle.in_pits()

        # Update compound while in pit (or switched pit state)
        if in_pits or self.last_in_pits != in_pits:
            self.last_in_pits = in_pits
            class_name = api.read.vehicle.class_name()
            tcmpd_f = f"{class_name} - {api.read.tyre.compound_name_front()}"
            tcmpd_r = f"{class_name} - {api.read.tyre.compound_name_rear()}"

            # Tyre compound
            if self.wcfg["show_tyre_compound"]:
                self.update_tcmpd(self.bars_tcmpd[0], tcmpd_f)
                self.update_tcmpd(self.bars_tcmpd[1], tcmpd_r)

        # Tyre pressure: 0 - fl, 1 - fr, 2 - rl, 3 - rr
        tpres = api.read.tyre.pressure()
        ctemp = api.read.tyre.carcass_temperature()
        for tyre_idx, bar_tpres in enumerate(self.bars_tpres):
            self.update_tpres(bar_tpres, tpres[tyre_idx], ctemp[tyre_idx] >= self.hot_pres_temp)

        # Pressure deviation
        if self.wcfg["show_pressure_deviation"]:
            peak_pres = max(self.tpavg)
            for tyre_idx, bar_pdiff in enumerate(self.bars_pdiff):
                self.update_pdiff(bar_pdiff, peak_pres - self.tpavg[tyre_idx])
                self.tpavg[tyre_idx] = self.calc_ema_tpres(self.tpavg[tyre_idx], tpres[tyre_idx])

    # GUI update methods
    def update_tpres(self, target, data, is_hot):
        """Tyre pressure"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.unit_pres(data):.2f}"[:self.text_width].strip("."))
            target.updateStyle(self.bar_style_tpres[is_hot])

    def update_pdiff(self, target, data):
        """Pressure deviation"""
        if target.last != data:
            target.last = data
            target.setText(f"{self.unit_pres(abs(data)):.2f}"[:self.text_width].strip("."))

    def update_tcmpd(self, target, data):
        """Tyre compound"""
        if target.last != data:
            target.last = data
            target.setText(select_compound_symbol(data))

```

# File: tinypedal/widget/tyre_temperature.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Tyre temperature Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NA, TEXT_PLACEHOLDER
from ..units import set_unit_temperature
from ..userfile.heatmap import (
    HEATMAP_DEFAULT_TYRE,
    load_heatmap_style,
    select_compound_symbol,
    select_tyre_heatmap_name,
)
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(
            gap_hori=self.wcfg["horizontal_gap"],
            gap_vert=self.wcfg["vertical_gap"],
        )
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        inner_gap = self.wcfg["inner_gap"]
        self.leading_zero = min(max(self.wcfg["leading_zero"], 1), 3) + 0.0  # no decimal
        self.sign_text = "Â°" if self.wcfg["show_degree_sign"] else ""
        text_width = 3 + len(self.sign_text) + (self.cfg.units["temperature_unit"] == "Fahrenheit")

        # Config units
        self.unit_temp = set_unit_temperature(self.cfg.units["temperature_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        bar_style_tcmpd = self.set_qss(
            fg_color=self.wcfg["font_color_tyre_compound"],
            bg_color=self.wcfg["bkg_color_tyre_compound"]
        )
        bar_style_stemp = self.set_qss(
            fg_color=self.wcfg["font_color_surface"],
            bg_color=self.wcfg["bkg_color_surface"]
        )

        # Heatmap style list: 0 - fl, 1 - fr, 2 - rl, 3 - rr
        self.heatmap_styles = 4 * [
            load_heatmap_style(
                heatmap_name=self.wcfg["heatmap_name"],
                default_name=HEATMAP_DEFAULT_TYRE,
                swap_style=self.wcfg["swap_style"],
                fg_color=self.wcfg["font_color_surface"],
                bg_color=self.wcfg["bkg_color_surface"],
            )
        ]

        # Tyre temperature
        self.bars_stemp = self.set_table(
            text=TEXT_NA,
            style=bar_style_stemp,
            width=font_m.width * text_width + bar_padx,
            layout=layout,
            inner_gap=inner_gap,
        )

        # Tyre compound
        if self.wcfg["show_tyre_compound"]:
            self.bars_tcmpd = self.set_qlabel(
                text=TEXT_PLACEHOLDER,
                style=bar_style_tcmpd,
                width=font_m.width + bar_padx,
                count=2,
            )
            self.set_grid_layout_vert(
                layout=layout,
                targets=self.bars_tcmpd,
            )

        # Last data
        self.last_in_pits = -1
        self.last_tcmpd_f = ""
        self.last_tcmpd_r = ""

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Update compound while in pit (or switched pit state)
        in_pits = api.read.vehicle.in_pits()
        if in_pits or self.last_in_pits != in_pits:
            self.last_in_pits = in_pits
            class_name = api.read.vehicle.class_name()
            tcmpd_f = f"{class_name} - {api.read.tyre.compound_name_front()}"
            tcmpd_r = f"{class_name} - {api.read.tyre.compound_name_rear()}"

            # Heatmap style
            if self.wcfg["enable_heatmap_auto_matching"]:
                if self.last_tcmpd_f != tcmpd_f:
                    self.update_heatmap(tcmpd_f, 0)
                    self.last_tcmpd_f = tcmpd_f
                if self.last_tcmpd_r != tcmpd_r:
                    self.update_heatmap(tcmpd_r, 2)
                    self.last_tcmpd_r = tcmpd_r

            # Tyre compound
            if self.wcfg["show_tyre_compound"]:
                self.update_tcmpd(self.bars_tcmpd[0], tcmpd_f)
                self.update_tcmpd(self.bars_tcmpd[1], tcmpd_r)

        # Surface temperature: 0 - fl, 3 - fr, 6 - rl, 9 - rr
        if self.wcfg["show_inner_center_outer"]:
            stemp = api.read.tyre.surface_temperature_ico()
            for tyre_idx, bar_stemp in enumerate(self.bars_stemp):
                self.update_stemp(bar_stemp, round(stemp[tyre_idx]), tyre_idx // 3)
        else:  # 0 - fl, 1 - fr, 2 - rl, 3 - rr
            stemp = api.read.tyre.surface_temperature_avg()
            for tyre_idx, bar_stemp in enumerate(self.bars_stemp):
                self.update_stemp(bar_stemp, round(stemp[tyre_idx]), tyre_idx)

    # GUI update methods
    def update_stemp(self, target, data, index):
        """Tyre surface temperature"""
        if target.last != data:
            target.last = data
            if data < -100:
                target.setText(TEXT_PLACEHOLDER)
            else:
                target.setText(f"{self.unit_temp(data):0{self.leading_zero}f}{self.sign_text}")
            target.updateStyle(calc.select_grade(self.heatmap_styles[index], data))

    def update_tcmpd(self, target, data):
        """Tyre compound"""
        if target.last != data:
            target.last = data
            target.setText(select_compound_symbol(data))

    def update_heatmap(self, compound, index):
        """Heatmap style"""
        heatmap_style = load_heatmap_style(
            heatmap_name=select_tyre_heatmap_name(compound),
            default_name=HEATMAP_DEFAULT_TYRE,
            swap_style=self.wcfg["swap_style"],
            fg_color=self.wcfg["font_color_surface"],
            bg_color=self.wcfg["bkg_color_surface"],
        )
        self.heatmap_styles[index] = heatmap_style
        self.heatmap_styles[index + 1] = heatmap_style

    # GUI generate methods
    def set_table(self, text, style, width, layout, inner_gap):
        """Set table"""
        if self.wcfg["show_inner_center_outer"]:
            layout_inner = tuple(self.set_grid_layout(gap=inner_gap) for _ in range(4))
            bar_set = self.set_qlabel(
                text=text,
                style=style,
                width=width,
                count=12,  # 3 x 4 tyres
                last=0,
            )
            for idx, inner in enumerate(layout_inner):
                self.set_grid_layout_table_row(inner, bar_set[idx * 3:idx * 3 + 3])
            self.set_grid_layout_quad(layout, layout_inner)
        else:
            bar_set = self.set_qlabel(
                text=text,
                style=style,
                width=width,
                count=4,
                last=0,
            )
            self.set_grid_layout_quad(layout, bar_set)
        return bar_set

```

# File: tinypedal/widget/tyre_wear.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Tyre Wear Widget
"""

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NA
from ..module_info import minfo
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        bar_width = font_m.width * 4 + bar_padx

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )
        bar_style_desc = self.set_qss(
            fg_color=self.wcfg["font_color_caption"],
            bg_color=self.wcfg["bkg_color_caption"],
            font_size=int(self.wcfg['font_size'] * 0.8)
        )

        # Remaining tyre tread
        if self.wcfg["show_remaining"]:
            layout_remain = self.set_grid_layout()
            self.bar_style_remain = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_remaining"],
                    bg_color=self.wcfg["bkg_color_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_remaining"])
            )
            self.bars_remain = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_remain[0],
                width=bar_width,
                count=4,
                last=0,
            )
            self.set_grid_layout_quad(
                layout=layout_remain,
                targets=self.bars_remain,
            )
            self.set_primary_orient(
                target=layout_remain,
                column=self.wcfg["column_index_remaining"],
            )

            if self.wcfg["show_caption"]:
                cap_remain = self.set_qlabel(
                    text=self.wcfg["caption_text_remaining"],
                    style=bar_style_desc,
                )
                layout_remain.addWidget(cap_remain, 0, 0, 1, 0)

        # Wear difference
        if self.wcfg["show_wear_difference"]:
            layout_diff = self.set_grid_layout()
            self.bar_style_diff = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_wear_difference"],
                    bg_color=self.wcfg["bkg_color_wear_difference"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_wear_difference"])
            )
            self.bars_diff = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_diff[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_diff,
                targets=self.bars_diff,
            )
            self.set_primary_orient(
                target=layout_diff,
                column=self.wcfg["column_index_wear_difference"],
            )

            if self.wcfg["show_caption"]:
                cap_diff = self.set_qlabel(
                    text=self.wcfg["caption_text_wear_difference"],
                    style=bar_style_desc,
                )
                layout_diff.addWidget(cap_diff, 0, 0, 1, 0)

        # Live wear difference
        if self.wcfg["show_live_wear_difference"]:
            layout_live = self.set_grid_layout()
            self.bar_style_live = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_live_wear_difference"],
                    bg_color=self.wcfg["bkg_color_live_wear_difference"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_live_wear_difference"])
            )
            self.bars_live = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_live[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_live,
                targets=self.bars_live,
            )
            self.set_primary_orient(
                target=layout_live,
                column=self.wcfg["column_index_live_wear_difference"],
            )

            if self.wcfg["show_caption"]:
                cap_live = self.set_qlabel(
                    text=self.wcfg["caption_text_live_wear_difference"],
                    style=bar_style_desc,
                )
                layout_live.addWidget(cap_live, 0, 0, 1, 0)

        # Estimated lifespan in laps
        if self.wcfg["show_lifespan_laps"]:
            layout_laps = self.set_grid_layout()
            self.bar_style_laps = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_lifespan_laps"],
                    bg_color=self.wcfg["bkg_color_lifespan_laps"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_lifespan_laps"])
            )
            self.bars_laps = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_laps[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_laps,
                targets=self.bars_laps,
            )
            self.set_primary_orient(
                target=layout_laps,
                column=self.wcfg["column_index_lifespan_laps"],
            )

            if self.wcfg["show_caption"]:
                cap_laps = self.set_qlabel(
                    text=self.wcfg["caption_text_lifespan_laps"],
                    style=bar_style_desc,
                )
                layout_laps.addWidget(cap_laps, 0, 0, 1, 0)

        # Estimated lifespan in minutes
        if self.wcfg["show_lifespan_minutes"]:
            layout_mins = self.set_grid_layout()
            self.bar_style_mins = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_lifespan_minutes"],
                    bg_color=self.wcfg["bkg_color_lifespan_minutes"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_lifespan_minutes"])
            )
            self.bars_mins = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_mins[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_mins,
                targets=self.bars_mins,
            )
            self.set_primary_orient(
                target=layout_mins,
                column=self.wcfg["column_index_lifespan_minutes"],
            )

            if self.wcfg["show_caption"]:
                cap_mins = self.set_qlabel(
                    text=self.wcfg["caption_text_lifespan_minutes"],
                    style=bar_style_desc,
                )
                layout_mins.addWidget(cap_mins, 0, 0, 1, 0)

        # Estimated end stint remaining tyre tread
        if self.wcfg["show_end_stint_remaining"]:
            layout_end = self.set_grid_layout()
            self.bar_style_end = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_end_stint_remaining"],
                    bg_color=self.wcfg["bkg_color_end_stint_remaining"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_warning"],
                    bg_color=self.wcfg["bkg_color_end_stint_remaining"])
            )
            self.bars_end = self.set_qlabel(
                text=TEXT_NA,
                style=self.bar_style_end[0],
                width=bar_width,
                count=4,
            )
            self.set_grid_layout_quad(
                layout=layout_end,
                targets=self.bars_end,
            )
            self.set_primary_orient(
                target=layout_end,
                column=self.wcfg["column_index_end_stint_remaining"],
            )

            if self.wcfg["show_caption"]:
                cap_end = self.set_qlabel(
                    text=self.wcfg["caption_text_end_stint_remaining"],
                    style=bar_style_desc,
                )
                layout_end.addWidget(cap_end, 0, 0, 1, 0)

    def timerEvent(self, event):
        """Update when vehicle on track"""
        laptime_pace = minfo.delta.lapTimePace
        if api.read.vehicle.max_virtual_energy():
            est_runlaps = min(minfo.fuel.estimatedLaps, minfo.energy.estimatedLaps)
        else:
            est_runlaps = minfo.fuel.estimatedLaps

        for idx in range(4):
            tread_curr = minfo.wheels.currentTreadDepth[idx]
            live_wear = minfo.wheels.currentLapTreadWear[idx]
            est_wear = minfo.wheels.estimatedTreadWear[idx]
            est_valid_wear = minfo.wheels.estimatedValidTreadWear[idx]

            # Remaining tyre tread
            if self.wcfg["show_remaining"]:
                self.update_remain(self.bars_remain[idx], tread_curr)

            # Wear differences
            if self.wcfg["show_wear_difference"]:
                self.update_diff(self.bars_diff[idx], est_wear)

            # Live wear difference
            if self.wcfg["show_live_wear_difference"]:
                self.update_live(self.bars_live[idx], live_wear)

            # Estimated lifespan in laps
            if self.wcfg["show_lifespan_laps"]:
                wear_laps = calc.wear_lifespan_in_laps(tread_curr, est_valid_wear)
                self.update_laps(self.bars_laps[idx], wear_laps)

            # Estimated lifespan in minutes
            if self.wcfg["show_lifespan_minutes"]:
                wear_mins = calc.wear_lifespan_in_mins(tread_curr, est_valid_wear, laptime_pace)
                self.update_mins(self.bars_mins[idx], wear_mins)

            # Estimated end stint remaining tyre tread
            if self.wcfg["show_end_stint_remaining"]:
                end_remain = calc.end_stint_tread(tread_curr, est_valid_wear, est_runlaps)
                self.update_end(self.bars_end[idx], end_remain)

    # GUI update methods
    def update_remain(self, target, data):
        """Remaining tyre tread"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_remain[data <= self.wcfg["warning_threshold_remaining"]]
            )

    def update_diff(self, target, data):
        """Wear differences"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_diff[data > self.wcfg["warning_threshold_wear"]]
            )

    def update_live(self, target, data):
        """Live wear differences"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_live[data > self.wcfg["warning_threshold_wear"]]
            )

    def update_laps(self, target, data):
        """Estimated lifespan in laps"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_laps[data <= self.wcfg["warning_threshold_laps"]]
            )

    def update_mins(self, target, data):
        """Estimated lifespan in minutes"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_mins[data <= self.wcfg["warning_threshold_minutes"]]
            )

    def update_end(self, target, data):
        """End stint remaining tyre tread"""
        if target.last != data:
            target.last = data
            target.setText(self.format_num(data))
            target.updateStyle(
                self.bar_style_end[data <= self.wcfg["warning_threshold_remaining"]]
            )

    # Additional methods
    @staticmethod
    def format_num(value):
        """Format number"""
        return f"{value:.2f}"[:4].strip(".")

```

# File: tinypedal/widget/virtual_energy.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Virtual energy Widget
"""

from .. import calculation as calc
from ..module_info import minfo
from ._base import Overlay
from ._common import WarningFlash
from ._painter import FuelLevelBar


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        text_def = "-.--"
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.bar_width = max(self.wcfg["bar_width"], 3)
        style_width = font_m.width * self.bar_width + bar_padx
        column_count = 0

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Create layout
        layout_upper = self.set_grid_layout()
        layout_lower = self.set_grid_layout()
        layout.addLayout(layout_upper, self.wcfg["column_index_upper"], 0)
        layout.addLayout(layout_lower, self.wcfg["column_index_lower"], 0)

        # Caption style
        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_size=int(self.wcfg['font_size'] * 0.8)
            )
            row_idx_upper = 2 * self.wcfg["swap_upper_caption"]
            row_idx_lower = 2 - 2 * self.wcfg["swap_lower_caption"]

        # Remaining
        self.bar_style_curr = (
            self.set_qss(
                fg_color=self.wcfg["font_color_remain"],
                bg_color=self.wcfg["bkg_color_remain"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_remain"],
                bg_color=self.wcfg["warning_color_low_energy"])
        )
        self.bar_curr = self.set_qlabel(
            text=text_def,
            style=self.bar_style_curr[0],
            fixed_width=style_width,
        )
        self.bar_curr.decimals = max(self.wcfg["decimal_places_remain"], 0)
        layout_upper.addWidget(self.bar_curr, 1, 1)
        column_count += 1

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_remain"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_upper.addWidget(cap_temp, row_idx_upper, 1)

        # Total needed
        self.bar_style_need = (
            self.set_qss(
                fg_color=self.wcfg["font_color_refill"],
                bg_color=self.wcfg["bkg_color_refill"]),
            self.set_qss(
                fg_color=self.wcfg["font_color_refill"],
                bg_color=self.wcfg["warning_color_low_energy"])
        )
        self.bar_need = self.set_qlabel(
            text=text_def,
            style=self.bar_style_need[0],
            fixed_width=style_width,
        )
        self.bar_need.decimals = max(self.wcfg["decimal_places_refill"], 0)
        layout_upper.addWidget(self.bar_need, 1, 2)
        column_count += 1

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=(
                    self.wcfg["caption_text_absolute_refill"]
                    if self.wcfg["show_absolute_refilling"]
                    else self.wcfg["caption_text_refill"]
                ),
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_upper.addWidget(cap_temp, row_idx_upper, 2)

        # Estimated laps can last
        bar_style_laps = self.set_qss(
            fg_color=self.wcfg["font_color_laps"],
            bg_color=self.wcfg["bkg_color_laps"]
        )
        self.bar_laps = self.set_qlabel(
            text=text_def,
            style=bar_style_laps,
            fixed_width=style_width,
        )
        self.bar_laps.decimals = max(self.wcfg["decimal_places_laps"], 0)
        layout_lower.addWidget(self.bar_laps, 1, 1)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_laps"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_lower.addWidget(cap_temp, row_idx_lower, 1)

        # Estimated minutes can last
        bar_style_mins = self.set_qss(
            fg_color=self.wcfg["font_color_minutes"],
            bg_color=self.wcfg["bkg_color_minutes"]
        )
        self.bar_mins = self.set_qlabel(
            text=text_def,
            style=bar_style_mins,
            fixed_width=style_width,
        )
        self.bar_mins.decimals = max(self.wcfg["decimal_places_minutes"], 0)
        layout_lower.addWidget(self.bar_mins, 1, 2)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_minutes"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_lower.addWidget(cap_temp, row_idx_lower, 2)

        # Estimated consumption
        bar_style_used = self.set_qss(
            fg_color=self.wcfg["font_color_used"],
            bg_color=self.wcfg["bkg_color_used"]
        )
        self.bar_used = self.set_qlabel(
            text=text_def,
            style=bar_style_used,
            fixed_width=style_width,
        )
        self.bar_used.decimals = max(self.wcfg["decimal_places_used"], 0)
        layout_upper.addWidget(self.bar_used, 1, 3)
        column_count += 1

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_used"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_upper.addWidget(cap_temp, row_idx_upper, 3)

        # Estimated one less pit consumption
        bar_style_save = self.set_qss(
            fg_color=self.wcfg["font_color_save"],
            bg_color=self.wcfg["bkg_color_save"]
        )
        self.bar_save = self.set_qlabel(
            text=text_def,
            style=bar_style_save,
            fixed_width=style_width,
        )
        self.bar_save.decimals = max(self.wcfg["decimal_places_save"], 0)
        layout_lower.addWidget(self.bar_save, 1, 3)

        if self.wcfg["show_caption"]:
            cap_temp = self.set_qlabel(
                text=self.wcfg["caption_text_save"],
                style=bar_style_desc,
                fixed_width=style_width,
            )
            layout_lower.addWidget(cap_temp, row_idx_lower, 3)

        if self.wcfg["show_estimated_pitstop_count"]:
            # Estimate pit stop counts when pitting at end of current stint
            bar_style_pits = self.set_qss(
                fg_color=self.wcfg["font_color_pits"],
                bg_color=self.wcfg["bkg_color_pits"]
            )
            self.bar_pits = self.set_qlabel(
                text=text_def,
                style=bar_style_pits,
                fixed_width=style_width,
            )
            self.bar_pits.decimals = max(self.wcfg["decimal_places_pits"], 0)
            layout_upper.addWidget(self.bar_pits, 1, 0)
            column_count += 1

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_pits"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_upper.addWidget(cap_temp, row_idx_upper, 0)

            # Estimate pit stop counts when pitting at end of current lap
            bar_style_early = self.set_qss(
                fg_color=self.wcfg["font_color_early"],
                bg_color=self.wcfg["bkg_color_early"]
            )
            self.bar_early = self.set_qlabel(
                text=text_def,
                style=bar_style_early,
                fixed_width=style_width,
            )
            self.bar_early.decimals = max(self.wcfg["decimal_places_early"], 0)
            layout_lower.addWidget(self.bar_early, 1, 0)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_early"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_lower.addWidget(cap_temp, row_idx_lower, 0)

        if self.wcfg["show_delta_and_end_remaining"]:
            # Delta consumption
            bar_style_delta = self.set_qss(
                fg_color=self.wcfg["font_color_delta"],
                bg_color=self.wcfg["bkg_color_delta"]
            )
            self.bar_delta = self.set_qlabel(
                text=text_def,
                style=bar_style_delta,
                fixed_width=style_width,
            )
            self.bar_delta.decimals = max(self.wcfg["decimal_places_delta"], 0)
            layout_upper.addWidget(self.bar_delta, 1, 4)
            column_count += 1

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_delta"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_upper.addWidget(cap_temp, row_idx_upper, 4)

            # Estimated end remaining
            bar_style_end = self.set_qss(
                fg_color=self.wcfg["font_color_end"],
                bg_color=self.wcfg["bkg_color_end"]
            )
            self.bar_end = self.set_qlabel(
                text=text_def,
                style=bar_style_end,
                fixed_width=style_width,
            )
            self.bar_end.decimals = max(self.wcfg["decimal_places_end"], 0)
            layout_lower.addWidget(self.bar_end, 1, 4)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_end"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_lower.addWidget(cap_temp, row_idx_lower, 4)

        if self.wcfg["show_fuel_ratio_and_bias"]:
            # Fuel ratio
            bar_style_ratio = self.set_qss(
                fg_color=self.wcfg["font_color_ratio"],
                bg_color=self.wcfg["bkg_color_ratio"]
            )
            self.bar_ratio = self.set_qlabel(
                text=text_def,
                style=bar_style_ratio,
                fixed_width=style_width,
            )
            self.bar_ratio.decimals = max(self.wcfg["decimal_places_ratio"], 0)
            layout_upper.addWidget(self.bar_ratio, 1, 5)
            column_count += 1

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_ratio"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_upper.addWidget(cap_temp, row_idx_upper, 5)

            # Fuel bias
            bar_style_bias = self.set_qss(
                fg_color=self.wcfg["font_color_bias"],
                bg_color=self.wcfg["bkg_color_bias"]
            )
            self.bar_bias = self.set_qlabel(
                text=text_def,
                style=bar_style_bias,
                fixed_width=style_width,
            )
            self.bar_bias.decimals = max(self.wcfg["decimal_places_bias"], 0)
            layout_lower.addWidget(self.bar_bias, 1, 5)

            if self.wcfg["show_caption"]:
                cap_temp = self.set_qlabel(
                    text=self.wcfg["caption_text_bias"],
                    style=bar_style_desc,
                    fixed_width=style_width,
                )
                layout_lower.addWidget(cap_temp, row_idx_lower, 5)

        # Energy level bar
        if self.wcfg["show_energy_level_bar"]:
            self.bar_level = FuelLevelBar(
                self,
                width=(font_m.width * self.bar_width + bar_padx) * column_count,
                height=max(self.wcfg["energy_level_bar_height"], 1),
                start_mark_width=max(self.wcfg["starting_energy_level_mark_width"], 1),
                refill_mark_width=max(self.wcfg["refilling_level_mark_width"], 1),
                input_color=self.wcfg["highlight_color_energy_level"],
                bg_color=self.wcfg["bkg_color_energy_level"],
                start_mark_color=self.wcfg["starting_energy_level_mark_color"],
                refill_mark_color=self.wcfg["refilling_level_mark_color"],
                show_start_mark=self.wcfg["show_starting_energy_level_mark"],
                show_refill_mark=self.wcfg["show_refilling_level_mark"],
            )
            layout.addWidget(self.bar_level, self.wcfg["column_index_middle"], 0)

        if self.wcfg["show_low_energy_warning_flash"]:
            self.warn_flash = WarningFlash(
                self.wcfg["warning_flash_highlight_duration"],
                self.wcfg["warning_flash_interval"],
                self.wcfg["number_of_warning_flashes"],
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        is_low_energy = minfo.energy.estimatedLaps <= self.wcfg["low_energy_lap_threshold"]
        if self.wcfg["show_low_energy_warning_flash"] and minfo.energy.estimatedValidConsumption:
            is_low_energy = self.warn_flash.state(is_low_energy)
            if is_low_energy:
                padding = 0.00000001  # add padding for switching state
            else:
                padding = 0
        else:
            padding = 0

        # Remaining
        amount_curr = minfo.energy.amountCurrent
        self.update_energy(self.bar_curr, amount_curr + padding, self.bar_style_curr[is_low_energy])

        # Total needed
        if self.wcfg["show_absolute_refilling"]:
            amount_need = calc.sym_max(minfo.energy.neededAbsolute, 9999)
            self.update_energy(self.bar_need, amount_need + padding, self.bar_style_need[is_low_energy])
        else:
            amount_need = calc.sym_max(minfo.energy.neededRelative, 9999)
            self.update_energy(self.bar_need, amount_need + padding, self.bar_style_need[is_low_energy], "+")

        # Estimated laps can last
        est_runlaps = min(minfo.energy.estimatedLaps, 9999)
        self.update_energy(self.bar_laps, est_runlaps)

        # Estimated minutes can last
        est_runmins = min(minfo.energy.estimatedMinutes, 9999)
        self.update_energy(self.bar_mins, est_runmins)

        # Estimated consumption
        used_last = minfo.energy.estimatedConsumption
        self.update_energy(self.bar_used, used_last)

        # Estimated one less pit consumption
        energy_save = calc.zero_max(minfo.energy.oneLessPitConsumption, 99.99)
        self.update_energy(self.bar_save, energy_save)

        if self.wcfg["show_estimated_pitstop_count"]:
            # Estimate pit stop counts when pitting at end of current stint
            est_pits_end = calc.zero_max(minfo.energy.estimatedNumPitStopsEnd, 99.99)
            self.update_energy(self.bar_pits, est_pits_end)

            # Estimate pit stop counts when pitting at end of current lap
            est_pits_early = calc.zero_max(minfo.energy.estimatedNumPitStopsEarly, 99.99)
            self.update_energy(self.bar_early, est_pits_early)

        if self.wcfg["show_delta_and_end_remaining"]:
            # Delta consumption
            delta_energy = minfo.energy.deltaConsumption
            self.update_energy(self.bar_delta, delta_energy, None, "+")

            # Estimated end remaining
            amount_end = minfo.energy.amountEndStint
            self.update_energy(self.bar_end, amount_end)

        if self.wcfg["show_fuel_ratio_and_bias"]:
            # Fuel ratio
            fuel_ratio = minfo.hybrid.fuelEnergyRatio
            self.update_energy(self.bar_ratio, fuel_ratio)

            # Fuel bias
            fuel_bias = minfo.hybrid.fuelEnergyBias
            self.update_energy(self.bar_bias, fuel_bias, None, "+")

        # Energy level bar
        if self.wcfg["show_energy_level_bar"]:
            level_capacity = minfo.energy.capacity
            level_curr = minfo.energy.amountCurrent
            level_start = minfo.energy.amountStart
            level_refill = level_curr + minfo.energy.neededRelative
            level_state = round(level_curr + level_start + level_refill, 3)
            if level_capacity and self.bar_level.last != level_state:
                self.bar_level.last = level_state
                self.bar_level.update_input(
                    level_curr / level_capacity,
                    level_start / level_capacity,
                    level_refill / level_capacity,
                )

    # GUI update methods
    def update_energy(self, target, data, color=None, sign=""):
        """Update energy data"""
        if target.last != data:
            target.last = data
            text = f"{data:{sign}.{target.decimals}f}"[:self.bar_width].strip(".")
            target.setText(text)
            if color:  # low energy warning
                target.updateStyle(color)

```

# File: tinypedal/widget/weather.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Weather Widget
"""

from ..api_control import api
from ..const_common import TEXT_TREND_SIGN
from ..module_info import minfo
from ..units import set_symbol_temperature, set_unit_temperature
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        prefix_wetness_just = max(len(self.wcfg["prefix_dry"]), len(self.wcfg["prefix_wet"]))
        decimals = min(max(self.wcfg["decimal_places_temperature"], 0), 6)

        self.prefix_rain = self.wcfg["prefix_rain"]
        self.prefix_dry = self.wcfg["prefix_dry"].ljust(prefix_wetness_just)
        self.prefix_wet = self.wcfg["prefix_wet"].ljust(prefix_wetness_just)
        self.temp_cut = 2 + (self.cfg.units["temperature_unit"] == "Fahrenheit") + (decimals != 0) + decimals
        self.temp_digits = f"0{self.temp_cut + round(0.1 + decimals * 0.1, decimals)}f"

        self.rubber_median_laps = max(int(self.wcfg["rubber_median_laps"]), 100)
        self.rubber_time_scale = (
            self.wcfg["rubber_time_scale_practice"],  # testday
            self.wcfg["rubber_time_scale_practice"],  # practice
            self.wcfg["rubber_time_scale_qualifying"],  # qualifying
            self.wcfg["rubber_time_scale_race"],  # warmup
            self.wcfg["rubber_time_scale_race"],  # race
        )
        self.rubber_starting = (
            self.wcfg["starting_rubber_practice"],  # testday
            self.wcfg["starting_rubber_practice"],  # practice
            self.wcfg["starting_rubber_qualifying"],  # qualifying
            self.wcfg["starting_rubber_race"],  # warmup
            self.wcfg["starting_rubber_race"],  # race
        )

        # Config units
        self.unit_temp = set_unit_temperature(self.cfg.units["temperature_unit"])
        self.symbol_temp = set_symbol_temperature(self.cfg.units["temperature_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Track temperature
        if self.wcfg["show_temperature"]:
            layout_temp = self.set_grid_layout()
            track_temp = f"{self.unit_temp(0):{self.temp_digits}}"[:self.temp_cut]
            air_temp = f"{self.unit_temp(0):{self.temp_digits}}"[:self.temp_cut]
            text_temp = f"{track_temp}({air_temp}){self.symbol_temp}"
            bar_style_temp = self.set_qss(
                fg_color=self.wcfg["font_color_temperature"],
                bg_color=self.wcfg["bkg_color_temperature"]
            )
            self.bar_temp = self.set_qlabel(
                text=text_temp,
                style=bar_style_temp,
                width=font_m.width * len(text_temp) + bar_padx,
                last=0,
            )
            layout_temp.addWidget(self.bar_temp, 0, 0)

            self.bar_style_temp_trend = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_constant"],
                    bg_color=self.wcfg["bkg_color_temperature"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_increasing"],
                    bg_color=self.wcfg["bkg_color_temperature"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_decreasing"],
                    bg_color=self.wcfg["bkg_color_temperature"]),
            )
            self.bar_temp_trend = self.set_qlabel(
                text=TEXT_TREND_SIGN[0],
                style=self.bar_style_temp_trend[0],
                width=font_m.width + bar_padx,
                last=0,
            )
            layout_temp.addWidget(self.bar_temp_trend, 0, 1)
            self.set_primary_orient(
                target=layout_temp,
                column=self.wcfg["column_index_temperature"],
                option=None,
                default=1,
            )

        # Rain precipitation
        if self.wcfg["show_rain"]:
            layout_rain = self.set_grid_layout()
            text_rain = f"{self.prefix_rain}  0%"
            bar_style_rain = self.set_qss(
                fg_color=self.wcfg["font_color_rain"],
                bg_color=self.wcfg["bkg_color_rain"]
            )
            self.bar_rain = self.set_qlabel(
                text=text_rain,
                style=bar_style_rain,
                width=font_m.width * len(text_rain) + bar_padx,
                last=0,
            )
            layout_rain.addWidget(self.bar_rain, 0, 0)

            self.bar_style_raininess_trend = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_constant"],
                    bg_color=self.wcfg["bkg_color_rain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_increasing"],
                    bg_color=self.wcfg["bkg_color_rain"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_decreasing"],
                    bg_color=self.wcfg["bkg_color_rain"]),
            )
            self.bar_raininess_trend = self.set_qlabel(
                text=TEXT_TREND_SIGN[0],
                style=self.bar_style_raininess_trend[0],
                width=font_m.width + bar_padx,
                last=0,
            )
            layout_rain.addWidget(self.bar_raininess_trend, 0, 1)
            self.set_primary_orient(
                target=layout_rain,
                column=self.wcfg["column_index_rain"],
                option=None,
                default=1,
            )

        # Surface wetness
        if self.wcfg["show_wetness"]:
            layout_wetness = self.set_grid_layout()
            text_wetness = f"{self.prefix_dry}  0%"
            bar_style_wetness = self.set_qss(
                fg_color=self.wcfg["font_color_wetness"],
                bg_color=self.wcfg["bkg_color_wetness"]
            )
            self.bar_wetness = self.set_qlabel(
                text=text_wetness,
                style=bar_style_wetness,
                width=font_m.width * len(text_wetness) + bar_padx,
                last=0,
            )
            layout_wetness.addWidget(self.bar_wetness, 0, 0)

            self.bar_style_wetness_trend = (
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_constant"],
                    bg_color=self.wcfg["bkg_color_wetness"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_increasing"],
                    bg_color=self.wcfg["bkg_color_wetness"]),
                self.set_qss(
                    fg_color=self.wcfg["font_color_trend_decreasing"],
                    bg_color=self.wcfg["bkg_color_wetness"]),
            )
            self.bar_wetness_trend = self.set_qlabel(
                text=TEXT_TREND_SIGN[0],
                style=self.bar_style_wetness_trend[0],
                width=font_m.width + bar_padx,
                last=0,
            )
            layout_wetness.addWidget(self.bar_wetness_trend, 0, 1)
            self.set_primary_orient(
                target=layout_wetness,
                column=self.wcfg["column_index_wetness"],
                option=None,
                default=1,
            )

        # Last data
        self.temp_trend = TrendTimer(self.wcfg["temperature_trend_interval"])
        self.rain_trend = TrendTimer(self.wcfg["raininess_trend_interval"])
        self.wet_trend = TrendTimer(self.wcfg["wetness_trend_interval"])

    def timerEvent(self, event):
        """Update when vehicle on track"""
        lap_etime = api.read.timing.elapsed()

        # Track temperature
        if self.wcfg["show_temperature"]:
            temp_track = api.read.session.track_temperature()
            temp_air = api.read.session.ambient_temperature()
            temperature = temp_track + temp_air
            # Temperature
            self.update_temperature(self.bar_temp, temperature, temp_track, temp_air)
            # Temperature trend
            temp_trend = self.temp_trend.update(round(temperature, 1), lap_etime)
            self.update_temperature_trend(self.bar_temp_trend, temp_trend)

        # Rain precipitation
        if self.wcfg["show_rain"]:
            raininess = round(api.read.session.raininess(), 2)
            # Rain percentage
            self.update_raininess(self.bar_rain, raininess)
            # Rain trend
            rain_trend = self.rain_trend.update(raininess, lap_etime)
            self.update_raininess_trend(self.bar_raininess_trend, rain_trend)

        # Surface wetness
        if self.wcfg["show_wetness"]:
            wet_min, wet_max, wet_avg = api.read.session.wetness()
            # Wetness percentage
            if wet_avg >= 0.01 or not self.wcfg["show_rubber_coverage_while_dry"]:
                self.update_wetness(self.bar_wetness, wet_avg)
            # Rubber coverage percentage
            else:
                session_type = api.read.session.session_type()
                rubber_scale = self.rubber_time_scale[session_type]
                laps_session = rubber_to_laps(self.rubber_starting[session_type], self.rubber_median_laps)
                if rubber_scale > 0:  # time-scaled coverage
                    laps_session += (minfo.vehicles.totalCompletedLaps * rubber_scale)
                self.update_rubber(self.bar_wetness, laps_session)
            # Wet trend
            wetness = wet_min + wet_max + wet_avg
            wet_trend = self.wet_trend.update(wetness, lap_etime)
            self.update_wetness_trend(self.bar_wetness_trend, wet_trend)

    # GUI update methods
    def update_temperature(self, target, data, track, air):
        """Track & ambient temperature"""
        if target.last != data:
            target.last = data
            track_temp = f"{self.unit_temp(track):{self.temp_digits}}"[:self.temp_cut]
            air_temp = f"{self.unit_temp(air):{self.temp_digits}}"[:self.temp_cut]
            target.setText(f"{track_temp}({air_temp}){self.symbol_temp}")

    def update_temperature_trend(self, target, data):
        """Temperature trend"""
        if target.last != data:
            target.last = data
            target.setText(TEXT_TREND_SIGN[data])
            target.updateStyle(self.bar_style_temp_trend[data])

    def update_raininess(self, target, data):
        """Rain percentage"""
        if target.last != data:
            target.last = data
            percent_rain = f"{data: >3.0%}"[:3]
            target.setText(f"{self.prefix_rain} {percent_rain}")

    def update_raininess_trend(self, target, data):
        """Raininess trend"""
        if target.last != data:
            target.last = data
            target.setText(TEXT_TREND_SIGN[data])
            target.updateStyle(self.bar_style_raininess_trend[data])

    def update_wetness(self, target, data):
        """Surface wetness percentage"""
        if target.last != data:
            target.last = data
            percent_wet = f"{data: >3.0%}"[:3]
            target.setText(f"{self.prefix_wet} {percent_wet}")

    def update_rubber(self, target, data):
        """Surface rubber coverage percentage"""
        if target.last != data:
            target.last = data
            percent_rubber = f"{laps_to_rubber(data, self.rubber_median_laps): >3.0%}"[:3]
            target.setText(f"{self.prefix_dry} {percent_rubber}")

    def update_wetness_trend(self, target, data):
        """Surface wetness trend"""
        if target.last != data:
            target.last = data
            target.setText(TEXT_TREND_SIGN[data])
            target.updateStyle(self.bar_style_wetness_trend[data])


def laps_to_rubber(value: float, median_laps: int = 2000) -> float:
    """Convert laps to rubber coverage (percent)"""
    max_laps = median_laps * 2
    if value > max_laps:
        return 1.0
    if value > median_laps:
        return 0.75 + (value - median_laps) / median_laps / 4
    if value > 0:
        return value * 0.75 / median_laps
    return 0.0


def rubber_to_laps(value: float, median_laps: int = 2000) -> float:
    """Convert rubber coverage (percent) to laps"""
    max_laps = median_laps * 2
    if value >= 1:
        return max_laps
    if value > 0.75:
        return median_laps + (value - 0.75) * median_laps * 4
    if value > 0:
        return value * median_laps / 0.75
    return 0


class TrendTimer:
    """Trend timer"""

    __slots__ = (
        "_trend_interval",
        "_last_reading",
        "_trend",
        "_timer",
    )

    def __init__(self, trend_interval: float) -> None:
        """
        Args:
            trend_interval: trend reset interval (seconds).
        """
        self._trend_interval = trend_interval
        self._last_reading = 0.0
        self._trend = 0
        self._timer = 0.0

    def update(self, reading: float, elapsed_time: float) -> int:
        """Update trend

        Args:
            reading: value.
            elapsed_time: current lap elapsed time.

        Returns:
            Trend, 0 = constant, 1 = increasing, -1 = decreasing.
        """
        if self._last_reading < reading:
            self._timer = elapsed_time
            self._trend = 1  # increased
        elif self._last_reading > reading:
            self._timer = elapsed_time
            self._trend = -1  # decreased
        elif elapsed_time - self._timer > self._trend_interval:
            self._timer = elapsed_time
            self._trend = 0  # no change
        self._last_reading = reading

        if self._timer > elapsed_time:
            self._timer = elapsed_time
        return self._trend

```

# File: tinypedal/widget/weather_forecast.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Weather forecast Widget
"""

from __future__ import annotations

from PySide2.QtCore import Qt
from PySide2.QtGui import QPainter, QPixmap

from ..api_control import api
from ..const_common import (
    ABS_ZERO_CELSIUS,
    MAX_FORECAST_MINUTES,
    MAX_FORECASTS,
    TEXT_NA,
)
from ..const_file import ImageFile
from ..process.weather import WeatherNode, forecast_sky_type
from ..units import set_unit_temperature
from ._base import Overlay
from ._painter import split_pixmap_icon


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap_hori=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        layout_reversed = self.wcfg["layout"] != 0
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        icon_size = max(self.wcfg["icon_size"], 16) // 2 * 2
        self.total_slot = min(max(self.wcfg["number_of_forecasts"], 1), MAX_FORECASTS - 1) + 1
        self.bar_width = max(font_m.width * 4 + bar_padx, icon_size)
        self.bar_rain_height = max(self.wcfg["rain_chance_bar_height"], 1)

        # Config units
        self.unit_temp = set_unit_temperature(self.cfg.units["temperature_unit"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Config canvas
        self.pixmap_weather = create_weather_icon_set(icon_size)
        self.pixmap_rainchance = QPixmap(self.bar_width, self.bar_rain_height)

        # Estimated time
        if self.wcfg["show_estimated_time"]:
            bar_style_time = self.set_qss(
                fg_color=self.wcfg["font_color_estimated_time"],
                bg_color=self.wcfg["bkg_color_estimated_time"]
            )
            self.bars_time = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_time,
                fixed_width=self.bar_width,
                count=self.total_slot,
            )
            self.bars_time[0].setText("now")
            self.set_grid_layout_table_row(
                layout=layout,
                targets=self.bars_time,
                row_index=self.wcfg["column_index_estimated_time"],
                right_to_left=layout_reversed,
            )

        # Ambient temperature
        if self.wcfg["show_ambient_temperature"]:
            bar_style_temp = self.set_qss(
                fg_color=self.wcfg["font_color_ambient_temperature"],
                bg_color=self.wcfg["bkg_color_ambient_temperature"]
            )
            self.bars_temp = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_temp,
                fixed_width=self.bar_width,
                count=self.total_slot,
            )
            self.set_grid_layout_table_row(
                layout=layout,
                targets=self.bars_temp,
                row_index=self.wcfg["column_index_ambient_temperature"],
                right_to_left=layout_reversed,
            )

        # Rain chance
        if self.wcfg["show_rain_chance_bar"]:
            bar_style_rain = self.set_qss(
                bg_color=self.wcfg["rain_chance_bar_bkg_color"]
            )
            self.bars_rain = self.set_qlabel(
                style=bar_style_rain,
                fixed_width=self.bar_width,
                fixed_height=self.bar_rain_height,
                count=self.total_slot,
            )
            self.set_grid_layout_table_row(
                layout=layout,
                targets=self.bars_rain,
                row_index=self.wcfg["column_index_rain_chance_bar"],
                right_to_left=layout_reversed,
            )

        # Forecast icon
        bar_style_icon = self.set_qss(
            bg_color=self.wcfg["bkg_color"]
        )
        self.bars_icon = self.set_qlabel(
            pixmap=self.pixmap_weather[-1],
            style=bar_style_icon,
            fixed_width=self.bar_width,
            count=self.total_slot,
        )
        self.set_grid_layout_table_row(
            layout=layout,
            targets=self.bars_icon,
            row_index=self.wcfg["column_index_weather_icon"],
            right_to_left=layout_reversed,
        )

        # Last data
        self.estimated_time = [MAX_FORECAST_MINUTES] * MAX_FORECASTS

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Read weather data
        is_lap_type = api.read.session.lap_type()
        forecast_info = api.read.session.weather_forecast()
        forecast_count = min(len(forecast_info), MAX_FORECASTS)

        if forecast_count < 1:
            return

        if is_lap_type:
            index_offset = 0
        else:  # time type race, add index offset to ignore negative estimated time
            index_offset = self.set_forecast_time(forecast_info)

        # Forecast
        for index in range(self.total_slot):
            index_bias = index + index_offset

            # Update slot 0 with live(now) weather condition
            if index == 0:
                rain_chance = api.read.session.raininess() * 100
                icon_index = forecast_sky_type(forecast_info[index_bias].sky_type, rain_chance)
                estimated_temp = api.read.session.ambient_temperature()
                estimated_time = 0
            # Update slot with available forecast
            elif index_bias < forecast_count:
                rain_chance = forecast_info[index_bias].rain_chance
                icon_index = forecast_info[index_bias].sky_type
                estimated_temp = forecast_info[index_bias].temperature
                if is_lap_type:
                    estimated_time = MAX_FORECAST_MINUTES
                else:
                    estimated_time = self.estimated_time[index_bias]
            # Update slot with unavailable forecast
            else:
                rain_chance = 0
                icon_index = -1
                estimated_temp = ABS_ZERO_CELSIUS
                estimated_time = MAX_FORECAST_MINUTES

            self.update_weather_icon(self.bars_icon[index], icon_index, index)

            if self.wcfg["show_estimated_time"] and index > 0:
                self.update_estimated_time(self.bars_time[index], estimated_time)

            if self.wcfg["show_ambient_temperature"]:
                self.update_estimated_temp(self.bars_temp[index], estimated_temp)

            if self.wcfg["show_rain_chance_bar"]:
                self.update_rain_chance_bar(self.bars_rain[index], rain_chance)

    # GUI update methods
    def update_estimated_time(self, target, data):
        """Estimated time"""
        if target.last != data:
            target.last = data
            if data >= MAX_FORECAST_MINUTES or data < 0:
                time_text = TEXT_NA
            elif data >= 60:
                time_text = f"{data / 60:.1f}h"
            else:
                time_text = f"{data:.0f}m"
            target.setText(time_text)

    def update_estimated_temp(self, target, data):
        """Estimated temperature"""
        if target.last != data:
            target.last = data
            if data > ABS_ZERO_CELSIUS:
                temp_text = f"{self.unit_temp(data):.0f}Â°"
            else:
                temp_text = TEXT_NA
            target.setText(temp_text)

    def update_rain_chance_bar(self, target, data):
        """Rain chance bar"""
        if target.last != data:
            target.last = data
            self.pixmap_rainchance.fill(Qt.transparent)
            painter = QPainter(self.pixmap_rainchance)
            painter.fillRect(
                0, 0, data * 0.01 * self.bar_width, self.bar_rain_height,
                self.wcfg["rain_chance_bar_color"]
            )
            target.setPixmap(self.pixmap_rainchance)

    def update_weather_icon(self, target, icon_index, slot_index):
        """Weather icon, toggle visibility"""
        if target.last != icon_index:
            target.last = icon_index
            if not 0 <= icon_index <= 10:
                icon_index = -1
            target.setPixmap(self.pixmap_weather[icon_index])

            if not self.wcfg["show_unavailable_data"] and slot_index > 0:  # skip first slot
                unavailable = icon_index < 0
                self.bars_icon[slot_index].setHidden(unavailable)
                if self.wcfg["show_estimated_time"]:
                    self.bars_time[slot_index].setHidden(unavailable)
                if self.wcfg["show_ambient_temperature"]:
                    self.bars_temp[slot_index].setHidden(unavailable)
                if self.wcfg["show_rain_chance_bar"]:
                    self.bars_rain[slot_index].setHidden(unavailable)

    # Additional methods
    def set_forecast_time(self, forecast_info: tuple[WeatherNode, ...]) -> int:
        """Set forecast estimated time"""
        index_offset = 0
        session_length = api.read.session.end()
        elapsed_time = api.read.session.elapsed()
        for index, forecast in enumerate(forecast_info):
            if index == 0:
                continue
            # Seconds away = next node start percent * session length - elapsed time
            _time = self.estimated_time[index] = round(
                (forecast.start_percent * session_length - elapsed_time) / 60)
            if _time <= 0:
                index_offset += 1
        return index_offset


def create_weather_icon_set(icon_size: int):
    """Create weather icon set"""
    icon_source = QPixmap(ImageFile.WEATHER)
    pixmap_icon = icon_source.scaledToWidth(icon_size * 12, mode=Qt.SmoothTransformation)
    return tuple(
        split_pixmap_icon(pixmap_icon, icon_size, h_offset)
        for h_offset in range(12)
    )

```

# File: tinypedal/widget/weight_distribution.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Weight distribution Widget
"""

from functools import partial

from .. import calculation as calc
from ..api_control import api
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])
        self.percent_sign_text = "%" if self.wcfg["show_percentage_sign"] else ""
        self.decimals = max(int(self.wcfg["decimal_places"]), 1)

        if self.wcfg["layout"] == 0:
            prefix_just = max(
                len(self.wcfg["prefix_front_to_rear_distribution"]),
                len(self.wcfg["prefix_left_to_right_distribution"]),
                len(self.wcfg["prefix_cross_weight"]),
            )
        else:
            prefix_just = 0

        self.prefix_distf = self.wcfg["prefix_front_to_rear_distribution"].ljust(prefix_just)
        self.prefix_distl = self.wcfg["prefix_left_to_right_distribution"].ljust(prefix_just)
        self.prefix_cross = self.wcfg["prefix_cross_weight"].ljust(prefix_just)

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        # Front to rear distribution
        if self.wcfg["show_front_to_rear_distribution"]:
            bar_style_distf = self.set_qss(
                fg_color=self.wcfg["font_color_front_to_rear_distribution"],
                bg_color=self.wcfg["bkg_color_front_to_rear_distribution"],
            )
            text_distf = self.format_dist(0, self.prefix_distf)
            self.bar_distf = self.set_qlabel(
                text=text_distf,
                style=bar_style_distf,
                width=font_m.width * len(text_distf) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_distf,
                column=self.wcfg["column_index_front_to_rear_distribution"],
            )

        # Left to right distribution
        if self.wcfg["show_left_to_right_distribution"]:
            bar_style_distl = self.set_qss(
                fg_color=self.wcfg["font_color_left_to_right_distribution"],
                bg_color=self.wcfg["bkg_color_left_to_right_distribution"],
            )
            text_distl = self.format_dist(0, self.prefix_distl)
            self.bar_distl = self.set_qlabel(
                text=text_distl,
                style=bar_style_distl,
                width=font_m.width * len(text_distl) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_distl,
                column=self.wcfg["column_index_left_to_right_distribution"],
            )

        # Cross weight
        if self.wcfg["show_cross_weight"]:
            bar_style_cross = self.set_qss(
                fg_color=self.wcfg["font_color_cross_weight"],
                bg_color=self.wcfg["bkg_color_cross_weight"],
            )
            text_cross = self.format_dist(0, self.prefix_cross)
            self.bar_cross = self.set_qlabel(
                text=text_cross,
                style=bar_style_cross,
                width=font_m.width * len(text_cross) + bar_padx,
                last=0,
            )
            self.set_primary_orient(
                target=self.bar_cross,
                column=self.wcfg["column_index_cross_weight"],
            )

        self.calc_ema_ratio = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.wcfg["smoothing_samples"])
        )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        load_fl, load_fr, load_rl, load_rr = api.read.tyre.load()
        total_load = load_fl + load_fr + load_rl + load_rr

        # Fallback to suspension load if tyre load data not avaiable
        if total_load <= 0:
            load_fl, load_fr, load_rl, load_rr = api.read.wheel.suspension_force()
            total_load = load_fl + load_fr + load_rl + load_rr

        # Front to rear distribution
        if self.wcfg["show_front_to_rear_distribution"]:
            ema_distf = self.calc_ema_ratio(self.bar_distf.last, calc.part_to_whole_ratio((load_fl + load_fr), total_load))
            self.update_dist(self.bar_distf, ema_distf, self.prefix_distf)

        # Left to right distribution
        if self.wcfg["show_left_to_right_distribution"]:
            ema_distl = self.calc_ema_ratio(self.bar_distl.last, calc.part_to_whole_ratio((load_fl + load_rl), total_load))
            self.update_dist(self.bar_distl, ema_distl, self.prefix_distl)

        # Cross weight
        if self.wcfg["show_cross_weight"]:
            ema_cross = self.calc_ema_ratio(self.bar_cross.last, calc.part_to_whole_ratio((load_fr + load_rl), total_load))
            self.update_dist(self.bar_cross, ema_cross, self.prefix_cross)

    # GUI update methods
    def update_dist(self, target, data, prefix):
        """Weight distribution ratio"""
        if target.last != data:
            target.last = data
            target.setText(self.format_dist(data, prefix))

    def format_dist(self, angle, prefix):
        """Format distribution ratio"""
        ratio = f"{angle:.{self.decimals + 1}f}"[:self.decimals + 3]
        return f"{prefix}{ratio}{self.percent_sign_text}"

```

# File: tinypedal/widget/wheel_camber.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Wheel camber Widget
"""

from functools import partial

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NA
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_size=int(self.wcfg['font_size'] * 0.8)
            )
            cap_camber = self.set_qlabel(
                text=self.wcfg["caption_text"],
                style=bar_style_desc,
            )
            self.set_primary_orient(
                target=cap_camber,
                column=0,
            )

        # Camber
        layout_camber = self.set_grid_layout(
            gap_hori=self.wcfg["horizontal_gap"],
            gap_vert=self.wcfg["vertical_gap"],
        )
        bar_style_camber = self.set_qss(
            fg_color=self.wcfg["font_color_camber"],
            bg_color=self.wcfg["bkg_color_camber"]
        )
        self.decimals_camber = max(self.wcfg["decimal_places_camber"], 1)
        self.bars_camber = self.set_qlabel(
            text=TEXT_NA,
            style=bar_style_camber,
            width=font_m.width * (3 + self.decimals_camber) + bar_padx,
            count=4,
            last=0,
        )
        self.set_grid_layout_quad(
            layout=layout_camber,
            targets=self.bars_camber,
        )
        self.set_primary_orient(
            target=layout_camber,
            column=1,
        )
        self.calc_ema_camber = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.wcfg["camber_smoothing_samples"])
        )

        # Camber difference
        if self.wcfg["show_camber_difference"]:
            bar_style_cdiff = self.set_qss(
                fg_color=self.wcfg["font_color_camber_difference"],
                bg_color=self.wcfg["bkg_color_camber_difference"]
            )
            self.decimals_cdiff = max(self.wcfg["decimal_places_camber_difference"], 1)
            self.bars_cdiff = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_cdiff,
                width=font_m.width * (3 + self.decimals_cdiff) + bar_padx,
                count=2,
                last=0,
            )
            self.set_grid_layout_vert(
                layout=layout_camber,
                targets=self.bars_cdiff,
            )
            self.calc_ema_cdiff = partial(
                calc.exp_mov_avg,
                calc.ema_factor(self.wcfg["camber_difference_smoothing_samples"])
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Camber
        camber_set = api.read.wheel.camber()
        for camber, bar_camber in zip(camber_set, self.bars_camber):
            self.update_camber(bar_camber, self.calc_ema_camber(bar_camber.last, camber))

        # Camber difference
        if self.wcfg["show_camber_difference"]:
            self.update_cdiff(self.bars_cdiff[0], self.calc_ema_cdiff(self.bars_cdiff[0].last, camber_set[0] - camber_set[1]))
            self.update_cdiff(self.bars_cdiff[1], self.calc_ema_cdiff(self.bars_cdiff[1].last, camber_set[2] - camber_set[3]))

    # GUI update methods
    def update_camber(self, target, data):
        """Camber data"""
        if target.last != data:
            target.last = data
            target.setText(f"{calc.rad2deg(data):+.{self.decimals_camber}f}"[:3 + self.decimals_camber])

    def update_cdiff(self, target, data):
        """Camber difference data"""
        if target.last != data:
            target.last = data
            target.setText(f"{calc.rad2deg(data):+.{self.decimals_cdiff}f}"[:3 + self.decimals_cdiff])

```

# File: tinypedal/widget/wheel_toe.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Wheel toe Widget
"""

from functools import partial

from .. import calculation as calc
from ..api_control import api
from ..const_common import TEXT_NA
from ._base import Overlay


class Realtime(Overlay):
    """Draw widget"""

    def __init__(self, config, widget_name):
        # Assign base setting
        super().__init__(config, widget_name)
        layout = self.set_grid_layout(gap=self.wcfg["bar_gap"])
        self.set_primary_layout(layout=layout)

        # Config font
        font_m = self.get_font_metrics(
            self.config_font(self.wcfg["font_name"], self.wcfg["font_size"]))

        # Config variable
        bar_padx = self.set_padding(self.wcfg["font_size"], self.wcfg["bar_padding"])

        # Base style
        self.set_base_style(self.set_qss(
            font_family=self.wcfg["font_name"],
            font_size=self.wcfg["font_size"],
            font_weight=self.wcfg["font_weight"])
        )

        if self.wcfg["show_caption"]:
            bar_style_desc = self.set_qss(
                fg_color=self.wcfg["font_color_caption"],
                bg_color=self.wcfg["bkg_color_caption"],
                font_size=int(self.wcfg['font_size'] * 0.8)
            )
            cap_toe_in = self.set_qlabel(
                text=self.wcfg["caption_text"],
                style=bar_style_desc,
            )
            self.set_primary_orient(
                target=cap_toe_in,
                column=0,
            )

        # Toe in
        layout_toe_in = self.set_grid_layout(
            gap_hori=self.wcfg["horizontal_gap"],
            gap_vert=self.wcfg["vertical_gap"],
        )
        bar_style_toe_in = self.set_qss(
            fg_color=self.wcfg["font_color_toe_in"],
            bg_color=self.wcfg["bkg_color_toe_in"]
        )
        self.decimals_toe_in = max(self.wcfg["decimal_places_toe_in"], 1)
        self.bars_toe_in = self.set_qlabel(
            text=TEXT_NA,
            style=bar_style_toe_in,
            width=font_m.width * (3 + self.decimals_toe_in) + bar_padx,
            count=4,
            last=0,
        )
        self.set_grid_layout_quad(
            layout=layout_toe_in,
            targets=self.bars_toe_in,
        )
        self.set_primary_orient(
            target=layout_toe_in,
            column=1,
        )
        self.calc_ema_toe_in = partial(
            calc.exp_mov_avg,
            calc.ema_factor(self.wcfg["toe_in_smoothing_samples"])
        )

        # Total toe angle
        if self.wcfg["show_total_toe_angle"]:
            bar_style_total = self.set_qss(
                fg_color=self.wcfg["font_color_total_toe_angle"],
                bg_color=self.wcfg["bkg_color_total_toe_angle"]
            )
            self.decimals_total = max(self.wcfg["decimal_places_total_toe_angle"], 1)
            self.bars_total = self.set_qlabel(
                text=TEXT_NA,
                style=bar_style_total,
                width=font_m.width * (2 + self.decimals_total) + bar_padx,
                count=2,
                last=0,
            )
            self.set_grid_layout_vert(
                layout=layout_toe_in,
                targets=self.bars_total,
            )
            self.calc_ema_total = partial(
                calc.exp_mov_avg,
                calc.ema_factor(self.wcfg["total_toe_angle_smoothing_samples"])
            )

    def timerEvent(self, event):
        """Update when vehicle on track"""
        # Toe in
        toe_in_set = api.read.wheel.toe_symmetric()
        for toe_in, bar_toe_in in zip(toe_in_set, self.bars_toe_in):
            self.update_toe_in(bar_toe_in, self.calc_ema_toe_in(bar_toe_in.last, toe_in))

        # Total toe angle
        if self.wcfg["show_total_toe_angle"]:
            self.update_total(self.bars_total[0], self.calc_ema_total(self.bars_total[0].last, toe_in_set[0] + toe_in_set[1]))
            self.update_total(self.bars_total[1], self.calc_ema_total(self.bars_total[1].last, toe_in_set[2] + toe_in_set[3]))

    # GUI update methods
    def update_toe_in(self, target, data):
        """Toe in data"""
        if target.last != data:
            target.last = data
            target.setText(f"{calc.rad2deg(data):+.{self.decimals_toe_in + 1}f}"[:3 + self.decimals_toe_in])

    def update_total(self, target, data):
        """Total toe angle data"""
        if target.last != data:
            target.last = data
            target.setText(f"{calc.rad2deg(abs(data)):.{self.decimals_total + 1}f}"[:2 + self.decimals_total])

```

# File: tinypedal/widget/_base.py
```python
#  TinyPedal is an open-source overlay application for racing simulation.
#  Copyright (C) 2022-2026 TinyPedal developers, see contributors.md file
#
#  This file is part of TinyPedal.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <unlinked: www_gnu_org/licenses/>.

"""
Overlay base window, events.
"""

from __future__ import annotations

from typing import Any

from PySide2.QtCore import QBasicTimer, Qt, Slot
from PySide2.QtGui import QFont, QFontMetrics, QPalette, QPixmap
from PySide2.QtWidgets import QGridLayout, QLabel, QLayout, QMenu, QWidget

from .. import overlay_signal, realtime_state
from .. import regex_pattern as rxp
from ..const_app import APP_NAME
from ..formatter import format_module_name
from ..setting import Setting
from ._common import ExLabel, FontMetrics, MousePosition

mousepos = MousePosition()  # single instance shared by all widgets


class Overlay(QWidget):
    """Overlay window"""

    def __init__(self, config: Setting, widget_name: str):
        super().__init__()
        self.widget_name = widget_name
        self.closed = False

        # Base config
        self.cfg = config

        # Widget config
        self.wcfg = self.cfg.user.setting[widget_name]
        validate_column_order(self.wcfg)

        # Base setting
        self.setWindowTitle(f"{APP_NAME} - {widget_name.capitalize()}")
        self.move(self.wcfg["position_x"], self.wcfg["position_y"])

        # Set update timer
        self._update_timer = QBasicTimer()
        self._update_interval = max(
            self.wcfg["update_interval"],
            self.cfg.application["minimum_update_interval"],
        )

    def start(self):
        """Set initial widget state in orders, and start update"""
        self.__connect_signal()
        self.__set_window_attributes()  # 1
        self.__set_window_flags()  # 2
        self.__toggle_timer(not realtime_state.active)

    def stop(self):
        """Stop and close widget"""
        self.__toggle_timer(True)
        self.__break_signal()
        self.unload_resource()
        self.wcfg = None
        self.cfg = None
        self.closed = self.close()

    def post_update(self):
        """Run once after state inactive"""

    def unload_resource(self):
        """Unload resource (such as images) on close, can re-implement in widget"""
        instance_var_list = dir(self)
        for var in instance_var_list:
            if var.startswith("pixmap_"):  # unload all pixmap instance
                setattr(self, var, None)

    def __set_window_attributes(self):
        """Set window attributes"""
        self.setWindowOpacity(self.wcfg["opacity"])
        self.setAttribute(Qt.WA_DeleteOnClose, True)
        if self.cfg.compatibility["enable_translucent_background"]:
            self.setAttribute(Qt.WA_TranslucentBackground, True)
        else:
            self.__set_window_style()

    def __set_window_flags(self):
        """Set window flags"""
        self.setWindowFlag(Qt.FramelessWindowHint, True)
        self.setWindowFlag(Qt.WindowStaysOnTopHint, True)
        if not self.cfg.overlay["vr_compatibility"]:  # hide taskbar widget
            self.setWindowFlag(Qt.Tool, True)
        if self.cfg.compatibility["enable_bypass_window_manager"]:
            self.setWindowFlag(Qt.X11BypassWindowManagerHint, True)
        self.__toggle_lock(locked=self.cfg.overlay["fixed_position"])

    def __set_window_style(self):
        """Set window style"""
        palette = self.palette()
        palette.setColor(QPalette.Window, self.cfg.compatibility["global_bkg_color"])
        self.setPalette(palette)

    def contextMenuEvent(self, event):
        """Widget context menu"""
        menu = QMenu()

        show_name = menu.addAction(format_module_name(self.widget_name))
        show_name.setDisabled(True)
        menu.addSeparator()

        menu.addAction("Center Horizontally")
        menu.addAction("Center Vertically")

        selected_action = menu.exec_(event.globalPos())
        if not selected_action:
            return

        action = selected_action.text()
        if action == "Center Horizontally":
            self.move((self.screen().geometry().width() - self.width()) // 2, self.y())
            self.__save_position()
        elif action == "Center Vertically":
            self.move(self.x(), (self.screen().geometry().height() - self.height()) // 2)
            self.__save_position()

    def mouseMoveEvent(self, event):
        """Update widget position"""
        if mousepos.valid() and event.buttons() == Qt.LeftButton:
            # Snapping to reference grid if Ctrl is pressed
            if (event.modifiers() & Qt.ControlModifier):
                self.move(mousepos.snapping(self, event.globalPos()))
            else:
                self.move(mousepos.moving(event.globalPos()))

    def mousePressEvent(self, event):
        """Set offset position & press state"""
        # Make sure overlay cannot be dragged while "fixed_position" enabled
        if self.cfg.overlay["fixed_position"]:
            return
        if event.buttons() == Qt.LeftButton:
            mousepos.config(
                event.pos(),
                self.cfg.overlay["enable_grid_move"],
                self.cfg.application["grid_move_size"],
                self.cfg.application["snap_gap"],
                self.cfg.application["snap_distance"],
            )

    def mouseReleaseEvent(self, event):
        """Save position on release"""
        mousepos.reset()
        self.__save_position()

    def __save_position(self):
        """Save widget position"""
        save_changes = False
        if self.wcfg["position_x"] != self.x():
            self.wcfg["position_x"] = self.x()
            save_changes = True
        if self.wcfg["position_y"] != self.y():
            self.wcfg["position_y"] = self.y()
            save_changes = True
        if save_changes:
            self.cfg.save()

    @Slot(bool)  # type: ignore[operator]
    def __toggle_lock(self, locked: bool):
        """Toggle widget lock state"""
        self.setWindowFlag(Qt.WindowTransparentForInput, locked)
        # Need re-check after lock/unlock
        self.setHidden(self.cfg.overlay["auto_hide"] and not realtime_state.active)

    @Slot(bool)  # type: ignore[operator]
    def __toggle_vr_compat(self, enabled: bool):
        """Toggle widget VR compatibility"""
        self.setWindowFlag(Qt.Tool, not enabled)
        # Need re-check
        self.setHidden(self.cfg.overlay["auto_hide"] and not realtime_state.active)

    @Slot(bool)  # type: ignore[operator]
    def __toggle_timer(self, paused: bool):
        """Toggle widget timer state"""
        if paused:
            self._update_timer.stop()
            self.post_update()
        else:
            self._update_timer.start(self._update_interval, self)

    def __connect_signal(self):
        """Connect overlay lock and hide signal"""
        overlay_signal.locked.connect(self.__toggle_lock)
        overlay_signal.hidden.connect(self.setHidden)
        overlay_signal.paused.connect(self.__toggle_timer)
        overlay_signal.iconify.connect(self.__toggle_vr_compat)

    def __break_signal(self):
        """Disconnect overlay lock and hide signal"""
        overlay_signal.locked.disconnect(self.__toggle_lock)
        overlay_signal.hidden.disconnect(self.setHidden)
        overlay_signal.paused.disconnect(self.__toggle_timer)
        overlay_signal.iconify.disconnect(self.__toggle_vr_compat)

    def closeEvent(self, event):
        """Ignore attempts to close via window Close button when VR compatibility enabled"""
        if self.cfg is not None:
            event.ignore()

    # Common GUI methods
    def config_font(self, name: str = "", size: int = 1, weight: str = "") -> QFont:
        """Config font

        Used for draw text in widget that uses QPainter,
        or get font metrics reading for sizing elements.

        Args:
            name: font name string.
            size: font size in pixel, minimum limit 1px.
            weight (optional): font weight name string, convert name to capital.

        Returns:
            QFont object.
        """
        font = self.font()  # get existing widget font
        font.setFamily(name)
        font.setPixelSize(max(size, 1))
        if weight:
            font.setWeight(getattr(QFont, weight.capitalize()))
        return font

    @staticmethod
    def get_font_metrics(qfont: QFont) -> FontMetrics:
        """Get font metrics

        Args:
            qfont: QFont object.

        Returns:
            FontMetrics object.
        """
        # Disable font hinting for more accuracy (necessary for pyside6)
        qfont.setHintingPreference(QFont.PreferNoHinting)
        font_metrics = QFontMetrics(qfont)
        return FontMetrics(
            width=font_metrics.averageCharWidth(),
            height=font_metrics.height(),
            leading=font_metrics.leading(),
            capital=font_metrics.capHeight(),
            descent=font_metrics.descent(),
        )

    def calc_font_offset(self, metrics: FontMetrics) -> int:
        """Calculate auto font vertical offset

        Find difference between actual height and height reading
        and use as offset for center vertical alignment position
        for overlay that uses QPainter drawing.

        Args:
            metrics: FontMetrics object.

        Returns:
            Calculated font offset in pixel.
        """
        if self.wcfg["enable_auto_font_offset"]:
            return (
                metrics.capital
                + metrics.descent * 2
                + metrics.leading * 2
                - metrics.height
            )
        return self.wcfg["font_offset_vertical"]

    def set_base_style(self, style_sheet: str):
        """Set base style sheet"""
        self.setStyleSheet(style_sheet)

    @staticmethod
    def set_padding(size: int, scale: float, side: int = 2) -> int:
        """Set padding

        Args:
            size: reference font size in pixel.
            scale: scale font size for relative padding.
            side: number of sides to add padding.

        Returns:
            Padding size in pixel.
        """
        return round(size * scale) * side

    @staticmethod
    def set_text_alignment(align: int | str = 0) -> Qt.Alignment:
        """Set text alignment

        Args:
            align: 0 or "Center", 1 or "Left", 2 or "Right".

        Returns:
            Qt alignment.
        """
        if align == 0 or align == "Center":
            return Qt.AlignCenter
        if align == 1 or align == "Left":
            return Qt.AlignLeft | Qt.AlignVCenter
        return Qt.AlignRight | Qt.AlignVCenter

    @staticmethod
    def set_qss(
        fg_color: str = "",
        bg_color: str = "",
        font_family: str = "",
        font_size: int = -1,
        font_weight: str = "",
    ) -> str:
        """Set qt style sheet

        Args:
            fg_color: foreground color.
            bg_color: background color.
            font_family: font family name string.
            font_size: font size in pixel, minimum limit 1px.
            font_weight: font weight string, "normal" or "bold".

        Returns:
            Qt style sheet string.
        """
        if fg_color:
            fg_color = f"color:{fg_color};"
        if bg_color:
            bg_color = f"background:{bg_color};"
        if font_family:
            font_family = f"font-family:{font_family};"
        if font_size >= 0:
            font_size_pixel = f"font-size:{max(font_size, 1)}px;"
        else:
            font_size_pixel = ""
        if font_weight in rxp.CHOICE_COMMON[rxp.CFG_FONT_WEIGHT]:
            font_weight = f"font-weight:{font_weight};"
        return f"{fg_color}{bg_color}{font_family}{font_size_pixel}{font_weight}"

    def __add_qlabel(
        self,
        *,
        text: str | None = None,
        pixmap: QPixmap | None = None,
        style: str | None = None,
        width: int = 0,
        height: int = 0,
        fixed_width: int = 0,
        fixed_height: int = 0,
        align: int | str = 0,
        last: Any | None = None,
    ) -> QLabel:
        """Add a single qlabel instance, keyword arguments only

        Args:
            text: label text.
            pixmap: pixmap image.
            style: qt style sheet.
            width: minimum label width in pixel.
            height: minimum label height in pixel.
            fixed_width: fixed label width in pixel, takes priority over width.
            fixed_height: fixed label height in pixel, takes priority over height.
            align: 0 or "Center", 1 or "Left", 2 or "Right".
            last: cache last data for comparison.

        Returns:
            QLabel instance.
        """
        bar_temp = ExLabel(self)
        bar_temp.setTextFormat(Qt.PlainText)
        bar_temp.setTextInteractionFlags(Qt.NoTextInteraction)
        bar_temp.setAlignment(self.set_text_alignment(align))

        if text is not None:
            bar_temp.setText(text)

        if pixmap is not None:
            bar_temp.setPixmap(pixmap)

        if style is not None:
            bar_temp.updateStyle(style)

        if fixed_width > 0:
            bar_temp.setFixedWidth(fixed_width)
        elif width > 0:
            bar_temp.setMinimumWidth(width)

        if fixed_height > 0:
            bar_temp.setFixedHeight(fixed_height)
        elif height > 0:
            bar_temp.setMinimumHeight(height)

        if last is not None:
            bar_temp.last = last

        return bar_temp

    def set_qlabel(
        self,
        *,
        text: str | None = None,
        pixmap: QPixmap | None = None,
        style: str | None = None,
        width: int = 0,
        height: int = 0,
        fixed_width: int = 0,
        fixed_height: int = 0,
        align: int | str = 0,
        last: Any | None = None,
        count: int = 1,
    ) -> tuple[QLabel, ...] | QLabel:
        """Set qlabel, keyword arguments only

        Args:
            text: label text.
            pixmap: pixmap image.
            style: qt style sheet.
            width: minimum label width in pixel.
            height: minimum label height in pixel.
            fixed_width: fixed label width in pixel, takes priority over width.
            fixed_height: fixed label height in pixel, takes priority over height.
            align: 0 or "Center", 1 or "Left", 2 or "Right".
            last: cache last data for comparison.
            count: number of qlabel to set.

        Returns:
            A single or multiple(tuple) QLabel instances,
            depends on count value (default 1).
        """
        bar_set = (
            self.__add_qlabel(
                text=text,
                pixmap=pixmap,
                style=style,
                width=width,
                height=height,
                fixed_width=fixed_width,
                fixed_height=fixed_height,
                align=align,
                last=last,
            )
            for _ in range(count)
        )
        if count > 1:
            return tuple(bar_set)
        return next(bar_set)

    @staticmethod
    def set_grid_layout_vert(
        layout: QGridLayout,
        targets: tuple[QWidget, ...],
        row_start: int = 1,
        column: int = 4,
    ):
        """Set grid layout - vertical

        Default row index start from 1; reserve row index 0 for caption.
        """
        for index, target in enumerate(targets):
            layout.addWidget(target, index + row_start, column)

    @staticmethod
    def set_grid_layout_quad(
        layout: QGridLayout,
        targets: tuple[QWidget | QLayout, ...],
        row_start: int = 1,
        column_left: int = 0,
        column_right: int = 9,
    ):
        """Set grid layout - quad - (0,1), (2,3), (4,5), ...

        Default row index start from 1; reserve row index 0 for caption.
        """
        for index, target in enumerate(targets):
            row_index = row_start + (index // 2)
            column_index = column_left + (index % 2) * column_right
            if isinstance(target, QWidget):
                layout.addWidget(target, row_index, column_index)
            else:
                layout.addLayout(target, row_index, column_index)

    @staticmethod
    def set_grid_layout_table_row(
        layout: QGridLayout,
        targets: tuple[QWidget, ...],
        row_index: int = 0,
        right_to_left: bool = False,
        hide_start: int = 99999,
    ):
        """Set grid layout - table by keys of each row"""
        if right_to_left:
            enum_target = enumerate(reversed(targets))
        else:
            enum_target = enumerate(targets)
        for column_index, target in enum_target:
            layout.addWidget(target, row_index, column_index)
            if hide_start <= column_index:
                target.hide()

    @staticmethod
    def set_grid_layout_table_column(
        layout: QGridLayout,
        targets: tuple[QWidget, ...],
        column_index: int = 0,
        bottom_to_top: bool = False,
        hide_start: int = 99999,
    ):
        """Set grid layout - table by keys of each column"""
        if bottom_to_top:
            enum_target = enumerate(reversed(targets))
        else:
            enum_target = enumerate(targets)
        for row_index, target in enum_target:
            layout.addWidget(target, row_index, column_index)
            if hide_start <= row_index:
                target.hide()

    @staticmethod
    def set_grid_layout(
        gap: int = 0,
        gap_hori: int = -1,
        gap_vert: int = -1,
        margin: int = -1,
        align: Qt.Alignment | None = None,
    ) -> QGridLayout:
        """Set grid layout (QGridLayout)"""
        layout = QGridLayout()
        layout.setSpacing(gap)
        if gap_hori >= 0:
            layout.setHorizontalSpacing(gap_hori)
        if gap_vert >= 0:
            layout.setVerticalSpacing(gap_vert)
        if margin >= 0:
            layout.setContentsMargins(margin, margin, margin, margin)
        if align is not None:
            layout.setAlignment(align)
        return layout

    def set_primary_layout(
        self,
        layout: QLayout,
        margin: int = 0,
        align: Qt.Alignment | None = Qt.AlignLeft | Qt.AlignTop,
    ):
        """Set primary layout"""
        layout.setContentsMargins(margin, margin, margin, margin)
        if align is not None:
            layout.setAlignment(align)
        self.setLayout(layout)

    def set_primary_orient(
        self,
        target: QWidget | QGridLayout,
        column: int = 0,
        row: int = 0,
        option: str = "layout",
        default: str | int = 0,
    ):
        """Set primary layout (QGridLayout) orientation

        Orientation is defined by "layout" option in Widget JSON.
        0 = vertical, 1 = horizontal.

        Args:
            target: QWidget or QGridLayout that adds to primary layout.
            column: column index determines display order.
            row: row index determines side display order.
            option: layout option name in Widget JSON.
            default: default layout value.
        """
        if self.wcfg.get(option, 0) == default:
            order = column, row  # Vertical layout
        else:
            order = row, column  # Horizontal layout
        layout = self.layout()
        assert isinstance(layout, QGridLayout)
        if isinstance(target, QWidget):
            layout.addWidget(target, *order)
        else:
            layout.addLayout(target, *order)


def validate_column_order(config: dict):
    """Validate column/row index order, correct any overlapping indexes"""
    column_set = []
    for key in config:
        if key.startswith("column_index"):
            while config[key] in column_set:
                config[key] += 1
            column_set.append(config[key])

```
