# ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY

> **WARNING**: This file is automatically generated by `scripts/create_context.py`.
> Any manual edits will be overwritten the next time the script runs.
> To modify the content, edit the source files directly.

---

# LMUFFB Project Context

This file contains the full source code and documentation of the project.
It is generated automatically to provide complete context for LLM queries.


# File: CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.10)
project(LMUFFB_CPP)

set(CMAKE_CXX_STANDARD 17)

# Security Flags (MSVC)
if(MSVC)
    # Compile flags: Buffer Security Check (/GS) is usually default, but good to ensure.
    add_compile_options(/GS)

    # Linker flags: ASLR (/DYNAMICBASE) and DEP (/NXCOMPAT)
    add_link_options(/DYNAMICBASE /NXCOMPAT)
endif()

# ImGui Core Detection & FetchContent
include(FetchContent)
set(IMGUI_DIR "${CMAKE_SOURCE_DIR}/vendor/imgui")

if(EXISTS "${IMGUI_DIR}/imgui.cpp")
    message(STATUS "ImGui Core found locally.")
    set(IMGUI_LOCAL_FOUND TRUE)
else()
    message(STATUS "ImGui not found locally. Using FetchContent...")
    FetchContent_Declare(
      imgui
      GIT_REPOSITORY unlinked: github_com/ocornut/imgui_git
      GIT_TAG        v1.91.8
    )
    FetchContent_GetProperties(imgui)
    if(NOT imgui_POPULATED)
        FetchContent_Populate(imgui)
    endif()
    set(IMGUI_DIR "${imgui_SOURCE_DIR}")
    set(IMGUI_FETCHED TRUE)
endif()

if(EXISTS "${IMGUI_DIR}/imgui.cpp")
    add_definitions(-DENABLE_IMGUI)

    set(IMGUI_CORE_SOURCES
        ${IMGUI_DIR}/imgui.cpp
        ${IMGUI_DIR}/imgui_demo.cpp
        ${IMGUI_DIR}/imgui_draw.cpp
        ${IMGUI_DIR}/imgui_tables.cpp
        ${IMGUI_DIR}/imgui_widgets.cpp
    )
    include_directories(${IMGUI_DIR})
    include_directories(${IMGUI_DIR}/backends)
endif()

# Platform specific Backends
option(BUILD_HEADLESS "Build without GUI support" OFF)
if(BUILD_HEADLESS)
    add_definitions(-DHEADLESS_GUI)
endif()
set(IMGUI_BACKEND_SOURCES "")

if(NOT BUILD_HEADLESS AND IMGUI_CORE_SOURCES)
    if(WIN32)
        list(APPEND IMGUI_BACKEND_SOURCES
            ${IMGUI_DIR}/backends/imgui_impl_win32.cpp
            ${IMGUI_DIR}/backends/imgui_impl_dx11.cpp
        )
        link_libraries(d3d11 d3dcompiler dxguid)
        add_definitions(-DUNICODE -D_UNICODE -DNOMINMAX -DIMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)
    else()
        # Linux / GLFW + OpenGL
        find_package(glfw3 REQUIRED)
        find_package(OpenGL REQUIRED)

        list(APPEND IMGUI_BACKEND_SOURCES
            ${IMGUI_DIR}/backends/imgui_impl_glfw.cpp
            ${IMGUI_DIR}/backends/imgui_impl_opengl3.cpp
        )

        include_directories(${OPENGL_INCLUDE_DIR})
    endif()
endif()

set(IMGUI_SOURCES ${IMGUI_CORE_SOURCES} ${IMGUI_BACKEND_SOURCES})

include_directories(src)
if(NOT WIN32)
    include_directories(src/lmu_sm_interface/linux_mock)
    include_directories(src/lmu_sm_interface)
endif()

# Copy icon file into build directory (Windows only)
if(WIN32)
    configure_file(${CMAKE_SOURCE_DIR}/icon/lmuffb.ico ${CMAKE_BINARY_DIR}/lmuffb.ico COPYONLY)
endif()

# Read Version
file(STRINGS "VERSION" LMUFFB_VERSION)

# Parse version for Resource File (e.g. 0.7.29 -> 0,7,29,0)
string(REPLACE "." ";" VERSION_LIST ${LMUFFB_VERSION})
list(GET VERSION_LIST 0 VERSION_MAJOR)
list(GET VERSION_LIST 1 VERSION_MINOR)
list(GET VERSION_LIST 2 VERSION_PATCH)
set(LMUFFB_VERSION_STR "${LMUFFB_VERSION}")
set(LMUFFB_VERSION_COMMA "${VERSION_MAJOR},${VERSION_MINOR},${VERSION_PATCH},0")

# Auto-generate versioned files in the BUILD directory
# This keeps the source tree clean and ensures a single source of truth.
configure_file(src/Version.h.in ${CMAKE_CURRENT_BINARY_DIR}/src/Version.h @ONLY)
if(WIN32)
    configure_file(src/res.rc.in ${CMAKE_CURRENT_BINARY_DIR}/src/res.rc @ONLY)
endif()

include_directories(${CMAKE_CURRENT_BINARY_DIR}/src)
add_definitions(-DLMUFFB_VERSION="${LMUFFB_VERSION}")

# Tests
add_subdirectory(tests)

set(APP_SOURCES
    src/main.cpp
    src/GuiLayer_Common.cpp
    src/GuiLayer.h
    src/Config.cpp src/Config.h
    src/DirectInputFFB.cpp src/DirectInputFFB.h
    src/GameConnector.cpp src/GameConnector.h
    src/FFBEngine.h
)

if(WIN32)
    list(APPEND APP_SOURCES src/GuiLayer_Win32.cpp ${CMAKE_CURRENT_BINARY_DIR}/src/res.rc)
else()
    list(APPEND APP_SOURCES src/GuiLayer_Linux.cpp)
endif()

add_executable(LMUFFB ${APP_SOURCES} ${IMGUI_SOURCES})

if(WIN32)
    target_link_libraries(LMUFFB PRIVATE dinput8.lib dxguid.lib winmm.lib)
endif()

if(NOT WIN32 AND NOT BUILD_HEADLESS)
    target_link_libraries(LMUFFB PRIVATE glfw OpenGL::GL dl pthread)
endif()

# Copy Distribution Files
add_custom_command(TARGET LMUFFB POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy
            "${CMAKE_SOURCE_DIR}/README.txt"
            "$<TARGET_FILE_DIR:LMUFFB>/README.txt")

```

# File: tests\CMakeLists.txt
```cmake
﻿cmake_minimum_required(VERSION 3.10)
project(LMUFFB_Tests)

set(CMAKE_CXX_STANDARD 17)


# Include main source dir for headers
include_directories(..)
include_directories(../src)
include_directories(${CMAKE_BINARY_DIR})
include_directories(${CMAKE_BINARY_DIR}/src)

if(NOT WIN32)
    include_directories(linux_mock)
    include_directories(../src/lmu_sm_interface/linux_mock)
    include_directories(../src/lmu_sm_interface)
endif()

# Combined Test Executable
set(TEST_SOURCES 
    main_test_runner.cpp 
    test_ffb_common.cpp
    test_ffb_core_physics.cpp
    test_ffb_slope_detection.cpp
    test_ffb_understeer.cpp
    test_ffb_smoothstep.cpp
    test_ffb_yaw_gyro.cpp
    test_ffb_coordinates.cpp
    test_ffb_features.cpp
    test_ffb_road_texture.cpp
    test_ffb_lockup_braking.cpp
    test_ffb_config.cpp
    test_ffb_slip_grip.cpp
    test_ffb_internal.cpp
    test_persistence_v0625.cpp
    test_persistence_v0628.cpp
    test_async_logger.cpp
    test_versioned_presets.cpp
    test_preset_improvements.cpp
    test_ffb_stability.cpp
    test_gui_tooltips_presence.cpp
    test_ffb_logic.cpp
    test_ffb_safety.cpp
    test_issue_100_timing.cpp
    test_issue_104_slope_disconnect.cpp

    # Core Application Logic (Now with Linux Mocks)
    ../src/Config.cpp
    ../src/DirectInputFFB.cpp
    ../src/GameConnector.cpp
    ../src/GuiLayer_Common.cpp
)

# ImGui Core is now always available if vendor exists

if(IMGUI_CORE_SOURCES)
    list(APPEND TEST_SOURCES
        test_gui_interaction.cpp
        ${IMGUI_CORE_SOURCES}
        ${IMGUI_BACKEND_SOURCES}
    )
endif()

if(WIN32)
    list(APPEND TEST_SOURCES 
        test_windows_platform.cpp 
        ../src/GuiLayer_Win32.cpp
        ${CMAKE_BINARY_DIR}/src/res.rc
        test_security_metadata.cpp
    )
else()
    # On Linux, always include the Linux backend file,
    # but it will use stubs if HEADLESS_GUI is defined.
    list(APPEND TEST_SOURCES ../src/GuiLayer_Linux.cpp)
    if(BUILD_HEADLESS)
        add_definitions(-DHEADLESS_GUI)
        # Enable some Windows-style tests on Linux using mocks
        list(APPEND TEST_SOURCES test_windows_platform.cpp)
    endif()
endif()

enable_testing()
add_executable(run_combined_tests ${TEST_SOURCES})
target_compile_definitions(run_combined_tests PRIVATE HEADLESS_GUI)

if(WIN32)
    target_link_libraries(run_combined_tests dinput8 dxguid version imm32 winmm d3d11 d3dcompiler dxgi)
elseif(NOT BUILD_HEADLESS)
    # Link GUI libraries if we are NOT in headless mode
    target_link_libraries(run_combined_tests glfw OpenGL::GL dl pthread)
endif()

# Add to CTest
add_test(NAME CombinedTests COMMAND run_combined_tests)


```

# File: tests\main_test_runner.cpp
```cpp
#include <iostream>
#include <atomic>
#include <mutex>
#include <cstdio>
#include <thread>
#include <chrono>
#include <filesystem>
#include "src/Config.h"

#ifdef _WIN32
#include <windows.h>
#endif

// Shared globals required by GuiLayer
std::atomic<bool> g_running(true);
std::mutex g_engine_mutex;

namespace FFBEngineTests { 
    extern int g_tests_passed; 
    extern int g_tests_failed; 
    extern int g_test_cases_run;
    extern int g_test_cases_passed;
    extern int g_test_cases_failed;
    void Run();
    void ParseTagArguments(int argc, char* argv[]);
}

int main(int argc, char* argv[]) {
    // Parse tag filtering arguments
    FFBEngineTests::ParseTagArguments(argc, argv);
    
    int total_passed = 0;
    int total_failed = 0;

    // Redirect config to a test-specific file to avoid overwriting user settings
    Config::m_config_path = "test_config_runner.ini";
    std::remove(Config::m_config_path.c_str());
    std::remove("imgui.ini");

    // --- Unified Test Suite Execution ---
    // All tests (including Windows-specific ones if compiled) are now auto-registered
    try {
        FFBEngineTests::Run();
        total_passed = FFBEngineTests::g_tests_passed;
        total_failed = FFBEngineTests::g_tests_failed;
    } catch (const std::exception& e) {
        std::cout << "\n[FATAL] Test Runner encountered unhandled exception: " << e.what() << std::endl;
        total_failed++;
    } catch (...) {
        std::cout << "\n[FATAL] Test Runner encountered unknown exception" << std::endl;
        total_failed++;
    }

    std::cout << "\n==============================================" << std::endl;
    std::cout << "           COMBINED TEST SUMMARY              " << std::endl;
    std::cout << "==============================================" << std::endl;
    std::cout << "  TEST CASES   : " << FFBEngineTests::g_test_cases_passed << "/" << FFBEngineTests::g_test_cases_run << std::endl;
    std::cout << "  ASSERTIONS   : " << total_passed << " passed, " << total_failed << " failed" << std::endl;
    std::cout << "==============================================" << std::endl;

    // Ensure output is visible on Windows before console closes
    std::cout << std::flush;
    std::this_thread::sleep_for(std::chrono::milliseconds(50));

    // Robust cleanup of test artifacts
    auto cleanup = []() {
        std::vector<std::string> to_remove = {
            Config::m_config_path,
            "test_persistence.ini", "test_config_win.ini", "test_config_top.ini",
            "test_config_preset_temp.ini", "test_config_brake.ini", "test_config_sg.ini",
            "test_config_ap.ini", "test_version.ini", "roundtrip.ini",
            "test_clamp.ini", "test_isolation.ini", "test_order.ini",
            "test_legacy.ini", "test_comments.ini", "imgui.ini",
            "config.ini", "test_config_runner.ini", "test_val.ini",
            "test_stability.ini", "tmp_invalid.ini", "test_config.ini",
            "test_preset_persistence.ini", "test_preservation.ini",
            "test_global_save.ini", "test_config_logic_window.ini",
            "test_config_logic_brake.ini", "test_config_logic_legacy.ini",
            "test_config_logic_legacy_slope.ini", "test_config_logic_legacy_slope_min.ini",
            "test_slope_config.ini", "test_slope_minmax.ini", "test_slope_migration.ini",
            "test_config_logic_guid.ini", "test_config_logic_top.ini", "test_config_logic_preset.ini",
            "tmp_unsafe_config_test.ini", "test_export_preset.ini", "collision_test.ini",
            "test_bad_config.ini", "test_version_presets.ini", "test_legacy_presets.ini"
        };

        for (const auto& file : to_remove) {
            try {
                if (!file.empty() && std::filesystem::exists(file)) {
                    std::filesystem::remove(file);
                }
            } catch (...) {}
        }

        try {
            if (std::filesystem::exists("test_logs")) {
                std::filesystem::remove_all("test_logs");
            }
        } catch (...) {}
    };

    cleanup();

    return (total_failed > 0) ? 1 : 0;
}

```

# File: tests\test_ffb_common.cpp
```cpp
#include "test_ffb_common.h"

namespace FFBEngineTests {

// --- Global Test Counters ---
int g_tests_passed = 0;
int g_tests_failed = 0;
int g_test_cases_run = 0;
int g_test_cases_passed = 0;
int g_test_cases_failed = 0;

// --- Tag Filtering Globals ---
std::vector<std::string> g_tag_filter;
std::vector<std::string> g_tag_exclude;
std::vector<std::string> g_category_filter;
bool g_enable_tag_filtering = false;

// --- Helper: Parse Command Line Arguments ---
void ParseTagArguments(int argc, char* argv[]) {
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        
        // --tag=Physics,Math
        if (arg.find("--tag=") == 0) {
            g_enable_tag_filtering = true;
            std::string tags_str = arg.substr(6);
            std::stringstream ss(tags_str);
            std::string tag;
            while (std::getline(ss, tag, ',')) {
                g_tag_filter.push_back(tag);
            }
        }
        // --exclude=Performance
        else if (arg.find("--exclude=") == 0) {
            g_enable_tag_filtering = true;
            std::string tags_str = arg.substr(10);
            std::stringstream ss(tags_str);
            std::string tag;
            while (std::getline(ss, tag, ',')) {
                g_tag_exclude.push_back(tag);
            }
        }
        // --category=CorePhysics,SlipGrip
        else if (arg.find("--category=") == 0) {
            g_enable_tag_filtering = true;
            std::string cats_str = arg.substr(11);
            std::stringstream ss(cats_str);
            std::string cat;
            while (std::getline(ss, cat, ',')) {
                g_category_filter.push_back(cat);
            }
        }
        // --help
        else if (arg == "--help" || arg == "-h") {
            std::cout << "\nLMUFFB Test Suite - Tag Filtering\n";
            std::cout << "==================================\n\n";
            std::cout << "Usage: run_combined_tests.exe [options]\n\n";
            std::cout << "Options:\n";
            std::cout << "  --tag=TAG1,TAG2       Run only tests with specified tags (OR logic)\n";
            std::cout << "  --exclude=TAG1,TAG2   Exclude tests with specified tags\n";
            std::cout << "  --category=CAT1,CAT2  Run only specified test categories\n";
            std::cout << "  --help, -h            Show this help message\n\n";
            std::cout << "Available Tags:\n";
            std::cout << "  Functional: Physics, Math, Integration, Config, Regression, Edge, Performance\n";
            std::cout << "  Component: SoP, Slope, Texture, Grip, Coordinates, Smoothing\n\n";
            std::cout << "Available Categories:\n";
            std::cout << "  CorePhysics, SlipGrip, Understeer, SlopeDetection, Texture,\n";
            std::cout << "  YawGyro, Coordinates, Config, SpeedGate, Internal\n\n";
            std::cout << "Examples:\n";
            std::cout << "  run_combined_tests.exe --tag=Physics\n";
            std::cout << "  run_combined_tests.exe --tag=Physics,Regression\n";
            std::cout << "  run_combined_tests.exe --exclude=Performance\n";
            std::cout << "  run_combined_tests.exe --category=CorePhysics,SlipGrip\n\n";
            std::cout << "For more information, see: docs/dev_docs/test_tagging_system.md\n\n";
            exit(0);
        }
    }
    
    // Print active filters
    if (g_enable_tag_filtering) {
        std::cout << "\n=== Tag Filtering Active ===\n";
        if (!g_tag_filter.empty()) {
            std::cout << "Include Tags: ";
            for (size_t i = 0; i < g_tag_filter.size(); i++) {
                std::cout << g_tag_filter[i];
                if (i < g_tag_filter.size() - 1) std::cout << ", ";
            }
            std::cout << "\n";
        }
        if (!g_tag_exclude.empty()) {
            std::cout << "Exclude Tags: ";
            for (size_t i = 0; i < g_tag_exclude.size(); i++) {
                std::cout << g_tag_exclude[i];
                if (i < g_tag_exclude.size() - 1) std::cout << ", ";
            }
            std::cout << "\n";
        }
        if (!g_category_filter.empty()) {
            std::cout << "Categories: ";
            for (size_t i = 0; i < g_category_filter.size(); i++) {
                std::cout << g_category_filter[i];
                if (i < g_category_filter.size() - 1) std::cout << ", ";
            }
            std::cout << "\n";
        }
        std::cout << "============================\n";
    }
}


// --- Helper: Create Basic Test Telemetry ---
TelemInfoV01 CreateBasicTestTelemetry(double speed, double slip_angle) {
    TelemInfoV01 data;
    std::memset(&data, 0, sizeof(data));
    
    // Time
    data.mDeltaTime = 0.01; // 100Hz
    
    // Velocity
    data.mLocalVel.z = -speed; // Game uses -Z for forward
    
    // Wheel setup (all 4 wheels)
    for (int i = 0; i < 4; i++) {
        data.mWheel[i].mGripFract = 0.0; // Trigger approximation mode
        data.mWheel[i].mTireLoad = 4000.0; // Realistic load
        data.mWheel[i].mStaticUndeflectedRadius = 30; // 0.3m radius
        data.mWheel[i].mRotation = speed * 3.33f; // Match speed (rad/s)
        data.mWheel[i].mLongitudinalGroundVel = speed;
        data.mWheel[i].mLateralPatchVel = slip_angle * speed; // Convert to m/s
        data.mWheel[i].mBrakePressure = 1.0; // Default for tests (v0.6.0)
        data.mWheel[i].mSuspForce = 4000.0; // Grounded (v0.6.0)
        data.mWheel[i].mVerticalTireDeflection = 0.001; // Avoid "missing data" warning (v0.6.21)
    }
    
    return data;
}

// --- Helper: Initialize Engine with Test Defaults ---
void InitializeEngine(FFBEngine& engine) {
    Preset::ApplyDefaultsToEngine(engine);
    // v0.5.12: Force consistent baseline for legacy tests
    engine.m_max_torque_ref = 20.0f;
    engine.m_invert_force = false;
    
    // v0.6.31: Zero out all auxiliary effects for clean physics testing by default.
    // Individual tests can re-enable what they need.
    engine.m_steering_shaft_smoothing = 0.0f; 
    engine.m_slip_angle_smoothing = 0.0f;
    engine.m_sop_smoothing_factor = 1.0f; // 1.0 = Instant/No smoothing
    engine.m_yaw_accel_smoothing = 0.0f;
    engine.m_gyro_smoothing = 0.0f;
    engine.m_chassis_inertia_smoothing = 0.0f;
    
    engine.m_sop_effect = 0.0f;
    engine.m_sop_yaw_gain = 0.0f;
    engine.m_oversteer_boost = 0.0f;
    engine.m_rear_align_effect = 0.0f;
    engine.m_gyro_gain = 0.0f;
    
    engine.m_slide_texture_enabled = false;
    engine.m_road_texture_enabled = false;
    engine.m_lockup_enabled = false;
    engine.m_spin_enabled = false;
    engine.m_abs_pulse_enabled = false;
    engine.m_scrub_drag_gain = 0.0f;
    engine.m_min_force = 0.0f;
    
    // v0.6.25: Disable speed gate by default for legacy tests (avoids muting physics at 0 speed)
    engine.m_speed_gate_lower = -10.0f;
    engine.m_speed_gate_upper = -5.0f;
}

// ============================================================
// Auto-Registration Implementation
// ============================================================

// Category ordering for consistent output
static const std::vector<std::string> CATEGORY_ORDER = {
    "CorePhysics", "SlopeDetection", "Understeer", "SpeedGate",
    "YawGyro", "Coordinates", "RoadTexture", "Texture",
    "LockupBraking", "Config", "SlipGrip", "Internal",
    "Windows", "Screenshot", "Persistence", "GUI"
};

static int GetCategoryOrder(const std::string& cat) {
    auto it = std::find(CATEGORY_ORDER.begin(), CATEGORY_ORDER.end(), cat);
    if (it != CATEGORY_ORDER.end()) {
        return static_cast<int>(std::distance(CATEGORY_ORDER.begin(), it));
    }
    return 999; // Unknown categories go last
}

TestRegistry& TestRegistry::Instance() {
    static TestRegistry instance;
    return instance;
}

void TestRegistry::Register(const std::string& name, 
                            const std::string& category,
                            const std::vector<std::string>& tags,
                            std::function<void()> func,
                            int order) {
    m_tests.push_back({name, category, tags, func, order});
}

void TestRegistry::SortByCategory() {
    if (m_sorted) return;
    std::stable_sort(m_tests.begin(), m_tests.end(), 
        [](const TestEntry& a, const TestEntry& b) {
            int orderA = GetCategoryOrder(a.category);
            int orderB = GetCategoryOrder(b.category);
            if (orderA != orderB) return orderA < orderB;
            return a.order_hint < b.order_hint;
        });
    m_sorted = true;
}

const std::vector<TestEntry>& TestRegistry::GetTests() const {
    return m_tests;
}

AutoRegister::AutoRegister(const std::string& name, 
                           const std::string& category, 
                           const std::vector<std::string>& tags,
                           std::function<void()> func,
                           int order) {
    TestRegistry::Instance().Register(name, category, tags, func, order);
}

void Run() {
    std::cout << "\n--- FFTEngine Regression Suite ---" << std::endl;
    
    // Auto-Registered Tests
    auto& registry = TestRegistry::Instance();
    if (!registry.GetTests().empty()) {
        registry.SortByCategory();
        auto& tests = registry.GetTests();
        
        std::cout << "\n--- Auto-Registered Tests (" << tests.size() << ") ---" << std::endl;
        
        std::string current_category;
        for (const auto& test : tests) {
            if (test.category != current_category) {
                current_category = test.category;
                std::cout << "\n=== " << current_category << " Tests ===" << std::endl;
            }
            
            if (!ShouldRunTest(test.tags, test.category)) continue;

            try {
                int initial_fails = g_tests_failed;
                test.func();

                g_test_cases_run++;
                if (g_tests_failed > initial_fails) {
                    g_test_cases_failed++;
                } else {
                    g_test_cases_passed++;
                }
            } catch (const std::exception& e) {
                std::cout << "[FAIL] " << test.name << " threw exception: " << e.what() << std::endl;
                g_tests_failed++;
                g_test_cases_run++;
                g_test_cases_failed++;
            } catch (...) {
                std::cout << "[FAIL] " << test.name << " threw unknown exception" << std::endl;
                g_tests_failed++;
                g_test_cases_run++;
                g_test_cases_failed++;
            }
        }
    }

    std::cout << "\n--- Physics Engine Test Summary ---" << std::endl;
    std::cout << "Test Cases: " << g_test_cases_passed << "/" << g_test_cases_run << " passed" << std::endl;
    std::cout << "Assertions: " << g_tests_passed << " passed, " << g_tests_failed << " failed" << std::endl;
}

} // namespace FFBEngineTests
```

# File: tests\test_ffb_common.h
```cpp
// test_ffb_common.h
#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <fstream>
#include <cstdio>
#include <random>
#include <sstream>
#include <functional>

#include "../src/FFBEngine.h"
#include "../src/lmu_sm_interface/InternalsPlugin.hpp"
#include "../src/lmu_sm_interface/LmuSharedMemoryWrapper.h"
#include "../src/Config.h"

namespace FFBEngineTests {

// --- Test Counters (defined in test_ffb_common.cpp) ---
extern int g_tests_passed;
extern int g_tests_failed;
extern int g_test_cases_run;
extern int g_test_cases_passed;
extern int g_test_cases_failed;

// --- Assert Macros ---
#define ASSERT_TRUE(condition) \
    if (condition) { \
        std::cout << "[PASS] " << #condition << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #condition << " (" << __FILE__ << ":" << __LINE__ << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_NEAR(a, b, epsilon) \
    if (std::abs((a) - (b)) < (epsilon)) { \
        std::cout << "[PASS] " << #a << " approx " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") != " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_EQ(a, b) \
    if ((a) == (b)) { \
        std::cout << "[PASS] " << #a << " == " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") != " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_GE(a, b) \
    if ((a) >= (b)) { \
        std::cout << "[PASS] " << #a << " >= " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") < " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_LE(a, b) \
    if ((a) <= (b)) { \
        std::cout << "[PASS] " << #a << " <= " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << (a) << ") > " << #b << " (" << (b) << ")" << std::endl; \
        g_tests_failed++; \
    }

#define ASSERT_EQ_STR(a, b) \
    if (std::string(a) == std::string(b)) { \
        std::cout << "[PASS] " << #a << " == " << #b << std::endl; \
        g_tests_passed++; \
    } else { \
        std::cout << "[FAIL] " << #a << " (" << a << ") != " << #b << " (" << b << ")" << std::endl; \
        g_tests_failed++; \
    }

// --- Test Constants ---
const int FILTER_SETTLING_FRAMES = 40;

// --- Test Tagging System ---
// Global tag filter (set via command line arguments)
extern std::vector<std::string> g_tag_filter;
extern std::vector<std::string> g_tag_exclude;
extern std::vector<std::string> g_category_filter;
extern bool g_enable_tag_filtering;

// Tag checking helper
inline bool ShouldRunTest(const std::vector<std::string>& test_tags, const std::string& category) {
    if (!g_enable_tag_filtering) return true;
    
    // Category filter (if specified)
    if (!g_category_filter.empty()) {
        bool category_match = false;
        for (const auto& cat : g_category_filter) {
            if (cat == category) {
                category_match = true;
                break;
            }
        }
        if (!category_match) return false;
    }
    
    // Tag exclude filter (if specified)
    if (!g_tag_exclude.empty()) {
        for (const auto& exclude_tag : g_tag_exclude) {
            for (const auto& test_tag : test_tags) {
                if (test_tag == exclude_tag) return false;
            }
        }
    }
    
    // Tag include filter (if specified)
    if (!g_tag_filter.empty()) {
        for (const auto& filter_tag : g_tag_filter) {
            for (const auto& test_tag : test_tags) {
                if (test_tag == filter_tag) return true;
            }
        }
        return false; // No matching tags found
    }
    
    return true; // No filters, run all tests
}

// Parse command line arguments for tag filtering
void ParseTagArguments(int argc, char* argv[]);

// --- Helper Functions ---
TelemInfoV01 CreateBasicTestTelemetry(double speed = 20.0, double slip_angle = 0.0);
void InitializeEngine(FFBEngine& engine);


void Run(); // Main runner

// --- Friend Access for Testing ---
class FFBEngineTestAccess {
public:
    static bool HasWarnings(const FFBEngine& engine) {
        return engine.m_warned_load || engine.m_warned_grip || engine.m_warned_dt;
    }
    static void test_unit_sop_lateral();
    static void test_unit_gyro_damping();
    static void test_unit_abs_pulse();
};

} // namespace FFBEngineTests

// ============================================================
// Auto-Registration System (v0.7.8)
// ============================================================

namespace FFBEngineTests {

struct TestEntry {
    std::string name;
    std::string category;
    std::vector<std::string> tags;
    std::function<void()> func;
    int order_hint; // For sorting within a category
};

class TestRegistry {
public:
    static TestRegistry& Instance();
    void Register(const std::string& name, 
                  const std::string& category, 
                  const std::vector<std::string>& tags,
                  std::function<void()> func,
                  int order = 0);
    const std::vector<TestEntry>& GetTests() const;
    void SortByCategory(); 

private:
    std::vector<TestEntry> m_tests;
    bool m_sorted = false;
};

// Helper class for static registration
struct AutoRegister {
    AutoRegister(const std::string& name, 
                 const std::string& category, 
                 const std::vector<std::string>& tags,
                 std::function<void()> func,
                 int order = 0);
};

} // namespace FFBEngineTests

// Usage: TEST_CASE(test_my_feature, "CorePhysics", {"Physics", "Regression"})
#define TEST_CASE_TAGGED(test_name, category, tags) \
    static void test_name(); \
    static FFBEngineTests::AutoRegister reg_##test_name( \
        #test_name, category, tags, test_name); \
    static void test_name()

// Simple version without tags (defaults to {"Functional"})
#define TEST_CASE(test_name, category_name) \
    TEST_CASE_TAGGED(test_name, category_name, {"Functional"})


```
