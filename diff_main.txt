diff --git a/main.cpp b/main.cpp
index 99f233f..8f88416 100644
--- a/main.cpp
+++ b/main.cpp
@@ -37,9 +37,7 @@ void FFBThread() {
     bool vJoyDllLoaded = false;
     if (DynamicVJoy::Get().Load()) {
         vJoyDllLoaded = true;
-        // Version check removed - vJoy is optional, no need to warn users
     } else {
-        // vJoy not found - this is fine, DirectInput FFB works without it
         std::cout << "[vJoy] Not found (optional component, not required)" << std::endl;
     }
 
@@ -54,8 +52,6 @@ void FFBThread() {
             // --- CRITICAL SECTION: READ DATA ---
             GameConnector::Get().CopyTelemetry(g_localData);
             
-            double force = 0.0;
-            
             // Check if player is in an active driving session (not in menu/replay)
             bool in_realtime = GameConnector::Get().IsInRealtime();
             static bool was_in_menu = true;
@@ -63,10 +59,13 @@ void FFBThread() {
             if (was_in_menu && in_realtime) {
                 std::cout << "[Game] User entered driving session." << std::endl;
             } else if (!was_in_menu && !in_realtime) {
-                std::cout << "[Game] User exited to menu." << std::endl;
+                std::cout << "[Game] User exited to menu (FFB Muted)." << std::endl;
             }
             was_in_menu = !in_realtime;
             
+            double force = 0.0;
+            bool should_output = false;
+
             // Only calculate FFB if actually driving
             if (in_realtime && g_localData.telemetry.playerHasVehicle) {
                 uint8_t idx = g_localData.telemetry.playerVehicleIdx;
@@ -79,9 +78,14 @@ void FFBThread() {
                         std::lock_guard<std::mutex> lock(g_engine_mutex);
                         force = g_engine.calculate_force(pPlayerTelemetry);
                     }
+                    should_output = true;
                 }
             }
-            // else: force remains 0.0 (muted in menus)
+            
+            // --- FIX: Explicitly send 0.0 if not driving ---
+            if (!should_output) {
+                force = 0.0;
+            }
 
             // --- DYNAMIC vJoy LOGIC (State Machine) ---
             if (vJoyDllLoaded && DynamicVJoy::Get().Enabled()) { 
@@ -107,11 +111,12 @@ void FFBThread() {
                 }
             }
             
-            // Update DirectInput (for FFB)
+            // Update DirectInput (Physical Wheel)
+            // This will now send 0.0 when in menu/paused, releasing the tension.
             DirectInputFFB::Get().UpdateForce(force);
         }
 
-        // Sleep 2ms ~ 500Hz. Ideally use high_resolution_clock wait for precise 400Hz.
+        // Sleep 2ms ~ 500Hz.
         std::this_thread::sleep_for(std::chrono::milliseconds(2));
     }
 
@@ -124,7 +129,7 @@ void FFBThread() {
 // --- GUI / Main Loop (Low Priority 60Hz or Lazy) ---
 int main(int argc, char* argv[]) {
 #ifdef _WIN32
-    // Improve timer resolution for sleep accuracy (Report v0.4.2)
+    // Improve timer resolution for sleep accuracy
     timeBeginPeriod(1);
 #endif
 
@@ -144,10 +149,6 @@ int main(int argc, char* argv[]) {
     if (!headless) {
         if (!GuiLayer::Init()) {
             std::cerr << "Failed to initialize GUI." << std::endl;
-            // Fallback? Or exit?
-            // If explicit GUI build failed, we probably want to exit or warn.
-            // For now, continue but set g_running false if critical.
-            // Actually, GuiLayer::Init() handles window creation.
         }
         
         // Initialize DirectInput (Requires HWND)
@@ -155,19 +156,16 @@ int main(int argc, char* argv[]) {
         
     } else {
         std::cout << "Running in HEADLESS mode." << std::endl;
-        // Headless DI init (might fail if HWND is NULL but some drivers allow it, or windowless mode)
         DirectInputFFB::Get().Initialize(NULL);
     }
 
     // 1. Setup Shared Memory
-    // Check for conflicts (silent - no popup, just log to console)
     if (GameConnector::Get().CheckLegacyConflict()) {
         std::cout << "[Info] Legacy rF2 plugin detected (not a problem for LMU 1.2+)" << std::endl;
     }
 
     if (!GameConnector::Get().TryConnect()) {
         std::cout << "Game not running or Shared Memory not ready. Waiting..." << std::endl;
-        // Don't exit, just continue to GUI. FFB Loop will wait.
     }
 
     // 3. Start FFB Thread
@@ -177,8 +175,6 @@ int main(int argc, char* argv[]) {
     std::cout << "[GUI] Main Loop Started." << std::endl;
 
     while (g_running) {
-        // Render returns true if the GUI is active (mouse over, focused).
-        // If false, we can sleep longer (Lazy Rendering).
         bool active = GuiLayer::Render(g_engine);
         
         if (active) {
@@ -197,7 +193,5 @@ int main(int argc, char* argv[]) {
     
     DirectInputFFB::Get().Shutdown();
     
-    // GameConnector cleans itself up
-    
     return 0;
 }
